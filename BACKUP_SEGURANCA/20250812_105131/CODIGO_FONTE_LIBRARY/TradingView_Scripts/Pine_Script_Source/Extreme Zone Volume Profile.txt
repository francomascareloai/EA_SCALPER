// MIT License
// Â©  2025 NateRichmond
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("Extreme Zone Volume Profile", shorttitle="EZVP", overlay=true, max_bars_back=5000, max_boxes_count=500, max_lines_count=50)

// INPUTS
lookback = input.int(200, "Lookback Period", minval=10, maxval=1000)
bins = input.int(120, "Number of Bins", minval=20, maxval=200)
zone_b_pct = input.float(2.5, "Zone B Percentage", minval=0.5, maxval=95.0, step=0.5)
zone_a_pct = input.float(14.0, "Zone A Percentage", minval=0.1, maxval=67.0, step=0.1)
// Line toggles
show_poc = input.bool(true, "Show POC Line")
show_median = input.bool(true, "Show Median Line")
show_mean = input.bool(true, "Show Mean Line")
show_zone_lines = input.bool(true, "Show Zone Lines")
//Zones
zone_b_upper = input.color(color.new(color.red, 20), "Upper Zone B")
zone_a_upper = input.color(color.new(color.orange, 30), "Upper Zone A")
zone_center = input.color(color.new(color.gray, 80), "Center Zone")
zone_a_lower = input.color(color.new(color.teal, 30), "Lower Zone A")
zone_b_lower = input.color(color.new(color.lime, 20), "Lower Zone B")
//Lines
poc = input.color(color.gray, "POC Line")
median = input.color(color.purple, "Median Line")
mean = input.color(color.fuchsia, "Mean Line")

zone_line_b_upper = input.color(color.red, "Upper B Line")
zone_line_a_upper = input.color(color.orange, "Upper A Line")
zone_line_a_lower = input.color(color.teal, "Lower A Line")
zone_line_b_lower = input.color(color.lime, "Lower B Line")

bar_width_multiplier = input.float(1.0, "Bar Width Multiplier", minval=0.1, maxval=2.0, step=0.1)
bar_thickness = input.int(1, "Bar Thickness", minval=1, maxval=5)

// VOLUME PROFILE CALCULATION
var float[] volume_bins = array.new<float>()
var float[] price_levels = array.new<float>()
var box[] volume_boxes = array.new<box>()
var line[] zone_lines = array.new<line>()

// Initialize or resize arrays
if barstate.isfirst or array.size(volume_bins) != bins
    array.clear(volume_bins)
    array.clear(price_levels)
    for i = 0 to bins - 1
        array.push(volume_bins, 0.0)
        array.push(price_levels, 0.0)

// Calculate price range for current lookback period
get_price_range() =>
    var float max_price = na
    var float min_price = na
    max_price := high
    min_price := low
    
    for i = 1 to math.min(lookback - 1, bar_index)
        max_price := math.max(max_price, high[i])
        min_price := math.min(min_price, low[i])
    
    [min_price, max_price]

// Get bin index for a given price
get_bin_index(price, min_price, max_price) =>
    if max_price == min_price
        0
    else
        bin_idx = math.floor((price - min_price) / (max_price - min_price) * bins)
        math.max(0, math.min(bins - 1, bin_idx))

// Clear previous drawings
clear_drawings() =>
    for box_item in volume_boxes
        box.delete(box_item)
    array.clear(volume_boxes)
    
    for line_item in zone_lines
        line.delete(line_item)
    array.clear(zone_lines)

// Main calculation on each bar
if barstate.isconfirmed or barstate.islast
    clear_drawings()
    
    // Reset volume bins
    for i = 0 to bins - 1
        array.set(volume_bins, i, 0.0)
    
    // Get price range
    [min_price, max_price] = get_price_range()
    
    // Calculate bin height
    bin_height = (max_price - min_price) / bins
    
    // Set price levels for each bin
    for i = 0 to bins - 1
        array.set(price_levels, i, min_price + (i + 0.5) * bin_height)
    
    // Accumulate volume in bins for lookback period
    for i = 0 to math.min(lookback - 1, bar_index)
        bar_high = high[i]
        bar_low = low[i]
        bar_volume = volume[i]
        
        // Distribute volume across bins that intersect with bar's price range
        start_bin = get_bin_index(bar_low, min_price, max_price)
        end_bin = get_bin_index(bar_high, min_price, max_price)
        
        bins_touched = math.max(1, end_bin - start_bin + 1)
        volume_per_bin = bar_volume / bins_touched
        
        for j = start_bin to end_bin
            current_volume = array.get(volume_bins, j)
            array.set(volume_bins, j, current_volume + volume_per_bin)
    
    // Find POC and calculate total volume
    total_volume = 0.0
    max_volume = 0.0
    poc_price = 0.0
    
    for i = 0 to bins - 1
        bin_volume = array.get(volume_bins, i)
        total_volume += bin_volume
        if bin_volume > max_volume
            max_volume := bin_volume
            poc_price := array.get(price_levels, i)
    
    // Sort bins by volume to find percentile thresholds
    var int[] sorted_indices = array.new<int>()
    array.clear(sorted_indices)
    for i = 0 to bins - 1
        array.push(sorted_indices, i)
    
    // Simple bubble sort by volume (descending)
    for i = 0 to bins - 2
        for j = 0 to bins - 2 - i
            idx1 = array.get(sorted_indices, j)
            idx2 = array.get(sorted_indices, j + 1)
            vol1 = array.get(volume_bins, idx1)
            vol2 = array.get(volume_bins, idx2)
            if vol1 < vol2
                array.set(sorted_indices, j, idx2)
                array.set(sorted_indices, j + 1, idx1)
    
    // Calculate zone thresholds by volume percentiles
    zone_b_upper_count = math.max(1, math.floor(bins * zone_b_pct / 100))
    zone_a_upper_count = math.max(1, math.floor(bins * zone_a_pct / 100))
    zone_a_lower_count = math.max(1, math.floor(bins * zone_a_pct / 100))
    zone_b_lower_count = math.max(1, math.floor(bins * zone_b_pct / 100))
    
    // Find zone boundary prices
    var float zone_b_lower_price = na
    var float zone_a_lower_price = na
    var float zone_a_upper_price = na
    var float zone_b_upper_price = na
    var float median_price = na
    
    // Find median price (middle of price range)
    median_price := (min_price + max_price) / 2

    // Mean price (volume-weighted average)
    mean_price_sum = 0.0
    for i = 0 to bins - 1
        mean_price_sum += array.get(price_levels, i) * array.get(volume_bins, i)
    mean_price = total_volume != 0.0 ? mean_price_sum / total_volume : na

    
    // Find zone boundaries based on price levels
    zone_b_upper_price := min_price + (max_price - min_price) * (100 - zone_b_pct) / 100
    zone_a_upper_price := min_price + (max_price - min_price) * (100 - zone_b_pct - zone_a_pct) / 100
    zone_a_lower_price := min_price + (max_price - min_price) * (zone_b_pct + zone_a_pct) / 100
    zone_b_lower_price := min_price + (max_price - min_price) * zone_b_pct / 100
    
    // Calculate max volume for scaling
    max_volume_for_scaling = max_volume
    if max_volume_for_scaling > 0
        // Draw volume profile bars
        bar_start = bar_index - lookback + 1
        max_bar_width = lookback * 0.3  // Maximum width as percentage of lookback
        
        for i = 0 to bins - 1
            bin_volume = array.get(volume_bins, i)
            if bin_volume > 0
                bin_price = array.get(price_levels, i)
                
                // Determine zone color
                bin_color = zone_center
                if bin_price <= zone_b_lower_price
                    bin_color := zone_b_lower
                else if bin_price <= zone_a_lower_price
                    bin_color := zone_a_lower
                else if bin_price >= zone_b_upper_price
                    bin_color := zone_b_upper
                else if bin_price >= zone_a_upper_price
                    bin_color := zone_a_upper
                
                // Calculate bar width
                bar_width = math.max(1, math.floor(bin_volume / max_volume_for_scaling * max_bar_width * bar_width_multiplier))
                
                // Create volume bar as box - extend rightward from current bar
                left_bar = bar_index + 1
                right_bar = bar_index + 1 + bar_width
                top_price = bin_price + bin_height * 0.4
                bottom_price = bin_price - bin_height * 0.4


                
                volume_box = box.new(left=left_bar, top=top_price, right=right_bar, bottom=bottom_price, border_color=bin_color, bgcolor=bin_color, border_width=bar_thickness)
                array.push(volume_boxes, volume_box)
        
        // Draw lines extending backward from current bar
        line_start = bar_index - lookback + 1
        line_end = bar_index
        
        // POC line
        if show_poc and not na(poc_price)
            poc_line = line.new(x1=line_start, y1=poc_price, x2=line_end, y2=poc_price, color=poc, width=2, style=line.style_dashed)
            array.push(zone_lines, poc_line)
        
        // Median line
        if show_median and not na(median_price)
            med_line = line.new(x1=line_start, y1=median_price, x2=line_end, y2=median_price, color=median, width=1, style=line.style_dashed)
            array.push(zone_lines, med_line)

        // Mean line
        if show_mean and not na(mean_price)
            mean_line = line.new(x1=line_start, y1=mean_price, x2=line_end, y2=mean_price, color=mean, width=1, style=line.style_dashed)
            array.push(zone_lines, mean_line)
        
        // Zone boundary lines
        if show_zone_lines
            if not na(zone_b_lower_price)
                zb_lower_line = line.new(x1=line_start, y1=zone_b_lower_price, x2=line_end, y2=zone_b_lower_price, color=zone_line_b_lower, width=1, style=line.style_dashed)
                array.push(zone_lines, zb_lower_line)
            
            if not na(zone_a_lower_price)
                za_lower_line = line.new(x1=line_start, y1=zone_a_lower_price, x2=line_end, y2=zone_a_lower_price, color=zone_line_a_lower, width=1, style=line.style_dashed)
                array.push(zone_lines, za_lower_line)
            
            if not na(zone_a_upper_price)
                za_upper_line = line.new(x1=line_start, y1=zone_a_upper_price, x2=line_end, y2=zone_a_upper_price, color=zone_line_a_upper, width=1, style=line.style_dashed)
                array.push(zone_lines, za_upper_line)
            
            if not na(zone_b_upper_price)
                zb_upper_line = line.new(x1=line_start, y1=zone_b_upper_price, x2=line_end, y2=zone_b_upper_price, color=zone_line_b_upper, width=1, style=line.style_dashed)
                array.push(zone_lines, zb_upper_line)