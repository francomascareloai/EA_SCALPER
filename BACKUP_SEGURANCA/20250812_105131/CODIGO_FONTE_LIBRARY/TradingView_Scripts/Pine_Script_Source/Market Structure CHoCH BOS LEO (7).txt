// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© Llopezf

//@version=5
indicator("Market Structure CHoCH/BOS LEO", overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500, max_bars_back = 1000)
//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{
length = input.int(5, minval = 3)

//Colors
showBull = input(true, 'Bullish Structures', inline = 'bull', group = 'Style')
bullCss = input.color(#089981, '', inline = 'bull', group = 'Style')

showBear = input(true, 'Bearish Structures', inline = 'bear', group = 'Style')
bearCss = input.color(#f23645, '', inline = 'bear', group = 'Style')

showSupport = input(false, 'Support', inline = 's', group = 'Style')
supCss = input.color(#089981, '', inline = 's', group = 'Style')

showResistance = input(false, 'Resistance', inline = 'r', group = 'Style')
resCss = input.color(#f23645, '', inline = 'r', group = 'Style')

//Dashboard
showDash  = input(false, 'Show Dashboard'                                                               , group = 'Dashboard')
dashLoc  = input.string('Top Right', 'Location', options = ['Top Right', 'Bottom Right', 'Bottom Left'], group = 'Dashboard')
textSize = input.string('Small', 'Size'        , options = ['Tiny', 'Small', 'Normal']                 , group = 'Dashboard')

//-----------------------------------------------------------------------------}
//Types
//-----------------------------------------------------------------------------{
type fractal
    float value
    int loc
    bool iscrossed

//-----------------------------------------------------------------------------}
//Fractal Detection
//-----------------------------------------------------------------------------{
var p = int(length/2)
n = bar_index

dh = math.sum(math.sign(high - high[1]), p)
dl = math.sum(math.sign(low - low[1]), p)

bullf = dh == -p and dh[p] == p and high[p] == ta.highest(length)
bearf = dl == p and dl[p] == -p and low[p] == ta.lowest(length)

bullf_count = ta.cum(bullf ? 1 : 0)
bearf_count = ta.cum(bearf ? 1 : 0)

//-----------------------------------------------------------------------------}
//Bullish market structure
//-----------------------------------------------------------------------------{
var upper = fractal.new()
var line lower_lvl = na
var label ms_lbl = na
var bull_ms_count = 0
var broken_sup = false
var os = 0

if bullf
    upper.value := high[p]
    upper.loc := n-p
    upper.iscrossed := false

if ta.crossover(close, upper.value) and not upper.iscrossed
    line.new(upper.loc, upper.value, n, upper.value, color = showBull ? bullCss : na)

    ms_lbl := label.new(int(math.avg(n, upper.loc)), upper.value, os == -1 ? 'ChoCH' : 'BOS'
      , color = color(na)
      , textcolor = showBull ? bullCss : na
      , style = label.style_label_down
      , size = size.tiny)

    //Set support
    k = 2
    min = low[1]
    for i = 2 to (n - upper.loc)-1
        min := math.min(low[i], min)
        k := low[i] == min ? i : k

    if showSupport
        lower_lvl := line.new(n-k, min, n, min, color = bullCss, style = line.style_dashed)
        broken_sup := false

    upper.iscrossed := true
    bull_ms_count += 1
    os := 1

else if showSupport and not broken_sup
    lower_lvl.set_x2(n)

    if close < lower_lvl.get_y2()
        broken_sup := true

//-----------------------------------------------------------------------------}
//Bearish market structure
//-----------------------------------------------------------------------------{
var lower = fractal.new()
var line upper_lvl = na
var broken_res = false
var bear_ms_count = 0

if bearf
    lower.value := low[p]
    lower.loc := n-p
    lower.iscrossed := false

if ta.crossunder(close, lower.value) and not lower.iscrossed
    line.new(lower.loc, lower.value, n, lower.value, color = showBear ? bearCss : na)
    
    label.new(int(math.avg(n, lower.loc)), lower.value, os == 1 ? 'ChoCH' : 'BOS'
      , color = color(na)
      , textcolor = showBear ? bearCss : na
      , style = label.style_label_up
      , size = size.tiny)

    //Set resistance
    k = 2
    max = high[1]
    for i = 2 to (n - lower.loc)-1
        max := math.max(high[i], max)
        k := high[i] == max ? i : k

    if showResistance
        upper_lvl := line.new(n-k, max, n, max, color = bearCss, style = line.style_dashed)
        broken_res := false
    
    lower.iscrossed := true
    bear_ms_count += 1
    os := -1

else if showResistance and not broken_res
    upper_lvl.set_x2(n)

    if close > upper_lvl.get_y2()
        broken_res := true

//-----------------------------------------------------------------------------}
//Dashboard
//-----------------------------------------------------------------------------{
var table_position = dashLoc == 'Bottom Left' ? position.bottom_left 
  : dashLoc == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = textSize == 'Tiny' ? size.tiny 
  : textSize == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 2, 3
  , bgcolor = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color = #373a46
  , frame_width = 1)

if showDash
    if barstate.isfirst
        tb.cell(0, 0, 'Structure To Fractal %', text_color = color.white, text_size = table_size)
        tb.merge_cells(0,0,1,0)

        tb.cell(0, 1, 'Bullish', text_color = #089981, text_size = table_size)
        tb.cell(1, 1, 'Bearish', text_color = #f23645, text_size = table_size)
    
    if barstate.islast
        tb.cell(0, 2, str.tostring(bull_ms_count / bullf_count * 100, format.percent), text_color = #089981, text_size = table_size)
        tb.cell(1, 2, str.tostring(bear_ms_count / bearf_count * 100, format.percent), text_color = #f23645, text_size = table_size)

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
plot(broken_res and not broken_res[1] ? low : na, 'Resistance Breakout', #089981, 2, plot.style_circles)
plot(broken_sup and not broken_sup[1] ? high : na, 'Support Breakout', #f23645, 2, plot.style_circles)

//-----------------------------------------------------------------------------}

numDays = input.int(7, "number of days lookback")
showUP = input.bool(true, "'UP' FVGs:", inline ='1')
colUp = input.color(color.new(#2195f3, 86), "", inline ='1')
showDN = input.bool(true, "'DOWN' FVGs:", inline ='2')
colDn = input.color(color.new(#ff9900, 86), "", inline ='2')
showCE = input.bool(true, "show CE", inline ='3')
ceCol = input.color(color.new(#363a45, 20), "| color:", inline ='3')
ceStyle = input.string(line.style_dotted, "| style:", options=[line.style_dotted,line.style_solid,  line.style_dashed], inline ='3')
deleteFilledBoxes = input.bool(true, "delete filled boxes & lines")
CEcond = input.bool (true, "Use CE (as opposed to Full Fill)", group = 'conditions/alerts', tooltip = "If toggled OFF, FVGs and CEs will paint until FVG has been completely filled.\n\nThis threshold is used for Above/Below threshold Alert conditions too (but does not effect the IOFED alerts):\ni.e. this will determine if your 'ABOVE threshold' alert fires when price hits latest active FVG CE ABOVE or latest active FVG Full Fill ABOVE\n\nAlerts are set by clicking the three dots on the indicator display line.")
colorNone = color.new(color.white, 100)
_day = 24*3600*1000
var box bxUp = na, var box bxDn = na, var line lnUp = na, var line lnDn = na
var array<box> bxUpArr = array.new<box>(0), var array<line> lnUpArr = array.new<line>(0)
var array<box> bxDnArr = array.new<box>(0), var array<line> lnDnArr = array.new<line>(0)
dnCE = high[1] + (low[3]-high[1])/2
upCE = low[1] - (low[1]-high[3])/2
if low[3] > high[1] and time> timenow- numDays*_day and showDN
    bxDnArr.push(box.new(bar_index-3, low[3], bar_index, high[1], bgcolor = colDn, border_color = colorNone))
    lnDnArr.push(line.new(bar_index-3, dnCE, bar_index, dnCE, color = showCE?ceCol:colorNone, style =ceStyle))
if high[3] < low[1] and time> timenow- numDays*_day and showUP
    bxUpArr.push(box.new(bar_index-3, low[1], bar_index, high[3], bgcolor = colUp, border_color = colorNone))
    lnUpArr.push(line.new(bar_index-3, upCE, bar_index, upCE, color = showCE?ceCol:colorNone, style =ceStyle))

var array<int> _countArr =array.new<int>(0)
var array<int> _countArrIOFED =array.new<int>(0)

//modified form of @Bjorgum's looping function.  This stops boxes/lines painting when price passes to or through them
extendAndRemoveBx(array<box> boxArray, array<line> lineArray, array<int> countArr1, array<int> countArr2, simple bool isBull, int maxSize) => 
    if boxArray.size() > 0
        for i = boxArray.size() -1 to 0
            line ln = lineArray.get(i)
            box bx = boxArray.get(i)
            bx.set_right(bar_index)
            ln.set_x2(bar_index)
            float price = CEcond?ln.get_price(bar_index):(isBull?bx.get_top():bx.get_bottom())    
            float price_IOFED = isBull?bx.get_bottom():bx.get_top()          
            int m = isBull ? 1 : -1
            float hiLo = isBull ? high : low  
            if hiLo * m > price * m 
                boxArray.remove(i)
                lineArray.remove(i)
                countArr1.push(isBull?1:-1) //for 'above/below threshold alerts; counter sum will decrement 1 on lower threshold hit, increment 1 on upper threshold hit
                if deleteFilledBoxes
                    bx.set_bgcolor(colorNone)
                    ln.set_color(colorNone)
            if hiLo*m>price_IOFED*m
                countArr2.push(isBull?1:-1)

    if boxArray.size() > maxSize
        box.delete(boxArray.shift())
        line.delete(lineArray.shift())

extendAndRemoveBx(bxDnArr,lnDnArr,_countArr,_countArrIOFED, true, 12) //12 should be good for around 2200 bars of history
extendAndRemoveBx(bxUpArr, lnUpArr,_countArr,_countArrIOFED, false, 12)

upThresholdLst = array.sum(_countArr)>array.sum(_countArr)[1]
dnThresholdLst = array.sum(_countArr)<array.sum(_countArr)[1]

upIOFEDlast= array.sum(_countArrIOFED)>array.sum(_countArrIOFED)[1]
dnIOFEDlast= array.sum(_countArrIOFED)<array.sum(_countArrIOFED)[1]

alertcondition(upThresholdLst, "ABOVE threshold of latest active Up FVG (CE or fvg High)", "price has crossed threshold of latest active Up FVG")
alertcondition(dnThresholdLst, "BELOW threshold of latest active Down FVG (CE or fvg low)", "price has crossed threshold of latest active Down FVG")

alertcondition(upIOFEDlast, "IOFED into latest active Up FVG", "price has entered latest active UP FVG")
alertcondition(dnIOFEDlast, "IOFED into latest active Down FVG", "price has entered latest active Down FVG")

alertcondition(low[3] > high[1], "Simple alert: Down FVG (confirmed)", "Down FVG has formed (confirmed)")
alertcondition(high[3] < low[1], "Simple alert: Up FVG (confirmed)", "Up FVG has formed (confirmed)")

alertcondition(low[2] > high, "Simple alert: Down FVG (UN-confirmed)", "Down FVG has formed (un-confirmed)")
alertcondition(high[2] < low, "Simple alert: Up FVG (UN-confirmed)", "Up FVG has formed (un-confirmed)")


// Inputs
a = input(2, title='Key Vaule. \'This changes the sensitivity\'')
c = input(1, title='ATR Period')
h111 = input(false, title='Signals from Heikin Ashi Candles')

xATR = ta.atr(c)
nLoss = a * xATR

src = h111 ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close, lookahead=barmerge.lookahead_off) : close

xATRTrailingStop = 0.0
iff_1 = src > nz(xATRTrailingStop[1], 0) ? src - nLoss : src + nLoss
iff_2 = src < nz(xATRTrailingStop[1], 0) and src[1] < nz(xATRTrailingStop[1], 0) ? math.min(nz(xATRTrailingStop[1]), src + nLoss) : iff_1
xATRTrailingStop := src > nz(xATRTrailingStop[1], 0) and src[1] > nz(xATRTrailingStop[1], 0) ? math.max(nz(xATRTrailingStop[1]), src - nLoss) : iff_2

pos = 0
iff_3 = src[1] > nz(xATRTrailingStop[1], 0) and src < nz(xATRTrailingStop[1], 0) ? -1 : nz(pos[1], 0)
pos := src[1] < nz(xATRTrailingStop[1], 0) and src > nz(xATRTrailingStop[1], 0) ? 1 : iff_3

xcolor = pos == -1 ? color.red : pos == 1 ? color.green : color.blue

ema = ta.ema(src, 1)
above = ta.crossover(ema, xATRTrailingStop)
below = ta.crossover(xATRTrailingStop, ema)

buy = src > xATRTrailingStop and above
sell = src < xATRTrailingStop and below

barbuy = src > xATRTrailingStop
barsell = src < xATRTrailingStop

plotshape(buy, title='Buy', text='Buy', style=shape.labelup, location=location.belowbar, color=color.new(color.green, 0), textcolor=color.new(color.white, 0), size=size.tiny)
plotshape(sell, title='Sell', text='Sell', style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 0), textcolor=color.new(color.white, 0), size=size.tiny)

barcolor(barbuy ? color.green : na)
barcolor(barsell ? color.red : na)

alertcondition(buy, 'UT Long', 'UT Long')
alertcondition(sell, 'UT Short', 'UT Short')

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
bullCss1          = input.color(color.teal, 'FVG Level'               , inline = 'bull')
bullAreaCss      = input.color(color.new(color.teal, 50), 'Area'     , inline = 'bull')
bullMitigatedCss = input.color(color.new(color.teal, 80), 'Mitigated', inline = 'bull')

bearCss1          = input.color(color.red, 'FVG Level'                , inline = 'bear')
bearAreaCss      = input.color(color.new(color.red, 50), 'Area'      , inline = 'bear')
bearMitigatedCss = input.color(color.new(color.red, 80), 'Mitigated' , inline = 'bear')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type fvg
    float top
    float btm
    bool  mitigated
    bool  isnew
    bool  isbull
    line  lvl
    box   area

type session_range
    line max
    line min

//-----------------------------------------------------------------------------}
//Methods
//-----------------------------------------------------------------------------{
nl = bar_index

//Method for setting fair value gaps
method set_fvg(fvg id, offset, bg_css, l_css)=>
    avg = math.avg(id.top, id.btm)

    area  = box.new(nl - offset, id.top, nl, id.btm, na, bgcolor = bg_css)
    avg_l = line.new(nl - offset, avg, nl, avg, color = l_css, style = line.style_dashed)

    id.lvl := avg_l
    id.area := area

//Method for setting session range maximum/minimum
method set_range(session_range id)=>
    max = math.max(high, id.max.get_y2())
    min = math.min(low, id.min.get_y2())

    id.max.set_xy2(nl, max)
    id.max.set_y1(max)

    id.min.set_xy2(nl, min)
    id.min.set_y1(min)

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
var chartCss = color.new(chart.fg_color, 50)

var fvg sfvg = fvg.new(na, na, na, true, na)
var session_range sesr = na

var box area = na
var line avg = na

bull_fvg = low > high[2] and close[1] > high[2]
bear_fvg = high < low[2] and close[1] < low[2]

//Alert conditions
bull_isnew      = false
bear_isnew      = false
bull_mitigated  = false
bear_mitigated  = false
within_bull_fvg = false
within_bear_fvg = false

//-----------------------------------------------------------------------------}
//New session
//-----------------------------------------------------------------------------{
dtf = timeframe.change('D')

//On new session
if dtf
    //Set delimiter
    line.new(nl, high + syminfo.mintick
      , nl, low - syminfo.mintick
      , color = chartCss
      , style = line.style_dashed
      , extend = extend.both)

    //Set new range
    sesr := session_range.new(
      line.new(nl, high, nl, high, color = chartCss)
      , line.new(nl, low, nl, low, color = chartCss))

    sfvg.isnew := true

    //Set prior session fvg right coordinates
    if not na(sfvg.lvl)
        sfvg.lvl.set_x2(nl-2)
        sfvg.area.set_right(nl-2)

//Set range
else if not na(sesr)
    sesr.set_range()

    //Set range lines color
    sesr.max.set_color(sfvg.isbull ? bullCss1 : bearCss1)
    sesr.min.set_color(sfvg.isbull ? bullCss1 : bearCss1)

//-----------------------------------------------------------------------------}
//Set FVG
//-----------------------------------------------------------------------------{
//New session bullish fvg
if bull_fvg and sfvg.isnew
    sfvg := fvg.new(low, high[2], false, false, true)
    sfvg.set_fvg(2, bullAreaCss, bullCss1)

    bull_isnew := true

//New session bearish fvg
else if bear_fvg and sfvg.isnew
    sfvg := fvg.new(low[2], high, false, false, false)
    sfvg.set_fvg(2, bearAreaCss, bearCss1)

    bear_isnew := true

//Change object transparencies if mitigated
if not sfvg.mitigated
    //If session fvg is bullish
    if sfvg.isbull and close < sfvg.btm
        sfvg.set_fvg(1, bullMitigatedCss, bullCss1)

        sfvg.mitigated := true
        bull_mitigated := true

    //If session fvg is bearish
    else if not sfvg.isbull and close > sfvg.top
        sfvg.set_fvg(1, bearMitigatedCss, bearCss1)

        sfvg.mitigated := true
        bear_mitigated := true

//Set fvg right coordinates to current bar
if not sfvg.isnew
    sfvg.lvl.set_x2(nl)
    sfvg.area.set_right(nl)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
//On new session fvg
alertcondition(bull_isnew, 'Bullish FVG', 'New session bullish fvg')
alertcondition(bear_isnew, 'Bearish FVG', 'New session bearish fvg')

//On fvg mitigation
alertcondition(bull_mitigated, 'Mitigated Bullish FVG', 'Session bullish fvg has been mitigated')
alertcondition(bear_mitigated, 'Mitigated Bearish FVG', 'Session bearish fvg has been mitigated')

//If within fvg
alertcondition(close >= sfvg.btm and close <= sfvg.top and sfvg.isbull and not sfvg.isnew
  , 'Price Within Bullish FVG'
  , 'Price is within bullish fvg')

alertcondition(close >= sfvg.btm and close <= sfvg.top and not sfvg.isbull and not sfvg.isnew
  , 'Price Within Bearish FVG'
  , 'Price is within bearish fvg')

//On fvg average cross
alertcondition(ta.cross(close, math.avg(sfvg.top, sfvg.btm)) and sfvg.isbull and not sfvg.isnew
  , 'Bullish FVG AVG Cross'
  , 'Price crossed bullish fvg average')

alertcondition(ta.cross(close, math.avg(sfvg.top, sfvg.btm)) and not sfvg.isbull and not sfvg.isnew
  , 'Bearish FVG AVG Cross'
  , 'Price crossed bearish fvg average')

//-----------------------------------------------------------------------------}

//INPUTS
cooldownPeriod = input.int(10,title="Cooldown Period", minval=0, group = "Settings") 

lbLeft = 20
lbRight = 20

showSwing = input.bool(true,title="Show Swings?", inline="s_1", group = 'Swing Detaction')
swingClr = input.color(color.new(color.orange, 0), title='', inline="s_1", group = 'Swing Detaction')

bullWidth = input.int(1, title='Line Width:', group='Bullish Sweep')
bullStyle = input.string('Dashed', title='Line Style:', options=['Solid', 'Dotted', 'Dashed'], group='Bullish Sweep')
bullColor = input.color(color.new(color.teal, 0), title='Bullish Color:', group='Bullish Sweep')

bearWidth = input.int(1, title='Line Width:', group='Bearish Sweep')
bearStyle = input.string('Dashed', title='Line Style:', options=['Solid', 'Dotted', 'Dashed'], group='Bearish Sweep')
bearColor = input.color(color.new(color.maroon, 0), title='Bearish Color:', group='Bearish Sweep')

//FUNCTIONS
lineStyle(s) =>
    if s == 'Solid'
        line.style_solid
    else if s == 'Dotted'
        line.style_dotted
    else
        line.style_dashed

//VARS
var int bullSignalIndex = 0
var int bearSignalIndex = 0

var line bullLine = na
var line bearLine = na

var line highLine = na
var line lowLine = na

var label swingHighLbl = na
var label swingLowLbl = na
var label swingHighLblTxt = na
var label swingLowLblTxt = na

var float swingLowVal = na
var float swingHighVal = na

//CALCULATIONS
pLow = ta.pivotlow(low, lbLeft, lbRight)
pHigh = ta.pivothigh(high, lbLeft, lbRight)

pLowVal = ta.valuewhen(not na(pLow), low[lbRight], 0) 
pHighVal = ta.valuewhen(not na(pHigh), high[lbRight], 0)

prevLowIndex = ta.valuewhen(not na(pLow), bar_index[lbRight], 0)
prevHighIndex = ta.valuewhen(not na(pHigh), bar_index[lbRight], 0)

lp = ta.lowest(low, lbLeft)
hp = ta.highest(high, lbLeft)

highestClose = ta.highest(close, lbLeft)
lowestClose = ta.lowest(close, lbLeft)

bullishSFP = low < pLowVal and close > pLowVal and open > pLowVal and low == lp and lowestClose >= pLowVal
bearishSFP = high > pHighVal and close < pHighVal and open < pHighVal and high == hp and highestClose <= pHighVal

bullCond = bullishSFP[3] and (close > pLowVal) and  (close[1] > pLowVal[1]) and (close[2] > pLowVal[2]) and bar_index >= bullSignalIndex + cooldownPeriod
bearCond = bearishSFP[3] and (close < pHighVal) and  (close[1] < pHighVal[1]) and (close[2] < pHighVal[2]) and bar_index >= bearSignalIndex + cooldownPeriod

//Check Swing H/L Stopper
var int swingLowCounter = 0
var int swingHighCounter = 0
var bool isSwingLowCheck = false
var bool isSwingHighCheck = false
var bool stopPrintingLow = false
var bool stopPrintingHigh = false

if high < swingLowVal and isSwingLowCheck
    swingLowCounter := swingLowCounter+1

if low > swingHighVal and isSwingHighCheck
    swingHighCounter := swingHighCounter+1

if ta.crossunder(close, swingLowVal) and isSwingLowCheck == false
    isSwingLowCheck := true
    swingLowCounter := 1

if ta.crossover(close, swingHighVal) and isSwingHighCheck == false
    isSwingHighCheck := true
    swingHighCounter := 1

if swingLowCounter == 5 and isSwingLowCheck
    stopPrintingLow := true
    isSwingLowCheck := false
    line.set_x2(lowLine,bar_index[4])

if swingHighCounter == 5 and isSwingHighCheck
    stopPrintingHigh := true
    isSwingHighCheck := false
    line.set_x2(highLine,bar_index[4])

//Draw sweep lines
if bullCond
    bullSignalIndex := bar_index
    bullLine := line.new(prevLowIndex, pLowVal, bar_index-3, pLowVal, color=bullColor, width=bullWidth, style=lineStyle(bullStyle))

if bearCond
    bearSignalIndex := bar_index
    bearLine := line.new(prevHighIndex, pHighVal, bar_index-3, pHighVal, color=bearColor, width=bearWidth, style=lineStyle(bearStyle))

var swingHighArr = array.new_label(0)
var swingHighTextArr = array.new_label(0)

var swingLowArr = array.new_label(0)
var swingLowTextArr = array.new_label(0)

if array.size(swingHighArr) >= 3
    label.delete(array.shift(swingHighArr))
    label.delete(array.shift(swingHighTextArr))
   
if array.size(swingLowArr) >= 3
    label.delete(array.shift(swingLowArr))
    label.delete(array.shift(swingLowTextArr))

//Draw range lines
if showSwing
    if stopPrintingHigh == false 
        line.set_x2(highLine,bar_index+5)
    if stopPrintingLow == false
        line.set_x2(lowLine,bar_index+5)

if showSwing and not na(pHigh) and bearishSFP[lbRight] == false
    stopPrintingHigh := false
    swingHighVal := high[lbRight]
    line.delete(highLine)
    highLine := line.new(bar_index[lbRight], high[lbRight], bar_index+10, high[lbRight], color = swingClr, width = 2)

    swingHighLbl := label.new(bar_index[lbRight], high[lbRight], text="", yloc=yloc.abovebar, color = swingClr, textcolor = swingClr, style = label.style_triangledown, size = size.auto)
    swingHighLblTxt := label.new(bar_index[lbRight], high[lbRight], text="Swing\nH", yloc=yloc.abovebar, color = swingClr, textcolor = swingClr, style = label.style_none, size = size.small)
    array.push(swingHighArr, swingHighLbl)
    array.push(swingHighTextArr, swingHighLblTxt)

if showSwing and not na(pLow) and bullishSFP[lbRight] == false
    stopPrintingLow := false
    swingLowVal := low[lbRight]
    line.delete(lowLine)
    lowLine := line.new(bar_index[lbRight], low[lbRight], bar_index+10, low[lbRight], color = swingClr, width = 2)

    swingLowLbl := label.new(bar_index[lbRight], low[lbRight], text="", yloc=yloc.belowbar, color = swingClr, textcolor = swingClr, style = label.style_triangleup, size = size.auto)
    swingLowLblTxt := label.new(bar_index[lbRight], low[lbRight], text="Swing\nL", yloc=yloc.belowbar, color = swingClr, textcolor = swingClr, style = label.style_none, size = size.small)
    array.push(swingLowArr, swingLowLbl)
    array.push(swingLowTextArr, swingLowLblTxt) 

//PLOTS
plotshape(bullCond, text='Sweep', color=bullColor, textcolor=bullColor, location=location.belowbar, offset = -3)
plotshape(bearCond, text='Sweep', color=bearColor, textcolor=bearColor, location=location.abovebar, offset = -3) 

//ALERTS
alertcondition(bullishSFP, title='Bullish Sweep', message='{{ticker}} Bullish Sweep, Price:{{close}}')
alertcondition(bearishSFP, title='Bearish Sweep', message='{{ticker}} Bearish Sweep, Price:{{close}}')


//------------------------------------------------------------------------------
length1      = input(100)
extend      = input(true,'Extend To Last Bar')
show_ext    = input(true,'Show Extremities') 
show_labels = input(true,'Show Labels') 

//Style

upcol = input(#ff1100,'Upper Extremity Color',group='Style')
midcol = input(#ff5d00,'Zig Zag Color',group='Style')
dncol = input(#2157f3,'Lower Extremity Color',group='Style')

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
liqGrp = 'Liquidity Detection'
liqLen = input.int   (7, title = 'Detection Length', minval = 3, maxval = 13, inline = 'LIQ', group = liqGrp)
liqMar = 10 / input.float (6.9, 'Margin', minval = 4, maxval = 9, step = 0.1, inline = 'LIQ', group = liqGrp)

liqBuy = input.bool (true, 'Buyside Liquidity Zones, Margin', inline = 'Buyside', group = liqGrp)
marBuy    = input.float(2.3, '', minval = 1.5, maxval = 10, step = .1, inline = 'Buyside', group = liqGrp)
cLIQ_B = input.color (color.new(#4caf50,  0), '', inline = 'Buyside', group = liqGrp)

liqSel = input.bool (true, 'Sellside Liquidity Zones, Margin', inline = 'Sellside', group = liqGrp)
marSel = input.float(2.3, '', minval = 1.5, maxval = 10, step = .1, inline = 'Sellside', group = liqGrp)
cLIQ_S = input.color (color.new(#f23645,  0), '', inline = 'Sellside', group = liqGrp)

lqVoid = input.bool (false, 'Liquidity Voids, Bullish', inline = 'void', group = liqGrp)
cLQV_B = input.color (color.new(#4caf50,  0), '', inline = 'void', group = liqGrp)
cLQV_S = input.color (color.new(#f23645,  0), 'Bearish', inline = 'void', group = liqGrp)
lqText = input.bool (false, 'Label', inline = 'void', group = liqGrp)

mode   = input.string('Present', title = 'Mode', options =['Present', 'Historical'], inline = 'MOD', group = liqGrp)
visLiq = input.int   (3, 'Â Â Â Â # Visible Levels', minval = 1, maxval = 50, inline = 'MOD', group = liqGrp)

//-----------------------------------------------------------------------------}
//General Calculations
//-----------------------------------------------------------------------------{
maxSize = 50
atr     = ta.atr(10)
atr200  = ta.atr(200)
per     = mode == 'Present' ? last_bar_index - bar_index <=  500 : true

//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
// @type        used to store pivot high/low data 
//
// @field d     (array<int>) The array where the trend direction is to be maintained
// @field x     (array<int>) The array where the bar index value of pivot high/low is to be maintained
// @field y     (array<float>) The array where the price value of pivot high/low is to be maintained

type ZZ 
    int   [] d
    int   [] x 
    float [] y 

// @type        bar properties with their values 
//
// @field o     (float) open price of the bar
// @field h     (float) high price of the bar
// @field l     (float) low price of the bar
// @field c     (float) close price of the bar
// @field i     (int) index of the bar

type bar
    float o = open
    float h = high
    float l = low
    float c = close
    int   i = bar_index

// @type        liquidity object definition 
//
// @field bx    (box) box maitaing the liquity level margin extreme levels
// @field bxz   (box) box maitaing the liquity zone margin extreme levels
// @field bxt   (box) box maitaing the labels
// @field brZ   (bool) mainains broken zone status
// @field brL   (bool) mainains broken level status
// @field ln    (line) maitaing the liquity level line
// @field lne   (line) maitaing the liquity extended level line

type liq
    box   bx
    box   bxz
    box   bxt
    bool  brZ
    bool  brL
    line  ln
    line  lne

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
var ZZ aZZ = ZZ.new(
 array.new <int>  (maxSize,  0), 
 array.new <int>  (maxSize,  0), 
 array.new <float>(maxSize, na)
 )

bar b = bar.new()

var liq[] b_liq_B = array.new<liq> (1, liq.new(box(na), box(na), box(na), false, false, line(na), line(na)))
var liq[] b_liq_S = array.new<liq> (1, liq.new(box(na), box(na), box(na), false, false, line(na), line(na)))

var b_liq_V = array.new_box()

var int dir = na, var int x1 = na, var float y1 = na, var int x2 = na, var float y2 = na

//-----------------------------------------------------------------------------}
//Functions/methods
//-----------------------------------------------------------------------------{
// @function        maintains arrays 
//                     it prepends a `value` to the arrays and removes their oldest element at last position
// @param aZZ       (UDT<array<int>, array<int>, array<float>>) The UDT obejct of arrays
// @param _d        (array<int>) The array where the trend direction is maintained
// @param _x        (array<int>) The array where the bar index value of pivot high/low is maintained
// @param _y        (array<float>) The array where the price value of pivot high/low is maintained
//
// @returns         none

method in_out(ZZ aZZ, int _d, int _x, float _y) =>
    aZZ.d.unshift(_d), aZZ.x.unshift(_x), aZZ.y.unshift(_y), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop()


// @function        (build-in) sets the maximum number of bars that is available for historical reference 
                    
max_bars_back(time, 1000)

//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
x2 := b.i - 1
ph  = ta.pivothigh(liqLen, 1)
pl  = ta.pivotlow (liqLen, 1)

if ph   
    dir := aZZ.d.get(0) 
    x1  := aZZ.x.get(0) 
    y1  := aZZ.y.get(0) 
    y2  := nz(b.h[1])

    if dir < 1
        aZZ.in_out(1, x2, y2)
    else
        if dir == 1 and ph > y1 
            aZZ.x.set(0, x2), aZZ.y.set(0, y2)
    
    if per
        count = 0
        st_P  = 0.
        st_B  = 0
        minP  = 0.
        maxP  = 10e6

        for i = 0 to maxSize - 1
            if aZZ.d.get(i) ==  1 
                if aZZ.y.get(i) > ph + (atr / liqMar)
                    break
                else
                    if aZZ.y.get(i) > ph - (atr / liqMar) and aZZ.y.get(i) < ph + (atr / liqMar)
                        count += 1
                        st_B := aZZ.x.get(i)
                        st_P := aZZ.y.get(i)
                        if aZZ.y.get(i) > minP
                            minP := aZZ.y.get(i)
                        if aZZ.y.get(i) < maxP 
                            maxP := aZZ.y.get(i)

        if count > 2
            getB = b_liq_B.get(0)

            if st_B == getB.bx.get_left()
                getB.bx.set_top(math.avg(minP, maxP) + (atr / liqMar))
                getB.bx.set_rightbottom(b.i + 10, math.avg(minP, maxP) - (atr / liqMar))
            else
                b_liq_B.unshift(
                 liq.new(
                   box.new(st_B, math.avg(minP, maxP) + (atr / liqMar), b.i + 10, math.avg(minP, maxP) - (atr / liqMar), bgcolor=color(na), border_color=color(na)), 
                   box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                   box.new(st_B, st_P, b.i + 10, st_P, text = 'Buyside liquidity', text_size = size.tiny, text_halign = text.align_left, text_valign = text.align_bottom, text_color = color.new(cLIQ_B, 25), bgcolor = color(na), border_color = color(na)),
                   false, 
                   false,
                   line.new(st_B   , st_P, b.i - 1, st_P, color = color.new(cLIQ_B, 0)),
                   line.new(b.i - 1, st_P, na     , st_P, color = color.new(cLIQ_B, 0), style = line.style_dotted))
                 )

                alert('buyside liquidity level detected/updated for ' + syminfo.ticker)

            if b_liq_B.size() > visLiq
                getLast = b_liq_B.pop()
                getLast.bx.delete()
                getLast.bxz.delete()
                getLast.bxt.delete()
                getLast.ln.delete()
                getLast.lne.delete()               

if pl
    dir := aZZ.d.get (0) 
    x1  := aZZ.x.get (0) 
    y1  := aZZ.y.get (0) 
    y2  := nz(b.l[1])
    
    if dir > -1
        aZZ.in_out(-1, x2, y2)
    else
        if dir == -1 and pl < y1 
            aZZ.x.set(0, x2), aZZ.y.set(0, y2)
    
    if per
        count = 0
        st_P  = 0.
        st_B  = 0
        minP  = 0.
        maxP  = 10e6

        for i = 0 to maxSize - 1
            if aZZ.d.get(i) == -1 
                if aZZ.y.get(i) < pl - (atr / liqMar)
                    break
                else
                    if aZZ.y.get(i) > pl - (atr / liqMar) and aZZ.y.get(i) < pl + (atr / liqMar)
                        count += 1
                        st_B := aZZ.x.get(i)
                        st_P := aZZ.y.get(i)
                        if aZZ.y.get(i) > minP
                            minP := aZZ.y.get(i)
                        if aZZ.y.get(i) < maxP 
                            maxP := aZZ.y.get(i)

        if count > 2
            getB = b_liq_S.get(0)

            if st_B == getB.bx.get_left()
                getB.bx.set_top(math.avg(minP, maxP) + (atr / liqMar))
                getB.bx.set_rightbottom(b.i + 10, math.avg(minP, maxP) - (atr / liqMar))
            else
                b_liq_S.unshift(
                 liq.new(
                   box.new(st_B, math.avg(minP, maxP) + (atr / liqMar), b.i + 10, math.avg(minP, maxP) - (atr / liqMar), bgcolor=color(na), border_color=color(na)),
                   box.new(na, na, na, na, bgcolor=color(na), border_color=color(na)),
                   box.new(st_B, st_P, b.i + 10, st_P, text = 'Sellside liquidity', text_size = size.tiny, text_halign = text.align_left, text_valign = text.align_top, text_color = color.new(cLIQ_S, 25), bgcolor=color(na), border_color=color(na)),
                   false,
                   false,
                   line.new(st_B   , st_P, b.i - 1, st_P, color = color.new(cLIQ_S, 0)),
                   line.new(b.i - 1, st_P, na     , st_P, color = color.new(cLIQ_S, 0), style = line.style_dotted))
                 )  

                alert('sellside liquidity level detected/updated for ' + syminfo.ticker)

            if b_liq_S.size() > visLiq
                getLast = b_liq_S.pop()
                getLast.bx.delete()
                getLast.bxz.delete()
                getLast.bxt.delete()
                getLast.ln.delete()            
                getLast.lne.delete()               


for i = 0 to b_liq_B.size() - 1
    x = b_liq_B.get(i)
    
    if not x.brL
        x.lne.set_x2(b.i)

        if b.h > x.bx.get_top()
            x.brL := true
            x.brZ := true
            alert('buyside liquidity level breached for ' + syminfo.ticker)

            x.bxz.set_lefttop(b.i - 1, math.min(x.ln.get_y1() + marBuy * (atr), b.h))
            x.bxz.set_rightbottom(b.i + 1, x.ln.get_y1())
            x.bxz.set_bgcolor(color.new(cLIQ_B, liqBuy ? 73 : 100))

    else if x.brZ
        if b.l > x.ln.get_y1() - marBuy * (atr) and b.h < x.ln.get_y1() + marBuy * (atr)
            x.bxz.set_right(b.i + 1)
            x.bxz.set_top(math.max(b.h, x.bxz.get_top()))
            if liqBuy
                x.lne.set_x2(b.i + 1)
        else
            x.brZ := false

for i = 0 to b_liq_S.size() - 1
    x = b_liq_S.get(i)

    if not x.brL
        x.lne.set_x2(b.i)

        if b.l < x.bx.get_bottom()
            x.brL := true
            x.brZ := true
            alert('sellside liquidity level breached for ' + syminfo.ticker)

            x.bxz.set_lefttop(b.i - 1, x.ln.get_y1())
            x.bxz.set_rightbottom(b.i + 1, math.max(x.ln.get_y1() - marSel * (atr), b.l))
            x.bxz.set_bgcolor(color.new(cLIQ_S, liqSel ? 73 : 100))

    else if x.brZ
        if b.l > x.ln.get_y1() - marSel * (atr) and b.h < x.ln.get_y1() + marSel * (atr)
            x.bxz.set_rightbottom(b.i + 1, math.min(b.l, x.bxz.get_bottom()))
            if liqSel
                x.lne.set_x2(b.i + 1)
        else
            x.brZ := false

if lqVoid and per
    bull = b.l - b.h[2] > atr200 and b.l > b.h[2] and b.c[1] > b.h[2]
    bear = b.l[2] - b.h > atr200 and b.h < b.l[2] and b.c[1] < b.l[2]

    if bull 
        l  = 13
        if bull[1] 
            st = math.abs(b.l - b.l[1]) / l
            for i = 0 to l - 1
                array.push(b_liq_V, box.new(b.i - 2, b.l[1] + i * st, b.i, b.l[1] + (i + 1) * st, border_color = na, bgcolor = color.new(cLQV_B, 90) ))
        else   
            st = math.abs(b.l - b.h[2]) / l
            for i = 0 to l - 1
                if lqText and i == 0
                    array.push(b_liq_V, box.new(b.i - 2, b.h[2] + i * st, b.i, b.h[2] + (i + 1) * st, text = 'Liquidity Void   ', text_size = size.tiny, text_halign = text.align_right, text_valign = text.align_bottom, text_color = na, border_color = na, bgcolor = color.new(cLQV_B, 90) ))
                else
                    array.push(b_liq_V, box.new(b.i - 2, b.h[2] + i * st, b.i, b.h[2] + (i + 1) * st, border_color = na, bgcolor = color.new(cLQV_B, 90) ))

    if bear
        l  = 13
        if bear[1]
            st = math.abs(b.h[1] - b.h) / l
            for i = 0 to l - 1
                array.push(b_liq_V, box.new(b.i - 2, b.h + i * st, b.i, b.h + (i + 1) * st, border_color = na, bgcolor = color.new(cLQV_S, 90) ))
        else
            st = math.abs(b.l[2] - b.h) / l
            for i = 0 to l - 1
                if lqText and i == l - 1
                    array.push(b_liq_V, box.new(b.i - 2, b.h + i * st, b.i, b.h + (i + 1) * st, text = 'Liquidity Void   ', text_size = size.tiny, text_halign = text.align_right, text_valign = text.align_top, text_color = na, border_color = na, bgcolor = color.new(cLQV_S, 90) ))
                else
                    array.push(b_liq_V, box.new(b.i - 2, b.h + i * st, b.i, b.h + (i + 1) * st, border_color = na, bgcolor = color.new(cLQV_S, 90) ))

if b_liq_V.size() > 0
    qt = b_liq_V.size()
    for bn = qt - 1 to 0
        if bn < b_liq_V.size()
            cb = b_liq_V.get(bn)
            ba = math.avg(cb.get_bottom(), cb.get_top())

            if math.sign(b.c[1] - ba) != math.sign(b.c - ba) or math.sign(b.c[1] - ba) != math.sign(b.l - ba) or math.sign(b.c[1] - ba) != math.sign(b.h - ba)
                b_liq_V.remove(bn)
            else
                cb.set_right(b.i + 1)

                if b.i - cb.get_left() > 21
                    cb.set_text_color(color.new(color.gray, 25))

//-----------------------------------------------------------------------------}

C_Len = 14 // ta.ema depth for bodyAvg
C_ShadowPercent = 5.0 // size of shadows
C_ShadowEqualsPercent = 100.0
C_DojiBodyPercent = 5.0
C_Factor = 2.0 // shows the number of times the shadow dominates the candlestick body

C_BodyHi = math.max(close, open)
C_BodyLo = math.min(close, open)
C_Body = C_BodyHi - C_BodyLo
C_BodyAvg = ta.ema(C_Body, C_Len)
C_SmallBody = C_Body < C_BodyAvg
C_LongBody = C_Body > C_BodyAvg
C_UpShadow = high - C_BodyHi
C_DnShadow = C_BodyLo - low
C_HasUpShadow = C_UpShadow > C_ShadowPercent / 100 * C_Body
C_HasDnShadow = C_DnShadow > C_ShadowPercent / 100 * C_Body
C_WhiteBody = open < close
C_BlackBody = open > close
C_Range = high-low
C_IsInsideBar = C_BodyHi[1] > C_BodyHi and C_BodyLo[1] < C_BodyLo
C_BodyMiddle = C_Body / 2 + C_BodyLo
C_ShadowEquals = C_UpShadow == C_DnShadow or (math.abs(C_UpShadow - C_DnShadow) / C_DnShadow * 100) < C_ShadowEqualsPercent and (math.abs(C_DnShadow - C_UpShadow) / C_UpShadow * 100) < C_ShadowEqualsPercent
C_IsDojiBody = C_Range > 0 and C_Body <= C_Range * C_DojiBodyPercent / 100
C_Doji = C_IsDojiBody and C_ShadowEquals

patternLabelPosLow = low - (ta.atr(30) * 0.6)
patternLabelPosHigh = high + (ta.atr(30) * 0.6)

label_color_bearish = input(color.rgb(255, 82, 82, 90), "Label Color Bearish")
label_color_bullish = input(color.rgb(33, 149, 243, 90), "Label Color Bullish")

C_MarubozuBlackBearishNumberOfCandles = 1
C_MarubozuWhiteBullishNumberOfCandles = 1
C_MarubozuShadowPercentBearish = 5.0
C_MarubozuShadowPercentWhite = 5.0

C_MarubozuBlackBearish = C_BlackBody and C_LongBody and C_UpShadow <= C_MarubozuShadowPercentBearish/100*C_Body and C_DnShadow <= C_MarubozuShadowPercentBearish/100*C_Body and C_BlackBody
C_MarubozuWhiteBullish = C_WhiteBody and C_LongBody and C_UpShadow <= C_MarubozuShadowPercentWhite/100*C_Body and C_DnShadow <= C_MarubozuShadowPercentWhite/100*C_Body and C_WhiteBody

combined_alert_condition = C_MarubozuBlackBearish or C_MarubozuWhiteBullish

alertcondition(combined_alert_condition, title = "Marubozu Pattern Detected", message = "A Marubozu pattern has been detected!")

if C_MarubozuBlackBearish
    var ttBearishMarubozuBlack = "Marubozu Black\nThis is a candlestick that has no shadow, which extends from the red-bodied candle at the open, the close, or even at both. In Japanese, the name means âclose-croppedâ or âclose-cut.â The candlestick can also be referred to as Bald or Shaven Head."
    label.new(bar_index, patternLabelPosHigh, text="MB", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishMarubozuBlack)

if C_MarubozuWhiteBullish
    var ttBullishMarubozuWhite = "Marubozu White\nA Marubozu White Candle is a candlestick that does not have a shadow that extends from its candle body at either the open or the close. Marubozu is Japanese for âclose-croppedâ or âclose-cut.â Other sources may call it a Bald or Shaven Head Candle."
    label.new(bar_index, patternLabelPosLow, text="MW", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishMarubozuWhite)

//--------------//

C_DownTrend = true
C_UpTrend = true
var trendRule1 = "SMA50"
var trendRule2 = "SMA50, SMA200"
var trendRule = input.string(trendRule1, "Detect Trend Based On", options=[trendRule1, trendRule2, "No detection"])

if trendRule == trendRule1
	priceAvg = ta.sma(close, 50)
	C_DownTrend := close < priceAvg
	C_UpTrend := close > priceAvg

if trendRule == trendRule2
	sma200 = ta.sma(close, 200)
	sma50 = ta.sma(close, 50)
	C_DownTrend := close < sma50 and sma50 < sma200
	C_UpTrend := close > sma50 and sma50 > sma200


C_EngulfingBullishNumberOfCandles = 2
C_EngulfingBullish = C_DownTrend and C_WhiteBody and C_LongBody and C_BlackBody[1] and C_SmallBody[1] and close >= open[1] and open <= close[1] and ( close > open[1] or open < close[1] )
alertcondition(C_EngulfingBullish, title = "New pattern detected", message = "New Engulfing â Bullish pattern detected")
if C_EngulfingBullish
    var ttBullishEngulfing = "Engulfing\nAt the end of a given downward trend, there will most likely be a reversal pattern. To distinguish the first day, this candlestick pattern uses a small body, followed by a day where the candle body fully overtakes the body from the day before, and closes in the trendâs opposite direction. Although similar to the outside reversal chart pattern, it is not essential for this pattern to completely overtake the range (high to low), rather only the open and the close."
    label.new(bar_index, patternLabelPosLow, text="BE", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishEngulfing)


C_EngulfingBearishNumberOfCandles = 2
C_EngulfingBearish = C_UpTrend and C_BlackBody and C_LongBody and C_WhiteBody[1] and C_SmallBody[1] and close <= open[1] and open >= close[1] and ( close < open[1] or open > close[1] )
alertcondition(C_EngulfingBearish, title = "New pattern detected", message = "New Engulfing â Bearish pattern detected")
if C_EngulfingBearish
    var ttBearishEngulfing = "Engulfing\nAt the end of a given uptrend, a reversal pattern will most likely appear. During the first day, this candlestick pattern uses a small body. It is then followed by a day where the candle body fully overtakes the body from the day before it and closes in the trendâs opposite direction. Although similar to the outside reversal chart pattern, it is not essential for this pattern to fully overtake the range (high to low), rather only the open and the close."
    label.new(bar_index, patternLabelPosHigh, text="BE", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishEngulfing)


//--------------//
// EMA 20 50 200
//-----------------------------------------------------------------------------{
shortest = ta.ema(close, 20)
short = ta.ema(close, 50)
long = ta.ema(close, 200)
color c0 = color.new(color.orange, 50)
color c1 = color.new(color.red, 80)
color c2 = color.new(color.blue, 80)
color c3 = color.new(color.blue, 50)
plot(shortest, color = c0)
plot(short, color = c1)
plot(long, color = c2)
plot(ta.cross(short, long) ? short : na, style = plot.style_cross, linewidth = 4,color = c3)

//------------------------------------------------------------------------------
// Nadaraya-Watson Envelope
//-----------------------------------------------------------------------------{
length2 = input.float(500,'Window Size',maxval=500,minval=0)
h1      = input.float(10.,'Bandwidth')
mult   = input.float(3.) 
srcUpperBand = input.source(low,'Source Upper Band')
src1    = input.source(high,'Source Lower Band')


up_col = input.color(#ff1100,'Colors',inline='col')
dn_col = input.color(#39ff14,'',inline='col')
show_bands = input(false, 'Show Bands')
show_sma_7_low_1 = input(false, 'Show SMA 7 LOW +1')
show_sma_7_low_7 = input(false, 'Show SMA 7 LOW -7')
show_sma_30_high = input(false, 'Show SMA 30 HIGH')
//----

var k = 2
var upper1 = array.new_line(0) 
var lower1 = array.new_line(0) 

sma7_low = ta.sma(low, 7)
sma30_high = ta.sma(high, 30)

strDownArrows = "ââ¼â"
strUpArrows = "ââ²â"

RoundUp(number, decimals) =>
    factor = math.pow(10, decimals)
    math.ceil(number * factor) / factor

plot(show_sma_7_low_1?sma7_low:na, color=color.rgb(255, 235, 59, 81), title="SMA 7 LOW +1", offset=+1, linewidth=1)
plot(show_sma_7_low_7?sma7_low:na, color=color.rgb(255, 235, 59, 81), title="7 sma", offset=-7, linewidth=1)
plot(show_sma_30_high ? sma30_high:na, color=color.purple, title="SMA 30 High", linewidth=1)
lset(l,x1,y1,x2,y2,col)=>
    line.set_xy1(l,x1,y1)
    line.set_xy2(l,x2,y2)
    line.set_color(l,col)
    line.set_width(l,2)

if barstate.isfirst
    for i = 0 to length2/k-1
        array.push(upper1,line.new(na,na,na,na))
        array.push(lower1,line.new(na,na,na,na))
//----
line up = na
line dn = na
//----
cross_up = 0.
cross_dn = 0.
if barstate.islast
    y = array.new_float(0)
    yUpper = array.new_float(0)
    
    sum_upper_e = 0.
    sum_e = 0.
    for i = 0 to length2-1
        sum_upper = 0.
        sumw_upper = 0.
        sum = 0.
        sumw = 0.
        
        for j = 0 to length2-1
            w = math.exp(-(math.pow(i-j,2)/(h1*h1*2)))
            sum_upper += srcUpperBand[j]*w
            sum += src1[j]*w
            sumw += w
        
        y_upper_2 = sum_upper/sumw
        sum_upper_e += math.abs(srcUpperBand[i] - y_upper_2)
        array.push(yUpper,y_upper_2)

        y2 = sum/sumw
        sum_e += math.abs(src1[i] - y2)
        array.push(y,y2)

    mae_upper = sum_upper_e/length2*mult
    mae = sum_e/length2*mult
    
    for i = 1 to length2-1
        upper_y2 = array.get(yUpper,i)
        upper_y1 = array.get(yUpper,i-1)

        y2 = array.get(y,i)
        y1 = array.get(y,i-1)
        
        up := array.get(upper1,i/k) 
        dn := array.get(lower1,i/k)

        //draw borders bands
        if show_bands
            lset(up,n-i+1,upper_y1 + mae_upper,n-i,upper_y2 + mae_upper,up_col)
            lset(dn,n-i+1,y1 - mae,n-i,y2 - mae,dn_col)
        
        //draw fractals
        //if src[i] > y1 + mae and src[i+1] < y1 + mae
        //    label.new(n-i,src[i],strDownArrows,color=#00000000,style=label.style_label_down,textcolor=dn_col,textalign=text.align_center)
        //if src[i] < y1 - mae and src[i+1] > y1 - mae
        //    label.new(n-i,src[i],strUpArrows,color=#00000000,style=label.style_label_up,textcolor=up_col,textalign=text.align_center)
        
        //draw sma 30 high signals
        if sma30_high[i] > upper_y1 + mae_upper and sma30_high[i+1] < upper_y2 + mae_upper
            label.new(n-i,srcUpperBand[i]+mae_upper,strDownArrows,color=#00000000,style=label.style_label_down,textcolor=#ec0505,textalign=text.align_center)
        //if sma30_high[i] < y1 - mae and sma30_high[i+1] > y2 - mae
        //    label.new(n-i,src[i+1],strUpArrows,color=#00000000,style=label.style_label_down,textcolor=#ec05af,textalign=text.align_center)

        //draw sma 7 low signals
        if sma7_low[i] > upper_y1 + mae_upper and sma7_low[i+1] < upper_y2 + mae_upper
            label.new(n-i,src1[i],strDownArrows,color=#00000000,style=label.style_label_down,textcolor=color.orange,textalign=text.align_center)
        if sma7_low[i] < y1 - mae and sma7_low[i+1] > y2 - mae
            label.new(n-i,src1[i]-mae,strUpArrows,color=#00000000,style=label.style_label_up,textcolor=color.rgb(16, 177, 4),textalign=text.align_center)
		
    cross_up := array.get(yUpper,0) + mae_upper
    cross_dn := array.get(y,0) - mae	

sma7_crossover = ta.crossover(sma7_low,cross_up)
sma7_crossunder = ta.crossunder(sma7_low,cross_dn)

sma30_crossover = ta.crossover(sma30_high,cross_up)
sma30_crossunder = ta.crossunder(sma30_high,cross_dn)

alertcondition(sma30_crossunder or sma7_crossunder,title="LONG", message='LONG: {{ticker}}/{{interval}} at price {{close}} on {{exchange}}' )
alertcondition(sma7_crossover or sma30_crossover,title="SHORT", message='SHORT: {{ticker}}/{{interval}} at price {{close}} on {{exchange}}' )


//------------------------------------------------------------------------------
//Settings DIVERGENCE
//-----------------------------------------------------------------------------{
length3 = input.int(3, 'Pivot Lookback', minval = 2)

//Symbol A
useSym1 = input(true, 'Comparison Symbol', inline = 'symA')
sym1    = input.symbol('CME_MINI_DL:ES1!', '', inline = 'symA')

//Symbol B
useSym2 = input(true, 'Comparison Symbol', inline = 'symB')
sym2   = input.symbol('CBOT_MINI_DL:YM1!', '', inline = 'symB')

//Style
bullDivCss = input.color(#ff110082, 'Swing High', group = 'Style')
bearDivCss = input.color(#2156f380, 'Swing Low', group = 'Style')


//-----------------------------------------------------------------------------}
//Function
//-----------------------------------------------------------------------------{

get_hl() => [high, low, close]

//Swing highs divergences
get_divergence(ph1, y2, sym_y2, css)=>
    var float y1 = na
    var float sym_y1 = na
    var int x1 = na
    var smt = 0

    if y2 != y2[1] and sym_y2 != sym_y2[1] 
        //Test for SMT
        if (y2 - y1) * (sym_y2 - sym_y1) < 0
            line.new(n[length3], y2, x1, y1, color = css)

            smt += 1
        
        sym_y1 := sym_y2
        y1 := y2
        x1 := n[length3]
    else if (ph1 and y2 > y2[1]) or (not ph1 and y2 < y2[1]) 
        sym_y1 := na
        y1 := y2
        x1 := n[length3]
    
    smt

//-----------------------------------------------------------------------------}
//Main variables
//-----------------------------------------------------------------------------{
var phN = 0, var plN = 0
var ph_smt1 = 0.
var pl_smt1 = 0.
var ph_smt2 = 0.
var pl_smt2 = 0.

ticker1 = syminfo.ticker(sym1)
ticker2 = syminfo.ticker(sym2)

//-----------------------------------------------------------------------------}
//Detect swing highs/lows and divergences
//-----------------------------------------------------------------------------{
ph1 = fixnan(ta.pivothigh(length3, length3))
pl1 = fixnan(ta.pivotlow(length3, length3))
phN += ph1 != ph1[1] ? 1 : 0
plN += pl1 != pl1[1] ? 1 : 0

//Comparison symbol pivots
[h11, l1, c11] = request.security(sym1, timeframe.period, get_hl())
[h21, l2, c21] = request.security(sym2, timeframe.period, get_hl())

//Detect swing high divergences
if useSym1
    sym_ph1 = fixnan(ta.pivothigh(h11, length3, length3))
    sym_pl1 = fixnan(ta.pivotlow(l1, length3, length3))

    ph_smt1 := get_divergence(true, ph1, sym_ph1, bullDivCss)
    pl_smt1 := get_divergence(false, pl1, sym_pl1, bearDivCss)

if useSym2
    sym_ph2 = fixnan(ta.pivothigh(h21, length3, length3))
    sym_pl2 = fixnan(ta.pivotlow(l2, length3, length3))
    
    ph_smt2 := get_divergence(true, ph1, sym_ph2, bullDivCss)
    pl_smt2 := get_divergence(false, pl1, sym_pl2, bearDivCss)

txt = ''
if ph1 != ph1[1]
    if ph_smt1 > ph_smt1[1]
        txt += ticker1
    if ph_smt2 > ph_smt2[1]
        txt += txt != '' ? ' | ' : ''
        txt += ticker2

    if txt != ''
        label.new(n[length3], ph1, txt
          , color = bullDivCss
          , style = label.style_label_down
          , textcolor = color.white
          , size = size.tiny)
else
    if pl_smt1 > pl_smt1[1]
        txt += ticker1
    if pl_smt2 > pl_smt2[1]
        txt += txt != '' ? ' | ' : ''
        txt += ticker2

    if txt != ''
        label.new(n[length3], pl1, txt
          , color = bearDivCss
          , style = label.style_label_up
          , textcolor = color.white
          , size = size.tiny)
    
//-----------------------------------------------------------------------------}
//Tables
//-----------------------------------------------------------------------------{

if barstate.isfirst and showDash
    tb.cell(1, 0, 'Swing High', text_color = color.white)
    tb.cell(2, 0, 'Swing Low', text_color = color.white)
    
    tb.cell(0, 1, ticker1, text_color = color.white)
    tb.cell(0, 2, ticker2, text_color = color.white)

if barstate.islast and showDash
    //Symbol 1
    tb.cell(1, 1, str.format('{0} ({1, number, percent})', ph_smt1, ph_smt1 / phN)
      , text_color = bullDivCss)
    tb.cell(2, 1, str.format('{0} ({1, number, percent})', pl_smt1, pl_smt1 / plN)
      , text_color = bearDivCss)
    
    //Symbol 2
    tb.cell(1, 2, str.format('{0} ({1, number, percent})', ph_smt2, ph_smt2 / phN)
      , text_color = bullDivCss)
    tb.cell(2, 2, str.format('{0} ({1, number, percent})', pl_smt2, pl_smt2 / plN)
      , text_color = bearDivCss)

//-----------------------------------------------------------------------------
// Imbalance Finder With Pip Target Box
//-----------------------------------------------------------------------------{
showema = input(defval=false, title='Show all EMAs', group='Plot EMA ')
Overridetargetsize = input(defval=false, title='Change Standard Target Size', group='Targets')
Targetssize = input.float(title='Pips for Target', defval=0.0001, minval=0.0001, group = 'Targets')

color black100 = color.new(color.black,100)
color green75 = color.new(color.green,75)
color green0 = color.new(#4caf4f, 10)
color aqua0 = color.new(color.aqua, 0)
color black0 = color.new(color.black, 0)
color blue0 = color.new(#0F52BA, 0)
color gray0 = color.new(#787b86, 100)
color orange0 = color.new(#ff8c00, 10)
color red0 = color.new(#ff5252, 10)
color red75 = color.new(color.red,75)
color white0 = color.new(color.white, 0)
color yellow0 = color.new(#fff700, 100)
bool showgreydiamond = input(defval=false, title='Show Diamond For Back Testing' ,group='=== Information ===')

LabelDigitDisplay =
 syminfo.ticker == 'AUDCAD' == true ? '#.#####' : syminfo.ticker == 'AUDCHF' == true ? '#.#####' : syminfo.ticker == 'AUDJPY' == true ? '#.###'   : syminfo.ticker == 'AUDNZD' == true ? '#.#####'  :
 syminfo.ticker == 'AUDUSD' == true ? '#.#####' : syminfo.ticker == 'CADCHF' == true ? '#.#####' : syminfo.ticker == 'CADJPY' == true ? '#.###'   : syminfo.ticker == 'CHFJPY' == true ? '#.###'    : 
 syminfo.ticker == 'EURAUD' == true ? '#.#####' : syminfo.ticker == 'EURCAD' == true ? '#.#####' : syminfo.ticker == 'EURCHF' == true ? '#.#####' : syminfo.ticker == 'EURGBP' == true ? '#.#####' :
 syminfo.ticker == 'EURJPY' == true ?  '#.###'  : syminfo.ticker == 'EURNZD' == true ? '#.#####' : syminfo.ticker == 'EURUSD' == true ? '#.#####' : syminfo.ticker == 'GBPAUD' == true ? '#.#####' :
 syminfo.ticker == 'GBPCAD' == true ? '#.#####' : syminfo.ticker == 'GBPCHF' == true ? '#.#####' : syminfo.ticker == 'GBPJPY' == true ? '#.###'   : syminfo.ticker == 'GBPNZD' == true ? '#.#####' : 
 syminfo.ticker == 'GBPUSD' == true ? '#.#####' : syminfo.ticker == 'NZDCAD' == true ? '#.#####' : syminfo.ticker == 'NZDCHF' == true ? '#.#####' : syminfo.ticker == 'NZDJPY' == true ? '#.###': 
 syminfo.ticker == 'NZDUSD' == true ? '#.#####' : syminfo.ticker == 'USDCAD' == true ? '#.#####' : syminfo.ticker == 'USDCHF' == true ? '#.#####' : syminfo.ticker == 'USDJPY' == true ? '#.###': 
 syminfo.ticker == 'GOLD'   == true ? '#.##'    : syminfo.ticker == 'US100'  == true ? '#.##'    : syminfo.ticker == 'US30'   == true ? '#.##'    : syminfo.ticker == 'US500'  == true ? '#.##'    : syminfo.ticker == 'DE40' == true ? '#.##' : '#.#####'
 
PipsMultiplier = 
 syminfo.ticker == 'AUDCAD' == true ? 0.00050 : syminfo.ticker == 'AUDCHF' == true ? 0.00050 : syminfo.ticker == 'AUDJPY' == true ? 00.050   : syminfo.ticker == 'AUDNZD' == true ? 0.00050 :
 syminfo.ticker == 'AUDUSD' == true ? 0.00050 : syminfo.ticker == 'CADCHF' == true ? 0.00050 : syminfo.ticker == 'CADJPY' == true ? 00.050   : syminfo.ticker == 'CHFJPY' == true ? 00.050: 
 syminfo.ticker == 'EURAUD' == true ? 0.00050 : syminfo.ticker == 'EURCAD' == true ? 0.00050 : syminfo.ticker == 'EURCHF' == true ? 0.00050 : syminfo.ticker == 'EURGBP' == true ? 0.00050 :
 syminfo.ticker == 'EURJPY' == true ? 00.050   : syminfo.ticker == 'EURNZD' == true ? 0.00050 : syminfo.ticker == 'EURUSD' == true ? 0.00050 : syminfo.ticker == 'GBPAUD' == true ? 0.00050 :
 syminfo.ticker == 'GBPCAD' == true ? 0.00050 : syminfo.ticker == 'GBPCHF' == true ? 0.00050 : syminfo.ticker == 'GBPJPY' == true ? 00.050   : syminfo.ticker == 'GBPNZD' == true ? 0.00050 : 
 syminfo.ticker == 'GBPUSD' == true ? 0.00050 : syminfo.ticker == 'NZDCAD' == true ? 0.00050 : syminfo.ticker == 'NZDCHF' == true ? 0.00050 : syminfo.ticker == 'NZDJPY' == true ? 00.050: 
 syminfo.ticker == 'NZDUSD' == true ? 0.00050 : syminfo.ticker == 'USDCAD' == true ? 0.00050 : syminfo.ticker == 'USDCHF' == true ? 0.00050 : syminfo.ticker == 'USDJPY' == true ? 00.050:
 syminfo.ticker == 'GOLD' == true ? 1.5 : syminfo.ticker == 'US100' == true ? 10 : syminfo.ticker == 'US30' == true ? 25   : syminfo.ticker == 'US500' == true ? 10 : syminfo.ticker == 'DE40' == true ? 10 : 1

Targettouse = Overridetargetsize ? Targetssize : PipsMultiplier

Imbcol = input.color(yellow0, 'Imbalance Colour', inline="1" ,group='=== Information ===')
Dimcol = input.color(gray0, 'Imbalance Colour', inline="1" ,group='=== Information ===')
TopImbalance = low[2] <= open[1] and high[0] >= close[1]
TopImbalancesize = low[2] - high[0]
if TopImbalance and TopImbalancesize > 0
    BOX1 = box.new(left=bar_index[1], top=low[2], right=bar_index[0], bottom=high[0])
    box.set_bgcolor(BOX1, Imbcol )
    box.set_border_color(BOX1, Imbcol )

BottomInbalance = high[2] >= open[1] and low[0] <= close[1]
BottomInbalancesize = low[0] - high[2]
if BottomInbalance and BottomInbalancesize > 0
    BOX2 = box.new(left=bar_index[1], top=low[0], right=bar_index[0], bottom=high[2])
    box.set_bgcolor(BOX2, Imbcol )
    box.set_border_color(BOX2, Imbcol )

DownImbalance = TopImbalance and TopImbalancesize > 0
plotshape(DownImbalance[0] and showgreydiamond, style=shape.diamond, location=location.abovebar, color=Dimcol, size=size.tiny)

UpImbalance = BottomInbalance and BottomInbalancesize > 0
plotshape(UpImbalance[0] and showgreydiamond, style=shape.diamond, location=location.belowbar, color=Dimcol, size=size.tiny)

DownSell = close[1]>open[1] and close<open
UpBuy    = close[1]<open[1] and close>open

boxcolourtop        = UpBuy    ? green0 : black100
boxcolourbottom     = DownSell ? red0   : black100
boxcolourtopfill    = UpBuy    ? green75 : black100
boxcolourbottomfill = DownSell ? red75   : black100

BottomLabel = label.new(x=bar_index, y=high+(Targettouse/3), xloc=xloc.bar_index)
label.set_text(BottomLabel, text
 = "\n \n Entry = " + str.tostring(close,LabelDigitDisplay) 
 + "\n Stop Loss = " + str.tostring(high,LabelDigitDisplay) 
 + "\n Take Profit = " + str.tostring(close-PipsMultiplier,LabelDigitDisplay)
 + "\n Target Size = " + str.tostring(PipsMultiplier,LabelDigitDisplay))
label.set_textalign(BottomLabel, text.align_left)    
label.set_style(BottomLabel, label.style_label_left)
label.set_color(BottomLabel,  black100)
label.set_textcolor(BottomLabel, boxcolourbottom) 
label.delete(BottomLabel[1])
Bottom = box.new(left=bar_index[0], top=low, right=bar_index[0], bottom=low-Targettouse, xloc=xloc.bar_index)
box.set_right(Bottom,right=box.get_right(id=Bottom)+10)
box.set_bgcolor(Bottom , color=boxcolourbottomfill )
box.set_border_color(Bottom , color=boxcolourbottom)
box.delete(Bottom [1]) 

TopLabel = label.new(x=bar_index, y=low-(Targettouse/3), xloc=xloc.bar_index)
label.set_text(TopLabel, text
 = "\n \n Entry = " + str.tostring(close,LabelDigitDisplay) 
 + "\n Stop Loss = " + str.tostring(low,LabelDigitDisplay) 
 + "\n Take Profit = " + str.tostring(close+Targettouse,LabelDigitDisplay)
 + "\n Target Size = " + str.tostring(PipsMultiplier,LabelDigitDisplay))
label.set_textalign(TopLabel, text.align_left)    
label.set_style(TopLabel, label.style_label_left)
label.set_color(TopLabel,  black100)
label.set_textcolor(TopLabel, boxcolourtop ) 
label.delete(TopLabel[1])   
Top =  box.new(left=bar_index[0], top=high+Targettouse, right=bar_index[0], bottom=high, xloc=xloc.bar_index)
box.set_right(Top,right=box.get_right(id=Top)+10)
box.set_bgcolor(Top , color=boxcolourtopfill  )
box.set_border_color(Top, color=boxcolourtop )
box.delete(Top[1]) 

ema13colour = showema ? red0    : black100
ema35colour = showema ? orange0 : black100
ema50colour = showema ? aqua0   : black100

offset = input.int(title='Offset', defval=0, minval=-500, maxval=500)

emalen1513 =26 //input.int(13, minval=1, title='Length 13 EMA 15 Min', group='=== EMA Information ===')
emasrc1513 = close
EMA13 = request.security(syminfo.tickerid, '1', ta.ema(emasrc1513, emalen1513))
plot(EMA13, title='EMA 13 15 Min', color=ema13colour, linewidth=1, offset=offset)

emalen1535 = 63 //input.int(35, minval=1, title='Length 35 EMA 15 Min', group='=== EMA Information ===')
emasrc1535 = close
EMA35 = request.security(syminfo.tickerid, '1', ta.ema(emasrc1535, emalen1535))
plot(EMA35, title='EMA 35 15 Min', color=ema35colour, linewidth=1, offset=offset)

emalen1550 = 100 //input.int(50, minval=1, title='Length 50 EMA 15 Min', group='=== EMA Information ===')
emasrc1550 = close
EMA50 = request.security(syminfo.tickerid, '1', ta.ema(emasrc1550, emalen1550))
plot(EMA50, title='EMA 50 15 Min', color=ema50colour, linewidth=2, offset=offset)

Up   = EMA13 > EMA35 and EMA35 > EMA50
Down = EMA13 < EMA35 and EMA35 < EMA50

plotshape(Up , title='Up',   style=shape.square,   location=location.bottom, color=green0, size=size.tiny) 
plotshape(Down , title='Down',   style=shape.square,   location=location.bottom, color=red0, size=size.tiny) 
plotshape(not Down and not Up , title='Warning',   style=shape.square,   location=location.bottom, color=orange0, size=size.tiny) 

alertcondition(Up and not Up[1] ,  title='Buy  Switch On', message='Buy  Switch On')
alertcondition(Down and not Down[1],  title='Sell Switch On', message='Sell Switch On')
alertcondition(Up[1] and not Up ,  title='Warning Stop any More Buys', message='Warning Stop any More Buys')
alertcondition(Down[1] and not Down,  title='Warning Stop any More Sells', message='Warning Stop any More Sells')

alertcondition(open > close or close <= open ,  title='Every Bar Alert', message='Every Bar Alert')
//-----------------------------------------------------------------------------}
//SUPLLY AND DEMAND
//-----------------------------------------------------------------------------{
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
per1 = input.float(10., 'Threshold %', minval = 0, maxval = 100)
div = input.int(50, 'Resolution'    , minval = 2, maxval = 500)
tf  = input.timeframe('', 'Intrabar TF')

//Colors
showSupply = input(true ,'SupplyÂ Â Â Â Â Â Â Â Â Â Â Â ', inline = 'supply', group = 'Style')
supplyCss  = input(#2157f3, ''         , inline = 'supply', group = 'Style')
supplyArea = input(true ,'Area'          , inline = 'supply', group = 'Style')
supplyAvg  = input(true ,'Average'       , inline = 'supply', group = 'Style')
supplyWavg = input(true ,'Weighted'      , inline = 'supply', group = 'Style')

showEqui   = input(true ,'Equilibrium'   , inline = 'equi'  , group = 'Style')
equiCss    = input(color.gray, ''      , inline = 'equi'  , group = 'Style')
equiAvg    = input(true ,'Average'       , inline = 'equi'  , group = 'Style')
equiWavg   = input(true ,'Weighted'      , inline = 'equi'  , group = 'Style')

showDemand = input(true ,'DemandÂ Â Â Â Â Â Â Â Â Â Â Â '    , inline = 'demand', group = 'Style')
demandCss  = input(#ff5d00, ''         , inline = 'demand', group = 'Style')
demandArea = input(true ,'Area'          , inline = 'demand', group = 'Style')
demandAvg  = input(true ,'Average'       , inline = 'demand', group = 'Style')
demandWavg = input(true ,'Weighted'      , inline = 'demand', group = 'Style')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type bin
    float lvl
    float prev
    float sum
    float prev_sum
    float csum
    float avg
    bool isreached

type area
    box  bx
    line avg 
    line wavg 

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{

get_hlv()=> [high, low, volume]

method set_area(area id, x11, top, btm, avg, wavg, showArea, showAvg, showWavg)=>
    if showArea
        id.bx.set_lefttop(x11, top)
        id.bx.set_rightbottom(n, btm)    
    
    if showAvg
        id.avg.set_xy1(x11, avg)
        id.avg.set_xy2(n, avg)
    
    if showWavg
        id.wavg.set_xy1(x11, wavg)
        id.wavg.set_xy2(n, wavg)

//-----------------------------------------------------------------------------}
//Main variables
//-----------------------------------------------------------------------------{
var max  = 0. 
var min  = 0.
var x11   = 0
var csum = 0.

//Intrabar data
[h, l, v] = request.security_lower_tf(syminfo.tickerid, tf, get_hlv())

//Init on left bar
if time == chart.left_visible_bar_time
    max := high
    min := low
    csum := volume
    x11 := n
else //Accumulate
    max := math.max(high, max)
    min := math.min(low, min)
    csum += volume

//-----------------------------------------------------------------------------}
//Set zones
//-----------------------------------------------------------------------------{
var supply_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(supplyCss, 80))
  , line.new(na, na, na, na, color = supplyCss)
  , line.new(na, na, na, na, color = supplyCss, style = line.style_dashed))

var demand_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(demandCss, 80))
  , line.new(na, na, na, na, color = demandCss)
  , line.new(na, na, na, na, color = demandCss, style = line.style_dashed))

var equi  = line.new(na, na, na, na, color = equiCss)
var wequi = line.new(na, na, na, na, color = equiCss, style = line.style_dashed)

var float supply_wavg = na
var float demand_wavg = na

if time == chart.right_visible_bar_time
    r = (max - min) / div
    supply = bin.new(max, max, 0, 0, 0, 0, false)
    demand = bin.new(min, min, 0, 0, 0, 0, false)

    //Loop trough intervals
    for i = 0 to div-1
        supply.lvl -= r
        demand.lvl += r

        //Accumulated volume column
        if not supply.isreached and showSupply and supplyArea
            box.new(x11, supply.prev, x11 + int(supply.sum / csum * (n - x11)), supply.lvl, na
              , bgcolor = color.new(supplyCss, 50))
        
        if not demand.isreached and showDemand and demandArea
            box.new(x11, demand.lvl, x11 + int(demand.sum / csum * (n - x11)), demand.prev, na
              , bgcolor = color.new(demandCss, 50))
        
        //Loop trough bars
        for j = 0 to (n - x11)-1
            //Loop trough intrabars
            for k = 0 to (v[j]).size()-1
                //Accumulate if within upper internal
                supply.sum      += (h[j]).get(k) > supply.lvl and (h[j]).get(k) < supply.prev ? (v[j]).get(k) : 0
                supply.avg      += supply.lvl * (supply.sum - supply.prev_sum)
                supply.csum     += supply.sum - supply.prev_sum
                supply.prev_sum := supply.sum

                //Accumulate if within lower interval
                demand.sum      += (l[j]).get(k) < demand.lvl and (l[j]).get(k) > demand.prev ? (v[j]).get(k) : 0
                demand.avg      += demand.lvl * (demand.sum - demand.prev_sum)
                demand.csum     += demand.sum - demand.prev_sum
                demand.prev_sum := demand.sum
                
            //Test if supply accumulated volume exceed threshold and set box
            if supply.sum / csum * 100 > per1 and not supply.isreached
                avg = math.avg(max, supply.lvl)
                supply_wavg := supply.avg / supply.csum

                //Set Box/Level coordinates
                if showSupply
                    supply_area.set_area(x11, max, supply.lvl, avg, supply_wavg, supplyArea, supplyAvg, supplyWavg)

                supply.isreached := true
            
            //Test if demand accumulated volume exceed threshold and set box
            if demand.sum / csum * 100 > per1 and not demand.isreached and showDemand
                avg = math.avg(min, demand.lvl)
                demand_wavg := demand.avg / demand.csum
                
                //Set Box/Level coordinates
                if showDemand
                    demand_area.set_area(x11, demand.lvl, min, avg, demand_wavg, demandArea, demandAvg, demandWavg)

                demand.isreached := true
            
            if supply.isreached and demand.isreached
                break
        
        if supply.isreached and demand.isreached and showEqui
            //Set equilibrium
            if equiAvg
                avg = math.avg(max, min)
                equi.set_xy1(x11, avg)
                equi.set_xy2(n, avg)
            
            //Set weighted equilibrium
            if equiWavg
                wavg = math.avg(supply_wavg, demand_wavg)
                wequi.set_xy1(x11, wavg)
                wequi.set_xy2(n, wavg)

            break
        
        supply.prev := supply.lvl
        demand.prev := demand.lvl

//-----------------------------------------------------------------------------}
//SUPPORT AND RESISTANCE MTF
//-----------------------------------------------------------------------------{
const bool DEBUG = false
const int timeframeCount = 3
const float touchATR = 1.0 / 30.0
const float retestATR = 1.0 / 30.0
const float labelOffsetY = 1.5
const int labelOffsetsXIndex = 30
const int maxPivotsBackSR = 15
const int retestLabelEveryXBars = 3
const int maxTraverse = 250  // Affects bar history limit. Default value 250.
const int maxRetestLabels = 100
const int maxSupports = 3
const int maxResistances = 3
const int debug_maxPivotLabels = 25

// _____ INPUTS _____
resistanceSupportCount = input.int(3, "Support & Resistance Count", options = [1, 2, 3], group = "General Configuration", display = display.none)
pivotRange = input.int(15, "Pivot Range", options = [5, 15, 30], tooltip = "Increase for more general pivots, decrease for more private pivots.", group = "General Configuration", display = display.none)
strength = input.int(1, "Strength", options = [1, 2, 3, 4], tooltip = "X many times price touched relative price area in order to be considered a support/resistance zone.", group = "General Configuration", display = display.none)
expandLines = input.bool(true,"Expand Lines & Zones", group = "General Configuration", display = display.none)

enableZones = input.bool(false, "Enable Zones", group = "Support & Resistance Zones", display = display.none)
zoneWidthType = input.string("Dynamic", "Zone Width Type", options = ["Fixed", "Dynamic"], group = "Support & Resistance Zones", display = display.none)
zoneWidth = input.int(1, "Fixed Zone Width", options = [1,2,3], group = "Support & Resistance Zones", display = display.none)

timeframe1Enabled = input.bool(true, title = "", group = "Timeframes", inline = "timeframe1", display = display.none)
timeframe1 = input.timeframe("", title = "", group = "Timeframes", inline = "timeframe1", display = display.none)
timeframe2Enabled = input.bool(true, title = "", group = "Timeframes", inline = "timeframe2", display = display.none)
timeframe2 = input.timeframe("240", title = "", group = "Timeframes", inline = "timeframe2", display = display.none)
timeframe3Enabled = input.bool(false, title = "", group = "Timeframes", inline = "timeframe3", display = display.none)
timeframe3 = input.timeframe("30", title = "", group = "Timeframes", inline = "timeframe3", display = display.none)

showBreaks = input.bool(true,"Show Breaks", group = "Breaks & Retests", inline = "ShowBR", display = display.none)
showRetests = input.bool(true,"Show Retests", group = "Breaks & Retests", inline = "ShowBR", display = display.none)
avoidFalseBreaks = input.bool(true, "Avoid False Breaks", group = "Breaks & Retests", display = display.none)
falseBreakoutVolumeThresholdOpt = input.float(0.3, "Break Volume Threshold", minval=0.1, maxval=1.0, step=0.1, group = "Breaks & Retests", tooltip = "Only taken into account if Avoid False Breakouts is enabled.\nHigher values mean it's less likely to be a break.", display = display.none)
inverseBrokenLineColor = input.bool(true, "Inverse Color After Broken", tooltip = "Needs Show Breaks & Expand Lines option enabled.", group = "Breaks & Retests", display = display.none)

falseBreakoutVolumeThreshold = falseBreakoutVolumeThresholdOpt * 100.0

lineStyle = input.string("....", "Line Style", ["____", "----", "...."], group = "Style", display = display.none)
lineWidth = input.int(1, "Line Width", minval = 1, group = "Style", display = display.none)
supportColor = input.color(#08998180, "Support Color", group = "Style", inline = "RScolors", display = display.none)
resistanceColor = input.color(#f2364580, "Resistance Color", group = "Style", inline = "RScolors", display = display.none)
textColor = input.color(#11101051, "Text Color", group = "Style", inline = "RScolors", display = display.none)
labelsAlign = input.string("Right", "Align Labels", options = ["Right", "Center"], group = "Style", tooltip = "Will only work when zones are disabled.", display = display.none)

enableRetestAlerts = input.bool(true, "Enable Retest Alerts", tooltip = "Needs Show Retests option enabled.", group = "Alerts", display = display.none)
enableBreakAlerts = input.bool(true, "Enable Break Alerts", group = "Alerts", display = display.none)

memoryOptimizatonEnabled = input.bool(true, "Enable Memory Optimization", tooltip = "Enable this option if you encounter memory errors.", group = "Advanced", display = display.none)
// _____ INPUTS END _____

// _____ DEBUG OPTIONS _____
debug_labelPivots = not DEBUG ? "None" : input.string("None", title = "[DBG] Label Pivots", group = "DEBUG", options = ["All", "RS", "None"], tooltip = "All -> Debugs all pivot labels.\nRS -> Debugs RS pivot labels.\nNone -> Debugs none of the last R&S pivots.")
debug_pivotLabelText = not DEBUG ? false : input.bool(false, title = "[DBG] Pivot Label Text", group = "DEBUG")
debug_showBrokenOnLabel = not DEBUG ? false : input.bool(false, "[DBG] Show Broken Text On Label", group = "DEBUG")
debug_removeDuplicateRS = not DEBUG ? true : input.bool(true, "[DBG] Remove Duplicate RS", group = "DEBUG")
debug_lastXResistances = not DEBUG ? 3 : input.int(3, "[DBG] Show Last X Resistances", minval = 0, maxval = maxResistances, group = "DEBUG")
debug_lastXSupports = not DEBUG ? 3 : input.int(3, "[DBG] Show Last X Supports", minval = 0, maxval = maxSupports, group = "DEBUG")
debug_enabledHistory = not DEBUG ? true : input.bool(true, "[DBG] Enable History", group = "DEBUG")
debug_maxHistoryRecords = not DEBUG ? 10 : input.int(10, "[DBG] Max History Records", options =  [1, 2, 5, 10, 25], group = "DEBUG")
// _____ DEBUG OPTIONS END _____

atr1 = ta.atr(30)

createRSLine (color) =>
    line.new(na, na, na, na, extend = expandLines ? extend.both : extend.none, xloc=xloc.bar_time, color = color, width = lineWidth, style = lineStyle == "----" ? line.style_dashed : lineStyle == "...." ? line.style_dotted : line.style_solid)

createRSBox (color, xlocType) =>
    box.new(na, na, na, na, text_size = size.normal, xloc = xlocType, extend = extend.both, bgcolor = color, text_color = textColor, text_halign = expandLines ? text.align_right : text.align_center, border_color = #00000000)

createRSLabel () =>
    label.new(na, na, "", style = label.style_none, textcolor = textColor)

createBreakLabel (RSType) =>
    var ttBreakResistance = "Breakout\nA breakout of Support or Resistance."
    label.new(na,na,"B",style = RSType == "Resistance" ? label.style_label_up : label.style_label_down, color=color.rgb(33, 149, 243, 50), textcolor = color.white, xloc = xloc.bar_time, size = size.small,tooltip = ttBreakResistance)

createRetestLabel (RSType) =>
    label.new(na,na,"R",style = RSType == "Resistance" ? label.style_label_down : label.style_label_up, color = RSType == "Resistance" ? resistanceColor : supportColor, textcolor = color.white, xloc = xloc.bar_time, size = size.small)

moveLine(_line, _x, _y, _x2) =>
    line.set_xy1(_line, _x,  _y)
    line.set_xy2(_line, _x2, _y)

moveBox (_box, _topLeftX, _topLeftY, _bottomRightX, _bottomRightY) =>
    box.set_lefttop(_box, _topLeftX, _topLeftY)
    box.set_rightbottom(_box, _bottomRightX, _bottomRightY)

moveRSInfoBox (_box, _startPointX, _price, _endPointX) =>
    zoneWidthPercent = zoneWidth == 1 ? 0.05 : zoneWidth == 2 ? 0.06 : 0.075
    if zoneWidthType == "Dynamic"
        zoneWidthPercent := ((atr1) / _price) * 100 / 3.0
    topY = _price * (1.0 + (zoneWidthPercent / 2.0 / 100.0))
    bottomY = _price * (1.0 - (zoneWidthPercent / 2.0 / 100.0))
    moveBox(_box, _startPointX, topY, _endPointX, bottomY)

// _____ TYPES _____

type customPoint
    int t
    float price

type RSInfo
    bool isBroken = na
    int brokenTime = na
    string RSType = na
    float price = na
    line line = na
    box box = na
    label priceLabel = na
    customPoint[] points = na
    label[] debugPoints = na
    label breakLabel = na
    label[] retestLabels = na
    line breakLine = na
    box breakBox = na

curTR = ta.tr(true)
lowPivot = ta.pivotlow(low, pivotRange, pivotRange)
highPivot = ta.pivothigh(high, pivotRange, pivotRange)
pivotTime = time[pivotRange]

newRSInfo (RSType) =>
    newRSInfoF = RSInfo.new()
    newRSInfoF.RSType := RSType
    newRSInfoF.price := na
    newRSInfoF.isBroken := false
    newRSInfoF.brokenTime := na

    newRSInfoF.line := enableZones ? na : createRSLine(RSType == "Resistance" ? resistanceColor : supportColor)
    newRSInfoF.box := enableZones ? createRSBox(RSType == "Resistance" ? resistanceColor : supportColor, xloc.bar_time) : na
    newRSInfoF.priceLabel := enableZones ? na : createRSLabel()
    newRSInfoF.points := array.new<customPoint>(0)
    newRSInfoF.debugPoints := array.new<label>(0)
    newRSInfoF.retestLabels := array.new<label>(0)
    newRSInfoF.breakLabel := na
    newRSInfoF.breakLine := na
    newRSInfoF.breakBox := na
    
    newRSInfoF

histRSInfo (RSInfo RSInfoF) =>
    RSType = RSInfoF.RSType
    newRS = RSInfo.new()
    newRS.RSType := RSType
    newRS.price := RSInfoF.price

    newRS.debugPoints := array.new<label>(0)
    newRS.retestLabels := array.new<label>(0)
    newRS.points := array.new<customPoint>(0)

    histText = "History | " + str.tostring(newRS.price, format.mintick)

    startTime = math.min(time, RSInfoF.points.get(RSInfoF.points.size() - 1).t)
    endTime = RSInfoF.isBroken ? RSInfoF.brokenTime : time

    if enableZones
        newRS.box := createRSBox(RSType == "Resistance" ? resistanceColor : supportColor, xloc.bar_time)
        moveRSInfoBox(newRS.box, startTime, newRS.price, endTime)
        box.set_extend(newRS.box, expandLines ? extend.both : extend.none)
        box.set_text(newRS.box, histText)
    else
        newRS.line := line.copy(RSInfoF.line)
        moveLine(newRS.line, startTime, newRS.price, endTime)
        line.set_extend(newRS.line, expandLines ? extend.both : extend.none)

        newRS.priceLabel := label.copy(RSInfoF.priceLabel)
        label.set_text(newRS.priceLabel, histText)
        label.set_xloc(newRS.priceLabel, (startTime + endTime) / 2, xloc.bar_time)
    
    if not na(newRS.breakLabel)
        newRS.breakLabel := label.copy(RSInfoF.breakLabel)
    
    newRS

derenderRSInfo (RSInfo RSInfoF) =>
    if not na(RSInfoF)
        line.delete(RSInfoF.line)
        box.delete(RSInfoF.box)
        label.delete(RSInfoF.priceLabel)

        if RSInfoF.debugPoints.size() > 0
            for i = 0 to RSInfoF.debugPoints.size() - 1
                label.delete(RSInfoF.debugPoints.get(i))

        if RSInfoF.retestLabels.size() > 0
            for i = 0 to RSInfoF.retestLabels.size() - 1
                label.delete(RSInfoF.retestLabels.get(i))
        
        label.delete(RSInfoF.breakLabel)
        line.delete(RSInfoF.breakLine)
        box.delete(RSInfoF.breakBox)

safeDeleteRSInfo (RSInfo RSInfoF) =>
    if not na(RSInfoF)
        derenderRSInfo(RSInfoF)
        RSInfoF.points.clear()
        RSInfoF.debugPoints.clear()
        RSInfoF.retestLabels.clear()


type timeframeInfo
    int index = na
    string timeframeStr = na
    bool isEnabled = false

    RSInfo[] resistances = na
    RSInfo[] supports = na

    float[] highPivots = na
    float[] highTRs = na
    int[] highTimes = na

    float[] lowPivots = na
    float[] lowTRs = na
    int[] lowTimes = na

newTimeframeInfo (index, timeframeStr, isEnabled) =>
    newTFInfo = timeframeInfo.new()
    newTFInfo.index := index
    newTFInfo.isEnabled := isEnabled
    newTFInfo.timeframeStr := timeframeStr

    newTFInfo.resistances := array.new<RSInfo>(debug_lastXResistances)
    newTFInfo.supports := array.new<RSInfo>(debug_lastXSupports)
    
    newTFInfo.highPivots := array.new<float>()
    newTFInfo.highTRs := array.new<float>()
    newTFInfo.highTimes := array.new<int>()

    newTFInfo.lowPivots := array.new<float>()
    newTFInfo.lowTRs := array.new<float>()
    newTFInfo.lowTimes := array.new<int>()
    
    newTFInfo

// _____ TYPES END _____

// _____ VARS _____

var timeframeInfo[] timeframeInfos = array.from(newTimeframeInfo(1, timeframe1, timeframe1Enabled), newTimeframeInfo(2, timeframe2, timeframe2Enabled), newTimeframeInfo(3, timeframe3, timeframe3Enabled))
var bool initRun = true

var float[] allLowPivots = array.new<float>(0)
var float[] allHighPivots = array.new<float>(0)

var int[] allLowTimes = array.new<int>(0)
var int[] allHighTimes = array.new<int>(0)

var float[] allHighTR = array.new<float>(0)
var float[] allLowTR = array.new<float>(0)

var RSInfo[] history = array.new<RSInfo>(0)

RSInfo[] curRSList = array.new<RSInfo>(0)
RSInfo[] oldRSList = array.new<RSInfo>(0)

int maxPivotsAllowed = memoryOptimizatonEnabled ? 7 : 15 // Affects memory limit. Default value 15.

// _____ VARS END _____

doValuesTouch (float value1, float value2, float tr) =>
    if math.abs(value1 - value2) <= tr * touchATR
        true
    else
        false

doValuesTouch (float value1, float value2, float tr, float customATRRatio) =>
    if math.abs(value1 - value2) <= tr * customATRRatio
        true
    else
        false

findLatestRS (timeframeInfo timeframeInfoF, string RSType, pivots, times, trs, bannedValues) =>
    RSInfo latestRSF = na
    pivotsCount = pivots.size()
    if pivotsCount > 0
        for i = 0 to pivotsCount - 1
            if i >= maxTraverse
                break
            
            index = pivotsCount - i - 1
            occurances = 0
            invalidValue = false
            pivotValue1 = pivots.get(index)
            if bannedValues.size() > 0
                for a = 0 to bannedValues.size() - 1
                    if doValuesTouch(pivotValue1, bannedValues.get(a), trs.get(index))
                        invalidValue := true
                        break
            
            if invalidValue
                continue
            
            for j = 0 to pivotsCount - 1
                if j >= maxTraverse
                    break
                
                index2 = pivotsCount - j - 1
                pivotValue2 = pivots.get(index2)
                if doValuesTouch(pivotValue1, pivotValue2, trs.get(index))
                    occurances += 1
                
                if occurances >= strength
                    latestRSF := newRSInfo(RSType)
                    latestRSF.price := pivotValue1
                    break
                
                if math.abs(index - index2) > maxPivotsBackSR * strength
                    break
                
            if not na(latestRSF)
                break
            
    if not na(latestRSF)
        cnt = 0
        if pivotsCount > 0
            for i = 0 to pivotsCount - 1
                if i >= maxTraverse
                    break
                
                index = pivotsCount - i - 1
                pivotValue = pivots.get(index)
                if doValuesTouch(pivotValue, latestRSF.price, trs.get(index))
                    labelTime = times.get(index)
                    latestRSF.points.push(customPoint.new(labelTime, pivotValue))
                    cnt += 1
                if cnt == strength
                    break

    if not (debug_labelPivots == "None")
        if not (debug_labelPivots == "All")
            if not na(latestRSF)
                cnt = 0
                if pivotsCount > 0
                    for i = 0 to pivotsCount - 1
                        index = pivotsCount - i - 1
                        pivotValue = pivots.get(index)
                        if doValuesTouch(pivotValue, latestRSF.price, trs.get(index))
                            labelTime = times.get(index)
                            latestRSF.debugPoints.push(RSType == "Resistance" ? label.new(labelTime,pivotValue,text=debug_pivotLabelText ? str.tostring(pivotValue) : "",xloc=xloc.bar_time, color=resistanceColor, textcolor=color.white) : label.new(labelTime,pivotValue,text=debug_pivotLabelText ? str.tostring(pivotValue) : "",xloc=xloc.bar_time, color=supportColor,style = label.style_label_up, textcolor=color.white))
                            cnt += 1
                        if cnt == strength
                            break
        else
            if not na(latestRSF)
                if pivotsCount > 0
                    for i = 0 to pivotsCount - 1
                        index = pivotsCount - i - 1
                        pivotValue = pivots.get(index)
                        labelTime = times.get(index)
                        latestRSF.debugPoints.push(RSType == "Resistance" ? label.new(labelTime,pivotValue,text=debug_pivotLabelText ? str.tostring(pivotValue) : "",xloc=xloc.bar_time, color=resistanceColor, textcolor=color.white) : label.new(labelTime,pivotValue,text=debug_pivotLabelText ? str.tostring(pivotValue) : "",xloc=xloc.bar_time, color=supportColor,style = label.style_label_up, textcolor=color.white))
                        if latestRSF.debugPoints.size() > debug_maxPivotLabels
                            break
    latestRSF

findLatestNthRS (timeframeInfo timeframeInfoF, string RSType, pivots, times, trs, n) =>
    float[] bannedValues = array.new<float>()
    foundRS = 0
    RSInfo foundLatestRS = na
    while foundRS < n
        foundLatestRS := findLatestRS(timeframeInfoF, RSType, pivots, times, trs, bannedValues)
        if not na(foundLatestRS)
            foundRS += 1
            bannedValues.push(foundLatestRS.price)
        else
            break
    foundLatestRS

isTimeframeLower (timeframe1F, timeframe2F) =>
    timeframe.in_seconds(timeframe1F) < timeframe.in_seconds(timeframe2F)

getMinTimeframe (timeframe1F, timeframe2F) =>
    if isTimeframeLower(timeframe1F, timeframe2F)
        timeframe1F
    else
        timeframe2F

getMaxTimeframe (timeframe1F, timeframe2F) =>
    if isTimeframeLower(timeframe1F, timeframe2F)
        timeframe2F
    else
        timeframe1F

getFirstBreak (RSInfo rsInfo) =>
    if na(rsInfo)
        [na, na]
    
    curIndex = 0
    float foundBreakLevel = na
    int foundBreakTime = na
    float foundBreakTR = na

    while true
        if curIndex >= maxTraverse
            break
        isBarBreak = rsInfo.RSType == "Resistance" ? (close[curIndex + 1] <= rsInfo.price and close[curIndex] > rsInfo.price) : (close[curIndex + 1] >= rsInfo.price and close[curIndex] < rsInfo.price)
        if isBarBreak
            isTrueBreakout = true
            if avoidFalseBreaks
                shortTerm = 2
                longTerm = 15
                
                shortSum = 0.0
                longSum = 0.0
                
                for i = 0 to shortTerm
                    shortSum += volume[curIndex + i]
                
                for i = 0 to longTerm
                    longSum += volume[curIndex + i]
                
                shortVolumeAvg = shortSum / shortTerm
                longVolumeAvg = longSum / longTerm

                volumeRatio = ((shortVolumeAvg - longVolumeAvg) / longVolumeAvg) * 100.0
                isTrueBreakout := (volumeRatio >= falseBreakoutVolumeThreshold)

            if isTrueBreakout
                foundBreakLevel := rsInfo.RSType == "Resistance" ? low[curIndex] : high[curIndex]
                foundBreakTime := time[curIndex]
                foundBreakTR := high[curIndex] - low[curIndex]
            
        curIndex += 1
        if time[curIndex] <= rsInfo.points.get(rsInfo.points.size() - 1).t
            break
    [foundBreakLevel, foundBreakTime, foundBreakTR]

getRetests (RSInfo rsInfo) =>
    if na(rsInfo)
        [na,na]
    
    curIndex = 0
    lastRetestIndex = -999
    int[] retestTimes = array.new<int>()
    float[] retestLevels = array.new<float>()
    float[] retestTRs = array.new<float>()

    while true
        if curIndex >= maxTraverse
            break
        if retestLevels.size() == maxRetestLabels
            break
        if rsInfo.isBroken and time[curIndex] >= rsInfo.brokenTime
            curIndex += 1
            continue

        tr = high[curIndex] - low[curIndex]
        isRetest = (rsInfo.RSType == "Resistance" ? (doValuesTouch(rsInfo.price, close[curIndex], tr, retestATR) or doValuesTouch(rsInfo.price, high[curIndex], tr, retestATR)) : (doValuesTouch(rsInfo.price, close[curIndex], tr, retestATR) or doValuesTouch(rsInfo.price, low[curIndex], tr, retestATR)))
        if isRetest and curIndex - lastRetestIndex >= retestLabelEveryXBars
            retestLevels.push(rsInfo.RSType == "Resistance" ? high[curIndex] : low[curIndex])
            retestTimes.push(time[curIndex])
            retestTRs.push(high[curIndex] - low[curIndex])
            lastRetestIndex := curIndex
        curIndex += 1
        if time[curIndex] <= rsInfo.points.get(rsInfo.points.size() - 1).t
            break
    [retestLevels, retestTimes, retestTRs]

formatTimeframeString (formatTimeframe) =>
    timeframeF = formatTimeframe == "" ? timeframe.period : formatTimeframe
    
    if str.contains(timeframeF, "D") or str.contains(timeframeF, "W") or str.contains(timeframeF, "S") or str.contains(timeframeF, "M")
        timeframeF
    else
        seconds = timeframe.in_seconds(timeframeF)
        if seconds >= 3600
            hourCount = int(seconds / 3600)
            str.tostring(hourCount) + " Hour" + (hourCount > 1 ? "s" : "")
        else
            timeframeF + " Min"

handleRSInfo (timeframeInfo timeframeInfoF, RSInfo RSInfoF, int index, string RSType) =>
    if not na(RSInfoF)
        if not na(timeframeInfoF)
            curRSList.push(RSInfoF)
        
        [foundBreakLevel, foundBreakTime, foundBreakTR] = getFirstBreak(RSInfoF)
        
        RSInfoF.isBroken := na(foundBreakLevel) ? false : true
        RSInfoF.brokenTime := na(foundBreakLevel) ? na : foundBreakTime

        if not na(foundBreakLevel)
            if showBreaks
                if na(RSInfoF.breakLabel)
                    RSInfoF.breakLabel := createBreakLabel(RSInfoF.RSType)
                label.set_xy(RSInfoF.breakLabel, foundBreakTime, foundBreakLevel + (RSInfoF.RSType == "Resistance" ? (-foundBreakTR / labelOffsetY) : foundBreakTR / labelOffsetY))
            
            if expandLines
                if na(RSInfoF.breakLine) and enableZones == false
                    RSInfoF.breakLine := createRSLine(color.black)
                
                if na(RSInfoF.breakBox) and enableZones == true
                    RSInfoF.breakBox := createRSBox(color.black, xloc.bar_time)

                if not enableZones
                    line.set_extend(RSInfoF.breakLine, extend.right)
                else
                    box.set_extend(RSInfoF.breakBox, extend.right)
                
                if inverseBrokenLineColor and showBreaks
                    if not enableZones
                        line.set_color(RSInfoF.breakLine, RSInfoF.RSType == "Resistance" ? supportColor : resistanceColor)
                    else    
                        box.set_bgcolor(RSInfoF.breakBox, RSInfoF.RSType == "Resistance" ? supportColor : resistanceColor)
                else
                    if not enableZones
                        line.set_color(RSInfoF.breakLine, RSInfoF.RSType == "Resistance" ? resistanceColor : supportColor)
                    else
                        box.set_bgcolor(RSInfoF.breakBox, RSInfoF.RSType == "Resistance" ? resistanceColor : supportColor)

        if showRetests
            [retestLevels, retestTimes, retestTRs] = getRetests(RSInfoF)

            if not na(retestLevels) and retestLevels.size() > 0
                for i = 0 to retestLevels.size() - 1
                    newRetestLabel = createRetestLabel(RSInfoF.RSType)
                    label.set_xy(newRetestLabel, retestTimes.get(i), retestLevels.get(i) + (RSInfoF.RSType == "Support" ? (-retestTRs.get(i) / labelOffsetY) : retestTRs.get(i) / labelOffsetY))
                    RSInfoF.retestLabels.push(newRetestLabel)

        timeSkipOffset = 0
        if enableZones
            zoneEndX = time + timeSkipOffset + timeframe.in_seconds(timeframe.period) * 1000 * labelOffsetsXIndex 
            startTime = math.min(time, RSInfoF.points.get(RSInfoF.points.size() - 1).t)
            moveRSInfoBox(RSInfoF.box, startTime, RSInfoF.price, na(foundBreakTime) ? zoneEndX : foundBreakTime)
            moveRSInfoBox(RSInfoF.breakBox, foundBreakTime, RSInfoF.price, zoneEndX)
        else
            endTime = time + timeSkipOffset + timeframe.in_seconds(timeframe.period) * 1000
            startTime = math.min(time, RSInfoF.points.get(RSInfoF.points.size() - 1).t)
            moveLine(RSInfoF.line, startTime, RSInfoF.price, na(foundBreakTime) ? endTime : foundBreakTime)
            moveLine(RSInfoF.breakLine, foundBreakTime, RSInfoF.price, endTime)
            //log.info(str.tostring(RSInfoF.price) + " | " + str.tostring(RSInfoF.points.get(strength - 1).time) + " = "  + str.tostring(line.get_x1(RSInfoF.line)) + " | " + str.tostring(endTime) + " = " + str.tostring(line.get_x2(RSInfoF.line)))
        
        if expandLines
            if not enableZones
                line.set_extend(RSInfoF.line, (na(foundBreakTime)) ? extend.both : extend.left)
            else    
                box.set_extend(RSInfoF.box, (na(foundBreakTime)) ? extend.both : extend.left)
        else
            if not enableZones
                line.set_extend(RSInfoF.line, na(foundBreakTime) ? extend.right : extend.none)
            else
                box.set_extend(RSInfoF.box, na(foundBreakTime) ? extend.right : extend.none)

        //labelTitleOld = formatTimeframeString(timeframeInfoF.timeframeStr) + " " + RSInfoF.RSType + " " + str.tostring(index + 1) + " (" + str.tostring(RSInfoF.price,format.mintick) + ")" + (RSInfoF.isBroken ? " [Broken]" : "")
        labelTitle = formatTimeframeString(timeframeInfoF.timeframeStr) + " | " + str.tostring(RSInfoF.price,format.mintick) + ((debug_showBrokenOnLabel and RSInfoF.isBroken)  ? " [B]" : "")
        
        if not enableZones
            label.set_text(RSInfoF.priceLabel, enableZones ? "" : labelTitle)
            label.set_y(RSInfoF.priceLabel, RSInfoF.price)
        else
            box.set_text(RSInfoF.box, (RSInfoF.isBroken and expandLines) ? "" : labelTitle)
            box.set_text(RSInfoF.breakBox, labelTitle)
        
        if expandLines or not RSInfoF.isBroken
            if not enableZones
                if labelsAlign == "Right"
                    label.set_xloc(RSInfoF.priceLabel, bar_index + labelOffsetsXIndex, xloc.bar_index)
                else
                    label.set_xloc(RSInfoF.priceLabel, labelsAlign == "Center" ? ((chart.right_visible_bar_time + chart.left_visible_bar_time) / 2) : na, xloc.bar_time)
            else
                box.set_text_halign(RSInfoF.breakBox, text.align_right)
                box.set_text_halign(RSInfoF.box, text.align_right)
        else
            if not enableZones
                label.set_xloc(RSInfoF.priceLabel, (RSInfoF.points.get(RSInfoF.points.size() - 1).t + RSInfoF.brokenTime) / 2, xloc.bar_time)
            else
                box.set_text_halign(RSInfoF.box, text.align_center)
                box.set_text_halign(RSInfoF.breakBox, text.align_center)
    else
        log.error("Couldn't find timeframe " + str.tostring(timeframeInfoF.index) + " " + str.tostring(index + 1) + "th " + RSType + " . Try decreasing pivot range in the settings.")

handleTimeframe (timeframeIndex, lowPivots, highPivots, lowTimes, highTimes, lowTRs, highTRs) =>
    timeframeInfoF = timeframeInfos.get(timeframeIndex - 1)
    
    timeframeInfoF.lowPivots.clear()
    timeframeInfoF.highPivots.clear()

    timeframeInfoF.lowTimes.clear()
    timeframeInfoF.highTimes.clear()

    timeframeInfoF.lowTRs.clear()
    timeframeInfoF.highTRs.clear()

    timeframeInfoF.lowPivots := lowPivots
    timeframeInfoF.highPivots := highPivots

    timeframeInfoF.lowTimes := lowTimes
    timeframeInfoF.highTimes := highTimes

    timeframeInfoF.lowTRs := lowTRs
    timeframeInfoF.highTRs := highTRs

getHigherTFData (timeframeStr) =>
    request.security(syminfo.tickerid, getMaxTimeframe(timeframe.period, timeframeStr), [allLowPivots, allHighPivots, allLowTimes, allHighTimes, allLowTR, allHighTR])

pushHighPivots (timeframeInfoF, highPivotF, timeF, trF) =>
    if not na(highPivotF)
        timeframeInfoF.highPivots.push(highPivotF)
        timeframeInfoF.highTimes.push(timeF)
        timeframeInfoF.highTRs.push(trF)

pushLowPivots (timeframeInfoF, lowPivotF, timeF, trF) =>
    if not na(lowPivotF)
        timeframeInfoF.lowPivots.push(lowPivotF)
        timeframeInfoF.lowTimes.push(timeF)
        timeframeInfoF.lowTRs.push(trF)

handleTimeframeIfLower (timeframeInfo timeframeInfoF, highs, lows, int[] timesF, float[] trsF) =>
    if timeframeInfoF.isEnabled and isTimeframeLower(timeframeInfoF.timeframeStr, timeframe.period)
        if highs.size() > 0
            for i = 0 to highs.size() - 1
                timeF = timesF.get(i)
                pushHighPivots(timeframeInfoF, highs.get(i), timeF, trsF.get(i))
        if lows.size() > 0
            for i = 0 to lows.size() - 1
                timeF = timesF.get(i)
                pushLowPivots(timeframeInfoF, lows.get(i), timeF, trsF.get(i))

getLowerTFData (timeframeStr) =>
    lowPivots = isTimeframeLower(timeframeStr, timeframe.period) ? request.security_lower_tf(syminfo.tickerid, getMinTimeframe(timeframeStr, timeframe.period), ta.pivotlow(low, pivotRange, pivotRange)) : na
    highPivots = isTimeframeLower(timeframeStr, timeframe.period) ? request.security_lower_tf(syminfo.tickerid, getMinTimeframe(timeframeStr, timeframe.period), ta.pivothigh(high, pivotRange, pivotRange)) : na
    times = isTimeframeLower(timeframeStr, timeframe.period) ? request.security_lower_tf(syminfo.tickerid, getMinTimeframe(timeframeStr, timeframe.period), pivotTime) : na
    trs = isTimeframeLower(timeframeStr, timeframe.period) ? request.security_lower_tf(syminfo.tickerid, getMinTimeframe(timeframeStr, timeframe.period), curTR[pivotRange]) : na
    [lowPivots, highPivots, times, times, trs, trs]

getTFData (timeframeStr) =>
    if isTimeframeLower(timeframeStr, timeframe.period)
        getLowerTFData(timeframeStr)
    else
        getHigherTFData(timeframeStr)

checkIfRSAreSame (RSInfo rsInfo1, RSInfo rsInfo2) =>
    if na(rsInfo1) or na(rsInfo2)
        false
    else if rsInfo1.RSType != rsInfo2.RSType
        false
    else if rsInfo1.price != rsInfo2.price
        false
    else
        true

checkIfArrHasRS (RSInfo[] arr, RSInfo rsInfoF) =>
    if na(arr) or na(rsInfoF)
        true
    else if arr.size() == 0
        false
    else
        foundRS = false
        for i = 0 to arr.size() - 1
            arrRS = arr.get(i)
            if checkIfRSAreSame(arrRS, rsInfoF)
                foundRS := true
                break
        if foundRS
            true
        else
            false

clearTimeframeRS (timeframeInfoF) =>
    oldRetestsCount = 0
    oldBreaksCount = 0

    if timeframeInfoF.resistances.size() > 0
        for j = 0 to timeframeInfoF.resistances.size() - 1
            RSInfo RSInfoF = timeframeInfoF.resistances.get(j)
            if not na(RSInfoF)
                if debug_enabledHistory
                    if checkIfArrHasRS(oldRSList, RSInfoF) == false
                        oldRSList.push(RSInfoF)

                oldRetestsCount += RSInfoF.retestLabels.size()
                oldBreaksCount += RSInfoF.isBroken ? 1 : 0
                derenderRSInfo(RSInfoF)
    
    if timeframeInfoF.supports.size() > 0
        for j = 0 to timeframeInfoF.supports.size() - 1
            RSInfo RSInfoF = timeframeInfoF.supports.get(j)
            if not na(RSInfoF)
                if debug_enabledHistory
                    if checkIfArrHasRS(history, RSInfoF) == false
                        oldRSList.push(RSInfoF)
                
                oldRetestsCount += RSInfoF.retestLabels.size()
                oldBreaksCount += RSInfoF.isBroken ? 1 : 0
                derenderRSInfo(RSInfoF)
    
    timeframeInfoF.resistances.clear()
    timeframeInfoF.supports.clear()
    [oldRetestsCount, oldBreaksCount]

findTimeframeRS (timeframeInfoF, RSType, arr, count, pivots, times, trs) =>
    curRetestsCount = 0
    curBreaksCount = 0

    if count > 0
        for j = 0 to count - 1
            foundRS = findLatestNthRS(timeframeInfoF, RSType, pivots, times, trs, j + 1)
            if not na(foundRS)
                notDuplicate = true
                for a = 0 to timeframeInfos.size() - 1
                    aInfo = timeframeInfos.get(a)
                    if na(aInfo) or aInfo.isEnabled == false
                        continue
                    otherTimeframeArray = (RSType == "Resistance" ? aInfo.resistances : aInfo.supports)
                    if otherTimeframeArray.size() > 0
                        for b = 0 to otherTimeframeArray.size() - 1
                            if checkIfRSAreSame(foundRS, otherTimeframeArray.get(b))
                                notDuplicate := false
                                break
                    if notDuplicate == false
                        break
                
                if notDuplicate or not debug_removeDuplicateRS
                    arr.push(foundRS)
        
        if arr.size() > 0
            for j = 0 to arr.size() - 1
                curRS = arr.get(j)
                if not na(curRS)
                    handleRSInfo(timeframeInfoF, curRS, j, RSType)
                    curRetestsCount += curRS.retestLabels.size()
                    curBreaksCount += curRS.isBroken ? 1 : 0
    [curRetestsCount, curBreaksCount]

if not na(lowPivot)
    allLowPivots.push(lowPivot)
    allLowTimes.push(pivotTime)
    allLowTR.push(curTR[pivotRange])
    if allLowPivots.size() > maxPivotsAllowed
        allLowPivots.remove(0)
        allLowTimes.remove(0)
        allLowTR.remove(0)
        
if not na(highPivot)
    allHighPivots.push(highPivot)
    allHighTimes.push(pivotTime)
    allHighTR.push(curTR[pivotRange])
    if allHighPivots.size() > maxPivotsAllowed
        allHighPivots.remove(0)
        allHighTimes.remove(0)
        allHighTR.remove(0)

[lowPivotsTF1, highPivotsTF1, lowTimesTF1, highTimesTF1, lowTRsTF1, highTRsTF1] = getTFData(timeframe1)
handleTimeframeIfLower(timeframeInfos.get(0), highPivotsTF1, lowPivotsTF1, highTimesTF1, highTRsTF1)

[lowPivotsTF2, highPivotsTF2, lowTimesTF2, highTimesTF2, lowTRsTF2, highTRsTF2] = getTFData(timeframe2)
handleTimeframeIfLower(timeframeInfos.get(1), highPivotsTF2, lowPivotsTF2, highTimesTF2, highTRsTF2)

[lowPivotsTF3, highPivotsTF3, lowTimesTF3, highTimesTF3, lowTRsTF3, highTRsTF3] = getTFData(timeframe3)
handleTimeframeIfLower(timeframeInfos.get(2), highPivotsTF3, lowPivotsTF3, highTimesTF3, highTRsTF3)

//plot(nz(na,timeframeInfos.get(0).highPivots.size() > 0 ? timeframeInfos.get(0).highPivots.get(timeframeInfos.get(0).highPivots.size() - 1) : 0), color = color.blue, title = "High Pivots")
//plot(nz(na,timeframeInfos.get(0).lowPivots.size() > 0 ? timeframeInfos.get(0).lowPivots.get(timeframeInfos.get(0).lowPivots.size() - 1) : 0), color = color.fuchsia, title = "Low Pivots")

if barstate.islastconfirmedhistory or (barstate.islast and barstate.isnew)
    if timeframe1Enabled and not isTimeframeLower(timeframe1, timeframe.period)
        handleTimeframe(1, lowPivotsTF1, highPivotsTF1, lowTimesTF1, highTimesTF1, lowTRsTF1, highTRsTF1)

    if timeframe2Enabled and not isTimeframeLower(timeframe2, timeframe.period)
        handleTimeframe(2, lowPivotsTF2, highPivotsTF2, lowTimesTF2, highTimesTF2, lowTRsTF2, highTRsTF2)
    
    if timeframe3Enabled and not isTimeframeLower(timeframe3, timeframe.period)
        handleTimeframe(3, lowPivotsTF3, highPivotsTF3, lowTimesTF3, highTimesTF3, lowTRsTF3, highTRsTF3)

    int enabledTimeframeCount = 0
    for i = 0 to timeframeCount - 1
        timeframeInfo curInfo = timeframeInfos.get(i)
        if curInfo.isEnabled
            enabledTimeframeCount += 1
    
    int oldRetestsCount = 0
    int curRetestsCount = 0

    int oldBreaksCount = 0
    int curBreaksCount = 0

    for i = 0 to timeframeCount - 1
        timeframeInfo curInfo = timeframeInfos.get(i)
        if not curInfo.isEnabled
            continue

        [oldRetests, oldBreaks] = clearTimeframeRS(curInfo)
        oldRetestsCount += oldRetests
        oldBreaksCount += oldBreaks

        resistanceCount = math.min(DEBUG ? debug_lastXResistances : resistanceSupportCount, maxResistances - (enabledTimeframeCount > 1 ? 1 : 0))
        resistanceCount := math.max(resistanceCount, 0)

        supportCount = math.min(DEBUG ? debug_lastXSupports : resistanceSupportCount, maxSupports - (enabledTimeframeCount > 1 ? 1 : 0))
        supportCount := math.max(supportCount, 0)

        [curRetests1, curBreaks1] = findTimeframeRS(curInfo, "Resistance", curInfo.resistances, resistanceCount, curInfo.highPivots, curInfo.highTimes, curInfo.highTRs)
        [curRetests2, curBreaks2] = findTimeframeRS(curInfo, "Support", curInfo.supports, supportCount, curInfo.lowPivots, curInfo.lowTimes, curInfo.lowTRs)
        curRetestsCount += curRetests1 + curRetests2
        curBreaksCount += curBreaks1 + curBreaks2
    
    if debug_enabledHistory
        historyIndexesToDelete = array.new<int>(0)
        if history.size() > 0
            for i = 0 to history.size() - 1
                if checkIfArrHasRS(curRSList, history.get(i))
                    historyIndexesToDelete.push(i)
            
            if historyIndexesToDelete.size() > 0
                for i = 0 to historyIndexesToDelete.size() - 1
                    deleteIndex = historyIndexesToDelete.get(historyIndexesToDelete.size() - i - 1)
                    safeDeleteRSInfo(history.get(deleteIndex))
                    history.remove(deleteIndex)
        
        if oldRSList.size() > 0
            for i = 0 to oldRSList.size() - 1
                curRS = oldRSList.get(i)
                if checkIfArrHasRS(curRSList, curRS) == false
                    history.push(histRSInfo(curRS))
                    if history.size() > debug_maxHistoryRecords
                        safeDeleteRSInfo(history.get(0))
                        history.remove(0)
    
    if oldRSList.size() > 0
        for i = 0 to oldRSList.size() - 1
            safeDeleteRSInfo(oldRSList.get(i))
    
    curRSList.clear()
    oldRSList.clear()

    if DEBUG
        log.info("History Size : " + str.tostring(history.size()))
        log.info("Label Count : " + str.tostring(label.all.size()))
        log.info("Line Count : " + str.tostring(line.all.size()))
        log.info("Box Count : " + str.tostring(box.all.size()))

    if enableRetestAlerts and curRetestsCount > oldRetestsCount and initRun == false
        alert("New Retests Occured.")
    
    if enableBreakAlerts and curBreaksCount > oldBreaksCount and initRun == false
        alert("New Breaks Occured.")
    
    initRun := false

//-----------------------------------------------------------------------------}
//Trend Channels With Liquidity Breaks
//-----------------------------------------------------------------------------{
length4 = input.int(8, "Length")
show   = input.bool(true, "Show Last Channel")
wait   = input.bool(true, "Wait for Break")
extend1 = input.bool(false, "Extend Line")
enable_liquid = input.bool(false, "Volume BG")
top_color = input.color(color.rgb(51, 124, 79, 80), "Colors", inline = "Colors")
center_color = input.color(color.rgb(120, 123, 134, 100), "", inline = "Colors")
bottom_color = input.color(color.rgb(165, 45, 45, 80), "", inline = "Colors")

source_high = high
source_low  = low

// variables to store the latest and previous pivot values 
var float prev_pivot_high = na
var int prev_pivot_high_index = na
var float last_pivot_high = na
var int last_pivot_high_index = na

var float prev_pivot_low = na
var int prev_pivot_low_index = na
var float last_pivot_low = na
var int last_pivot_low_index = na

atan2(y, x) =>
    var float angle = 0.0
    if x > 0
        angle := math.atan(y / x)
    else
        if x < 0 and y >= 0
            angle := math.atan(y / x) + math.pi
        else
            if x < 0 and y < 0
                angle := math.atan(y / x) - math.pi
            else
                if x == 0 and y > 0
                    angle := math.pi / 2
                else
                    if x == 0 and y < 0
                        angle := -math.pi / 2
    angle

min_max_volume(src) =>
    out = (src - ta.lowest(src, 100))/(ta.highest(src, 100) - ta.lowest(src, 100)) * 100
    math.max(math.min(100, out), 0)

volume_normalized()=>
    min_max_volume(ta.wma(volume, 21))

simple_moving_average(source)=>
    var float sum = na
    var int count = na
    count := nz(count[1]) + 1
    sum := nz(sum[1]) + source 
    sum/count

liquidity_break()=>
    vol = volume_normalized()
    avg = simple_moving_average(vol)
    rank = ta.percentile_nearest_rank(vol, 75, 100)
    avg_rank = simple_moving_average(rank)
    colour = vol < avg ? "LV" : (vol > avg and vol < avg_rank ? "MV" : "HV")


// Pivot high calculation
ph3 = ta.pivothigh(source_high, length4, length4)
if (not na(ph3))
    // Update the previous pivot high to the last pivot high before we update the last pivot high
    prev_pivot_high := last_pivot_high
    prev_pivot_high_index := last_pivot_high_index
    // Update the last pivot high
    last_pivot_high := ph3
    last_pivot_high_index := bar_index

// Pivot low calculation
pl3 = ta.pivotlow(source_low, length4, length4)
if (not na(pl3))
    // Update the previous pivot low to the last pivot low before we update the last pivot low
    prev_pivot_low := last_pivot_low
    prev_pivot_low_index := last_pivot_low_index
    // Update the last pivot low
    last_pivot_low := pl3
    last_pivot_low_index := bar_index

volume_score = volume_normalized()

var down_trend_top = line.new(na, na, na, na, color = na, width = 1)
var down_trend_bottom = line.new(na, na, na, na, color = na, width = 1)
var down_trend_top_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_bottom_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_top_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_bottom_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_center = line.new(na, na, na, na, color = na, width = 1, style = line.style_dashed)
var down_break_label = label.new(na, na, na, textcolor = color.new(#ffffff, 0))
linefill.new(down_trend_top, down_trend_top_zone_mid, color.new(top_color, 80))
linefill.new(down_trend_bottom, down_trend_bottom_zone_mid, color.new(bottom_color, 80))
down_trend_top_zone_mid_fill = linefill.new(down_trend_top_zone_mid, down_trend_top_zone, color.new(top_color, 90))
down_trend_bottom_zone_mid_fill = linefill.new(down_trend_bottom_zone_mid, down_trend_bottom_zone, color.new(bottom_color, 90))
var up_trend_top = line.new(na, na, na, na, color = na, width = 1)
var up_trend_bottom = line.new(na, na, na, na, color = na, width = 1)
var up_trend_top_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_bottom_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_top_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_bottom_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_center = line.new(na, na, na, na, color = na, width = 1, style = line.style_dashed)
linefill.new(up_trend_top, up_trend_top_zone_mid, color.new(top_color, 80))
linefill.new(up_trend_bottom, up_trend_bottom_zone_mid, color.new(bottom_color, 80))
top_trend_top_zone_mid_fill = linefill.new(up_trend_top_zone_mid, up_trend_top_zone, color.new(top_color, 90))
top_trend_bottom_zone_mid_fill = linefill.new(up_trend_bottom_zone_mid, up_trend_bottom_zone, color.new(bottom_color, 90))
var up_break_label = label.new(na, na, na, textcolor = color.new(#ffffff, 0), style = label.style_label_up)

if extend1
    line.set_extend(down_trend_top, extend.right)
    line.set_extend(down_trend_bottom, extend.right)
    line.set_extend(down_trend_top_zone, extend.right)
    line.set_extend(down_trend_bottom_zone, extend.right)
    line.set_extend(down_trend_center, extend.right)
    line.set_extend(up_trend_top, extend.right)
    line.set_extend(up_trend_bottom, extend.right)
    line.set_extend(up_trend_top_zone, extend.right)
    line.set_extend(up_trend_bottom_zone, extend.right)
    line.set_extend(up_trend_center, extend.right)
    line.set_extend(down_trend_top_zone_mid, extend.right)
    line.set_extend(down_trend_bottom_zone_mid, extend.right)
    line.set_extend(up_trend_top_zone_mid, extend.right)
    line.set_extend(up_trend_bottom_zone_mid, extend.right)
else
    line.set_extend(down_trend_top, extend.none)
    line.set_extend(down_trend_bottom, extend.none)
    line.set_extend(down_trend_top_zone, extend.none)
    line.set_extend(down_trend_bottom_zone, extend.none)
    line.set_extend(down_trend_center, extend.none)
    line.set_extend(up_trend_top, extend.none)
    line.set_extend(up_trend_bottom, extend.none)
    line.set_extend(up_trend_top_zone, extend.none)
    line.set_extend(up_trend_bottom_zone, extend.none)
    line.set_extend(up_trend_center, extend.none)
    line.set_extend(down_trend_top_zone_mid, extend.none)
    line.set_extend(down_trend_bottom_zone_mid, extend.none)
    line.set_extend(up_trend_top_zone_mid, extend.none)
    line.set_extend(up_trend_bottom_zone_mid, extend.none)

var down_dydx = 0.
var up_dydx = 0.

atr_10 = ta.atr(10) * 6
var down_count = 0
var up_count = 0

// Plot the trendlines if we have enough pivots
if (not na(prev_pivot_high)
 and not na(last_pivot_high)) 
 and prev_pivot_high != prev_pivot_high[1] 
 and atan2(last_pivot_high - prev_pivot_high, last_pivot_high_index - prev_pivot_high_index) <= 0 
 and down_count == 0 
 and (wait ? up_count != 1 : true)
 and barstate.isconfirmed
    down_count := 1
    offset = atr_10
    line.set_xy1(down_trend_top, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high + offset/7))
    line.set_xy2(down_trend_top, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high + offset/7))
    line.set_color(down_trend_top, top_color)
    line.set_xy1(down_trend_top_zone, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset/7))
    line.set_xy2(down_trend_top_zone, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset/7))
    line.set_xy1(down_trend_top_zone_mid, prev_pivot_high_index - length4, prev_pivot_high)
    line.set_xy2(down_trend_top_zone_mid, last_pivot_high_index - length4, last_pivot_high)
    down_dydx := (last_pivot_high - prev_pivot_high) / (last_pivot_high_index - prev_pivot_high_index)
    line.set_xy1(down_trend_bottom, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset - offset/7))
    line.set_xy2(down_trend_bottom, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset - offset/7))
    line.set_color(down_trend_bottom, bottom_color)
    line.set_xy1(down_trend_bottom_zone, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset + offset/7))
    line.set_xy2(down_trend_bottom_zone, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset + offset/7))
    line.set_xy1(down_trend_bottom_zone_mid, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset))
    line.set_xy2(down_trend_bottom_zone_mid, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset))

    // Set center line for down trend
    line.set_xy1(down_trend_center, prev_pivot_high_index - length4, math.round_to_mintick((prev_pivot_high + prev_pivot_high - offset) / 2))
    line.set_xy2(down_trend_center, last_pivot_high_index - length4, math.round_to_mintick((last_pivot_high + last_pivot_high - offset) / 2))
    line.set_color(down_trend_center, center_color)
    label.set_text(down_break_label, "")
    label.set_color(down_break_label, color.new(color.black, 100))
    // Blank previous channel
    if not show
        line.set_xy1(up_trend_bottom, na, na)
        line.set_xy2(up_trend_bottom, na, na)
        line.set_xy1(up_trend_top, na, na)
        line.set_xy2(up_trend_top, na, na)
        line.set_xy1(up_trend_center, na, na)
        line.set_xy2(up_trend_center, na, na)
        line.set_xy1(up_trend_bottom_zone, na, na)
        line.set_xy2(up_trend_bottom_zone, na, na)
        line.set_xy1(up_trend_bottom_zone_mid, na, na)
        line.set_xy2(up_trend_bottom_zone_mid, na, na)
        line.set_xy1(up_trend_top_zone, na, na)
        line.set_xy2(up_trend_top_zone, na, na)
        line.set_xy1(up_trend_top_zone_mid, na, na)
        line.set_xy2(up_trend_top_zone_mid, na, na)
        label.set_text(up_break_label, "")
        label.set_color(up_break_label, color.new(color.black, 100))

if (not na(prev_pivot_low)
 and not na(last_pivot_low)) 
 and prev_pivot_low != prev_pivot_low[1] 
 and atan2(last_pivot_low - prev_pivot_low, last_pivot_low_index - prev_pivot_low_index) >= 0 
 and up_count == 0 
 and (wait ? down_count != 1 : true)
 and barstate.isconfirmed
    up_count := 1
    offset = atr_10
    line.set_xy1(up_trend_top, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset + offset/7))
    line.set_xy2(up_trend_top, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset + offset/7))
    line.set_color(up_trend_top, top_color)
    line.set_xy1(up_trend_top_zone, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset - offset/7))
    line.set_xy2(up_trend_top_zone, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset - offset/7))
    line.set_xy1(up_trend_top_zone_mid, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset))
    line.set_xy2(up_trend_top_zone_mid, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset))
    line.set_xy1(up_trend_bottom, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low - offset/7))
    line.set_xy2(up_trend_bottom, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low - offset/7))
    line.set_color(up_trend_bottom, bottom_color)
    line.set_xy1(up_trend_bottom_zone, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset/7))
    line.set_xy2(up_trend_bottom_zone, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset/7))
    line.set_xy1(up_trend_bottom_zone_mid, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low))
    line.set_xy2(up_trend_bottom_zone_mid, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low))
    up_dydx := (last_pivot_low - prev_pivot_low) / (last_pivot_low_index - prev_pivot_low_index)
    // Set center line for up trend
    line.set_xy1(up_trend_center, prev_pivot_low_index - length4, math.round_to_mintick((prev_pivot_low + prev_pivot_low + offset) / 2))
    line.set_xy2(up_trend_center, last_pivot_low_index - length4, math.round_to_mintick((last_pivot_low + last_pivot_low + offset) / 2))
    line.set_color(up_trend_center, center_color)
    label.set_text(up_break_label, "")
    label.set_color(up_break_label, color.new(color.black, 100))
    // Blank previous channel
    if not show
        line.set_xy1(down_trend_bottom, na, na)
        line.set_xy2(down_trend_bottom, na, na)
        line.set_xy1(down_trend_top, na, na)
        line.set_xy2(down_trend_top, na, na)
        line.set_xy1(down_trend_center, na, na)
        line.set_xy2(down_trend_center, na, na)
        line.set_xy1(down_trend_bottom_zone, na, na)
        line.set_xy2(down_trend_bottom_zone, na, na)
        line.set_xy1(down_trend_bottom_zone_mid, na, na)
        line.set_xy2(down_trend_bottom_zone_mid, na, na)
        line.set_xy1(down_trend_top_zone, na, na)
        line.set_xy2(down_trend_top_zone, na, na)
        line.set_xy1(down_trend_top_zone_mid, na, na)
        line.set_xy2(down_trend_top_zone_mid, na, na)
        label.set_text(down_break_label, "")
        label.set_color(down_break_label, color.new(color.black, 100))

liquidity_score = liquidity_break()
volume_color_high = color.new(top_color, 60 + (100 - volume_score)/5)
volume_color_low = color.new(bottom_color, 60 + (100 - volume_score)/5)

atr_20 = ta.atr(20)/1.5
if down_count == 1
    if enable_liquid    
        linefill.set_color(down_trend_top_zone_mid_fill, volume_color_high)
        linefill.set_color(down_trend_bottom_zone_mid_fill, volume_color_low)
    if not extend1
        line.set_y2(down_trend_top, line.get_y2(down_trend_top) + down_dydx)
        line.set_y2(down_trend_bottom, line.get_y2(down_trend_bottom) + down_dydx)
        line.set_y2(down_trend_top_zone, line.get_y2(down_trend_top_zone) + down_dydx)
        line.set_y2(down_trend_bottom_zone, line.get_y2(down_trend_bottom_zone) + down_dydx)
        line.set_y2(down_trend_top_zone_mid, line.get_y2(down_trend_top_zone_mid) + down_dydx)
        line.set_y2(down_trend_bottom_zone_mid, line.get_y2(down_trend_bottom_zone_mid) + down_dydx)
        line.set_y2(down_trend_center, line.get_y2(down_trend_center) + down_dydx)
        line.set_x2(down_trend_top, bar_index)
        line.set_x2(down_trend_bottom, bar_index)
        line.set_x2(down_trend_top_zone, bar_index)
        line.set_x2(down_trend_bottom_zone, bar_index)
        line.set_x2(down_trend_top_zone_mid, bar_index)
        line.set_x2(down_trend_bottom_zone_mid, bar_index)
        line.set_x2(down_trend_center, bar_index)

    if low > line.get_price(down_trend_top, bar_index)
        down_count := 0
        label.set_text(down_break_label, liquidity_score)
        label.set_color(down_break_label, top_color)
        label.set_style(down_break_label, label.style_label_up)
        label.set_xy(down_break_label, bar_index, line.get_y2(down_trend_top) - atr_20)
    if high < line.get_price(down_trend_bottom, bar_index)
        down_count := 0
        label.set_text(down_break_label, liquidity_score)
        label.set_color(down_break_label, bottom_color)
        label.set_style(down_break_label, label.style_label_down)
        label.set_xy(down_break_label, bar_index, line.get_y2(down_trend_bottom) + atr_20)

if up_count == 1
    if enable_liquid
        linefill.set_color(top_trend_top_zone_mid_fill, volume_color_high)
        linefill.set_color(top_trend_bottom_zone_mid_fill, volume_color_low)
    if not extend1
        line.set_y2(up_trend_top, line.get_y2(up_trend_top) + up_dydx)
        line.set_y2(up_trend_bottom, line.get_y2(up_trend_bottom) + up_dydx)
        line.set_y2(up_trend_top_zone, line.get_y2(up_trend_top_zone) + up_dydx)
        line.set_y2(up_trend_bottom_zone, line.get_y2(up_trend_bottom_zone) + up_dydx)
        line.set_y2(up_trend_top_zone_mid, line.get_y2(up_trend_top_zone_mid) + up_dydx)
        line.set_y2(up_trend_bottom_zone_mid, line.get_y2(up_trend_bottom_zone_mid) + up_dydx)
        line.set_y2(up_trend_center, line.get_y2(up_trend_center) + up_dydx)
        line.set_x2(up_trend_top, bar_index)
        line.set_x2(up_trend_bottom, bar_index)
        line.set_x2(up_trend_top_zone, bar_index)
        line.set_x2(up_trend_bottom_zone, bar_index)
        line.set_x2(up_trend_top_zone_mid, bar_index)
        line.set_x2(up_trend_bottom_zone_mid, bar_index)
        line.set_x2(up_trend_center, bar_index)

    if low > line.get_price(up_trend_top, bar_index) and barstate.isconfirmed
        up_count := 0
        label.set_text(up_break_label, liquidity_score)
        label.set_color(up_break_label, top_color)
        label.set_style(up_break_label, label.style_label_up)
        label.set_xy(up_break_label, bar_index, line.get_y2(up_trend_top) - atr_20)
    if high < line.get_price(up_trend_bottom, bar_index) and barstate.isconfirmed
        up_count := 0
        label.set_text(up_break_label, liquidity_score)
        label.set_color(up_break_label, bottom_color)
        label.set_style(up_break_label, label.style_label_down)
        label.set_xy(up_break_label, bar_index, line.get_y2(up_trend_bottom) + atr_20)