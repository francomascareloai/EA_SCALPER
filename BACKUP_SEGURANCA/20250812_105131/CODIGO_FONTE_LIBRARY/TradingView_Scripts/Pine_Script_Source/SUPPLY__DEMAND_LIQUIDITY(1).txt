// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © BrookstarNZ

//@version=5
indicator("SUPPLY & DEMAND/LIQUIDITY", overlay=true, max_bars_back=500)

//INDICATOR SETTINGS
BB_group                  = 'SUPPLY/DEMAND'
switch_BB                 = input.bool(false                        , "SUPPLY/DEMAND ON/OFF"                                                , group = BB_group)
swing_length              = input.int(10                            , title = 'SWING HIGH/LOW LENGTH'  , minval = 1, maxval = 50            , group = BB_group)
history_of_demand_to_keep = input.int(5                             , title = 'HISTORY TO KEEP'        , minval = 1, maxval = 50            , group = BB_group)
box_width                 = input.float(2.5                         , title = 'SUPPLY/DEMAND BOX WIDTH', minval = 1, maxval = 10, step = 0.5, group = BB_group)
supply_color              = input.color(color.new(#00FFFF,70)     , title = 'SUPPLY ' , inline = '3'                                      , group = BB_group)
supply_outline_color      = input.color(color.new(color.white,100), title = 'OUTLINE' , inline = '3'                                      , group = BB_group)
demand_color              = input.color(color.new(#EDEDED,70)     , title = 'DEMAND'  , inline = '4'                                      , group = BB_group)
demand_outline_color      = input.color(color.new(color.white,100), title = 'OUTLINE' , inline = '4'                                      , group = BB_group)

atrBB = ta.atr(50)

//FUNCTIONS
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

f_check_overlapping(new_BB, box_array, atrBB) =>
    atr_threshold = atrBB * 2
    okay_to_draw = true
    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        BB = (top + bottom) / 2
        upper_boundary = BB + atr_threshold
        lower_boundary = BB - atr_threshold
        if new_BB >= lower_boundary and new_BB <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw

f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atrBB) =>
    atr_buffer = atrBB * (box_width / 10)
    box_left = array.get(bn_array, 0)
    box_right = bar_index
    var float box_top = 0.00
    var float box_bottom = 0.00
    var float BB = 0.00
    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        BB := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        BB := (box_top + box_bottom) / 2
    okay_to_draw = f_check_overlapping(BB, box_array, atrBB)
    if box_type == 1 and okay_to_draw and switch_BB
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = supply_outline_color, bgcolor = supply_color, extend = extend.right, text = 'SUPPLY', text_halign = text.align_center, text_valign = text.align_center, text_color = color.white, text_size = size.small, xloc = xloc.bar_index))   
    else if box_type == -1 and okay_to_draw  and switch_BB
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = demand_outline_color, bgcolor = demand_color, extend = extend.right,  text = 'DEMAND', text_halign = text.align_center, text_valign = text.align_center, text_color = color.white, text_size = size.small, xloc = xloc.bar_index))
f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>
    if zone_type == 1  and switch_BB
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            if close >= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), '' )
                box.set_text_color( array.get(bos_array,0), color.new(color.white, 0))
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))
    if zone_type == -1  and switch_BB
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            if close <= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), '' )
                box.set_text_color( array.get(bos_array,0),  color.new(color.white, 0))
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))
f_extend_box_endpoint(box_array) =>
    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 100)

//CALCULATE SWING HIGHS & SWING LOWS
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)

//ARRAYS FOR SWING H/L & BN 
var swing_high_values = array.new_float(5,0.00)
var swing_low_values = array.new_float(5,0.00)
var swing_high_bns = array.new_int(5,0)
var swing_low_bns = array.new_int(5,0)
var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var current_demand_box = array.new_box(history_of_demand_to_keep, na)
var current_supply_BB = array.new_box(history_of_demand_to_keep, na)
var current_demand_BB = array.new_box(history_of_demand_to_keep, na)
var supply_bos = array.new_box(5, na)
var demand_bos = array.new_box(5, na)
//END CALCULATIONS

//NEW SWING HIGH
if not na(swing_high)
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_BB, 1, atrBB)
else if not na(swing_low)
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_BB, -1, atrBB)
f_sd_to_bos(current_supply_box, supply_bos, current_supply_BB, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_BB, -1)
f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

//LIQUIDITY ZONE
import TradersReality/Traders_Reality_Lib/1 as trLib
vz_group                     = "LIQUIDITY ZONE"
switch_vectorzone            = input.bool (false, "LIQUIDITY ZONE"                                                       , inline='Switch3'              , group=vz_group)
bool colorOverride           = input.bool(true, 'OVERRIDE'                                                               , inline="vcz1"                 , group=vz_group)
color regularCandleUpColor   = input.color(title='REGULAR: UP CANDLE'                , defval=#ffffff                  , inline='nonVectors'           , group=vz_group)
color regularCandleDownColor = input.color(title='DOWN CANDLE'                       , defval=#00def6                  , inline='nonVectors'           , group=vz_group, tooltip='Bullish candles are white and Bearish candles are Aqua when none of the Red/Green/Blue/Pink Vector conditions are met.')
int zonesMax                 = input.int(20, 'ZONES TO DRAW', minval = 0, maxval = 1000                                                                  , group=vz_group)
string zoneType              = input.string(title='ZONE TOP/BOTTOM IS DEFINED WITH ' , defval='Body with wicks', options=['Body only', 'Body with wicks'], group=vz_group)
string zoneUpdateType        = input.string(title='ZONES ARE CLEARED USING CANDLE '  , defval='Body with wicks', options=['Body only', 'Body with wicks'], group=vz_group)
int borderWidth              = input.int(0, 'ZONE BORDER WIDTH'                                                                                          , group=vz_group)
color zoneColor              = input.color(title='COLOR'                             , defval=#00def61a                , inline="vcz1"                 , group=vz_group, tooltip='the Vector candle zones color to use if you dont not want to use the Vector Candle Colors.')
int transperancy             = input.int(75, 'VECTOR CANDLE TRANSPERANCY', minval = 0, maxval = 100                                                      , group=vz_group, tooltip='If the vector candle zones color is not overriden, then we want to set the transparancy of the vector candle colors as defined by the Vector candle colors.\nThis setting only affects the candle zone colors not the candle colors themselves.')
bool setcandlecolors         = input.bool(false, title='VECTOR CANDLES ON/OFF'                                           , inline='setCandle'            , group=vz_group)
color redVectorColor         = input.color(title='VECTOR: RED'                       , defval=color.rgb(255, 0, 21, 10), inline='vectors'              , group=vz_group)
color greenVectorColor       = input.color(title='GREEN'                             , defval=color.rgb(0, 255, 10, 10), inline='vectors'              , group=vz_group)
color violetVectorColor      = input.color(title='PINK'                              , defval=color.rgb(233, 30, 99,10), inline='vectors'              , group=vz_group) 
color blueVectorColor        = input.color(title='BLUE'                              , defval=color.rgb(0, 48, 177, 10), inline='vectors'              , group=vz_group, tooltip='(RED) BEARISH\n Bearish candle with high volume.\n(GREEN) BULLISH\n Bullish candle with high volume.\n(PINK) VERY BEARISH\n Bearish candle with above average volume.\n(BLUE) VERY BULLISH\n Bullish candle with above average volume.')
bool overrideSym             = input.bool(title='OVERRIDE CHART SYMBOL'              , defval=false                      , inline='pvsra'                , group=vz_group)
string pvsraSym              = input.string(title=''                                 , defval='INDEX:BTCUSD'             , inline='pvsra'                , group=vz_group, tooltip='You can use INDEX:BTCUSD or you can combine multiple feeds.\nFor example BINANCE:BTCUSDT+COINBASE:BTCUSD.\nNote that adding too many will slow things down.')
pvsraVolume(overrideSymbolX, pvsraSymbolX, tickerIdX) =>
    request.security(overrideSymbolX ? pvsraSymbolX : tickerIdX, '', volume, barmerge.gaps_off, barmerge.lookahead_off)
pvsraHigh(overrideSymbolX, pvsraSymbolX, tickerIdX) =>
    request.security(overrideSymbolX ? pvsraSymbolX : tickerIdX, '', high, barmerge.gaps_off, barmerge.lookahead_off)
pvsraLow(overrideSymbolX, pvsraSymbolX, tickerIdX) =>
    request.security(overrideSymbolX ? pvsraSymbolX : tickerIdX, '', low, barmerge.gaps_off, barmerge.lookahead_off)
pvsraClose(overrideSymbolX, pvsraSymbolX, tickerIdX) =>
    request.security(overrideSymbolX ? pvsraSymbolX : tickerIdX, '', close, barmerge.gaps_off, barmerge.lookahead_off)
pvsraOpen(overrideSymbolX, pvsraSymbolX, tickerIdX) =>
    request.security(overrideSymbolX ? pvsraSymbolX : tickerIdX, '', open, barmerge.gaps_off, barmerge.lookahead_off)

pvsraVolume = pvsraVolume(overrideSym, pvsraSym, syminfo.tickerid)
pvsraHigh = pvsraHigh(overrideSym, pvsraSym, syminfo.tickerid)
pvsraLow = pvsraLow(overrideSym, pvsraSym, syminfo.tickerid)
pvsraClose = pvsraClose(overrideSym, pvsraSym, syminfo.tickerid)
pvsraOpen = pvsraOpen(overrideSym, pvsraSym, syminfo.tickerid)
[pvsraColor, alertFlag, averageVolume, volumeSpread, highestVolumeSpread] = trLib.calcPvsra(pvsraVolume, pvsraHigh, pvsraLow, pvsraClose, pvsraOpen, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor, regularCandleDownColor, regularCandleUpColor)

var zoneBoxesAbove = array.new_box()
var zoneBoxesBelow = array.new_box()

barcolor(setcandlecolors ? pvsraColor : na)
pvsra = trLib.getPvsraFlagByColor(switch_vectorzone ? pvsraColor:na, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor, regularCandleUpColor)
trLib.updateZones(pvsra, 0, zoneBoxesBelow, zonesMax, pvsraHigh, pvsraLow, pvsraOpen, pvsraClose, transperancy, zoneUpdateType, zoneColor, zoneType, borderWidth, colorOverride, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor)
trLib.updateZones(pvsra, 1, zoneBoxesAbove, zonesMax, pvsraHigh, pvsraLow, pvsraOpen, pvsraClose, transperancy, zoneUpdateType, zoneColor, zoneType, borderWidth, colorOverride, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor)
trLib.cleanarr(zoneBoxesAbove)
trLib.cleanarr(zoneBoxesBelow)

// CRYPTO SLAYA CALL SIGN
var tLog = table.new(position = position.bottom_right, rows = 1, columns = 2, border_width=-6)
table.cell(tLog, row = 0, column = 0, text = " CRYPTO ", text_size=size.normal, text_color = #ffffff)
table.cell(tLog, row = 0, column = 1, text = "SLAYA ", text_size=size.normal, text_color = #00def6)