//@version=5

indicator("Max e Min Range Spazio e Tempo Intraday", shorttitle='MaxMinP Prova Intra(MTF)', overlay=true)
// Parametri
SMAX = input(true, title="SMAX")
SMIN = input(true, title="SMIN")
nMM = input.int(120, title="Numero di massimi giornalieri")
RangeX = input.float(0.15, title="Range")

// MTF
TF = input.timeframe(title="Timeframe", defval="D")

//calcolo scarto intervallo
ATRD = request.security(syminfo.tickerid, TF, ta.atr(5))
SFMin = ATRD * RangeX

// Trova il massimo e minimo di oggi
dailyHigh = request.security(syminfo.tickerid, TF, high[0], lookahead=barmerge.lookahead_on)
dailyLow = request.security(syminfo.tickerid, TF, low[0], lookahead=barmerge.lookahead_on)

// Riferimento ai massimi e minimi Daily
Dhigh = request.security(syminfo.tickerid, TF, high, lookahead=barmerge.lookahead_on)
Dlow = request.security(syminfo.tickerid, TF, low, lookahead=barmerge.lookahead_on)

// Calcola i limiti dell'intervallo solo per la giornata attuale
lowerBoundU = na(dailyHigh) ? na : dailyHigh - SFMin
upperBoundU = na(dailyHigh) ? na : dailyHigh
lowerBoundD = na(dailyLow) ? na : dailyLow 
upperBoundD = na(dailyLow) ? na : dailyLow + SFMin

// Traccia per verifica gli intervalli
plot(lowerBoundU, color=color.red, style=plot.style_linebr)
plot(upperBoundU, color=color.orange, style=plot.style_linebr)
plot(lowerBoundD, color=color.orange, style=plot.style_linebr)
plot(upperBoundD, color=color.red, style=plot.style_linebr)

if barstate.islast // (bar_index == last_bar_index) 
    // Segmenti massimi
    for i = 0 to nMM
        if Dhigh[i] > lowerBoundU and Dhigh[i] < upperBoundU and SMAX
            line.new(x1=bar_index, y1=Dhigh[i], x2=bar_index + 10, y2=Dhigh[i], color=color.new(color.black, 0), width = 3)
            label.new(x=bar_index + 5,  y=Dhigh[i], text=str.tostring(Dhigh[i]), style=label.style_label_down, color=color.green, size=size.normal)
    // Segmenti minimi
    for i = 0 to nMM 
        if Dlow[i] > lowerBoundD and Dlow[i] < upperBoundD and SMIN
            line.new(x1=bar_index, y1=Dlow[i], x2=bar_index + 10, y2=Dlow[i], color=color.new(color.black, 0), width = 3)
            label.new(x=bar_index + 5,  y=Dlow[i], text=str.tostring(Dlow[i]), style=label.style_label_down, color=color.green, size=size.normal)

//==================================================================================================================================================//

string i_tableYpos = input.string("bottom", "Position", inline="12", options=["top", "middle", "bottom"])
string i_tableXpos = input.string("center", "", inline="12", options=["left", "center", "right"])
string size1 = input.string("huge", "Title", inline="14", options=["tiny", "small", "normal", "large", "huge", "auto"])
// 
color color1 = input.color(#999999, "Color1")
string separator = input.string("/", "Separator")
string symbol_text = input.string("🕙")

cur = syminfo.currency
base = syminfo.basecurrency
exchange = syminfo.prefix
// 
getTimeFrame() =>
    tf = timeframe.multiplier
    tfstr = ""
    if timeframe.isseconds
        tfstr := "s"
    if timeframe.isminutes
        if tf >= 60
            tf := tf / 60
            tfstr := "h"
        else
            tfstr := "m"
    if timeframe.isdaily
        tfstr := "D"
    if timeframe.isweekly
        tfstr := "W"
    if timeframe.ismonthly
        tfstr := "M"  
        
    [tfstr, str.tostring(tf)]

// 
get_candle_color() =>
    c = close > open ? #05ff0d : #ff0505

var table table1 = table.new(position = i_tableYpos + "_" + i_tableXpos, columns = 1, rows = 1)
// 
if barstate.islast
    str1 = base + separator + cur
    [tf, period] = getTimeFrame()

    table.cell(table1, 0, 0, str1 + " " + period + tf + " " + symbol_text, text_color = get_candle_color(), text_size = size1)
    
//==============================================================================================================================//