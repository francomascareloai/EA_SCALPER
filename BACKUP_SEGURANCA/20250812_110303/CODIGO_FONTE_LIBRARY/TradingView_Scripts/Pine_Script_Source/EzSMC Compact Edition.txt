//@version=5
indicator("<EzSMC Compact Edition>",overlay = true, max_bars_back = 5000, max_lines_count = 500, max_boxes_count = 500, max_labels_count = 500)
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------      Input Settings
//Order Blocks
show_order_blocks=input.bool(true,"Order Blocks", inline = "ob1")
ibull_ob_css = input.color(#5d606b19, '', inline = 'ob1')
ibear_ob_css = input.color(#5d606b19, '', inline = 'ob1')
i_tf_ob = input.timeframe("", "Timeframe", inline = "ob2")

v_buy = #00dbff4d
v_sell = #e91e634d

timeframe1=' : '
show_iob = 'All'=='All' or 'All'=='Internal' //input(true, 'Internal', inline = 'ob', group = 'Order Blocks')
show_ob = 'All'=='All' or 'All'=='External' //input(false, 'External', inline = 'ob', group = 'Order Blocks')
ob_showlast = 5//input.int(10, 'LookBack', minval = 1, inline = 'ob', group = 'Order Blocks')
iob_showlast = 5//input.int(5, 'LookBack', minval = 1, inline = 'iob', group = 'Order Blocks')

style = 'Colored'
v_lookback= 10
ob_loockback=10
timediff=(time[1]-time[101])/100

//Liquidity Levels
//----------------------------------------{
currentTF  = input.bool(true, title = "Liquidity Levels", inline="1")
htfTF  = input.timeframe("", title = "Timeframe", inline="1_")
_highLineStyleHTF  = "Solid"//input.string("Solid", title = "Line Style", options=["Solid", "Dashed", "Dotted"], group=liquidity_level_group,inline='5')
highLineStyleHTF = _highLineStyleHTF=="Solid" ? line.style_solid : _highLineStyleHTF=="Dashed" ? line.style_dashed : line.style_dotted
box_width  = 2.5//input.float(3.0, title = "Width", group=liquidity_level_group,inline='5', minval = 1, maxval = 10, step = 0.5)
lineWidthHTF=2
lowLineColorHTF = input.color(#00bbf94d, "", inline = "1")
highLineColorHTF = input.color(#e91e624d, "", inline = "1")
highBoxBorderColorHTF = color.new(highLineColorHTF,90)
lowBoxBorderColorHTF = color.new(lowLineColorHTF,90)
displayStyle_liq  = "Boxes"//'Lines'

//Fair Value Gaps (FVG
//----------------------------------------{
show_fvg = input(true, 'Fair Value Gaps', inline = 'fvg_css')
i_tf = input.timeframe("", "Timeframe", inline = 'tf')
i_mtfbearishfvgcolor = input.color(#2962ff , "", inline = "fvg_css")
i_mtfbullishfvgcolor = input.color(#c2185b, "", inline = "fvg_css")

i_bullishfvgcolor = color.new(color.green,100)
i_bearishfvgcolor = color.new(color.green,90)
i_fillByMid = true
i_deleteonfill = true
i_textColor = color.white
i_mtf = "HTF"
i_tfos = 10
i_mtfos = 50

//BOS and ChoCH
//----------------------------------------{
// Constants
color CLEAR = color.rgb(0,0,0,100)

// Inputs
showms=input(true,title="ChoCH & BoS ", inline="0")
bosColor1 = input.color(#787b86 , '', inline="0")
bosColor2 = input.color(#787b86 , '', inline="0")
swingSize = 3

//Global variables
//-----------------------------------------------------------------------------{
color transparent = #ffffff00
length = 50
is_newbar(res) =>
    t = time(res)
    not na(t) and (na(t[1]) or t > t[1])

Show_MS(x, y, txt, css, dashed, down, lbl_size)=>
    label.new(int(math.avg(x, bar_index)), y, txt, color = transparent, textcolor = css, style = down ? label.style_label_down : label.style_label_up, size = lbl_size)
    line.new(x, y, bar_index, y, color = css, style = dashed ? line.style_dashed : line.style_solid)

f_barssince(_cond, _count) =>
    _barssince = bar_index - ta.valuewhen(_cond, bar_index, _count)
    _barssince

//Swings detection/measurements
calculate_swing_points(length)=>
    var prev = 0
    prev := high[length] > ta.highest(length) ? 0 : low[length] < ta.lowest(length) ? 1 : prev[1]
    t = prev == 0 and prev[1] != 0 ? high[length] : 0
    b = prev == 1 and prev[1] != 1 ? low[length] : 0
    [t, b]

var t_MS = 0, var int_t_MS = 0
var internal_y_up = 0., var internal_x_up = 0, var internal_y_dn = 0., var internal_x_dn = 0
var y_up = 0., var x_up = 0 , var y_dn = 0., var x_dn = 0
var crossed_up = true,  var crossed_down = true
var internal_up_broke = true, var internal_dn_broke = true
var up_trailing = high, var down_trailing = low
var up_trailing_x = 0,  var down_trailing_x = 0
var high_text = '',  var low_text = ''
bullish_OB_Break = false 
bearish_OB_Break = false

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------       Market Structure
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bosConfType = 'Candle High'//input.string('Candle Close', 'BOS Confirmation', ['Candle Close', 'Wicks'], tooltip='Choose whether candle close/wick above previous swing point counts as a BOS.')
ChoCH = true//input.bool(false, 'Show ChoCH', tooltip='Renames the first counter t_MS BOS to ChoCH' )
// showSwing = false//input.bool(true, 'Show Swing Points', tooltip='Show or hide HH, LH, HL, LL')

// Functions
lineStyle(x) =>
    switch x
        'Solid' => line.style_solid
        'Dashed' => line.style_dashed
        'Dotted' => line.style_dotted
pivot_high_found = ta.pivothigh(high, 10, 10)
pivot_low_found = ta.pivotlow(low, 10, 10)

var float prevHigh_s = na,var float prevLow_s = na,var int prevHighIndex_s = na,var int prevLowIndex_s = na
bool higher_highs = false, bool lower_highs = false, bool higher_lows = false, bool lower_lows = false

var int prevSwing_s = 0

if not na(pivot_high_found)
    if pivot_high_found >= prevHigh_s
        higher_highs := true
        prevSwing_s := 2
    else
        lower_highs := true
        prevSwing_s := 1
    prevHigh_s := pivot_high_found
    prevHighIndex_s := bar_index - 10

if not na(pivot_low_found)
    if pivot_low_found >= prevLow_s
        higher_lows := true
        prevSwing_s := -1
    else
        lower_lows := true
        prevSwing_s := -2
    prevLow_s := pivot_low_found
    prevLowIndex_s := bar_index - 10

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------       Fair Value Gaps
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// }
// ———————————————————— Global data {
//Using current bar data for HTF highs and lows instead of security to prevent future leaking
var htfH = open
var htfL = open

if close > htfH 
    htfH:= close
if close < htfL
    htfL := close


//Security Data, used for HTF Bar Data reference
sClose = request.security(ticker.standard(syminfo.tickerid), i_tf, close[1], barmerge.gaps_off, barmerge.lookahead_on)
sHighP2 = request.security(ticker.standard(syminfo.tickerid), i_tf, high[2], barmerge.gaps_off, barmerge.lookahead_on)
sLowP2 = request.security(ticker.standard(syminfo.tickerid), i_tf, low[2], barmerge.gaps_off, barmerge.lookahead_on)
sOpen = request.security(ticker.standard(syminfo.tickerid), i_tf, open[1], barmerge.gaps_off, barmerge.lookahead_on)
sBar = request.security(ticker.standard(syminfo.tickerid), i_tf, bar_index, barmerge.gaps_off, barmerge.lookahead_on)

// }
//var keyword can be used to hold data in memory, with pinescript all data is lost including variables unless the var keyword is used to preserve this data
var bullishgapholder = array.new_box(0)
var bearishgapholder = array.new_box(0)

var bullishgapholder_fill = array.new_box(0)
var bearishgapholder_fill = array.new_box(0)

var bullish_high_holder = array.new_line(0)
var bearish_high_holder = array.new_line(0)
var bullish_low_holder = array.new_line(0)
var bearish_low_holder = array.new_line(0)
var bullishmidholder = array.new_line(0)
var bearishmidholder = array.new_line(0)
var bullishlabelholder = array.new_label(0)
var bearishlabelholder = array.new_label(0)
var transparentcolor = color.new(color.white,100)

var fvg_apper=false
var fvg_break=false

fvg_apper:=false
fvg_break:=false
// ———————————————————— Functions {
//function paramaters best declared with '_' this helps defer from variables in the function scope declaration and elsewhere e.g. close => _close
create_fvg_func(_upperlimit,_lowerlimit,_midlimit,_bar,_boxholder,_boxholder_fill,_midholder,_highholder,_lowholder,_labelholder,_boxcolor,_mtfboxcolor, _htf)=>
    timeholder = str.tostring(i_tf)
    offset = i_mtfos
    boxbgcolor = _mtfboxcolor
    bg_color = color.new(_mtfboxcolor,90)
    if _htf == false
        timeholder := str.tostring(timeframe.period)
        offset := i_tfos
        boxbgcolor := _boxcolor
    array.push(_boxholder,box.new(_bar,_upperlimit,_bar+(timediff)*20,_lowerlimit,border_color=true? bg_color : na,bgcolor = true? bg_color : na, extend = false ? extend.right:extend.none,xloc = xloc.bar_time,text='',text_color=#787b86,text_halign=text.align_right,text_size=size.small))
    array.push(_boxholder_fill,box.new(_bar,_upperlimit,_bar+(timediff)*20,_lowerlimit,border_color=true? bg_color : na ,bgcolor = true? bg_color : na, extend = false ? extend.right:extend.none,xloc = xloc.bar_time))
    array.push(_midholder,line.new(_bar,(_lowerlimit+_upperlimit)/2.0,_bar+(timediff)*20,_midlimit,color = #787b86, extend = false ? extend.right:extend.none,style=line.style_solid,width=1,xloc = xloc.bar_time))
    array.push(_lowholder,line.new(_bar,_lowerlimit,_bar+(timediff)*20,_lowerlimit,color = i_fillByMid?boxbgcolor:na, extend = false ? extend.right:extend.none,width=1,xloc = xloc.bar_time))
    array.push(_highholder,line.new(_bar,_upperlimit,_bar+(timediff)*20,_upperlimit,color = i_fillByMid?boxbgcolor:na, extend = false ? extend.right:extend.none,width=1,xloc = xloc.bar_time))

//checks for gap between current candle and 2 previous candle e.g. low of current candle and high of the candle before last, this is the fair value gap.
check_fvg_func(_close,_high,_highp2,_low,_lowp2,_open,_bar,_htf)=>
    gap=0
    thold_ = (ta.highest(_high,300) - ta.lowest(_low,300)) * math.max(1.5, 0.1) / 100.
    if _open > _close // red

        if _lowp2>_high
            if not(true) or math.abs(_lowp2 -_high) > thold_
                upperlimit = _high//_close - (_close - _lowp2 )
                lowerlimit = _lowp2//_close - (_close-_high)
                midlimit = lowerlimit + ((upperlimit - lowerlimit) / 2.)
                gap:=1
                create_fvg_func(upperlimit,lowerlimit,midlimit,_bar,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder,i_bullishfvgcolor,i_mtfbullishfvgcolor,_htf)
            
    else
        
        if _low>_highp2
            if not(true) or math.abs(_low - _highp2) > thold_
                upperlimit = _low//_close - (_close-_low)
                lowerlimit = _highp2//_close- (_close - _highp2),
                midlimit = lowerlimit + ((upperlimit - lowerlimit) / 2.)
                gap:=-1
                create_fvg_func(upperlimit,lowerlimit,midlimit,_bar,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder,i_bearishfvgcolor,i_mtfbearishfvgcolor,_htf)
            
    gap

//Used to remove the gap from its relevant array as a result of it being filled.
delete_fvg_func(_currentgap,_currentgap_fill,_i,_boxholder,_boxholder_fill,_midholder,_highholder,_lowholder,_labelholder)=>
   
    array.remove(_boxholder,_i)
    array.remove(_boxholder_fill,_i)

    currentmid=array.get(_midholder,_i)
    currenthigh=array.get(_highholder,_i)
    currentlow=array.get(_lowholder,_i)
    array.remove(_midholder,_i)
    array.remove(_highholder,_i)
    array.remove(_lowholder,_i)
    
    if i_deleteonfill
        line.delete(currentmid)
        line.delete(currenthigh)
        line.delete(currentlow)
    else
        line.set_extend(currentmid, extend.none)
        line.set_x2(currentmid,time)
        line.set_extend(currenthigh, extend.none)
        line.set_x2(currenthigh,time)
        line.set_extend(currentlow, extend.none)
        line.set_x2(currentlow,time)

    if i_deleteonfill
        box.delete(_currentgap)
        box.delete(_currentgap_fill)
         
    else
        box.set_extend(_currentgap,extend.none)
        box.set_right(_currentgap,time)

//checks if gap has been filled either by 0.5 fill (i_fillByMid) or SHRINKS the gap to reflect the true value gap left.
validate_fvg_func(_high,_low)=>

    fvg_removed=0
    if array.size(bullishgapholder) > 0

        for i = array.size(bullishgapholder)-1 to 0
            currentgap_fill = array.get(bullishgapholder_fill,i)
            currentgap = array.get(bullishgapholder,i)
            cmid = array.get(bullishmidholder,i)
            chigh = array.get(bullish_high_holder,i)
            clow = array.get(bullish_low_holder,i)
            line.set_x2(cmid,timenow+(timediff)*20)
            line.set_x2(chigh,timenow+(timediff)*20)
            line.set_x2(clow,timenow+(timediff)*20)
            box.set_right(currentgap_fill,timenow+(timediff)*20)
            box.set_right(currentgap,timenow+(timediff)*20)

              
            currentmid = array.get(bullishmidholder,i)
            currenthigh = array.get(bullish_high_holder,i)
            currentlow = array.get(bullish_low_holder,i)
            currenttop = box.get_top(currentgap)

            if high > currenttop
                fvg_removed:=1
                delete_fvg_func(currentgap,currentgap_fill,i,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder)
            
       
    if array.size(bearishgapholder) > 0
            
        for i = array.size(bearishgapholder)-1 to 0
            
            currentgap_fill = array.get(bearishgapholder_fill,i)
            currentgap = array.get(bearishgapholder,i)
            cmid = array.get(bearishmidholder,i)
            chigh = array.get(bearish_high_holder,i)
            clow = array.get(bearish_low_holder,i)
            line.set_x2(cmid,timenow+(timediff)*20)
            line.set_x2(chigh,timenow+(timediff)*20)
            line.set_x2(clow,timenow+(timediff)*20)
            box.set_right(currentgap_fill,timenow+(timediff)*20)
            box.set_right(currentgap,timenow+(timediff)*20)


            currenttop = box.get_top(currentgap)
            currentmid = array.get(bearishmidholder,i)
            currenthigh = array.get(bearish_high_holder,i)
            currentlow = array.get(bearish_low_holder,i)
    
            if low < currenttop
                fvg_removed:=-1
                delete_fvg_func(currentgap,currentgap_fill,i,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder)
       
    fvg_removed
                
// pine provided function to determine a new bar

if is_newbar(i_tf)
    htfH := high
    htfL := low

// }

fvg_gap=0

// User Input, allow MTF data calculations
if is_newbar(i_tf) and (i_mtf == "Current + HTF" or i_mtf == "HTF") and show_fvg and barstate.isconfirmed
    fvg_gap:=check_fvg_func(sClose,htfH,sHighP2,htfL,sLowP2,sOpen,time[2],true)
    

alertcondition(fvg_gap==1,"Bullish FVG","Bullish FVG Found Ez-SMC")
alertcondition(fvg_gap==-1,"Bearish FVG","Bearish FVG Found Ez-SMC")

fvg_removed=validate_fvg_func(high,low)

alertcondition(fvg_removed==1,"Bullish FVG Break","Bullish FVG Broken Ez-SMC")
alertcondition(fvg_removed==-1,"Bearish FVG Break","Bearish FVG Broken Ez-SMC")

if array.size(bullishgapholder) > 4
    d_box=array.shift(bullishgapholder)
    box.delete(d_box)

if array.size(bullishgapholder_fill) > 4
    d_box=array.shift(bullishgapholder_fill)
    box.delete(d_box)

if array.size(bullishmidholder) > 4
    d_line=array.shift(bullishmidholder)
    line.delete(d_line)

if array.size(bullish_high_holder) > 4
    d_line=array.shift(bullish_high_holder)
    line.delete(d_line)

if array.size(bullish_low_holder) > 4
    d_line=array.shift(bullish_low_holder)
    line.delete(d_line)

if array.size(bearishgapholder) > 4
    d_box_=array.shift(bearishgapholder)
    box.delete(d_box_)

if array.size(bearishgapholder_fill) > 4
    d_box_=array.shift(bearishgapholder_fill)
    box.delete(d_box_)

if array.size(bearishmidholder) > 4
    d_line_=array.shift(bearishmidholder)
    line.delete(d_line_)

if array.size(bearish_high_holder) > 4
    d_line_=array.shift(bearish_high_holder)
    line.delete(d_line_)

if array.size(bearish_low_holder) > 4
    d_line_=array.shift(bearish_low_holder)
    line.delete(d_line_)
    
n=bar_index

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------       Liquidity Levels
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// --
highLineColor = highLineColorHTF//input.color(#1f4ef5, "High Line???", group = liquidity_level_group, inline = "1")
lowLineColor = lowLineColorHTF//input.color(#fd441c, "Low Line", group = liquidity_level_group, inline = "1")
highBoxBgColor = highLineColorHTF//input.color(color.new(#1f4ef5, 80), "High Box Bg?", group = liquidity_level_group, inline = "2")
highBoxBorderColor = highBoxBorderColorHTF//input.color(color.new(#1f4ef5, 80), "Box Border", group = liquidity_level_group, inline = "2")
lowBoxBgColor = lowLineColorHTF//input.color(color.new(#fd441c, 80), "Low Box Bg??", group = liquidity_level_group, inline = "3")
lowBoxBorderColor = lowBoxBorderColorHTF//input.color(color.new(#fd441c, 80), "Box Border", group = liquidity_level_group, inline = "3")
atr_liq = ta.atr(300)

float thold_liq = atr_liq * (box_width / 10)
// --
// --
// --
// ----------------------------------------------------
// Functions 
// ----------------------------------------------------

tf_multi(tf) =>
    ts = timeframe.in_seconds("")
    htfs = timeframe.in_seconds(tf)
    htfs/ts

display_limit_line(_array) =>
    if array.size(_array) > 6/2
        a = array.shift(_array)
        line.delete(a)

display_limit_box(_array) =>
    if array.size(_array) > 6/2
        a = array.shift(_array)
        box.delete(a)

remove_mitigated_lines(_array, _hl) =>
    m = false
    if array.size(_array) > 0      
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = "Close" == "Close" ? close[1] : high
            ll = "Close" == "Close" ? close[1] : low
            if _hl == "High" and hh > line.get_y1(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = highLineColorHTF, style=highLineStyleHTF, width = lineWidthHTF)
                line.delete(l)
                m := true
            if _hl == "Low" and ll < line.get_y1(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = lowLineColorHTF, style=highLineStyleHTF, width = lineWidthHTF)
                line.delete(l) 
                m := true  
    display_limit_line(_array) 
    m

remove_mitigated_boxes(_array, _hl) =>
    m = false
    if array.size(_array) > 0
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = "Close" == "Close" ? close[1] : high
            ll = "Close" == "Close" ? close[1] : low
            if _hl == "High" and hh > box.get_top(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(highBoxBgColor, 90), border_color = color.new(highBoxBorderColor, 90), border_style = highLineStyleHTF)
                box.delete(l)
                m := true
            if _hl == "Low" and ll < box.get_top(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(lowBoxBgColor, 90), border_color = color.new(lowBoxBorderColor, 90), border_style = highLineStyleHTF)
                box.delete(l)
                m := true
    display_limit_box(_array) 
    m

extend_line_to_current(lineArray) =>
    if array.size(lineArray) > 0
        for i = array.size(lineArray) - 1 to 0 by 1
            l = array.get(lineArray, i)
            timeExt = timenow + ((timediff)*20)
            line.set_x2(l, timeExt)

extend_box_to_current(boxArray) =>
    if array.size(boxArray) > 0
        for i = array.size(boxArray) - 1 to 0 by 1
            b = array.get(boxArray, i)
            timeExt = timenow + ((timediff)*20)
            box.set_right(b, timeExt)

// ----------------------------------------------------
// Higher TimeFrame
// ----------------------------------------------------
// Varibles 
// Lines
var highLineArrayHTF = array.new_line()
var lowLineArrayHTF = array.new_line()

// Boxes
var highBoxArrayHTF = array.new_box()
var lowBoxArrayHTF = array.new_box()

// Get HTF
[_time, _open, _high, _low, _close] = request.security(syminfo.tickerid, htfTF, [time, open, high, low, close])

// Pivots
pivotHighHTF = ta.pivothigh(_high, 8*tf_multi(htfTF), 8+tf_multi(htfTF))
pivotLowHTF = ta.pivotlow(_low, 8*tf_multi(htfTF), 8+tf_multi(htfTF))

if currentTF
    timeExt = time+((time[1]-time[2])*10)
    dis = 8+tf_multi(htfTF)
    if pivotHighHTF
        if displayStyle_liq == "Lines"
            array.push(highLineArrayHTF, line.new(_time[dis],_high[dis],_time[+1],_high[dis],color = highLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, width = lineWidthHTF))
        else
            y1 = _high[dis]-thold_liq//math.max(_open[dis], _close[dis])
            array.push(highBoxArrayHTF, box.new(_time[dis],_high[dis],_time[+1],y1,bgcolor = highLineColorHTF, border_color=highBoxBorderColorHTF, xloc=xloc.bar_time, border_style = highLineStyleHTF, border_width = lineWidthHTF))  
    if pivotLowHTF
        if displayStyle_liq == "Lines"
            array.push(lowLineArrayHTF, line.new(_time[dis],_low[dis],_time[+1],_low[dis],color = lowLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, width = lineWidthHTF))
        else
            y1 = _low[dis]+thold_liq//math.min(_open[dis], _close[dis])
            array.push(lowBoxArrayHTF, box.new(_time[dis],_low[dis],_time[+1],y1,bgcolor = lowLineColorHTF, border_color=lowBoxBorderColorHTF, xloc=xloc.bar_time, border_style = highLineStyleHTF, border_width = lineWidthHTF))

// ----------------------------------------------------
// Run Functions
// ----------------------------------------------------
highLineAlertHTF = remove_mitigated_lines(highLineArrayHTF, "High")
lowLineAlertHTF = remove_mitigated_lines(lowLineArrayHTF, "Low")
highBoxAlertHTF = remove_mitigated_boxes(highBoxArrayHTF, "High")
lowBoxAlertHTF = remove_mitigated_boxes(lowBoxArrayHTF, "Low")

extend_line_to_current(highLineArrayHTF)
extend_line_to_current(lowLineArrayHTF)
extend_box_to_current(highBoxArrayHTF)
extend_box_to_current(lowBoxArrayHTF)

// Alerts
alertcondition(pivotHighHTF, "High Liquidity Level", "High Liquidity Level Found Ez-SMC")
alertcondition(pivotLowHTF, "Low Liquidity Level", "Low Liquidity Level Found Ez-SMC")

alertcondition(highLineAlertHTF or highBoxAlertHTF, "High Liquidity Level Break", "High Liquidity Level Broken Ez-SMC")
alertcondition(lowLineAlertHTF or lowBoxAlertHTF, "Low Liquidity Level Break", "Low Liquidity Level Broken Ez-SMC")

swing_bull_css = bosColor1
swing_bear_css = bosColor2 
var bullish_col_ChoCH = swing_bull_css
var bearish_col_ChoCH = swing_bear_css
var internal_bullish_col_ChoCH = bosColor1
var internal_bearish_col_ChoCH = bosColor2
[high_ms, low_ms] = calculate_swing_points(length)
n := bar_index
//HL Output function
hl() => [high, low]
var float thold = (ta.highest(300) - ta.lowest(300)) * math.max(0.5, 0.1) / 100.
internal_structure_lbl_size=size.small
[int_high_ms, int_low_ms] = calculate_swing_points(swingSize)
swing_structure_lbl_size=size.small
if low_ms
    crossed_down := true
    y_dn := low_ms
    x_dn := n-length
if high_ms
    crossed_up := true
    y_up := high_ms
    x_up := n - length
if int_low_ms
    internal_dn_broke := true
    internal_y_dn := int_low_ms
    internal_x_dn := n - swingSize
if int_high_ms
    internal_up_broke := true
    internal_y_up := int_high_ms
    internal_x_up := n - swingSize
bull_ChoCH=false,bull_ChoCH_=false,bull_bos=false,bull_bos_=false,bear_ChoCH=false,bear_ChoCH_=false,bear_bos=false,bear_bos_=false
if ta.crossover(close, internal_y_up) and internal_up_broke and y_up != internal_y_up
    bool ChoCH = na
    ChoCH := int_t_MS < 0
    internal_up_broke := false
    int_t_MS := 1
    bull_ChoCH:=ChoCH?true:false
    bull_bos:=ChoCH?false:true
    if showms
        Show_MS(internal_x_up, internal_y_up, ChoCH ? 'ChoCH' : 'BOS', internal_bullish_col_ChoCH, true, true, internal_structure_lbl_size)
if ta.crossunder(close, internal_y_dn) and internal_dn_broke and y_dn != internal_y_dn 
    bool ChoCH = false
    ChoCH := int_t_MS > 0    
    internal_dn_broke := false
    int_t_MS := -1
    bear_ChoCH:=ChoCH?true:false
    bear_bos:=ChoCH?false:true
    if showms
        Show_MS(internal_x_dn, internal_y_dn, ChoCH ? 'ChoCH' : 'BOS', internal_bearish_col_ChoCH, true, false, internal_structure_lbl_size)

alertcondition(bull_ChoCH,"Bullish ChoCH",'Bullish ChoCH Found Ez-SMC')
alertcondition(bear_ChoCH,"Bearish ChoCH",'Bearish ChoCH Found Ez-SMC')
alertcondition(bull_bos,"Bullish BOS",'Bullish BOS Found Ez-SMC')
alertcondition(bear_bos,"Bearish BOS",'Bearish ChoCH Found Ez-SMC')

if ta.crossover(close, y_up) and crossed_up
    bool ChoCH = na
    ChoCH := t_MS < 0
    crossed_up := false
    t_MS := 1
    bull_ChoCH_:=ChoCH?true:false
    bull_bos_:=ChoCH?false:true
    if showms
        Show_MS(x_up, y_up, ChoCH ? 'ChoCH+' : 'BOS+', bullish_col_ChoCH, false, true, swing_structure_lbl_size)
if ta.crossunder(close, y_dn) and crossed_down
    bool ChoCH = na
    ChoCH := t_MS > 0
    crossed_down := false
    t_MS := -1
    bear_ChoCH_:=ChoCH?true:false
    bear_bos_:=ChoCH?false:true
    if showms
        Show_MS(x_dn, y_dn, ChoCH ? 'ChoCH+' : 'BOS+', bearish_col_ChoCH, false, false, swing_structure_lbl_size)

alertcondition(bull_ChoCH_,"Bullish ChoCH+",'Bullish ChoCH+ Found Ez-SMC')
alertcondition(bear_ChoCH_,"Bearish ChoCH+",'Bearish ChoCH+ Found Ez-SMC')
alertcondition(bear_bos_,"Bearish BOS+",'Bearish BOS+ Found Ez-SMC')
alertcondition(bull_bos_,"Bullish BOS+",'Bullish BOS+ Found Ez-SMC')

//-----------------------------------------------------------------------------}
//Order Blocks
//-----------------------------------------------------------------------------{
first_nonzero_digit(n) => 
    s = str.tostring(n)

    int r=int (str.tonumber(s[0]))
    for c=0 to str.length(s)-1
        if s[c] != '0'
            r:=int (str.tonumber(s[c]))
    r 

//Order block coordinates function
ob_found(loc,b_index,show_ob,show_iob)=>
    
    type_obs="none"
    valid=false
    H=high
    L=low
    O=open
    C=close
    V=volume
    idx=1
    volume_=0.0
    b_volume=0
    s_volume=0
    use_max=false
    min = 99999999.
    max = 0.

    if open[5]>close[5] and close[4]>=open[5] and low[1]>high[5] and low>high[5] and show_iob
        if low[5]>low[4]
            type_obs:="Internal Bearish"
            H:=math.min(high[4],high[5])
            L:=low[4]
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=false
        else
            type_obs:="Internal Bearish"
            H:=high[5]
            L:=low[5]
            O:=open[5]        
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=false
    
    else if open[5]<close[5] and close[4]<=open[5] and high[1]<low[5] and high<low[5] and show_iob
        if high[4]>high[5]
            type_obs:="Internal Bullish"
            H:=high[4]
            L:=math.max(low[4],low[5])
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=true
        else
            type_obs:="Internal Bullish"
            H:=high[5]
            L:=low[5]
            O:=open[5]        
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=true

    else if open[5]>close[5] and close[4]>close[5] and close[3]>=open[5] and low>high[5] and show_iob
        if low[5]>low[4]
            type_obs:="Internal Bearish"
            H:=math.min(high[4],high[5])
            L:=low[4]
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=false
        else
            type_obs:="Internal Bearish"
            H:=high[5]
            L:=low[5]
            O:=open[5]        
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=false

    else if open[5]<close[5] and close[4]<close[5] and close[3]<=open[5] and high<low[5] and show_iob
        if high[4]>high[5]
            type_obs:="Internal Bullish"
            H:=high[4]
            L:=math.max(low[4],low[5])
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=true
        else
            type_obs:="Internal Bullish"
            H:=high[5]
            L:=low[5]
            O:=open[5]      
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=true
    else
        valid:=false

    if valid
        
        ind=0
        thold_ = (ta.highest(300) - ta.lowest(300)) * (3/2.) / 100.

        buyingVolume = math.round(V * (C - L) / (H - L))
        sellingVolume = math.round(V * (H - C) / (H - L))
        t_volume = (buyingVolume+sellingVolume)/2.
        b_volume:=int ((buyingVolume/ta.highest(t_volume,300))*100)
        s_volume:=int ((sellingVolume/ta.highest(t_volume,300))*100)

        volume_:=V
        //Search for highest/lowest high within the structure interval and get range
        if use_max
            max:=H//[idx]
            min_1=L//[idx]//H[1]-math.min(open[1],close[1])>ob_threshold
            min:=math.max(min_1,max-thold_)
        else
            max_1=H//[idx]//math.max(open[idx],close[idx])
            min:=L//[idx]
            max:=math.min(max_1,min+thold_)

    [valid,volume_,b_volume,s_volume,max,min,idx,use_max ? -1 : 1,type_obs]

//Set order blocks
show_orderblock(boxes,lines, target_top, target_btm, target_left, target_type, show_last, swing, size,vol,col_1,col_2,length_extend_ob,ob_extend,tf_text,tf_text_2,ob_text_size,vol_text,perct_text,text_color_ob,show_line_obs,line_style_obs)=>
    for x = 0 to show_last-1
        get_box = array.get(boxes, x)
        box.set_lefttop(get_box, na, na)
        box.set_rightbottom(get_box, na , na)
        box.set_border_color(get_box, na)
        box.set_bgcolor(get_box, na)
        get_line = array.get(lines, x)
        line.set_color(get_line,na)
        line.set_xy1(get_line,na,na)
        line.set_xy2(get_line,na,na)

    for i = 0 to size-1
        get_box = array.get(boxes, i)
        get_line = array.get(lines, i)
        max_left=bar_index-750
        volume_sum=array.sum(vol)
        volume_=array.get(vol, i)>100000000 ? array.get(vol, i)/100000000.: array.get(vol, i)>1000000 ? array.get(vol, i)/1000000. : array.get(vol, i)/1000.
        volume_per=(array.get(vol, i)/volume_sum)*100
        unit=array.get(vol, i)>100000000 ?' B': array.get(vol, i)>1000000 ?' M' : ' K'
        text_vol=vol_text and perct_text ? tf_text +  str.tostring(volume_,'#.##')+ unit + ' ('+ str.tostring(volume_per,'#.##')+'%)' : vol_text and not(perct_text) ? tf_text +  str.tostring(volume_,'#.##')+ unit : not(vol_text) and perct_text ? tf_text +   ' '+ str.tostring(volume_per,'#.##')+'%' : tf_text_2+  ''
        if true//max_left<array.get(target_left, i)
            box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
            box.set_rightbottom(get_box,timenow+((timediff)*length_extend_ob) , array.get(target_btm, i))
            box.set_text(get_box,text_vol)
            box.set_text_color(get_box,text_color_ob)
            box.set_border_color(get_box,color.gray)
            box.set_border_width(get_box,2)
            box.set_text_halign(get_box,text.align_right)
            box.set_text_valign(get_box,text.align_center)
            box.set_text_size(get_box,ob_text_size)
            fully_extend=not(vol_text) and not(perct_text) and ob_extend? extend.right : extend.none
            len_ext=not(vol_text) and not(perct_text)?length_extend_ob : length_extend_ob/2
            line.set_extend(get_line,fully_extend)
            line.set_style(get_line,line_style_obs)
            line.set_xy1(get_line,array.get(target_left, i),array.get(target_top, i)-(array.get(target_top, i) - array.get(target_btm, i))/2)
            line.set_xy2(get_line,time+((timediff)*(len_ext)),array.get(target_top, i)-(array.get(target_top, i) - array.get(target_btm, i))/2)
            if show_line_obs
                line.set_color(get_line,color.gray)

            if ob_extend
                box.set_extend(get_box, extend.right)

            color css = na
            css := array.get(target_type, i) == 1 ? col_1 : col_2
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
            box.set_border_color(get_box, css)
            
display_sub_ob_buy(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size,right1,right2)=>
    for x = 0 to show_last-1
        get_box = array.get(boxes, x)
        box.set_lefttop(get_box, na, na)
        box.set_rightbottom(get_box, na , na)
        box.set_border_color(get_box, na)
        box.set_bgcolor(get_box, na)

    for i = 0 to math.min(show_last-1, size-1)
        get_box = array.get(boxes, i)
        x=1000000000000
        max_left=bar_index-750
        right=math.max(array.get(right1, i),array.get(right2, i))
        max_right=array.get(target_left, i)+(((timediff)*right+10)) //> time+((time[1]-time[2])*20 ? time+((time[1]-time[2])*20) : array.get(target_left, i)+(time+((time[1]-time[2])*(array.get(right, i)+10))))
        if true//max_left<array.get(target_left, i)
            box.set_lefttop(get_box, math.max(array.get(target_left, i),max_left), array.get(target_top, i)-(array.get(target_top, i) - array.get(target_btm, i))/10)
            box.set_rightbottom(get_box, math.min(max_right,timenow+((timediff)*20)), array.get(target_btm, i)+(array.get(target_top, i) - array.get(target_btm, i))/10)
            //box.set_right(get_box, array.get(target_left, i)+100)
            //box.set_extend(get_box, extend.right)
            color css = na
            if true//max_left<array.get(target_left, i)
                css := array.get(right1, i)>array.get(right2, i)? v_sell : v_buy
                box.set_border_color(get_box, color.new(css,100))
                box.set_bgcolor(get_box, css)

remove_ob(target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    del_index=0
    deleted=false
    for i = 0 to size-1
        if i>0
            for x=i-1 to 0
                if array.get(target_top,i)>=array.get(target_btm,x) and array.get(target_top,i)<=array.get(target_top,x)
                    deleted:=true
                    del_index:=i
                if array.get(target_btm,i)>=array.get(target_btm,x) and array.get(target_btm,i)<=array.get(target_top,x)
                    deleted:=true
                    del_index:=i
                if array.get(target_btm,i)==array.get(target_btm,x) and array.get(target_top,i)==array.get(target_top,x)
                    deleted:=true
                    del_index:=i
                if array.get(target_btm,i)<=array.get(target_btm,x) and array.get(target_top,i)>=array.get(target_top,x)
                    deleted:=true
                    del_index:=i
    [deleted,del_index]

time_diff()=>((time[1]-time[101])/100)

//-----------------------------------------------------------------------------}
//Order Blocks Arrays
//-----------------------------------------------------------------------------{
var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)
var ob_sell_vol = array.new_int(0)
var ob_buy_vol = array.new_int(0)
var ob_vol = array.new_float(0)

bar_merge=barmerge.gaps_off
look_bars=barmerge.lookahead_on

[valid_ob,volume_,b_volume,s_volume,top_ob,btm_ob,left_ob,type_ob,_type]=request.security(ticker.standard(syminfo.tickerid), i_tf_ob, ob_found(x_up,bar_index,show_ob,show_iob), bar_merge,look_bars)

tf1_time=request.security(ticker.standard(syminfo.tickerid),i_tf_ob,time_diff(), bar_merge,look_bars)

if valid_ob and not(valid_ob[1]) and barstate.isconfirmed
    array.unshift(ob_vol, volume_)
    array.unshift(ob_buy_vol, b_volume)
    array.unshift(ob_sell_vol, s_volume)
    array.unshift(ob_top, top_ob)
    array.unshift(ob_btm, btm_ob)
    array.unshift(ob_left, left_ob)
    array.unshift(ob_type, type_ob)

alertcondition(_type=="External Bearish",'Bearish External OB','Bearish External OB Found Ez-SMC')
alertcondition(_type=="External Bullish",'Bullish External OB','Bullish External OB Found Ez-SMC')
alertcondition(_type=="Internal Bearish",'Bearish Internal OB','Bearish Internal OB Found Ez-SMC')
alertcondition(_type=="Internal Bullish",'Bullish Internal OB','Bullish Internal OB Found Ez-SMC')

//Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

var ob_volume = array.new_line(0)
var ob_volume_labels = array.new_label(0)

var iob_boxes_buy = array.new_box(0)
var ob_boxes_buy = array.new_box(0)

var iob_boxes_sell = array.new_box(0)
var ob_boxes_sell = array.new_box(0)

if array.size(ob_top)>4// or array.get(ob_left,array.size(ob_left)-1)>bar_index-400
    array.pop(ob_top)
    array.pop(ob_btm)
    array.pop(ob_left)
    array.pop(ob_type)
    array.pop(ob_buy_vol)
    array.pop(ob_sell_vol)
    array.pop(ob_vol)

// //Delete internal order blocks box coordinates if high_ms/bottom is broken
if array.size(ob_top)>1
    for index=0 to array.size(ob_top)-1
        src1= low
        src2= high
        up= array.get(ob_btm, index)
        dn= array.get(ob_top, index)

        if (src1 < up or src1[1] < up) and array.get(ob_type, index) == 1
            array.remove(ob_top, index) 
            array.remove(ob_btm, index) 
            array.remove(ob_left, index) 
            array.remove(ob_type, index)
            array.remove(ob_buy_vol, index)
            array.remove(ob_sell_vol, index)
            array.remove(ob_vol, index)
            bullish_OB_Break := true
            break

        else if (src2 > dn or src2[1] > dn) and array.get(ob_type, index) == -1
            array.remove(ob_top, index) 
            array.remove(ob_btm, index)
            array.remove(ob_left, index) 
            array.remove(ob_type, index)
            array.remove(ob_buy_vol, index)
            array.remove(ob_sell_vol, index)
            array.remove(ob_vol, index)
            bearish_OB_Break := true
            break

alertcondition(bullish_OB_Break,'Bullish OB Break','Bullish OB Broken Ez-SMC')
alertcondition(bearish_OB_Break,'Bearish OB Break','Bearish OB Broken Ez-SMC')

// iob_size = array.size(iob_type)
ob_size = array.size(ob_type)

if barstate.islast
    if true
        for i = 0 to 4-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
            array.push(ob_boxes_buy, box.new(na,na,na,na, xloc = xloc.bar_time))
            array.push(ob_boxes_sell, box.new(na,na,na,na, xloc = xloc.bar_time))
            array.push(ob_volume, line.new(na,na,na,na,xloc = xloc.bar_time,color=color.gray,style=line.style_solid,width = 1))

if ob_size > 1
    [deleted_ob,del_index]=remove_ob(ob_top, ob_btm, ob_left, ob_type, 4, false, ob_size)
    if deleted_ob
        array.remove(ob_top, del_index)
        array.remove(ob_btm, del_index)
        array.remove(ob_left, del_index)
        array.remove(ob_type, del_index)
        array.remove(ob_buy_vol, del_index)
        array.remove(ob_sell_vol, del_index)
        array.remove(ob_vol, del_index)

// iob_size := array.size(iob_type)
ob_size := array.size(ob_type)

if ob_size > 0 and barstate.islast
    if show_order_blocks
        show_orderblock(ob_boxes,ob_volume, ob_top, ob_btm, ob_left, ob_type, 4, false, ob_size,ob_vol,ibull_ob_css,ibear_ob_css,30,false,'','',size.small,false,true,#787b86,true,line.style_solid)
        // if v_filter
        //     display_sub_ob_buy(ob_boxes_buy, ob_top, ob_btm, ob_left, ob_type, max_obs, false, ob_size,ob_buy_vol,ob_sell_vol)
        //     display_sub_ob_sell(ob_boxes_sell, ob_top, ob_btm, ob_left, ob_type, max_obs, false, ob_size,ob_sell_vol)

//-----------------------------------------------------------------------------}