// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © leandrolopezf1920

//@version=5
indicator("Simple System by LEO 1", shorttitle ="SSL1",format=format.price, precision=4, overlay = true, max_bars_back = 4000,max_lines_count=500,max_labels_count=500, max_boxes_count=500)

//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{
length = input.int(5, minval = 3)

//Colors
showBull = input(true, 'Bullish Structures', inline = 'bull', group = 'Style')
bullCss = input.color(#089981, '', inline = 'bull', group = 'Style')

showBear = input(true, 'Bearish Structures', inline = 'bear', group = 'Style')
bearCss = input.color(#f23645, '', inline = 'bear', group = 'Style')

showSupport = input(false, 'Support', inline = 's', group = 'Style')
supCss = input.color(#089981, '', inline = 's', group = 'Style')

showResistance = input(false, 'Resistance', inline = 'r', group = 'Style')
resCss = input.color(#f23645, '', inline = 'r', group = 'Style')


//-----------------------------------------------------------------------------}
//Types
//-----------------------------------------------------------------------------{
type fractal
    float value
    int loc
    bool iscrossed

//-----------------------------------------------------------------------------}
//Fractal Detection
//-----------------------------------------------------------------------------{
var p = int(length/2)
n = bar_index

dh = math.sum(math.sign(high - high[1]), p)
dl = math.sum(math.sign(low - low[1]), p)

bullf = dh == -p and dh[p] == p and high[p] == ta.highest(length)
bearf = dl == p and dl[p] == -p and low[p] == ta.lowest(length)

bullf_count = ta.cum(bullf ? 1 : 0)
bearf_count = ta.cum(bearf ? 1 : 0)

//-----------------------------------------------------------------------------}
//Bullish market structure
//-----------------------------------------------------------------------------{
var upper = fractal.new()
var line lower_lvl = na
var label ms_lbl = na
var bull_ms_count = 0
var broken_sup = false
var os = 0

if bullf
    upper.value := high[p]
    upper.loc := n-p
    upper.iscrossed := false

if ta.crossover(close, upper.value) and not upper.iscrossed
    line.new(upper.loc, upper.value, n, upper.value, color = showBull ? bullCss : na)

    ms_lbl := label.new(int(math.avg(n, upper.loc)), upper.value, os == -1 ? 'ChoCH' : 'BOS'
      , color = color(na)
      , textcolor = showBull ? bullCss : na
      , style = label.style_label_down
      , size = size.tiny)

    //Set support
    k = 2
    min = low[1]
    for i = 2 to (n - upper.loc)-1
        min := math.min(low[i], min)
        k := low[i] == min ? i : k

    if showSupport
        lower_lvl := line.new(n-k, min, n, min, color = bullCss, style = line.style_dashed)
        broken_sup := false

    upper.iscrossed := true
    bull_ms_count += 1
    os := 1

else if showSupport and not broken_sup
    lower_lvl.set_x2(n)

    if close < lower_lvl.get_y2()
        broken_sup := true

//-----------------------------------------------------------------------------}
//Bearish market structure
//-----------------------------------------------------------------------------{
var lower = fractal.new()
var line upper_lvl = na
var broken_res = false
var bear_ms_count = 0

if bearf
    lower.value := low[p]
    lower.loc := n-p
    lower.iscrossed := false

if ta.crossunder(close, lower.value) and not lower.iscrossed
    line.new(lower.loc, lower.value, n, lower.value, color = showBear ? bearCss : na)
    
    label.new(int(math.avg(n, lower.loc)), lower.value, os == 1 ? 'ChoCH' : 'BOS'
      , color = color(na)
      , textcolor = showBear ? bearCss : na
      , style = label.style_label_up
      , size = size.tiny)

    //Set resistance
    k = 2
    max = high[1]
    for i = 2 to (n - lower.loc)-1
        max := math.max(high[i], max)
        k := high[i] == max ? i : k

    if showResistance
        upper_lvl := line.new(n-k, max, n, max, color = bearCss, style = line.style_dashed)
        broken_res := false
    
    lower.iscrossed := true
    bear_ms_count += 1
    os := -1

else if showResistance and not broken_res
    upper_lvl.set_x2(n)

    if close > upper_lvl.get_y2()
        broken_res := true

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
plot(broken_res and not broken_res[1] ? low : na, 'Resistance Breakout', #089981, 2, plot.style_circles)
plot(broken_sup and not broken_sup[1] ? high : na, 'Support Breakout', #f23645, 2, plot.style_circles)

//-----------------------------------------------------------------------------}
//UT Bot Alerts
//-----------------------------------------------------------------------------{

// Inputs
a = input(2, title='Key Vaule. \'This changes the sensitivity\'')
c = input(1, title='ATR Period')
h111 = input(false, title='Signals from Heikin Ashi Candles')

xATR = ta.atr(c)
nLoss = a * xATR

src = h111 ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close, lookahead=barmerge.lookahead_off) : close

xATRTrailingStop = 0.0
iff_1 = src > nz(xATRTrailingStop[1], 0) ? src - nLoss : src + nLoss
iff_2 = src < nz(xATRTrailingStop[1], 0) and src[1] < nz(xATRTrailingStop[1], 0) ? math.min(nz(xATRTrailingStop[1]), src + nLoss) : iff_1
xATRTrailingStop := src > nz(xATRTrailingStop[1], 0) and src[1] > nz(xATRTrailingStop[1], 0) ? math.max(nz(xATRTrailingStop[1]), src - nLoss) : iff_2

pos = 0
iff_3 = src[1] > nz(xATRTrailingStop[1], 0) and src < nz(xATRTrailingStop[1], 0) ? -1 : nz(pos[1], 0)
pos := src[1] < nz(xATRTrailingStop[1], 0) and src > nz(xATRTrailingStop[1], 0) ? 1 : iff_3

xcolor = pos == -1 ? color.red : pos == 1 ? color.green : color.blue

ema = ta.ema(src, 1)
above = ta.crossover(ema, xATRTrailingStop)
below = ta.crossover(xATRTrailingStop, ema)

buy = src > xATRTrailingStop and above
sell = src < xATRTrailingStop and below

barbuy = src > xATRTrailingStop
barsell = src < xATRTrailingStop

plotshape(buy, title='Buy', text='Buy', style=shape.labelup, location=location.belowbar, color=color.new(color.green, 0), textcolor=color.new(color.white, 0), size=size.tiny)
plotshape(sell, title='Sell', text='Sell', style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 0), textcolor=color.new(color.white, 0), size=size.tiny)

barcolor(barbuy ? color.green : na)
barcolor(barsell ? color.red : na)

alertcondition(buy, 'UT Long', 'UT Long')
alertcondition(sell, 'UT Short', 'UT Short')

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
bullCss1          = input.color(color.teal, 'FVG Level'               , inline = 'bull')
bullAreaCss      = input.color(color.new(color.teal, 50), 'Area'     , inline = 'bull')
bullMitigatedCss = input.color(color.new(color.teal, 80), 'Mitigated', inline = 'bull')

bearCss1          = input.color(color.red, 'FVG Level'                , inline = 'bear')
bearAreaCss      = input.color(color.new(color.red, 50), 'Area'      , inline = 'bear')
bearMitigatedCss = input.color(color.new(color.red, 80), 'Mitigated' , inline = 'bear')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type fvg
    float top
    float btm
    bool  mitigated
    bool  isnew
    bool  isbull
    line  lvl
    box   area

type session_range
    line max
    line min

//-----------------------------------------------------------------------------}
//Methods
//-----------------------------------------------------------------------------{
nl = bar_index

//Method for setting fair value gaps
method set_fvg(fvg id, offset, bg_css, l_css)=>
    avg = math.avg(id.top, id.btm)

    area  = box.new(nl - offset, id.top, nl, id.btm, na, bgcolor = bg_css)
    avg_l = line.new(nl - offset, avg, nl, avg, color = l_css, style = line.style_dashed)

    id.lvl := avg_l
    id.area := area

//Method for setting session range maximum/minimum
method set_range(session_range id)=>
    max = math.max(high, id.max.get_y2())
    min = math.min(low, id.min.get_y2())

    id.max.set_xy2(nl, max)
    id.max.set_y1(max)

    id.min.set_xy2(nl, min)
    id.min.set_y1(min)

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
var chartCss = color.new(chart.fg_color, 50)

var fvg sfvg = fvg.new(na, na, na, true, na)
var session_range sesr = na

var box area = na
var line avg = na

bull_fvg = low > high[2] and close[1] > high[2]
bear_fvg = high < low[2] and close[1] < low[2]

//Alert conditions
bull_isnew      = false
bear_isnew      = false
bull_mitigated  = false
bear_mitigated  = false
within_bull_fvg = false
within_bear_fvg = false

//-----------------------------------------------------------------------------}
//New session
//-----------------------------------------------------------------------------{
dtf = timeframe.change('D')

//On new session
if dtf
    //Set delimiter
    line.new(nl, high + syminfo.mintick
      , nl, low - syminfo.mintick
      , color = chartCss
      , style = line.style_dashed
      , extend = extend.both)

    //Set new range
    sesr := session_range.new(
      line.new(nl, high, nl, high, color = chartCss)
      , line.new(nl, low, nl, low, color = chartCss))

    sfvg.isnew := true

    //Set prior session fvg right coordinates
    if not na(sfvg.lvl)
        sfvg.lvl.set_x2(nl-2)
        sfvg.area.set_right(nl-2)

//Set range
else if not na(sesr)
    sesr.set_range()

    //Set range lines color
    sesr.max.set_color(sfvg.isbull ? bullCss1 : bearCss1)
    sesr.min.set_color(sfvg.isbull ? bullCss1 : bearCss1)

//-----------------------------------------------------------------------------}
//Set FVG
//-----------------------------------------------------------------------------{
//New session bullish fvg
if bull_fvg and sfvg.isnew
    sfvg := fvg.new(low, high[2], false, false, true)
    sfvg.set_fvg(2, bullAreaCss, bullCss1)

    bull_isnew := true

//New session bearish fvg
else if bear_fvg and sfvg.isnew
    sfvg := fvg.new(low[2], high, false, false, false)
    sfvg.set_fvg(2, bearAreaCss, bearCss1)

    bear_isnew := true

//Change object transparencies if mitigated
if not sfvg.mitigated
    //If session fvg is bullish
    if sfvg.isbull and close < sfvg.btm
        sfvg.set_fvg(1, bullMitigatedCss, bullCss1)

        sfvg.mitigated := true
        bull_mitigated := true

    //If session fvg is bearish
    else if not sfvg.isbull and close > sfvg.top
        sfvg.set_fvg(1, bearMitigatedCss, bearCss1)

        sfvg.mitigated := true
        bear_mitigated := true

//Set fvg right coordinates to current bar
if not sfvg.isnew
    sfvg.lvl.set_x2(nl)
    sfvg.area.set_right(nl)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
//On new session fvg
alertcondition(bull_isnew, 'Bullish FVG', 'New session bullish fvg')
alertcondition(bear_isnew, 'Bearish FVG', 'New session bearish fvg')

//On fvg mitigation
alertcondition(bull_mitigated, 'Mitigated Bullish FVG', 'Session bullish fvg has been mitigated')
alertcondition(bear_mitigated, 'Mitigated Bearish FVG', 'Session bearish fvg has been mitigated')

//If within fvg
alertcondition(close >= sfvg.btm and close <= sfvg.top and sfvg.isbull and not sfvg.isnew
  , 'Price Within Bullish FVG'
  , 'Price is within bullish fvg')

alertcondition(close >= sfvg.btm and close <= sfvg.top and not sfvg.isbull and not sfvg.isnew
  , 'Price Within Bearish FVG'
  , 'Price is within bearish fvg')

//On fvg average cross
alertcondition(ta.cross(close, math.avg(sfvg.top, sfvg.btm)) and sfvg.isbull and not sfvg.isnew
  , 'Bullish FVG AVG Cross'
  , 'Price crossed bullish fvg average')

alertcondition(ta.cross(close, math.avg(sfvg.top, sfvg.btm)) and not sfvg.isbull and not sfvg.isnew
  , 'Bearish FVG AVG Cross'
  , 'Price crossed bearish fvg average')

//-----------------------------------------------------------------------------}
//==Linear Regression Candles==
//-----------------------------------------------------------------------------{
colors    = input.string(title = "Color Scheme", defval="BRIGHT", options=["DARK", "BRIGHT"])
periods   = input(5,     "Relevant Periods to identify OB")                // Required number of subsequent candles in the same direction to identify Order Block
threshold = input.float(0.0,   "Min. Percent move to identify OB", step = 0.1)   // Required minimum % move (from potential OB close to last subsequent candle to identify Order Block)
usewicks  = input(false, "Use whole range [High/Low] for OB marking?" )    // Display High/Low range for each OB instead of Open/Low for Bullish / Open/High for Bearish
showbull  = input(true,  "Show latest Bullish Channel?")                   // Show Channel for latest Bullish OB?
showbear  = input(true,  "Show latest Bearish Channel?")                   // Show Channel for latest Bearish OB?
showdocu  = input(false, "Show Label for documentation tooltip?")          // Show Label which shows documentation as tooltip?
info_pan  = input(false, "Show Latest OB Panel?")                          // Show Info Panel with latest OB Stats

ob_period = periods + 1                                                    // Identify location of relevant Order Block candle
absmove   = ((math.abs(close[ob_period] - close[1]))/close[ob_period]) * 100    // Calculate absolute percent move from potential OB to last candle of subsequent candles
relmove   = absmove >= threshold                                           // Identify "Relevant move" by comparing the absolute move to the threshold

// Color Scheme
bullcolor = colors == "DARK"? color.white : color.green
bearcolor = colors == "DARK"? color.blue : color.red

// Bullish Order Block Identification
bullishOB = close[ob_period] < open[ob_period]                             // Determine potential Bullish OB candle (red candle)

int upcandles  = 0
for i = 1 to periods
    upcandles := upcandles + (close[i] > open[i]? 1 : 0)                   // Determine color of subsequent candles (must all be green to identify a valid Bearish OB)

OB_bull      = bullishOB and (upcandles == (periods)) and relmove          // Identification logic (red OB candle & subsequent green candles)
OB_bull_high = OB_bull? usewicks? high[ob_period] : open[ob_period] : na   // Determine OB upper limit (Open or High depending on input)
OB_bull_low  = OB_bull? low[ob_period]  : na                               // Determine OB lower limit (Low)
OB_bull_avg  = (OB_bull_high + OB_bull_low)/2                              // Determine OB middle line


// Bearish Order Block Identification
bearishOB = close[ob_period] > open[ob_period]                             // Determine potential Bearish OB candle (green candle)

int downcandles  = 0
for i = 1 to periods
    downcandles := downcandles + (close[i] < open[i]? 1 : 0)               // Determine color of subsequent candles (must all be red to identify a valid Bearish OB)

OB_bear      = bearishOB and (downcandles == (periods)) and relmove        // Identification logic (green OB candle & subsequent green candles)
OB_bear_high = OB_bear? high[ob_period] : na                               // Determine OB upper limit (High)
OB_bear_low  = OB_bear? usewicks? low[ob_period] : open[ob_period] : na    // Determine OB lower limit (Open or Low depending on input)
OB_bear_avg  = (OB_bear_low + OB_bear_high)/2                              // Determine OB middle line

// Plotting

plotshape(OB_bull, title="Bullish OB", style = shape.triangleup,   color = bullcolor, textcolor = bullcolor, size = size.tiny, location = location.belowbar, offset = -ob_period, text = "Bullish OB")     // Bullish OB Indicator
bull1 = plot(OB_bull_high, title="Bullish OB High", style = plot.style_linebr, color = bullcolor, offset = -ob_period, linewidth = 3)                                               // Bullish OB Upper Limit
bull2 = plot(OB_bull_low,  title="Bullish OB Low",  style = plot.style_linebr, color = bullcolor, offset = -ob_period, linewidth = 3)                                               // Bullish OB Lower Limit
fill(bull1, bull2, color=bullcolor, title = "Bullish OB fill")                                                                                                          // Fill Bullish OB
plotshape(OB_bull_avg, title="Bullish OB Average", style = shape.cross,   color = bullcolor, size = size.normal, location = location.absolute, offset = -ob_period)                 // Bullish OB Average


plotshape(OB_bear, title="Bearish OB", style = shape.triangledown, color = bearcolor, textcolor = bearcolor,  size = size.tiny, location = location.abovebar, offset = -ob_period, text = "Bearish OB")     // Bearish OB Indicator
bear1 = plot(OB_bear_low,  title="Bearish OB Low",  style = plot.style_linebr, color = bearcolor, offset = -ob_period, linewidth = 3)                                                // Bearish OB Lower Limit
bear2 = plot(OB_bear_high, title="Bearish OB High", style = plot.style_linebr, color = bearcolor, offset = -ob_period, linewidth = 3)                                                // Bearish OB Upper Limit
fill(bear1, bear2, color=bearcolor, title = "Bearish OB fill")                                                                                                           // Fill Bearish OB
plotshape(OB_bear_avg, title="Bearish OB Average", style = shape.cross,   color = bearcolor, size = size.normal, location = location.absolute, offset = -ob_period)                  // Bullish OB Average

var line linebull1 = na       // Bullish OB average 
var line linebull2 = na       // Bullish OB open
var line linebull3 = na       // Bullish OB low
var line linebear1 = na       // Bearish OB average
var line linebear2 = na       // Bearish OB high
var line linebear3 = na       // Bearish OB open

if OB_bull and showbull
    line.delete(linebull1)
    linebull1 := line.new(x1 = bar_index, y1 = OB_bull_avg, x2 = bar_index - 1, y2 = OB_bull_avg, extend = extend.left, color = bullcolor, style = line.style_solid, width = 1)
    
    line.delete(linebull2)
    linebull2 := line.new(x1 = bar_index, y1 = OB_bull_high, x2 = bar_index - 1, y2 = OB_bull_high, extend = extend.left, color = bullcolor, style = line.style_dashed, width = 1)
    
    line.delete(linebull3)
    linebull3 := line.new(x1 = bar_index, y1 = OB_bull_low, x2 = bar_index - 1, y2 = OB_bull_low, extend = extend.left, color = bullcolor, style = line.style_dashed, width = 1)

if OB_bear and showbear
    line.delete(linebear1)
    linebear1 := line.new(x1 = bar_index, y1 = OB_bear_avg, x2 = bar_index - 1, y2 = OB_bear_avg, extend = extend.left, color = bearcolor,  style = line.style_solid, width = 1)
    
    line.delete(linebear2)
    linebear2 := line.new(x1 = bar_index, y1 = OB_bear_high, x2 = bar_index - 1, y2 = OB_bear_high, extend = extend.left, color = bearcolor,  style = line.style_dashed, width = 1)
    
    line.delete(linebear3)
    linebear3 := line.new(x1 = bar_index, y1 = OB_bear_low, x2 = bar_index - 1, y2 = OB_bear_low, extend = extend.left, color = bearcolor,  style = line.style_dashed, width = 1)


// Alerts for Order Blocks Detection

alertcondition(OB_bull, title='New Bullish OB detected', message='New Bullish OB detected - This is NOT a BUY signal!')
alertcondition(OB_bear, title='New Bearish OB detected', message='New Bearish OB detected - This is NOT a SELL signal!')

// Print latest Order Blocks in Data Window

var latest_bull_high = 0.0         // Variable to keep latest Bull OB high
var latest_bull_avg  = 0.0         // Variable to keep latest Bull OB average
var latest_bull_low  = 0.0         // Variable to keep latest Bull OB low
var latest_bear_high = 0.0         // Variable to keep latest Bear OB high
var latest_bear_avg  = 0.0         // Variable to keep latest Bear OB average
var latest_bear_low  = 0.0         // Variable to keep latest Bear OB low

// Assign latest values to variables
if OB_bull_high > 0
    latest_bull_high := OB_bull_high

if OB_bull_avg > 0
    latest_bull_avg := OB_bull_avg

if OB_bull_low > 0
    latest_bull_low := OB_bull_low

if OB_bear_high > 0
    latest_bear_high := OB_bear_high
    
if OB_bear_avg > 0
    latest_bear_avg := OB_bear_avg
    
if OB_bear_low > 0
    latest_bear_low := OB_bear_low

//-----------------------------------------------------------------------------}
//==Humble LinReg Candles==
//-----------------------------------------------------------------------------{

signal_length = input.int(title="Signal Smoothing",  minval = 1, maxval = 200, defval = 7)
sma_signal = input.bool(title="Simple MA (Signal Line)",  defval=true)

lin_reg = input.bool(title="Lin Reg",  defval=true)
linreg_length = input.int(title="Linear Regression Length",  minval = 1, maxval = 200, defval = 11)

bopen = lin_reg ? ta.linreg(open, linreg_length, 0) : open
bhigh = lin_reg ? ta.linreg(high, linreg_length, 0) : high
blow = lin_reg ? ta.linreg(low, linreg_length, 0) : low
bclose = lin_reg ? ta.linreg(close, linreg_length, 0) : close

r = bopen < bclose

signal = sma_signal ? ta.sma(bclose, signal_length) : ta.ema(bclose, signal_length)

plotcandle(r ? bopen : na, r ? bhigh : na, r ? blow: na, r ? bclose : na, title="LinReg Candles", color= color.green, wickcolor=color.green, bordercolor=color.green, editable= true)
plotcandle(r ? na : bopen, r ? na : bhigh, r ? na : blow, r ? na : bclose, title="LinReg Candles", color=color.red, wickcolor=color.red, bordercolor=color.red, editable= true)

plot(signal, color=color.blue,linewidth = 2)

//------------------------------------------------------------------------------
//  === Hull Suite ===
//------------------------------------------------------------------------------

//INPUT
src10 = input(close, title="Source")
modeSwitch = input.string("Hma", title="Hull Variation", options=["Hma", "Thma", "Ehma"])
length10 = input(55, title="Length(180-200 for floating S/R , 55 for swing entry)")
lengthMult = input(1.0, title="Length multiplier (Used to view higher timeframes with straight band)")

useHtf = input(false, title="Show Hull MA from X timeframe? (good for scalping)")
htf = input.timeframe("240", title="Higher timeframe")
//ta.change(time("D"), 240)
//label.new(x=bar_index, y=high, text="Higher timeframe", style=label.style_label_down, color=color.green)
switchColor = input(true, "Color Hull according to trend?")
candleCol = input(false,title="Color candles based on Hull's Trend?")
visualSwitch  = input(true, title="Show as a Band?")
thicknesSwitch = input(1, title="Line Thickness")
transpSwitch = input.int(40, title="Band Transparency",step=5)

//FUNCTIONS
//HMA
HMA(_src, _length) =>  ta.wma(2 * ta.wma(_src, _length / 2) - ta.wma(_src, _length), math.round(math.sqrt(_length)))
//EHMA    
EHMA(_src, _length) =>  ta.ema(2 * ta.ema(_src, _length / 2) - ta.ema(_src, _length), math.round(math.sqrt(_length)))
//THMA    
THMA(_src, _length) =>  ta.wma(ta.wma(_src,_length / 3) * 3 - ta.wma(_src, _length / 2) - ta.wma(_src, _length), _length)
    
//SWITCH
Mode(modeSwitch, src, len) =>
      modeSwitch == "Hma"  ? HMA(src10, len) :
      modeSwitch == "Ehma" ? EHMA(src10, len) : 
      modeSwitch == "Thma" ? THMA(src10, len/2) : na

//OUT
_hull = Mode(modeSwitch, src10, int(length10 * lengthMult))
HULL = useHtf ? request.security(syminfo.ticker, htf, _hull) : _hull
MHULL = HULL[0]
SHULL = HULL[2]

//COLOR
hullColor = switchColor ? (HULL > HULL[2] ? #00ff0070 : #ff000070) : #ff9800

//PLOT
///< Frame
Fi1 = plot(MHULL, title="MHULL", color=hullColor, linewidth=thicknesSwitch)
Fi2 = plot(visualSwitch ? SHULL : na, title="SHULL", color=hullColor, linewidth=thicknesSwitch)

///< Ending Filler
fill(Fi1, Fi2, title="Band Filler", color=hullColor, transp=transpSwitch)
///BARCOLOR
barcolor(color = candleCol ? (switchColor ? hullColor : na) : na)


//------------------------------------------------------------------------------
//  Gann Square of 9 
//------------------------------------------------------------------------------
var bool RedGan = input.bool(true, title="On/Off Red line")
var bool BlueGan = input.bool(true, title="On/Off Blue line")
var bool labelOn = input.bool(true, title="On/Off Label")
var color LabelColor = input.color(title="Label color", defval=color.black)
var color BlueLineColor = input.color(title="Blue Line color", defval=color.blue)
var color RedLineColor = input.color(title="Red  Line color", defval=color.red)
var string Extend = input.string(defval="true", title="Extend line")
var int PriceLevel = input.int(3, title="Price Level", options=[3, 5])

// Variables
var label rl1 = na
var label rl2 = na
var label sl1 = na
var label bl1 = na
var label bl2 = na
label.delete(rl1)
label.delete(rl2)
label.delete(sl1)
label.delete(bl1)
label.delete(bl2)

// Función para dibujar líneas
drawLine(resistance, start, end, extend, linecolor) =>
    gannLine = line.new(x1=start, y1=resistance, x2=end, y2=resistance)
    line.set_color(gannLine, linecolor)
    if extend
        line.set_extend(id=gannLine, extend=extend.left)
    gannLine
// Función para dibujar etiquetas
drawLabel(x, y, labelText) =>
    GannLabel = label.new(x, y, labelText, xloc=xloc.bar_time, style=label.style_none)
    GannLabel

// Variables y cálculos
var int max = 20
var int rangeMin = 0
var float[] GannNum = array.new_float(0)
dt = time - time[1]
labelPosition = time + 3 * dt

// Condiciones de última barra
if barstate.islast
    for min = rangeMin to max
        for i = 0 to 3
            var float gNum = 0
            if min == rangeMin and i == 0
                gNum := min + (min+2)
            else if min > rangeMin and i == 0
                gNum := math.round(array.get(GannNum, array.size(GannNum)-1)) + (min+1) + min
            else
                gNum := math.round(array.get(GannNum, array.size(GannNum)-1)) + (min+2) + min
            array.push(GannNum, gNum)

    var int maxItem = array.size(GannNum)-1
    var int next = 0
    var float denomenator = 0.0
    if close[0] >= 10000
        denomenator := 0.01
    else if close[0] >= 1000
        denomenator := 0.1
    else if close[0] >= 100
        denomenator := 1
    else if close[0] >=10
        denomenator := 10
    else if close[0] >=0.05
        denomenator := 100
    else 
        denomenator := 1000
        
    var float price = close[0] * denomenator
    var float resistance = 0.0
    var float support = 0.0
    var float blueGannPrice1 = 0.0
    var int GannPos = 0
    for i = 0 to array.size(GannNum)-1
        if i == maxItem
            next := i
        else 
            next := i + 1
            
        if array.get(GannNum, i) <= price and array.get(GannNum, next) > price
            resistance := array.get(GannNum, next) / denomenator
            support := array.get(GannNum, i) / denomenator
            blueGannPrice1 := (support + resistance) / 2
            GannPos := i
            break
    
    var int startLine = bar_index[0]
    var int endLine = bar_index[10]
    var int GannWeightPosition = close[0] >= blueGannPrice1 ? 2 : -1
    
    if RedGan
        resistance1 = drawLine(resistance, startLine, endLine, Extend == "true", RedLineColor)
        support1 = drawLine(support, startLine, endLine, Extend == "true", RedLineColor)
    if labelOn
        rl1 := drawLabel(labelPosition, resistance, "R1 = " + str.tostring(resistance))
        sl1 := drawLabel(labelPosition, support, "S1 = " + str.tostring(support))
        label.set_textcolor(sl1, LabelColor)
    if PriceLevel == 5
        resistancePrice2 = array.get(GannNum, GannPos+GannWeightPosition) / denomenator
        resistance2 = drawLine(resistancePrice2, startLine, endLine, Extend == "true", RedLineColor)
        if labelOn
            resistanceText2 = GannWeightPosition > 0 ? "R2 = " : "S2 = "
            rl2 := drawLabel(labelPosition, resistancePrice2, resistanceText2 + str.tostring(resistancePrice2))
            label.set_textcolor(rl2, LabelColor)
    if BlueGan
        var line blueGann1 = drawLine(blueGannPrice1, startLine, endLine, Extend == "true", BlueLineColor)
        if labelOn
            BlueText1 = close[0] >= blueGannPrice1 ? "S1 = " : "R1 = "
            bl1 := drawLabel(labelPosition, blueGannPrice1, BlueText1 + str.tostring(blueGannPrice1))
            label.set_textcolor(bl1, LabelColor)
        if PriceLevel == 5
            var float BlueGannPrice2 = GannWeightPosition > 0 ? (array.get(GannNum, GannPos+1) + array.get(GannNum, GannPos+2)) / 2 : (array.get(GannNum, GannPos-1) + array.get(GannNum, GannPos)) / 2
            BlueGannPrice2 := BlueGannPrice2 / denomenator
            var line blueGann2 = drawLine(BlueGannPrice2, startLine, endLine, Extend == "true", BlueLineColor)
            if labelOn
                BlueText2 = GannWeightPosition > 0 ? "R1 = " : "S1 = "
                bl2 := drawLabel(labelPosition, BlueGannPrice2, BlueText2 + str.tostring(BlueGannPrice2))
                label.set_textcolor(bl2, LabelColor)

//-----------------------------------------------------------------------------}
//Market Structure Break & Order Block
//-----------------------------------------------------------------------------{
settings = "Settings"
zigzag_len = input.int(9, "ZigZag Length", group=settings)
show_zigzag = input.bool(false, "Show Zigzag", group=settings)
fib_factor = input.float(0.273, "Fib Factor for breakout confirmation", 0, 1, 0.01, group=settings)

text_size = input.string(size.tiny, "Text Size", [size.tiny, size.small, size.normal, size.large, size.huge], group=settings)

delete_boxes = input.bool(true, "Delete Old/Broken Boxes", group=settings)

bu_ob_inline_color = "Bu-OB Colors"
be_ob_inline_color = "Be-OB Colors"
bu_bb_inline_color = "Bu-BB Colors"
be_bb_inline_color = "Be-BB Colors"

bu_ob_display_settings = "Bu-OB Display Settings"
bu_ob_color = input.color(color.new(color.green, 80), "Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_border_color = input.color(color.rgb(76, 175, 79, 80), "Border Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_text_color = input.color(color.rgb(76, 175, 79, 80), "Text Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)

be_ob_display_settings = "Be-OB Display Settings"
be_ob_color = input.color(color.new(color.red, 80), "Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_border_color = input.color(color.rgb(255, 82, 82, 80), "Border Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_text_color = input.color(color.rgb(255, 82, 82, 80), "Text Color", group=be_ob_display_settings, inline=be_ob_inline_color)

bu_bb_display_settings = "Bu-BB & Bu-MB Display Settings"
bu_bb_color = input.color(color.new(color.green, 80), "Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_border_color = input.color(color.rgb(76, 175, 79, 80), "Border Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_text_color = input.color(color.rgb(76, 175, 79, 80), "Text Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)

be_bb_display_settings = "Be-BB & Be-MB Display Settings"
be_bb_color = input.color(color.new(color.red, 80), "Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_border_color = input.color(color.rgb(255, 82, 82, 80), "Border Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_text_color = input.color(color.rgb(255, 82, 82, 80), "Text Color", group=be_bb_display_settings, inline=be_bb_inline_color)


var float[] high_points_arr = array.new_float(5)
var int[] high_index_arr = array.new_int(5)
var float[] low_points_arr = array.new_float(5)
var int[] low_index_arr = array.new_int(5)

var box[] bu_ob_boxes = array.new_box(5)
var box[] be_ob_boxes = array.new_box(5)
var box[] bu_bb_boxes = array.new_box(5)
var box[] be_bb_boxes = array.new_box(5)

to_up = high >= ta.highest(zigzag_len)
to_down = low <= ta.lowest(zigzag_len)

trend = 1
trend := nz(trend[1], 1)
trend := trend == 1 and to_down ? -1 : trend == -1 and to_up ? 1 : trend

last_trend_up_since = ta.barssince(to_up[1])
low_val = ta.lowest(nz(last_trend_up_since > 0 ? last_trend_up_since : 1, 1))
low_index = bar_index - ta.barssince(low_val == low)

last_trend_down_since = ta.barssince(to_down[1])
high_val = ta.highest(nz(last_trend_down_since > 0 ? last_trend_down_since : 1, 1))
high_index = bar_index - ta.barssince(high_val == high)

if ta.change(trend) != 0
    if trend == 1
        array.push(low_points_arr, low_val)
        array.push(low_index_arr, low_index)
    if trend == -1
        array.push(high_points_arr, high_val)
        array.push(high_index_arr, high_index)


f_get_high(ind) =>
    [array.get(high_points_arr, array.size(high_points_arr) - 1 - ind), array.get(high_index_arr, array.size(high_index_arr) - 1 - ind)]


f_get_low(ind) =>
    [array.get(low_points_arr, array.size(low_points_arr) - 1 - ind), array.get(low_index_arr, array.size(low_index_arr) - 1 - ind)]


f_delete_box(box_arr) =>
    if delete_boxes
        box.delete(array.shift(box_arr))
    else
        array.shift(box_arr)
    0


[h0, h0i] = f_get_high(0)
[h1, h1i] = f_get_high(1)

[l0, l0i] = f_get_low(0)
[l1, l1i] = f_get_low(1)

if ta.change(trend) != 0 and show_zigzag
    if trend == 1
        line.new(h0i, h0, l0i, l0)
    if trend == -1
        line.new(l0i, l0, h0i, h0)

market = 1
market := nz(market[1], 1)
// market := market == 1 and close < l0 and low < l0 - math.abs(h0 - l0) * fib_factor ? -1 : market == -1 and close > h0 and high > h0 + math.abs(h0 - l0) * fib_factor ? 1 : market
last_l0 = ta.valuewhen(ta.change(market) != 0, l0, 0)
last_h0 = ta.valuewhen(ta.change(market) != 0, h0, 0)
market := last_l0 == l0 or last_h0 == h0 ? market : market == 1 and l0 < l1 and l0 < l1 - math.abs(h0 - l1) * fib_factor ? -1 : market == -1 and h0 > h1 and h0 > h1 + math.abs(h1 - l0) * fib_factor ? 1 : market

bu_ob_index = bar_index
bu_ob_index := nz(bu_ob_index[1], bar_index)
for i=h1i to l0i[zigzag_len]
    index = bar_index - i 
    if open[index] > close[index]
        bu_ob_index := bar_index[index]

bu_ob_since = bar_index - bu_ob_index

be_ob_index = bar_index
be_ob_index := nz(be_ob_index[1], bar_index)
for i=l1i to h0i[zigzag_len]
    index = bar_index - i 
    if open[index] < close[index]
        be_ob_index := bar_index[index]

be_ob_since = bar_index - be_ob_index

be_bb_index = bar_index
be_bb_index := nz(be_bb_index[1], bar_index)
for i=h1i - zigzag_len to l1i
    index = bar_index - i
    if open[index] > close[index]
        be_bb_index := bar_index[index]

be_bb_since = bar_index - be_bb_index

bu_bb_index = bar_index
bu_bb_index := nz(bu_bb_index[1], bar_index)
for i=l1i - zigzag_len to h1i
    index = bar_index - i
    if open[index] < close[index]
        bu_bb_index := bar_index[index]

bu_bb_since = bar_index - bu_bb_index

if ta.change(market) != 0
    if market == 1
        line.new(h1i, h1, h0i, h1, color=color.rgb(76, 175, 79, 100), width=1)
        label.new(int(math.avg(h1i, l0i)), h1, "MSB", color=color.new(color.black, 100), style=label.style_label_down, textcolor=color.rgb(76, 175, 79, 100), size=size.small)
        bu_ob = box.new(bu_ob_index, high[bu_ob_since], bar_index + 10, low[bu_ob_since], bgcolor=bu_ob_color, border_color=bu_ob_border_color, text="Bu-OB", text_color=bu_ob_text_color, text_halign=text.align_right, text_size=text_size)
        bu_bb = box.new(bu_bb_index, high[bu_bb_since], bar_index + 10, low[bu_bb_since], bgcolor=bu_bb_color, border_color=bu_bb_border_color, text=l0 < l1 ? "Bu-BB" : "Bu-MB", text_color=bu_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(bu_ob_boxes, bu_ob)
        array.push(bu_bb_boxes, bu_bb)
    if market == -1
        line.new(l1i, l1, l0i, l1, color=color.rgb(255, 82, 82, 100), width=1)
        label.new(int(math.avg(l1i, h0i)), l1, "MSB", color=color.new(color.black, 100), style=label.style_label_up, textcolor=color.rgb(255, 82, 82, 100), size=size.small)
        be_ob = box.new(be_ob_index, high[be_ob_since], bar_index + 10, low[be_ob_since], bgcolor=be_ob_color, border_color=be_ob_border_color, text="Be-OB", text_color=be_ob_text_color, text_halign=text.align_right, text_size=text_size)
        be_bb = box.new(be_bb_index, high[be_bb_since], bar_index + 10, low[be_bb_since], bgcolor=be_bb_color, border_color=be_bb_border_color, text=h0 > h1 ? "Be-BB" : "Be-MB", text_color=be_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(be_ob_boxes, be_ob)
        array.push(be_bb_boxes, be_bb)

for bull_ob in bu_ob_boxes
    bottom = box.get_bottom(bull_ob)
    top = box.get_top(bull_ob)
    if close < bottom
        f_delete_box(bu_ob_boxes)
    else if close < top
        alert("Price in the BU-OB zone")
    else
        box.set_right(bull_ob, bar_index + 10)
    
for bear_ob in be_ob_boxes
    top = box.get_top(bear_ob)
    bottom = box.get_bottom((bear_ob))
    if close > top
        f_delete_box(be_ob_boxes)
    if close > bottom
        alert("Price in the BE-OB zone")
    else
        box.set_right(bear_ob, bar_index + 10)
        
for bear_bb in be_bb_boxes
    top = box.get_top(bear_bb)
    bottom = box.get_bottom(bear_bb)
    if close > top
        f_delete_box(be_bb_boxes)
    else if close > bottom
        alert("Price in the BE-BB zone")
    else
        box.set_right(bear_bb, bar_index + 10)
        
for bull_bb in bu_bb_boxes
    bottom = box.get_bottom(bull_bb)
    top = box.get_top(bull_bb)
    if close < bottom
        f_delete_box(bu_bb_boxes)
    else if close < top
        alert("Price in the BU-BB zone")
    else
        box.set_right(bull_bb, bar_index + 10)


alertcondition(ta.change(market) != 0, "MSB", "MSB")

//-----------------------------------------------------------------------------}
//Targets with Market Structure Break & Order Block
//-----------------------------------------------------------------------------{
showLabels = input(true, 'Show Target Labels', inline = 'style')
candleColoring = input(true, 'Candle Coloring', inline = 'style')

//Condition Rule
enableTarget1 = input(true, 'Enable Target'
  , inline    = 'enable'
  , group     = 'Target 1')

isLong1       = input(true, 'Long Position Target'
  , inline    = 'enable'
  , group     = 'Target 1')

_ = input.string('Source A', 'New Target Condition', options = ['Source A']
  , inline    = 'targetRule1'
  , group     = 'Target 1')

target1Condition = input.string('CrossOver', ''
  , options   = ['CrossOver', 'CrossUnder', 'Cross', 'Equal']
  , inline    = 'targetRule1'
  , group     = 'Target 1')

_ = input.string('Source B', '', options = ['Source B']
  , inline    = 'targetRule1'
  , group     = 'Target 1')  

//Source A
targetSource1A = input.string('External', 'Source A'
  , options   = ['External', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'A'
  , group     = 'Target 1')

targetExternal1A = input(close, 'External'
  , inline    = 'A'
  , group     = 'Target 1')

targetTiSettings1A = input.string('', 'Settings'
  , inline    = 'A'
  , group     = 'Target 1')

//Source B
targetSource1B = input.string('Supertrend', 'Source B'
  , options   = ['External', 'Value', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'B'
  , group     = 'Target 1')

targetExternal1B = input(open, 'External'
  , inline    = 'B'
  , group     = 'Target 1')

targetTiSettings1B = input.string('10,3', 'Settings'
  , inline    = 'B'
  , group     = 'Target 1')

targetValue1B = input(0, 'Source B Value'
  , inline    = 'B_'
  , group     = 'Target 1')

target1Css    = input(#089981c1, 'Target Color '
  , inline    = 'style'
  , group     = 'Target 1')

target1Style  = input.string('· · ·', '    Levels Style'
  , options   = ['──','- - -','· · ·']
  , inline    = 'style'
  , group     = 'Target 1')

showSource1   = input.bool(false, 'Show Source Values'
  , group     = 'Target 1')

//-----------------------------------------------------------------------------}
//Target 1 Logic
//-----------------------------------------------------------------------------{
waitTarget1   = input(false, 'Wait Until Reached'
  , group     = 'Target 1 Logic')

newTarget1    = input(false, 'New Target When Reached'
  , group     = 'Target 1 Logic')

useWicks1     = input(true, 'Evaluate Wicks'
  , group     = 'Target 1 Logic')

distTarget1   = input.float(3, 'Target Distance From Price'
  , inline    = 'dist1'
  , group     = 'Target 1 Logic')

distOptions1  = input.string('ATR', ''
  , options   = ['Currencies', '%', 'ATR', 'Ticks', 'External Value']
  , inline    = 'dist1'
  , group     = 'Target 1 Logic')

externalDist1 = input(close, 'External Distance Value'
  , group     = 'Target 1 Logic')

//-----------------------------------------------------------------------------}
//Target 2
//-----------------------------------------------------------------------------{
//Condition Rule
enableTarget2 = input(true, 'Enable Target'
  , inline    = 'enable'
  , group     = 'Target 2')

isLong2 = input(false, 'Long Position Target'
  , inline    = 'enable'
  , group     = 'Target 2')

_ = input.string('Source A', 'New Target Condition', options = ['Source A']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

target2Condition = input.string('CrossUnder', ''
  , options   = ['CrossOver', 'CrossUnder', 'Cross', 'Equal']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

_ = input.string('Source B', '', options = ['Source B']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

//Source A
targetSource2A = input.string('External', 'Source A'
  , options   = ['External', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'A'
  , group     = 'Target 2')

targetExternal2A = input(close, 'External'
  , inline    = 'A'
  , group     = 'Target 2')

targetTiSettings2A = input.string('', 'Settings'
  , inline    = 'A'
  , group     = 'Target 2')

//Source B
targetSource2B = input.string('Supertrend', 'Source B'
  , options   = ['External', 'Value', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'B'
  , group     = 'Target 2')

targetExternal2B = input(open, 'External'
  , inline    = 'B'
  , group     = 'Target 2')

targetTiSettings2B = input.string('10,3', 'Settings'
  , inline    = 'B'
  , group     = 'Target 2')

targetValue2B = input(0, 'Source B Value'  
  , inline    = 'B_'
  , group     = 'Target 2')

target2Css    = input(#f23646c0, 'Target Color '
  , inline    = 'style'
  , group     = 'Target 2')

target2Style  = input.string('· · ·', '    Levels Style'
  , options   = ['──','- - -','· · ·']
  , inline    = 'style'
  , group     = 'Target 2')

showSource2   = input.bool(false, 'Show Source Values'
  , group     = 'Target 2')

//-----------------------------------------------------------------------------}
//Target 2 Logic
//-----------------------------------------------------------------------------{
waitTarget2   = input(false, 'Wait Until Reached'
  , group     = 'Target 2 Logic')

newTarget2    = input(false, 'New Target When Reached'
  , group     = 'Target 2 Logic')

useWicks2     = input(true, 'Evaluate Wicks'
  , group     = 'Target 2 Logic')

distTarget2   = input.float(3, 'Target Distance From Price'
  , inline    = 'dist1'
  , group     = 'Target 2 Logic')

distOptions2  = input.string('ATR', ''
  , options   = ['Currencies', '%', 'ATR', 'Ticks', 'External Value']
  , inline    = 'dist1'
  , group     = 'Target 2 Logic')

externalDist2 = input(close, 'External Distance Value   '
  , group     = 'Target 2 Logic')

//-----------------------------------------------------------------------------}
//Target 2 Logic
//-----------------------------------------------------------------------------{
showDash      = input.bool     (    false      , 'Show Dashboard'                                                     , group= 'Dashboard')
dashLoc       = input.string   (  'Top Right' , 'Location'  , options = ['Top Right', 'Bottom Right', 'Bottom Left'] , group= 'Dashboard')
textSize      = input.string   (   'Normal'   , 'Size'      , options =          ['Tiny', 'Small', 'Normal']         , group= 'Dashboard')

//-----------------------------------------------------------------------------}
//UDT
//-----------------------------------------------------------------------------{
type lshape
    line v
    line h

type target
    float  value
    int    loc
    bool   reached
    bool   islong
    bool   active
    lshape lines
    label  lbl

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{

INV = color.new(color.blue, 100)

aNoVisuals = array.from('ACCDIST', 'ATR', 'CCI', 'CMO', 'COG', 'III', 'MACD', 'MACD-signal', 'MACD-histogram', 'MFI', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'ROC', 'RSI', 'STOCH', 'WAD', 'WVAD', '%R')

a_1Val       = array.from( 'ATR'  ,  'CCI'  ,  'CMO'  ,  'COG'  , 'DC High', 'DC Mid', 'DC Low', 'DEMA'  ,  'EMA'  ,  'HMA'  , 'MEDIAN',  'MFI'  ,  'MODE' ,  'MOM'  ,  'RMA'  ,  'ROC'  ,  'RSI'  ,  'SMA'  , 'STOCH' , 'TEMA'  , 'VWMA'  ,  'WMA'  ,   '%R'  )
a_1ValValues = array.from('Length', 'Length', 'Length', 'Length', 'Length' , 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length')

a_2Val       = array.from( 'BB Middle'     ,   'BB Upper'     ,   'BB Lower'     ,  'KC Middle'     ,   'KC Upper'     ,   'KC Lower'     ,    'LINREG'      ,     'Supertrend'    )
a_2ValValues = array.from('Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Offset' , 'ATR Length, Factor')

a_3Val       = array.from(              'MACD'             ,           'MACD-signal'          ,         'MACD-histogram'         )
a_3ValValues = array.from('Short, Long & Signal EMA Length', 'Short, Long & Signal EMA Length', 'Short, Long & Signal EMA Length')

method set_target(target id, css, lstyle)=>
    style = switch lstyle
        '- - -' => line.style_dashed
        '· · ·' => line.style_dotted
        =>         line.style_solid
    
    id.lines := lshape.new(line.new(n, close, n, id.value, color = css, style = style),
      line.new(n, id.value, n, id.value, color = css, style = style))

method delete(target id)=>
    id.lines.v.delete()
    id.lines.h.delete()

method getSetting(array<string> id , idx) => int(str.tonumber(id.get(idx)))

method getStFloat(array<string> id , idx) =>     str.tonumber(id.get(idx))

method isString  (array<string> settings) =>
    isS = false 
    for s in settings 
        if na(str.tonumber(s) / 1)
            isS := true 
            break 
    txt = isS ? 'Please, use numbers' : ''

method ema(int len, float source) => 
    alpha = 2 / (len + 1)
    float ema = na
    sma = ta.sma(source, len)
    ema := alpha * source + (1 - alpha) * nz(ema[1], sma[1])

method rma(int len, float source) =>
    alpha = 1 / len, float sum = 0
    sum := na(sum[1]) ? ta.sma(source, len) : alpha * source + (1 - alpha) * nz(sum[1])

method value(string choice, array<string> setting, float targetExternal, float targetValue) => 
  
    sZ  =  setting.size() , float value = na
    int int1 = na 

    if sZ > 0
        for  i  = setting.size ( ) -1 to 0
            get = setting.get  (i) 
            if  get == ''   or get == ' '
             or get == '  ' or get == '   '
                setting.remove (i)

    isS = setting.isString()
    txt = switch 
        isS != '' => isS
        a_1Val.includes(choice) =>
            if setting.size() != 1
                str.format    (   'Please enter 1 value for {0}: {1}'        , choice, a_1ValValues.get(a_1Val.indexof(choice)))
            else 
                if setting.getSetting(0) - setting.getStFloat(0) != 0
                    str.format('{0} ({1}) -> Length must be an Integer value', choice, a_1ValValues.get(a_1Val.indexof(choice)))
        
        a_2Val.includes(choice) =>
            if setting.size() != 2
                str.format    (   'Please enter 2 values for {0}: {1}'       , choice, a_2ValValues.get(a_2Val.indexof(choice)))
            else 
                if setting.getSetting(0) - setting.getStFloat(0) != 0
                    str.format('{0} ({1}) -> Length must be an Integer value', choice, a_2ValValues.get(a_2Val.indexof(choice)))

        a_3Val.includes(choice) =>
            if setting.size() != 3
                str.format    (   'Please enter 3 values for {0}: {1}'       , choice, a_3ValValues.get(a_3Val.indexof(choice)))
            else                
                if  setting.getSetting(0) - setting.getStFloat(0) != 0                
                 or setting.getSetting(1) - setting.getStFloat(1) != 0
                 or setting.getSetting(2) - setting.getStFloat(2) != 0
                    'Each Number must be an Integer value'

    float shortEMA = na, float longEMA = na, float macd    = na, float signal2  = na, float hist = na
    float BBmiddle = na, float BBupper = na, float BBlower = na
    float KCmiddle = na, float KCupper = na, float KClower = na

    if txt == '' 
        if str.contains(choice, 'BB')
            len           = setting.getSetting(0)
            BBmiddle     := ta.sma(close, len)
            float dev     = setting.getStFloat(1) * ta.stdev(close, len)
            BBupper      := BBmiddle + dev 
            BBlower      := BBmiddle - dev

        if str.contains(choice, 'KC')
            KCmiddle     := setting.getSetting(0).ema(close)
            KCrange       = setting.getSetting(0).ema(ta.tr) 
            KCupper      := KCmiddle + KCrange * setting.getStFloat(1)
            KClower      := KCmiddle - KCrange * setting.getStFloat(1)

        if str.contains(choice, 'MACD')
            shortEMA     := setting.getSetting(0).ema(close) 
            longEMA      := setting.getSetting(1).ema(close) 
            macd         := shortEMA - longEMA
            signal2       := setting.getSetting(2).ema(macd)
            hist         := macd - signal2 

        value := switch choice 

            'ACCDIST'        => ta.accdist

            'ATR'            => setting.getSetting(0).rma(ta.tr(true))

            'BB Middle'      => BBmiddle 
            'BB Upper'       => BBupper
            'BB Lower'       => BBlower

            'CCI'            => ta.cci(close, setting.getSetting(0))

            'CMO'            => ta.cmo(close, setting.getSetting(0))

            'COG'            => ta.cog(close, setting.getSetting(0))

            'DC High'        =>                                             ta.highest(setting.getSetting(0))             
            'DC Mid'         => math.avg(ta.highest(setting.getSetting(0)), ta.lowest (setting.getSetting(0)))
            'DC Low'         =>                                             ta.lowest (setting.getSetting(0)) 

            'DEMA'           =>  
                len  = setting.getSetting(0)
                ema1 = len.ema(close)
                ema2 = len.ema(ema1 )
                2    * ema1 -  ema2       

            'EMA'            => setting.getSetting(0).ema(close)

            'External'       => targetExternal

            'HMA'            => 
                len = setting.getSetting(0)
                ta.wma(2 * ta.wma(close, math.floor(len / 2)) - ta.wma(close, len), math.floor(math.sqrt(len)))

            'III'            => ta.iii 

            'KC Middle'      => KCmiddle
            'KC Upper'       => KCupper
            'KC Lower'       => KClower

            'LINREG'         => 
                len = setting.getSetting(0), off = setting.getSetting(1)
                float sX     = 0, float sY = 0, float sXSqr = 0, float sXY = 0
                for i = 1   to len
                    val      = close[len-i], per = i+1, sX += per, sY += val
                    sXSqr   += math.pow(per, 2), sXY += val * per
                slope        = (sXY * len - sX * sY) / (sXSqr * len - math.pow(sX, 2))
                intcp        = ta.sma(close, len) - slope * sX / len + slope
                intcp + slope * (len - off)

            'MACD'           => macd 
            'MACD-signal'    => signal
            'MACD-histogram' => hist

            'MEDIAN'         => ta.median(close, setting.getSetting(0))

            'MFI'            => ta.mfi(close, setting.getSetting(0))  

            'MODE'           => ta.mode(close, setting.getSetting(0))

            'MOM'            => ta.mom(close, setting.getSetting(0))  

            'NVI'            => ta.nvi

            'OBV'            => ta.obv

            'PVI'            => ta.pvi

            'PVT'            => ta.pvt 

            'SMA'            => ta.sma(close, setting.getSetting(0))

            'RMA'            => setting.getSetting(0).rma(close)

            'ROC'            => ta.roc(close, setting.getSetting(0))

            'RSI'            => 
                len  = setting.getSetting(0), var num = 0., var den = 0., d = nz(close - close[1])
                num += (math.max(d, 0) - num) / len, den += (math.abs(d   ) - den) / len
                num / den * 100        

            'STOCH'          => ta.stoch(close, high, low, setting.getSetting(0))

            'Supertrend'     => 
                len          = setting.getSetting(0), factor    = setting.getStFloat(1)
                var atr      = 0. , var upper = high, var lower = low, var float trend = na
                atr         += (nz(ta.tr) - atr)  / len
                up           = hl2 + atr * factor   , dn = hl2 - atr * factor
                upper       := close[1] < upper ? math.min(up, upper) : up
                lower       := close[1] > lower ? math.max(dn, lower) : dn
                trend       := close    > upper ? 1 : close < lower ? 0 : trend
                trend       == 1 ? lower : upper

            'TEMA'           => 
                len  = setting.getSetting(0)
                ema1 = len.ema(close)
                ema2 = len.ema(ema1 )
                ema3 = len.ema(ema2 )
                (3 * ema1) - (3 * ema2) + ema3

            'Value'          => targetValue

            'VWAP'           => ta.vwap(close)

            'VWMA'           => ta.vwma(close, setting.getSetting(0))
            
            'WAD'            => ta.wad 

            'WMA'            => ta.wma(close, setting.getSetting(0))

            'WVAD'           => ta.wvad

            '%R'             => ta.wpr(setting.getSetting(0))

    [txt, value]

//-----------------------------------------------------------------------------}
//Set target 1
//-----------------------------------------------------------------------------{
var color css            = na
bool      isNewTarget1   = false
bool      isTgReached1   = false

var int countTargets1   = 0
var int countTgReached1 = 0

var target1_object      = target.new(reached = true, active = false)

var setting1A           = str.split(targetTiSettings1A, ',')
var setting1B           = str.split(targetTiSettings1B, ',')

[txt1A, source1A] = targetSource1A.value(setting1A, targetExternal1A,       na     )
[txt1B, source1B] = targetSource1B.value(setting1B, targetExternal1B, targetValue1B)

target1_condition = switch target1Condition
    'CrossOver'  => ta.crossover (source1A, source1B)
    'CrossUnder' => ta.crossunder(source1A, source1B)
    'Cross'      => ta.cross     (source1A, source1B)
    'Equal'      => source1A == source1B

//Distance
dist1 = switch distOptions1
    'Currencies' => distTarget1
    '%' => close + distTarget1 / 100 * close
    'ATR' => nz(ta.atr(50)) * distTarget1
    'Ticks' => syminfo.mintick * distTarget1
    'External Value' => externalDist1 * distTarget1

if target1_object.active and target1_object.reached == false
    target1_object.lines.h.set_x2(n)
    target1_object.lbl.set_x(n)

if (isLong1 ? (useWicks1 ? high : close) > target1_object.value : (useWicks1 ? low : close) < target1_object.value) and target1_object.active 
    target1_object.reached := true
    target1_object.active  := false 
    isTgReached1           := true
    countTgReached1        += 1
    css := na
    target1_object.lbl.set_color(target1Css)

if enableTarget1 and 
 (
  (target1_condition and (waitTarget1 ? target1_object.reached : true)) 
  or 
  (newTarget1 and target1_object.reached)
 ) 
    target_value = close + (isLong1 ? dist1 : -dist1)

    //Delete label if reached and creating new target
    if newTarget1 and target1_object.reached and showLabels
        target1_object.lbl.delete()

    //Create new target
    target1_object := target.new(target_value, n, false, isLong1, active = true)

    if showLabels
        target1_object.lbl := label.new(n, target_value, 'Target'
          , color = color.new(target1Css, 50)
          , textcolor = color.white
          , size = size.tiny
          , style = label.style_label_left
          , tooltip = str.tostring(target_value, format.mintick))

    css := target1Css

    target1_object.set_target(target1Css, target1Style)

    isNewTarget1  := true 
    countTargets1 += 1

//-----------------------------------------------------------------------------}
//Set target 2
//-----------------------------------------------------------------------------{
bool     isNewTarget2   = false
bool     isTgReached2   = false

var int countTargets2   = 0
var int countTgReached2 = 0

var target2_object      = target.new(reached = true, active = false)

var setting2A           = str.split(targetTiSettings2A, ',')
var setting2B           = str.split(targetTiSettings2B, ',')

[txt2A, source2A] = targetSource2A.value(setting2A, targetExternal2A,       na     )
[txt2B, source2B] = targetSource2B.value(setting2B, targetExternal2B, targetValue2B)

target2_condition = switch target2Condition
    'CrossOver'  => ta.crossover (source2A, source2B)
    'CrossUnder' => ta.crossunder(source2A, source2B)
    'Cross'      => ta.cross     (source2A, source2B)
    'Equal'      => source2A == source2B

//Distance
dist2 = switch distOptions2
    'Currencies' => distTarget2
    '%' => close + distTarget2 / 100 * close
    'ATR' => nz(ta.atr(50)) * distTarget2
    'Ticks' => syminfo.mintick * distTarget2
    'External Value' => externalDist2 * distTarget2

if target2_object.active and target2_object.reached == false
    target2_object.lines.h.set_x2(n)
    target2_object.lbl.set_x(n)

if (isLong2 ? (useWicks2 ? high : close) > target2_object.value : (useWicks2 ? low : close) < target2_object.value) and target2_object.active 
    target2_object.reached := true
    target2_object.active  := false 
    isTgReached2           := true
    countTgReached2        += 1
    css := na
    target2_object.lbl.set_color(target2Css)

if enableTarget2     and
 (
  (target2_condition and (waitTarget2 ? target2_object.reached : true)) 
  or 
  (newTarget2 and target2_object.reached)
 ) 
    target_value = close + (isLong2 ? dist2 : -dist2)

    //Delete label if reached and creating new target
    if newTarget2 and target2_object.reached and showLabels
        target2_object.lbl.delete()

    //Create new target
    target2_object := target.new(target_value, n, false, isLong2, active = true)

    if showLabels
        target2_object.lbl := label.new(n, target_value, 'Target'
          , color = color.new(target2Css, 50)
          , textcolor = color.white
          , size = size.tiny
          , style = label.style_label_left
          , tooltip = str.tostring(target_value, format.mintick))
    
    css := target2Css

    target2_object.set_target(target2Css, target2Style)

    isNewTarget2  := true 
    countTargets2 += 1

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
noVisuals1 = array.includes(aNoVisuals, targetSource1A) or array.includes(aNoVisuals, targetSource1B) 
noVisuals2 = array.includes(aNoVisuals, targetSource2A) or array.includes(aNoVisuals, targetSource2B) 

plot(showSource1 and enableTarget1 and not noVisuals1 ? source1A : na, 'Target 1, source A', color=#089981)
plot(showSource1 and enableTarget1 and not noVisuals1 ? source1B : na, 'Target 1, source B', color=#2157f3)

plot(showSource2 and enableTarget2 and not noVisuals2 ? source2A : na, 'Target 2, source A', color=#ffe400)
plot(showSource2 and enableTarget2 and not noVisuals2 ? source2B : na, 'Target 2, source B', color=#ff1100)

barcolor(candleColoring ? css : na, title = 'Candle Coloring')

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
alertcondition(isNewTarget1, "Target 1 New"    , "Target 1 New"    )
alertcondition(isTgReached1, 'Target 1 Reached', 'Target 1 Reached')

alertcondition(isNewTarget2, "Target 2 New"    , "Target 2 New"    )
alertcondition(isTgReached2, 'Target 2 Reached', 'Target 2 Reached')
//------------------------------------------------------------------------------
//  === Trend Line ===
//------------------------------------------------------------------------------

startyear = input(defval = 2020, title = "Start Year")
startmonth = input(defval = 1, title = "Start Month")
startday = input(defval = 1, title = "Start day")
prd = input.int(defval = 20, title="Pivot Period", minval = 10, maxval = 50)
PPnum = input.int(defval = 3, title="Number of Pivot Points to check", minval = 2, maxval = 6)
utcol = input(defval = color.lime, title = "Colors", inline = "tcol")
dtcol = input(defval = color.red, title = "", inline = "tcol")

float ph = ta.pivothigh(prd, prd)
float pl = ta.pivotlow(prd, prd)

var tval = array.new_float(PPnum)
var tpos = array.new_int(PPnum)
var bval = array.new_float(PPnum)
var bpos = array.new_int(PPnum)

add_to_array(apointer1, apointer2, val)=>
    array.unshift(apointer1, val)
    array.unshift(apointer2, bar_index)
    array.pop(apointer1)
    array.pop(apointer2)

if ph
    add_to_array(tval, tpos, ph)

if pl
    add_to_array(bval, bpos, pl)
    
// line definitions
maxline = 3
var bln = array.new_line(maxline, na)
var tln = array.new_line(maxline, na)

// loop for pivot points to check if there is possible trend line
countlinelo = 0
countlinehi = 0

starttime = timestamp(startyear, startmonth, startday, 0, 0, 0)

if time >= starttime
    for x = 0 to maxline - 1
        line.delete(array.get(bln, x))
        line.delete(array.get(tln, x))
    for p1 = 0 to PPnum - 2 
        uv1 = 0.0
        uv2 = 0.0
        up1 = 0
        up2 = 0
        if countlinelo <= maxline
            for p2 = PPnum - 1 to p1 + 1
                val1 = array.get(bval, p1)
                val2 = array.get(bval, p2)
                pos1 = array.get(bpos, p1)
                pos2 = array.get(bpos, p2)
                if val1 > val2
                    diff = (val1 - val2) / (pos1 - pos2)
                    hline = val2 + diff
                    lloc = bar_index
                    lval = low
                    valid = true
                    for x = pos2 + 1 - prd to bar_index
                        if close[bar_index - x] < hline
                            valid := false
                            break
                        lloc := x
                        lval := hline
                        hline := hline + diff
                    
                        
                    if valid
                        uv1 := hline - diff
                        uv2 := val2
                        up1 := lloc
                        up2 := pos2
                        break

        dv1 = 0.0
        dv2 = 0.0
        dp1 = 0
        dp2 = 0                
        if countlinehi <= maxline
            for p2 = PPnum - 1 to p1 + 1                
                val1 = array.get(tval, p1)
                val2 = array.get(tval, p2)
                pos1 = array.get(tpos, p1)
                pos2 = array.get(tpos, p2)
                if val1 < val2
                    diff = (val2 - val1) / float(pos1 - pos2)
                    hline = val2 - diff
                    lloc = bar_index
                    lval = high
                    valid = true
                    for x = pos2 + 1 - prd to bar_index
                        if close[bar_index - x] > hline
                            valid := false
                            break
                        lloc := x
                        lval := hline
                        hline := hline - diff
                        
                    if valid
                        dv1 := hline + diff
                        dv2 := val2
                        dp1 := lloc
                        dp2 := pos2
                        break
                         
        // if there is continues uptrend line then draw it
        if up1 != 0 and up2 != 0 and countlinelo < maxline
            countlinelo += 1
            array.set(bln, countlinelo - 1, line.new(up2 - prd, uv2, up1, uv1, color = utcol))
        
        // if there is continues downtrend line then draw it
        if dp1 != 0 and dp2 != 0 and countlinehi < maxline
            countlinehi += 1
            array.set(tln, countlinehi - 1, line.new(dp2 - prd, dv2, dp1, dv1, color = dtcol))
