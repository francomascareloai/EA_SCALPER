// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join us https://t.me/simpleforextools

//@version=6
indicator(title = 'WaveTrend Oscillator + AutoFib Trend Scouter', shorttitle = 'WaveTrend Oscillator + AutoFib Trend Scouter', max_lines_count = 500, max_labels_count = 500, overlay = false, max_bars_back = 5000)

// ############ Elliott Wave ##################

i_hi = input.string('high', title = '', group = 'source [high - low] (Elliott Wave Settings)', inline = 'hl', options = ['high', 'close', 'max open/close'])
i_lo = input.string('low', title = '', group = 'source [high - low] (Elliott Wave Settings)', inline = 'hl', options = ['low', 'close', 'min open/close'])

s1 = input.bool(true, title = '', group = 'ZigZag', inline = '1')
len1 = input.int(4, title = '  1 Length', group = 'ZigZag', inline = '1', minval = 1)
col1 = input.color(color.red, title = '', group = 'ZigZag', inline = '1')
s2 = input.bool(true, title = '', group = 'ZigZag', inline = '2')
len2 = input.int(8, title = '  2 Length', group = 'ZigZag', inline = '2', minval = 1)
col2 = input.color(color.blue, title = '', group = 'ZigZag', inline = '2')
s3 = input.bool(true, title = '', group = 'ZigZag', inline = '3')
len3 = input.int(16, title = '  3 Length', group = 'ZigZag', inline = '3', minval = 1)
col3 = input.color(color.white, title = '', group = 'ZigZag', inline = '3')


i_500 = input.float(0.500, title = '           level 1', group = 'Fibonacci values', minval = 0, maxval = 1, step = 0.01)
i_618 = input.float(0.618, title = '           level 2', group = 'Fibonacci values', minval = 0, maxval = 1, step = 0.01)
i_764 = input.float(0.764, title = '           level 3', group = 'Fibonacci values', minval = 0, maxval = 1, step = 0.01)
i_854 = input.float(0.854, title = '           level 4', group = 'Fibonacci values', minval = 0, maxval = 1, step = 0.01)

shZZ = input.bool(false, title = '', group = 'show ZZ', inline = 'zz')

//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
type ZZ
	array<int> d
	array<int> x
	array<float> y
	array<line> l

type Ewave
	line l1
	line l2
	line l3
	line l4
	line l5
	label b1
	label b2
	label b3
	label b4
	label b5
	//
	bool on
	bool br //= na
	//
	int dir
	//
	line lA
	line lB
	line lC
	label bA
	label bB
	label bC
	//
	bool next = false
	//
	label lb
	box bx

type fibL
	line wave1_0_500
	line wave1_0_618
	line wave1_0_764
	line wave1_0_854
	line wave1_pole_
	linefill l_fill_
	bool _break_ //= na

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
hi = i_hi == 'high' ? high : i_hi == 'close' ? close : math.max(open, close)
lo = i_lo == 'low' ? low : i_hi == 'close' ? close : math.min(open, close)

in_out(aZZ, d, x1, y1, x2, y2, col) =>
    aZZ.d.unshift(d)
    aZZ.x.unshift(x2)
    aZZ.y.unshift(y2)
    aZZ.d.pop()
    aZZ.x.pop()
    aZZ.y.pop()
    if shZZ
        aZZ.l.unshift(line.new(x1, y1, x2, y2, color = col, force_overlay = true))
        aZZ.l.pop().delete()

method isSame(Ewave gEW, _1x, _2x, _3x, _4x) =>
    t1 = _1x == gEW.l1.get_x1()
    t2 = _2x == gEW.l2.get_x1()
    t3 = _3x == gEW.l3.get_x1()
    t4 = _4x == gEW.l4.get_x1()
    t1 and t2 and t3 and t4

method isSame2(Ewave gEW, _1x, _2x, _3x) =>
    t1 = _1x == gEW.l3.get_x2()
    t2 = _2x == gEW.l4.get_x2()
    t3 = _3x == gEW.l5.get_x2()
    t1 and t2 and t3

method dot(Ewave gEW) =>
    gEW.l1.set_style(line.style_dotted)
    gEW.l2.set_style(line.style_dotted)
    gEW.l3.set_style(line.style_dotted)
    gEW.l4.set_style(line.style_dotted)
    gEW.l5.set_style(line.style_dotted)
    gEW.b1.set_textcolor(color(na))
    gEW.b2.set_textcolor(color(na))
    gEW.b3.set_textcolor(color(na))
    gEW.b4.set_textcolor(color(na))
    gEW.b5.set_textcolor(color(na))
    gEW.on := false
    gEW.on

method dash(Ewave gEW) =>
    gEW.lA.set_style(line.style_dashed)
    gEW.lB.set_style(line.style_dashed)
    gEW.lC.set_style(line.style_dashed)
    gEW.bA.set_textcolor(color(na))
    gEW.bB.set_textcolor(color(na))
    gEW.bC.set_textcolor(color(na))
    gEW.bx.set_bgcolor(color(na))
    gEW.bx.set_border_color(color(na))

method sol_dot(fibL nFibL, sol_dot, col) =>
    style = sol_dot == 'dot' ? line.style_dotted : sol_dot == 'sol' ? line.style_solid : line.style_dashed
    nFibL.wave1_0_500.set_style(style)
    nFibL.wave1_0_618.set_style(style)
    nFibL.wave1_0_764.set_style(style)
    nFibL.wave1_0_854.set_style(style)
    nFibL.l_fill_.set_color(col)

method set(fibL nFibL, int x1, int x2, float max_500, float max_618, float max_764, float max_854, float y2) =>
    nFibL.wave1_0_500.set_xy1(x1, max_500)
    nFibL.wave1_0_500.set_xy2(x2, max_500)
    nFibL.wave1_0_618.set_xy1(x1, max_618)
    nFibL.wave1_0_618.set_xy2(x2, max_618)
    nFibL.wave1_0_764.set_xy1(x1, max_764)
    nFibL.wave1_0_764.set_xy2(x2, max_764)
    nFibL.wave1_0_854.set_xy1(x1, max_854)
    nFibL.wave1_0_854.set_xy2(x2, max_854)
    nFibL.wave1_pole_.set_xy1(x1, y2)
    nFibL.wave1_pole_.set_xy2(x1, max_854)
    nFibL.l_fill_.get_line1().set_xy1(x1, max_764)
    nFibL.l_fill_.get_line1().set_xy2(x2, max_764)
    nFibL.l_fill_.get_line2().set_xy1(x1, max_854)
    nFibL.l_fill_.get_line2().set_xy2(x2, max_854)

method setNa(fibL nFibL) =>
    nFibL.wave1_0_500.set_xy1(na, na)
    nFibL.wave1_0_500.set_xy2(na, na)
    nFibL.wave1_0_618.set_xy1(na, na)
    nFibL.wave1_0_618.set_xy2(na, na)
    nFibL.wave1_0_764.set_xy1(na, na)
    nFibL.wave1_0_764.set_xy2(na, na)
    nFibL.wave1_0_854.set_xy1(na, na)
    nFibL.wave1_0_854.set_xy2(na, na)
    nFibL.wave1_pole_.set_xy1(na, na)
    nFibL.wave1_pole_.set_xy2(na, na)
    nFibL.l_fill_.set_color(color(na))

draw(enabled, left, col, n) =>
    //
    max_bars_back(time, 2000)
    var int dir = na
    var int x1 = na
    var float y1 = na
    var int x2 = na
    var float y2 = na
    var Ewave gEW = na
    var int last_0x = na
    var float last_0y = na
    var int last_6x = na
    var float last_6y = na
    //
    if enabled
        var fibL nFibL = fibL.new(wave1_0_500 = line.new(na, na, na, na, color = color.new(col, 50), style = line.style_solid, force_overlay = true), wave1_0_618 = line.new(na, na, na, na, color = color.new(col, 38), style = line.style_solid, force_overlay = true), wave1_0_764 = line.new(na, na, na, na, color = color.new(col, 24), style = line.style_solid, force_overlay = true), wave1_0_854 = line.new(na, na, na, na, color = color.new(col, 15), style = line.style_solid, force_overlay = true), wave1_pole_ = line.new(na, na, na, na, color = color.new(col, 50), style = line.style_dashed, force_overlay = true), l_fill_ = linefill.new(line.new(na, na, na, na, color = color(na), force_overlay = true), line.new(na, na, na, na, color = color(na), force_overlay = true), color = color(na)), _break_ = false)

        //
        var ZZ aZZ = ZZ.new(array.new<int>(), array.new<int>(), array.new<float>(), array.new<line>())
        var array<Ewave> aEW = array.new<Ewave>()
        //
        if barstate.isfirst
            aEW.unshift(Ewave.new())
            for i = 0 to 10 by 1
                aZZ.d.unshift(0)
                aZZ.x.unshift(0)
                aZZ.y.unshift(0)
                aZZ.l.unshift(shZZ ? line.new(na, na, na, na, force_overlay = true) : na)
        //
        sz = aZZ.d.size()
        x2 := bar_index - 1
        ph = ta.pivothigh(hi, left, 1)
        pl = ta.pivotlow(lo, left, 1)
        t = n == 2 ? '\n\n' : n == 1 ? '\n' : ''
        //
        // when a new Pivot High is found
        if not na(ph)
            gEW := aEW.get(0)
            dir := aZZ.d.get(0)
            x1 := aZZ.x.get(0)
            y1 := aZZ.y.get(0)
            y2 := nz(hi[1])
            //
            if dir < 1 // if previous point was a pl, add, and change direction ( 1)
                in_out(aZZ, 1, x1, y1, x2, y2, col)
            else
                if dir == 1 and ph > y1
                    aZZ.x.set(0, x2)
                    aZZ.y.set(0, y2)
                    if shZZ
                        aZZ.l.get(0).set_xy2(x2, y2)
            //
            _6x = x2
            _6y = y2
            _5x = aZZ.x.get(1)
            _5y = aZZ.y.get(1)
            _4x = aZZ.x.get(2)
            _4y = aZZ.y.get(2)
            _3x = aZZ.x.get(3)
            _3y = aZZ.y.get(3)
            _2x = aZZ.x.get(4)
            _2y = aZZ.y.get(4)
            _1x = aZZ.x.get(5)
            _1y = aZZ.y.get(5)
            //
            // –––––––––––––––––––––[ 12345 ]–––––––––––––––––––––
            _W5 = _6y - _5y
            _W3 = _4y - _3y
            _W1 = _2y - _1y
            min = math.min(_W1, _W3, _W5)
            isWave = _W3 != min and _6y > _4y and _3y > _1y and _5y > _2y
            // 
            same = gEW.isSame(_1x, _2x, _3x, _4x)
            if isWave
                if same
                    gEW.l5.set_xy2(_6x, _6y)
                    gEW.b5.set_xy(_6x, _6y)
                else
                    tx = ''
                    if _2x == aEW.get(0).b5.get_x()
                        tx := '(5) (1)'
                        aEW.get(0).b5.set_text('')
                    else
                        tx := '(1)'
                        tx
                    //                
                    wave = Ewave.new(l1 = line.new(_1x, _1y, _2x, _2y, color = col, style = line.style_solid, force_overlay = true), l2 = line.new(_2x, _2y, _3x, _3y, color = col, style = line.style_solid, force_overlay = true), l3 = line.new(_3x, _3y, _4x, _4y, color = col, style = line.style_solid, force_overlay = true), l4 = line.new(_4x, _4y, _5x, _5y, color = col, style = line.style_solid, force_overlay = true), l5 = line.new(_5x, _5y, _6x, _6y, color = col, style = line.style_solid, force_overlay = true), b1 = label.new(_2x, _2y, text = tx + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true), b2 = label.new(_3x, _3y, text = t + '(2)', textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true), b3 = label.new(_4x, _4y, text = '(3)' + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true), b4 = label.new(_5x, _5y, text = t + '(4)', textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true), b5 = label.new(_6x, _6y, text = '(5)' + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true), on = true, br = false, dir = 1)
                    aEW.unshift(wave)
                    nFibL._break_ := false
                    alert('New EW Motive Bullish Pattern found', alert.freq_once_per_bar_close)
            //
            if not isWave
                if same and gEW.on == true
                    gEW.dot()
                    alert('Invalidated EW Motive Bullish Pattern', alert.freq_once_per_bar_close)
            //
            // –––––––––––––––––––––[ ABC ]–––––––––––––––––––––
            getEW = aEW.get(0)
            last_0x := getEW.l1.get_x1()
            last_0y := getEW.l1.get_y1()
            last_6x := getEW.l5.get_x2()
            last_6y := getEW.l5.get_y2()
            diff = math.abs(last_6y - last_0y)
            //
            if getEW.dir == -1
                getX = getEW.l5.get_x2()
                getY = getEW.l5.get_y2()
                isSame2 = getEW.isSame2(_1x, _2x, _3x)
                isValid = _3x == getX and _6y < getY + diff * i_854 and _4y < getY + diff * i_854 and _5y > getY
                //
                if isValid
                    width = _6x - _2x // –––[ width (4) - (c) ]–––
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.lC.set_xy1(_5x, _5y)
                        getEW.lC.set_xy2(_6x, _6y)
                        getEW.bC.set_xy(_6x, _6y)
                        getEW.bx.set_lefttop(_6x, _6y)
                        getEW.bx.set_right(_6x + width)
                    else
                        getEW.lA := line.new(_3x, _3y, _4x, _4y, color = col, force_overlay = true)
                        getEW.bA := label.new(_4x, _4y, text = '(a)' + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true)
                        getEW.lB := line.new(_4x, _4y, _5x, _5y, color = col, force_overlay = true)
                        getEW.bB := label.new(_5x, _5y, text = t + '(b)', textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true)
                        getEW.lC := line.new(_5x, _5y, _6x, _6y, color = col, force_overlay = true)
                        getEW.bC := label.new(_6x, _6y, text = '(c)' + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true)
                        getEW.bx := box.new(_6x, _6y, _6x + width, _4y, bgcolor = color.new(col, 93), border_color = color.new(col, 65), force_overlay = true)
                        alert('New EW Corrective Bullish Pattern found', alert.freq_once_per_bar_close)
                else
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.dash()
                        alert('Invalidated EW Corrective Bullish Pattern', alert.freq_once_per_bar_close)
            //
            // –––––––––––––––––––––[ new (1) ? ]–––––––––––––––––––––
            if getEW.dir == 1
                if _5x == getEW.bC.get_x() and _6y > getEW.b5.get_y() and getEW.next == false
                    getEW.next := true
                    getEW.lb := label.new(_6x, _6y, style = label.style_circle, color = color.new(col, 65), yloc = yloc.abovebar, size = size.tiny, force_overlay = true)
                    alert('Possible new start of EW Motive Bullish Wave', alert.freq_once_per_bar_close)
        //
        // when a new Pivot Low is found
        if not na(pl)
            gEW := aEW.get(0)
            dir := aZZ.d.get(0)
            x1 := aZZ.x.get(0)
            y1 := aZZ.y.get(0)
            y2 := nz(lo[1])
            //
            if dir > -1 // if previous point was a ph, add, and change direction (-1)
                in_out(aZZ, -1, x1, y1, x2, y2, col)
            else
                if dir == -1 and pl < y1
                    aZZ.x.set(0, x2)
                    aZZ.y.set(0, y2)
                    if shZZ
                        aZZ.l.get(0).set_xy2(x2, y2)
            //
            _6x = x2
            _6y = y2
            _5x = aZZ.x.get(1)
            _5y = aZZ.y.get(1)
            _4x = aZZ.x.get(2)
            _4y = aZZ.y.get(2)
            _3x = aZZ.x.get(3)
            _3y = aZZ.y.get(3)
            _2x = aZZ.x.get(4)
            _2y = aZZ.y.get(4)
            _1x = aZZ.x.get(5)
            _1y = aZZ.y.get(5)
            //
            // –––––––––––––––––––––[ 12345 ]–––––––––––––––––––––
            _W5 = _5y - _6y
            _W3 = _3y - _4y
            _W1 = _1y - _2y
            min = math.min(_W1, _W3, _W5)
            isWave = _W3 != min and _4y > _6y and _1y > _3y and _2y > _5y
            // 
            same = isSame(gEW, _1x, _2x, _3x, _4x)
            if isWave
                if same
                    gEW.l5.set_xy2(_6x, _6y)
                    gEW.b5.set_xy(_6x, _6y)
                else
                    tx = ''
                    if _2x == aEW.get(0).b5.get_x()
                        tx := '(5) (1)'
                        aEW.get(0).b5.set_text('')
                    else
                        tx := '(1)'
                        tx
                    //
                    wave = Ewave.new(l1 = line.new(_1x, _1y, _2x, _2y, color = col, style = line.style_solid, force_overlay = true), l2 = line.new(_2x, _2y, _3x, _3y, color = col, style = line.style_solid, force_overlay = true), l3 = line.new(_3x, _3y, _4x, _4y, color = col, style = line.style_solid, force_overlay = true), l4 = line.new(_4x, _4y, _5x, _5y, color = col, style = line.style_solid, force_overlay = true), l5 = line.new(_5x, _5y, _6x, _6y, color = col, style = line.style_solid, force_overlay = true), b1 = label.new(_2x, _2y, text = t + tx, textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true), b2 = label.new(_3x, _3y, text = '(2)' + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true), b3 = label.new(_4x, _4y, text = t + '(3)', textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true), b4 = label.new(_5x, _5y, text = '(4)' + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true), b5 = label.new(_6x, _6y, text = t + '(5)', textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true), on = true, br = false, dir = -1)
                    aEW.unshift(wave)
                    nFibL._break_ := false
                    alert('New EW Motive Bearish Pattern found', alert.freq_once_per_bar_close)
            //        
            if not isWave
                if same and gEW.on == true
                    gEW.dot()
                    alert('Invalidated EW Motive Bearish Pattern', alert.freq_once_per_bar_close)
            //
            // –––––––––––––––––––––[ ABC ]–––––––––––––––––––––
            getEW = aEW.get(0)
            last_0x := getEW.l1.get_x1()
            last_0y := getEW.l1.get_y1()
            last_6x := getEW.l5.get_x2()
            last_6y := getEW.l5.get_y2()
            diff = math.abs(last_6y - last_0y)
            //
            if getEW.dir == 1
                getX = getEW.l5.get_x2()
                getY = getEW.l5.get_y2()
                isSame2 = getEW.isSame2(_1x, _2x, _3x)
                isValid = _3x == getX and _6y > getY - diff * i_854 and _4y > getY - diff * i_854 and _5y < getY
                //
                if isValid
                    width = _6x - _2x // –––[ width (4) - (c) ]–––
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.lC.set_xy1(_5x, _5y)
                        getEW.lC.set_xy2(_6x, _6y)
                        getEW.bC.set_xy(_6x, _6y)
                        getEW.bx.set_lefttop(_6x, _6y)
                        getEW.bx.set_right(_6x + width)
                    else
                        getEW.lA := line.new(_3x, _3y, _4x, _4y, color = col, force_overlay = true)
                        getEW.bA := label.new(_4x, _4y, text = t + '(a)', textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true)
                        getEW.lB := line.new(_4x, _4y, _5x, _5y, color = col, force_overlay = true)
                        getEW.bB := label.new(_5x, _5y, text = '(b)' + t, textcolor = col, color = color(na), style = label.style_label_down, force_overlay = true)
                        getEW.lC := line.new(_5x, _5y, _6x, _6y, color = col, force_overlay = true)
                        getEW.bC := label.new(_6x, _6y, text = t + '(c)', textcolor = col, color = color(na), style = label.style_label_up, force_overlay = true)
                        getEW.bx := box.new(_6x, _6y, _6x + width, _4y, bgcolor = color.new(col, 93), border_color = color.new(col, 65), force_overlay = true)
                        alert('New EW Corrective Bearish Pattern found', alert.freq_once_per_bar_close)
                else
                    if isSame2 and getEW.bA.get_x() > _3x
                        getEW.dash()
                        alert('Invalidated EW Corrective Bullish Pattern', alert.freq_once_per_bar_close)
            //
            // –––[ check (only once) for a possible new (1) after an impulsive AND corrective wave ]–––
            if getEW.dir == -1
                if _5x == getEW.bC.get_x() and _6y < getEW.b5.get_y() and getEW.next == false
                    getEW.next := true
                    getEW.lb := label.new(_6x, _6y, style = label.style_circle, color = color.new(col, 65), yloc = yloc.belowbar, size = size.tiny, force_overlay = true)
                    alert('Possible new start of EW Motive Bearish Wave', alert.freq_once_per_bar_close)
        //                    
        // –––[ check for break box ]–––
        if aEW.size() > 0
            gEW := aEW.get(0)
            if gEW.dir == 1
                if ta.crossunder(low, gEW.bx.get_bottom()) and bar_index <= gEW.bx.get_right()
                    label.new(bar_index, low, yloc = yloc.belowbar, style = label.style_xcross, color = color.red, size = size.tiny, force_overlay = true)
            else
                if ta.crossover(high, gEW.bx.get_top()) and bar_index <= gEW.bx.get_right()
                    label.new(bar_index, high, yloc = yloc.abovebar, style = label.style_xcross, color = color.red, size = size.tiny, force_overlay = true)
        //
        if barstate.islast
            //  –––[ get last 2 EW's ]–––
            getEW = aEW.get(0)
            if aEW.size() > 1
                getEW1 = aEW.get(1)
                last_0x := getEW.l1.get_x1()
                last_0y := getEW.l1.get_y1()
                last_6x := getEW.l5.get_x2()
                last_6y := getEW.l5.get_y2()
                //
                diff = math.abs(last_6y - last_0y) // –––[ max/min difference ]–––
                _500 = diff * i_500
                _618 = diff * i_618
                _764 = diff * i_764
                _854 = diff * i_854
                bull = getEW.dir == 1
                // –––[ if EW is not valid or an ABC has developed -> remove fibonacci lines ]–––
                if getEW.on == false or getEW.bC.get_x() > getEW.b5.get_x()
                    nFibL.setNa()
                else // –––[ get.on == true ~ valid EW ]–––
                    max_500 = last_6y + (bull ? -1 : 1) * _500
                    max_618 = last_6y + (bull ? -1 : 1) * _618
                    max_764 = last_6y + (bull ? -1 : 1) * _764
                    max_854 = last_6y + (bull ? -1 : 1) * _854
                    //
                    nFibL.set(last_6x, bar_index + 10, max_500, max_618, max_764, max_854, last_6y)
                // –––[ if (2) label overlap with (C) label ]–––
                if getEW.b2.get_x() == getEW1.bC.get_x()
                    getEW.b1.set_textcolor(color(na))
                    getEW.b2.set_textcolor(color(na))
                    strB = getEW1.bB.get_text()
                    strC = getEW1.bC.get_text()
                    strB_ = str.replace(strB, '(b)', '(b) (1)', 0)
                    strC_ = str.replace(strC, '(c)', '(c) (2)', 0)
                    getEW1.bB.set_text(strB_)
                    getEW1.bC.set_text(strC_)
            //        
            // –––[ check if fib limits are broken ]–––
            getP_854 = nFibL.wave1_0_854.get_y1()
            for i = 0 to bar_index - nFibL.wave1_0_854.get_x1() by 1
                if getEW.dir == -1
                    if high[i] > getP_854
                        nFibL._break_ := true
                        break
                else
                    if low[i] < getP_854
                        nFibL._break_ := true
                        break
            //––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            switch nFibL._break_
                true => nFibL.sol_dot('dot', color.new(color.red, 95))
                false => nFibL.sol_dot('sol', color.new(color.lime, 95))
                => 
            	    nFibL.wave1_0_500.set_xy1(na, na)
            	    nFibL.wave1_0_500.set_xy2(na, na)
            	    nFibL.wave1_0_618.set_xy1(na, na)
            	    nFibL.wave1_0_618.set_xy2(na, na)
            	    nFibL.wave1_0_764.set_xy1(na, na)
            	    nFibL.wave1_0_764.set_xy2(na, na)
            	    nFibL.wave1_0_854.set_xy1(na, na)
            	    nFibL.wave1_0_854.set_xy2(na, na)
            	    nFibL.wave1_pole_.set_xy1(na, na)
            	    nFibL.wave1_pole_.set_xy2(na, na)
            	    nFibL.l_fill_.set_color(color(na))

        if aEW.size() > 15
            pop = aEW.pop()
            pop.l1.delete()
            pop.b1.delete()
            pop.l2.delete()
            pop.b2.delete()
            pop.l3.delete()
            pop.b3.delete()
            pop.l4.delete()
            pop.b4.delete()
            pop.l5.delete()
            pop.b5.delete()
            pop.lA.delete()
            pop.bA.delete()
            pop.lB.delete()
            pop.bB.delete()
            pop.lC.delete()
            pop.bC.delete()
            pop.lb.delete()
            pop.bx.delete()
            //----------------------------------

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
draw(s1, len1, col1, 0)
draw(s2, len2, col2, 1)
draw(s3, len3, col3, 2)

//-----------------------------------------------------------------------------}



// ############## Adaptive Trend Finder (log) ###################

confidence(pearsonR) =>
    switch 
        pearsonR < 0.2 => 'Extremely Weak'
        pearsonR < 0.3 => 'Very Weak'
        pearsonR < 0.4 => 'Weak'
        pearsonR < 0.5 => 'Mostly Weak'
        pearsonR < 0.6 => 'Somewhat Weak'
        pearsonR < 0.7 => 'Moderately Weak'
        pearsonR < 0.8 => 'Moderate'
        pearsonR < 0.9 => 'Moderately Strong'
        pearsonR < 0.92 => 'Mostly Strong'
        pearsonR < 0.94 => 'Strong'
        pearsonR < 0.96 => 'Very Strong'
        pearsonR < 0.98 => 'Exceptionally Strong'
        => 'Ultra Strong'

getTablePosition(string pos) =>
    switch pos
        'Bottom Right' => position.bottom_right
        'Bottom Center' => position.bottom_center
        'Bottom Left' => position.bottom_left
        'Top Right' => position.top_right
        'Top Left' => position.top_left
        'Top Center' => position.top_center
        'Middle Right' => position.middle_right
        => position.middle_left // "Middle Left" - default

// Calculate deviations for given length
calcDev(float source, int length) =>
    float logSource = math.log(source)
    var int period_1 = length - 1
    if barstate.islast
        float sumX = 0.0
        float sumXX = 0.0
        float sumYX = 0.0
        float sumY = 0.0
        for int i = 1 to length by 1
            float lSrc = logSource[i - 1]
            sumX := sumX + i
            sumXX := sumXX + i * i
            sumYX := sumYX + i * lSrc
            sumY := sumY + lSrc
            sumY
        float slope = nz((length * sumYX - sumX * sumY) / (length * sumXX - sumX * sumX))
        float average = sumY / length
        float intercept = average - slope * sumX / length + slope
        float sumDev = 0.0
        float sumDxx = 0.0
        float sumDyy = 0.0
        float sumDyx = 0.0
        float regres = intercept + slope * period_1 * 0.5
        float sumSlp = intercept
        for int i = 0 to period_1 by 1
            float lSrc = logSource[i]
            float dxt = lSrc - average
            float dyt = sumSlp - regres
            lSrc := lSrc - sumSlp
            sumSlp := sumSlp + slope
            sumDxx := sumDxx + dxt * dxt
            sumDyy := sumDyy + dyt * dyt
            sumDyx := sumDyx + dxt * dyt
            sumDev := sumDev + lSrc * lSrc
            sumDev
        float unStdDev = math.sqrt(sumDev / period_1) // unbiased
        float divisor = sumDxx * sumDyy
        float pearsonR = nz(sumDyx / math.sqrt(divisor))
        [unStdDev, pearsonR, slope, intercept]
    else
        [na, na, na, na]

string t1 = 'In Long-Term Channel mode, if the channel is not visible, scroll back on the chart for additional historical data. To view both Short-Term and Long-Term channels simultaneously, load this indicator twice on your chart.'
string t2 = 'Displays the length of the period automatically selected by the indicator that shows the strongest trend. This period is determined by identifying the highest correlation between price movements and trend direction.'
string t3 = 'Pearson\'s R is a statistical measure that evaluates the linear relationship between price movements and trend projection. A value closer to 1 indicates a strong positive correlation, increasing confidence in the trend direction based on historical data.'
string t4 = 'Displays the annualized return (CAGR) of the trend over the auto-selected period. This feature is available only for daily (D) and weekly (W) timeframes, providing insight into the expected yearly growth rate if the trend continues.'

sourceInput = input.source(close, title = 'Source')

string group0 = 'CHANNEL SETTINGS (Adaptive Trend Finder)'
bool periodMode = input.bool(false, 'Use Long-Term Channel', group = group0, tooltip = t1)
float devMultiplier = input.float(2.0, 'Deviation Multiplier:', group = group0, step = 0.1)
color colorInput = input.color(color.gray, '', group = group0, inline = group0)
string lineStyle1 = input.string('Solid', '', group = group0, inline = group0, options = ['Solid', 'Dotted', 'Dashed'])
string extendStyle = input.string('Extend Right', '', group = group0, inline = group0, options = ['Extend Right', 'Extend Both', 'Extend None', 'Extend Left'])
int fillTransparency = input.int(93, 'Fill Transp:', group = group0, inline = 'mid', minval = 0, maxval = 100, step = 1)
int channelTransparency = input.int(40, 'Line Transp:', group = group0, inline = 'mid', minval = 0, maxval = 100, step = 1)

string group1 = 'MIDLINE SETTINGS'
color colorInputMidline = input.color(color.blue, '', group = group1, inline = group1)
int transpInput = input.int(100, 'Transp:', group = group1, inline = group1, minval = 0, maxval = 100, step = 10)
int lineWidth = input.int(1, 'Line Width:', group = group1, inline = group1)
string midLineStyle = input.string('Dashed', '', group = group1, inline = group1, options = ['Dotted', 'Solid', 'Dashed'])

string group2 = 'TABLE SETTINGS'
bool showAutoSelectedPeriod = input(true, 'Show Auto-Selected Period', group = group2, tooltip = t2)
bool showTrendStrength = input(true, 'Show Trend Strength', group = group2, inline = 'secondLine')
bool showPearsonInput = input.bool(false, 'Show Pearson\'s R', group = group2, inline = 'secondLine', tooltip = t3)
bool showTrendAnnualizedReturn = input(true, 'Show Trend Annualized Return', group = group2, tooltip = t4)
string tablePositionInput = input.string('Bottom Right', 'Table Position', options = ['Bottom Right', 'Bottom Left', 'Middle Right', 'Middle Left', 'Top Right', 'Top Left', 'Top Center', 'Bottom Center'], group = group2, inline = 'fourthLine')
string textSizeInput = input.string('Normal', 'Text Size', options = ['Normal', 'Large', 'Small'], group = group2, inline = 'fourthLine')

// Helper function to get the multiplier based on timeframe
get_tf_multiplier() =>
    var float multiplier = 1.0
    if syminfo.type == 'crypto'
        if timeframe.isdaily
            multiplier := 365 // ~365 trading days per year
            multiplier
        else if timeframe.isweekly
            multiplier := 52 // 52 weeks per year
            multiplier
        multiplier
    else // Default for stocks and other asset types
        if timeframe.isdaily
            multiplier := 252 // ~252 trading days per year
            multiplier
        else if timeframe.isweekly
            multiplier := 52 // 52 weeks per year
            multiplier
        multiplier

// Helper function to check if the timeframe is daily or weekly
is_valid_timeframe() =>
    timeframe.isdaily or timeframe.isweekly

var string EXTEND_STYLE = switch extendStyle
    'Extend Right' => extend.right
    'Extend Both' => extend.both
    'Extend None' => extend.none
    => extend.left

// Length Inputs
var array<int> Periods = periodMode ? array.from(na, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000, 1050, 1100, 1150, 1200) : array.from(na, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200)

// Calculate deviations, correlation, slope, and intercepts for different lengths
[stdDev01, pearsonR01, slope01, intercept01] = calcDev(sourceInput, Periods.get(1))
[stdDev02, pearsonR02, slope02, intercept02] = calcDev(sourceInput, Periods.get(2))
[stdDev03, pearsonR03, slope03, intercept03] = calcDev(sourceInput, Periods.get(3))
[stdDev04, pearsonR04, slope04, intercept04] = calcDev(sourceInput, Periods.get(4))
[stdDev05, pearsonR05, slope05, intercept05] = calcDev(sourceInput, Periods.get(5))
[stdDev06, pearsonR06, slope06, intercept06] = calcDev(sourceInput, Periods.get(6))
[stdDev07, pearsonR07, slope07, intercept07] = calcDev(sourceInput, Periods.get(7))
[stdDev08, pearsonR08, slope08, intercept08] = calcDev(sourceInput, Periods.get(8))
[stdDev09, pearsonR09, slope09, intercept09] = calcDev(sourceInput, Periods.get(9))
[stdDev10, pearsonR10, slope10, intercept10] = calcDev(sourceInput, Periods.get(10))
[stdDev11, pearsonR11, slope11, intercept11] = calcDev(sourceInput, Periods.get(11))
[stdDev12, pearsonR12, slope12, intercept12] = calcDev(sourceInput, Periods.get(12))
[stdDev13, pearsonR13, slope13, intercept13] = calcDev(sourceInput, Periods.get(13))
[stdDev14, pearsonR14, slope14, intercept14] = calcDev(sourceInput, Periods.get(14))
[stdDev15, pearsonR15, slope15, intercept15] = calcDev(sourceInput, Periods.get(15))
[stdDev16, pearsonR16, slope16, intercept16] = calcDev(sourceInput, Periods.get(16))
[stdDev17, pearsonR17, slope17, intercept17] = calcDev(sourceInput, Periods.get(17))
[stdDev18, pearsonR18, slope18, intercept18] = calcDev(sourceInput, Periods.get(18))
[stdDev19, pearsonR19, slope19, intercept19] = calcDev(sourceInput, Periods.get(19))

if barstate.islast
    // Find the highest Pearson's R
    float highestPearsonR = math.max(pearsonR01, pearsonR02, pearsonR03, pearsonR04, pearsonR05, pearsonR06, pearsonR07, pearsonR08, pearsonR09, pearsonR10, pearsonR11, pearsonR12, pearsonR13, pearsonR14, pearsonR15, pearsonR16, pearsonR17, pearsonR18, pearsonR19)

    // Determine selected length, slope, intercept, and deviations
    int detectedPeriod = na
    float detectedSlope = na
    float detectedIntrcpt = na
    float detectedStdDev = na
    switch highestPearsonR 
        pearsonR01 => 
    	    detectedPeriod := Periods.get(1)
    	    detectedSlope := slope01
    	    detectedIntrcpt := intercept01
    	    detectedStdDev := stdDev01
    	    detectedStdDev
        pearsonR02 => 
    	    detectedPeriod := Periods.get(2)
    	    detectedSlope := slope02
    	    detectedIntrcpt := intercept02
    	    detectedStdDev := stdDev02
    	    detectedStdDev
        pearsonR03 => 
    	    detectedPeriod := Periods.get(3)
    	    detectedSlope := slope03
    	    detectedIntrcpt := intercept03
    	    detectedStdDev := stdDev03
    	    detectedStdDev
        pearsonR04 => 
    	    detectedPeriod := Periods.get(4)
    	    detectedSlope := slope04
    	    detectedIntrcpt := intercept04
    	    detectedStdDev := stdDev04
    	    detectedStdDev
        pearsonR05 => 
    	    detectedPeriod := Periods.get(5)
    	    detectedSlope := slope05
    	    detectedIntrcpt := intercept05
    	    detectedStdDev := stdDev05
    	    detectedStdDev
        pearsonR06 => 
    	    detectedPeriod := Periods.get(6)
    	    detectedSlope := slope06
    	    detectedIntrcpt := intercept06
    	    detectedStdDev := stdDev06
    	    detectedStdDev
        pearsonR07 => 
    	    detectedPeriod := Periods.get(7)
    	    detectedSlope := slope07
    	    detectedIntrcpt := intercept07
    	    detectedStdDev := stdDev07
    	    detectedStdDev
        pearsonR08 => 
    	    detectedPeriod := Periods.get(8)
    	    detectedSlope := slope08
    	    detectedIntrcpt := intercept08
    	    detectedStdDev := stdDev08
    	    detectedStdDev
        pearsonR09 => 
    	    detectedPeriod := Periods.get(9)
    	    detectedSlope := slope09
    	    detectedIntrcpt := intercept09
    	    detectedStdDev := stdDev09
    	    detectedStdDev
        pearsonR10 => 
    	    detectedPeriod := Periods.get(10)
    	    detectedSlope := slope10
    	    detectedIntrcpt := intercept10
    	    detectedStdDev := stdDev10
    	    detectedStdDev
        pearsonR11 => 
    	    detectedPeriod := Periods.get(11)
    	    detectedSlope := slope11
    	    detectedIntrcpt := intercept11
    	    detectedStdDev := stdDev11
    	    detectedStdDev
        pearsonR12 => 
    	    detectedPeriod := Periods.get(12)
    	    detectedSlope := slope12
    	    detectedIntrcpt := intercept12
    	    detectedStdDev := stdDev12
    	    detectedStdDev
        pearsonR13 => 
    	    detectedPeriod := Periods.get(13)
    	    detectedSlope := slope13
    	    detectedIntrcpt := intercept13
    	    detectedStdDev := stdDev13
    	    detectedStdDev
        pearsonR14 => 
    	    detectedPeriod := Periods.get(14)
    	    detectedSlope := slope14
    	    detectedIntrcpt := intercept14
    	    detectedStdDev := stdDev14
    	    detectedStdDev
        pearsonR15 => 
    	    detectedPeriod := Periods.get(15)
    	    detectedSlope := slope15
    	    detectedIntrcpt := intercept15
    	    detectedStdDev := stdDev15
    	    detectedStdDev
        pearsonR16 => 
    	    detectedPeriod := Periods.get(16)
    	    detectedSlope := slope16
    	    detectedIntrcpt := intercept16
    	    detectedStdDev := stdDev16
    	    detectedStdDev
        pearsonR17 => 
    	    detectedPeriod := Periods.get(17)
    	    detectedSlope := slope17
    	    detectedIntrcpt := intercept17
    	    detectedStdDev := stdDev17
    	    detectedStdDev
        pearsonR18 => 
    	    detectedPeriod := Periods.get(18)
    	    detectedSlope := slope18
    	    detectedIntrcpt := intercept18
    	    detectedStdDev := stdDev18
    	    detectedStdDev
        =>  // pearsonR19
    	    detectedPeriod := Periods.get(19)
    	    detectedSlope := slope19
    	    detectedIntrcpt := intercept19
    	    detectedStdDev := stdDev19
    	    detectedStdDev

    var line upperLine = na
    var linefill upperFill = na
    var line baseLine = na
    var line lowerLine = na
    var linefill lowerFill = na

    // Calculate start and end price based on detected slope and intercept
    float startPrice = math.exp(detectedIntrcpt + detectedSlope * (detectedPeriod - 1))
    float endPrice = math.exp(detectedIntrcpt)

    int startAtBar = bar_index - detectedPeriod + 1
    var color ChannelColor = color.new(colorInput, channelTransparency)

    if na(baseLine)
        baseLine := line.new(startAtBar, startPrice, bar_index, endPrice, width = lineWidth, extend = EXTEND_STYLE, color = color.new(colorInputMidline, transpInput), style = midLineStyle == 'Dotted' ? line.style_dotted : midLineStyle == 'Dashed' ? line.style_dashed : line.style_solid, force_overlay = true)
        baseLine
    else
        line.set_xy1(baseLine, startAtBar, startPrice)
        line.set_xy2(baseLine, bar_index, endPrice)

    float upperStartPrice = startPrice * math.exp(devMultiplier * detectedStdDev)
    float upperEndPrice = endPrice * math.exp(devMultiplier * detectedStdDev)
    if na(upperLine)
        upperLine := line.new(startAtBar, upperStartPrice, bar_index, upperEndPrice, width = 1, extend = EXTEND_STYLE, color = ChannelColor, style = lineStyle1 == 'Dotted' ? line.style_dotted : lineStyle1 == 'Dashed' ? line.style_dashed : line.style_solid, force_overlay = true)
        upperLine
    else
        line.set_xy1(upperLine, startAtBar, upperStartPrice)
        line.set_xy2(upperLine, bar_index, upperEndPrice)
        line.set_color(upperLine, colorInput)

    float lowerStartPrice = startPrice / math.exp(devMultiplier * detectedStdDev)
    float lowerEndPrice = endPrice / math.exp(devMultiplier * detectedStdDev)
    if na(lowerLine)
        lowerLine := line.new(startAtBar, lowerStartPrice, bar_index, lowerEndPrice, width = 1, extend = EXTEND_STYLE, color = ChannelColor, style = lineStyle1 == 'Dotted' ? line.style_dotted : lineStyle1 == 'Dashed' ? line.style_dashed : line.style_solid, force_overlay = true)
        lowerLine
    else
        line.set_xy1(lowerLine, startAtBar, lowerStartPrice)
        line.set_xy2(lowerLine, bar_index, lowerEndPrice)
        line.set_color(lowerLine, colorInput)

    if na(upperFill)
        upperFill := linefill.new(upperLine, baseLine, color = color.new(colorInput, fillTransparency))
        upperFill
    if na(lowerFill)
        lowerFill := linefill.new(baseLine, lowerLine, color = color.new(colorInput, fillTransparency))
        lowerFill

    var table t = na
    if periodMode
        t := table.new(position.bottom_center, 2, 3, force_overlay = true)
        t
    else
        t := table.new(getTablePosition(tablePositionInput), 2, 3, force_overlay = true)
        t

    string text1 = periodMode ? 'Auto-Selected Period (Long Term): ' + str.tostring(detectedPeriod) : 'Auto-Selected Period: ' + str.tostring(detectedPeriod)
    var colorInputLight = color.new(colorInput, 0)

    // Display or hide the "Auto-Selected Period" cell
    if showAutoSelectedPeriod
        table.cell(t, 0, 0, text1, text_color = colorInputLight, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)

    // Display or hide the "Trend Strength" or "Pearson's R" cell
    if showTrendStrength
        if showPearsonInput
            table.cell(t, 0, 1, 'Pearson\'s R: ' + str.tostring(detectedSlope > 0.0 ? -highestPearsonR : highestPearsonR, '#.###'), text_color = colorInput, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)
        else
            table.cell(t, 0, 1, 'Trend Strength: ' + confidence(highestPearsonR), text_color = colorInput, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)

    // Calculate CAGR
    float cagr = na
    if not na(detectedPeriod) and bar_index >= detectedPeriod and is_valid_timeframe()
        float num_of_periods = detectedPeriod
        float multiplier = get_tf_multiplier()
        float startClosePrice = close[detectedPeriod - 1]
        cagr := math.pow(close / startClosePrice, multiplier / num_of_periods) - 1
        cagr

    // Display or hide the "Trend Annualized Return" cell
    if showTrendAnnualizedReturn and is_valid_timeframe()
        table.cell(t, 0, 2, 'Trend Annualized Return: ' + (not na(cagr) ? str.tostring(cagr * 100, '#.#') + '%' : 'N/A'), text_color = colorInput, text_size = textSizeInput == 'Large' ? size.large : textSizeInput == 'Small' ? size.small : size.normal)




// ################## Fibonacci Auto Trend Scouter ##################
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987

// INPUTS {{{
var max_array_size = 21 // [6, 3] matrix
// TREND {{{
src = input.source(hlc3, 'Source data:', group = 'Trend', inline = 'period')
trend_data = input.string('High/Low', 'Trend Coords:', options = ['Source', 'High/Low'], group = 'Trend', inline = 'period2')
medium_period = input.int(21, 'Length: ‍‍Long', group = 'Trend', inline = 'period1')
small_period = input.int(8, 'Short', group = 'Trend', inline = 'period1')
//
show_sm_coord_labels = input.bool(false, 'Short HH/LL Labels', group = 'Trend')
show_md_coord_labels = input.bool(false, 'Long HH/LL Labels', group = 'Trend')
//

// }}}
// Trend Short {{{
// Selection
trend_s1_top_from = input.string('Back', 'Top', options = ['Front', 'Mid', 'Back'], group = 'Short Trend', inline = 's1topsel')
trend_s1_top_to = input.string('Mid', '--->', options = ['Front', 'Mid', 'Back'], group = 'Short Trend', inline = 's1topsel')
trend_s1_bottom_from = input.string('Back', 'Bottom', options = ['Front', 'Mid', 'Back'], group = 'Short Trend', inline = 's1btmsel')
trend_s1_bottom_to = input.string('Mid', '--->', options = ['Front', 'Mid', 'Back'], group = 'Short Trend', inline = 's1btmsel')
//
trend_s1_line_styleI = input.string('Solid', 'Lines', options = ['Solid', 'Dashed', 'Dotted'], group = 'Short Trend', inline = 'ts1line')
trend_s1_line_width = input.int(4, '', minval = 1, group = 'Short Trend', inline = 'ts1line')
trend_s1_line_style = trend_s1_line_styleI == 'Solid' ? line.style_solid : trend_s1_line_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
trend_s1_line_extend = input.bool(true, 'Extend', group = 'Short Trend', inline = 'extend1')
trend_s1_xline_styleI = input.string('Dashed', '', options = ['Solid', 'Dashed', 'Dotted'], group = 'Short Trend', inline = 'extend1')
trend_s1_xline_width = input.int(1, '', minval = 1, group = 'Short Trend', inline = 'extend1')
trend_s1_xline_style = trend_s1_xline_styleI == 'Solid' ? line.style_solid : trend_s1_xline_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
show_sight_small = input.bool(false, 'Sight', group = 'Short Trend', inline = 'sight1')
sight_small_styleI = input.string('Solid', '', options = ['Solid', 'Dashed', 'Dotted'], group = 'Short Trend', inline = 'sight1')
sight_small_width = input.int(2, '', minval = 1, group = 'Short Trend', inline = 'sight1')
sight_small_style = sight_small_styleI == 'Solid' ? line.style_solid : sight_small_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
trend_s1_use_colors = input.bool(true, 'Colors: ', group = 'Short Trend', inline = 'TColor')
trend_s1_line_color_up = input.color(color.new(color.blue, 10), 'Up', group = 'Short Trend', inline = 'TColor')
trend_s1_line_color_dn = input.color(color.new(color.orange, 10), 'Down', group = 'Short Trend', inline = 'TColor')
trend_s1_color_default = input.color(color.white, 'Default', group = 'Short Trend', inline = 'TColor')
// }}}
// Trend Long {{{
trend_s2_top_from = input.string('Back', 'Top', options = ['Front', 'Mid', 'Back'], group = 'Long Trend', inline = 's2topsel')
trend_s2_top_to = input.string('Mid', '--->', options = ['Front', 'Mid', 'Back'], group = 'Long Trend', inline = 's2topsel')
trend_s2_bottom_from = input.string('Back', 'Bottom', options = ['Front', 'Mid', 'Back'], group = 'Long Trend', inline = 's2btmsel')
trend_s2_bottom_to = input.string('Mid', '--->', options = ['Front', 'Mid', 'Back'], group = 'Long Trend', inline = 's2btmsel')
//
trend_s2_line_styleI = input.string('Solid', 'Lines', options = ['Solid', 'Dashed', 'Dotted'], group = 'Long Trend', inline = 'ts2line')
trend_s2_line_width = input.int(4, '', minval = 1, group = 'Long Trend', inline = 'ts2line')
trend_s2_line_style = trend_s2_line_styleI == 'Solid' ? line.style_solid : trend_s2_line_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
trend_s2_line_extend = input.bool(true, 'Extend', group = 'Long Trend', inline = 'extend2')
trend_s2_xline_styleI = input.string('Dashed', '', options = ['Solid', 'Dashed', 'Dotted'], group = 'Long Trend', inline = 'extend2')
trend_s2_xline_width = input.int(1, '', minval = 1, group = 'Long Trend', inline = 'extend2')
trend_s2_xline_style = trend_s2_xline_styleI == 'Solid' ? line.style_solid : trend_s2_xline_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
show_sight_medium = input.bool(false, 'Sight', group = 'Long Trend', inline = 'sight2')
sight_medium_styleI = input.string('Solid', '', options = ['Solid', 'Dashed', 'Dotted'], group = 'Long Trend', inline = 'sight2')
sight_medium_width = input.int(2, '', minval = 1, group = 'Long Trend', inline = 'sight2')
sight_medium_style = sight_medium_styleI == 'Solid' ? line.style_solid : sight_medium_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
trend_s2_use_colors = input.bool(true, 'Colors: ', group = 'Long Trend', inline = 'T2Color')
trend_s2_line_color_up = input.color(color.new(color.green, 10), 'Up', group = 'Long Trend', inline = 'T2Color')
trend_s2_line_color_dn = input.color(color.new(color.red, 10), 'Down', group = 'Long Trend', inline = 'T2Color')
trend_s2_color_default = input.color(color.white, 'Default', group = 'Long Trend', inline = 'T2Color')
// }}}
// Trend Custom 3 {{{
trend_s3_show_top = input.bool(false, 'Top', group = 'Custom Trend', inline = 's3topsel1')
trend_s3_top_from_group = input.string('Long', '', options = ['Long', 'Short'], group = 'Custom Trend', inline = 's3topsel1')
trend_s3_top_from_pair = input.string('Mid', '', options = ['Front', 'Mid', 'Back'], group = 'Custom Trend', inline = 's3topsel1')
trend_s3_top_to_group = input.string('Short', '--->', options = ['Long', 'Short'], group = 'Custom Trend', inline = 's3topsel2')
trend_s3_top_to_pair = input.string('Mid', '', options = ['Front', 'Mid', 'Back'], group = 'Custom Trend', inline = 's3topsel2')

trend_s3_show_btm = input.bool(false, 'Bottom', group = 'Custom Trend', inline = 's3btmsel1')
trend_s3_bottom_from_group = input.string('Long', '', options = ['Long', 'Short'], group = 'Custom Trend', inline = 's3btmsel1')
trend_s3_bottom_from_pair = input.string('Mid', '', options = ['Front', 'Mid', 'Back'], group = 'Custom Trend', inline = 's3btmsel1')
trend_s3_bottom_to_group = input.string('Short', '--->', options = ['Long', 'Short'], group = 'Custom Trend', inline = 's3btmsel2')
trend_s3_bottom_to_pair = input.string('Mid', '', options = ['Front', 'Mid', 'Back'], group = 'Custom Trend', inline = 's3btmsel2')
//
trend_s3_line_styleI = input.string('Solid', 'Lines', options = ['Solid', 'Dashed', 'Dotted'], group = 'Custom Trend', inline = 'ts3line')
trend_s3_line_width = input.int(2, '', minval = 1, group = 'Custom Trend', inline = 'ts3line')
trend_s3_line_style = trend_s3_line_styleI == 'Solid' ? line.style_solid : trend_s3_line_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
trend_s3_line_extend = input.bool(false, 'Extend', group = 'Custom Trend', inline = 'extend2')
trend_s3_xline_styleI = input.string('Dashed', '', options = ['Solid', 'Dashed', 'Dotted'], group = 'Custom Trend', inline = 'extend2')
trend_s3_xline_width = input.int(1, '', minval = 1, group = 'Custom Trend', inline = 'extend2')
trend_s3_xline_style = trend_s3_xline_styleI == 'Solid' ? line.style_solid : trend_s3_xline_styleI == 'Dashed' ? line.style_dashed : line.style_dotted
//
trend_s3_use_colors = input.bool(false, 'Colors: ', group = 'Custom Trend', inline = 'T2Color')
trend_s3_line_color_up = input.color(color.new(#673ab7, 10), 'Up', group = 'Custom Trend', inline = 'T2Color')
trend_s3_line_color_dn = input.color(color.new(color.purple, 10), 'Down', group = 'Custom Trend', inline = 'T2Color')
trend_s3_color_default = input.color(color.white, 'Default', group = 'Custom Trend', inline = 'T2Color')
// }}}
// HTF S/L {{{
// 1
htf1_show = input.bool(true, 'Show Plot', group = 'Higher TF Level 1', inline = 'htf1_0')
htf1_label = input.bool(true, 'Show Label', group = 'Higher TF Level 1', inline = 'htf1_0')
htf1_source = input.source(close, '', group = 'Higher TF Level 1', inline = 'htf1_1')
htf1_timeframe = input.timeframe('360', '', group = 'Higher TF Level 1', inline = 'htf1_1')
htf1_length = input.int(13, 'Length', group = 'Higher TF Level 1', inline = 'htf1_3')
htf1_size = input.int(200, 'Size', minval = 1, group = 'Higher TF Level 1', inline = 'htf1_3')
htf1_styleI = input.string('Line', 'Style: ', options = ['Line', 'Cross', 'Circle'], group = 'Higher TF Level 1', inline = 'htf1_2')
htf1_style = htf1_styleI == 'Line' ? plot.style_line : htf1_styleI == 'Cross' ? plot.style_cross : plot.style_circles
htf1_width = input.int(4, '', minval = 0, group = 'Higher TF Level 1', inline = 'htf1_2')
htf1_color = input.color(color.new(color.yellow, 50), '', group = 'Higher TF Level 1', inline = 'htf1_2')
// 2
htf2_show = input.bool(true, 'Show Plot', group = 'Higher TF Level 2', inline = 'htf2_0')
htf2_label = input.bool(true, 'Show Label', group = 'Higher TF Level 2', inline = 'htf2_0')
htf2_source = input.source(close, '', group = 'Higher TF Level 2', inline = 'htf2_1')
htf2_timeframe = input.timeframe('720', '', group = 'Higher TF Level 2', inline = 'htf2_1')
htf2_length = input.int(13, 'Length', group = 'Higher TF Level 2', inline = 'htf2_3')
htf2_size = input.int(200, 'Size', minval = 1, group = 'Higher TF Level 2', inline = 'htf2_3')
htf2_styleI = input.string('Line', 'Style: ', options = ['Line', 'Cross', 'Circle'], group = 'Higher TF Level 2', inline = 'htf2_2')
htf2_style = htf2_styleI == 'Line' ? plot.style_line : htf2_styleI == 'Cross' ? plot.style_cross : plot.style_circles
htf2_width = input.int(4, '', minval = 0, group = 'Higher TF Level 2', inline = 'htf2_2')
htf2_color = input.color(color.new(color.aqua, 50), '', group = 'Higher TF Level 2', inline = 'htf2_2')
// 3
htf3_show = input.bool(true, 'Show Plot', group = 'Higher TF Level 3', inline = 'htf3_0')
htf3_label = input.bool(true, 'Show Label', group = 'Higher TF Level 3', inline = 'htf3_0')
htf3_source = input.source(close, '', group = 'Higher TF Level 3', inline = 'htf3_1')
htf3_timeframe = input.timeframe('1D', '', group = 'Higher TF Level 3', inline = 'htf3_1')
htf3_length = input.int(13, 'Length', group = 'Higher TF Level 3', inline = 'htf3_3')
htf3_size = input.int(200, 'Size', minval = 1, group = 'Higher TF Level 3', inline = 'htf3_3')
htf3_styleI = input.string('Line', 'Style: ', options = ['Line', 'Cross', 'Circle'], group = 'Higher TF Level 3', inline = 'htf3_2')
htf3_style = htf3_styleI == 'Line' ? plot.style_line : htf3_styleI == 'Cross' ? plot.style_cross : plot.style_circles
htf3_width = input.int(4, '', minval = 0, group = 'Higher TF Level 3', inline = 'htf3_2')
htf3_color = input.color(color.new(#b2b5be, 50), '', group = 'Higher TF Level 3', inline = 'htf3_2')
// }}}
// FIBONACCI {{{
show_fib_src_line = input.bool(false, 'Show source line           ​‌‍', group = 'Fibonacci', inline = 'fiblvlconf1')
show_fib_labelsgroup = input.bool(false, 'Show TF on labels', group = 'Fibonacci', inline = 'fiblvlconf1')
show_fib_src_label = input.bool(false, 'Show source labels         ', group = 'Fibonacci', inline = 'fiblvlconf2')
show_fib_farlabels = input.bool(false, 'Show far labels', group = 'Fibonacci', inline = 'fiblvlconf2')
show_fib_src_label_info = input.string('Order', 'Show Info', options = ['Ratio', 'Order', 'None'], group = 'Fibonacci', inline = 'fiblvlconf3')
fib_color_style = input.string('Multi', 'Coloring', options = ['Multi', 'Kind', 'Default'], group = 'Fibonacci', inline = 'fiblvlconf3')
fib_reverse = false // input(false, "Reverse Levels", group="Fibonacci")
//
// fib_use_colors = input(false, "Use Colors", group="Fibonacci")
fib_color_resistance = input.color(#e91e63, 'Resistance', group = 'Fibonacci', inline = 'fibrescol')
fib_color_support = input.color(#2196f3, '           ​‌‍Support', group = 'Fibonacci', inline = 'fibrescol')
//
fib_color_0 = input.color(#d1d4dc, 'Short 0 ', group = 'Fibonacci', inline = 'fibcol0')
sm_fib_color_0 = input.color(#d1d4dc, '      Long 0 ', group = 'Fibonacci', inline = 'fibcol0')
fib_color_236 = input.color(#81c784, 'Short .236', group = 'Fibonacci', inline = 'fibcol236')
sm_fib_color_236 = input.color(#81c784, '     Long .236', group = 'Fibonacci', inline = 'fibcol236')
fib_color_382 = input.color(#4caf50, 'Short .382', group = 'Fibonacci', inline = 'fibcol382')
sm_fib_color_382 = input.color(#4caf50, '     Long .382', group = 'Fibonacci', inline = 'fibcol382')
fib_color_50 = input.color(#f44336, 'Short .50', group = 'Fibonacci', inline = 'fibcol50')
sm_fib_color_50 = input.color(#f44336, '      Long .50', group = 'Fibonacci', inline = 'fibcol50')
fib_color_618 = input.color(#fbc02d, 'Short .618', group = 'Fibonacci', inline = 'fibcol618')
sm_fib_color_618 = input.color(#fbc02d, '     Long .618', group = 'Fibonacci', inline = 'fibcol618')
fib_color_786 = input.color(#64b5f6, 'Short .786', group = 'Fibonacci', inline = 'fibcol786')
sm_fib_color_786 = input.color(#64b5f6, '     Long .786', group = 'Fibonacci', inline = 'fibcol786')
fib_color_1 = input.color(#d1d4dc, 'Short 1 ', group = 'Fibonacci', inline = 'fibcol1')
sm_fib_color_1 = input.color(#d1d4dc, '       Long 1 ', group = 'Fibonacci', inline = 'fibcol1')
//
fib_color_default_s = input.color(color.white, 'Default Short', group = 'Fibonacci', inline = 'fibdefcol')
fib_color_default = input.color(color.silver, '     Default Long', group = 'Fibonacci', inline = 'fibdefcol')
//
// -- FIB LONG
show_fib_next_far_long = input.int(1, 'Long TF far levels shown', minval = 0, maxval = 6, group = 'Fib Long TF')
fib_lvl_line_style_activeI = input.string('Solid', 'Active Line', options = ['Solid', 'Dashed', 'Dotted'], group = 'Fib Long TF', inline = 'fibactive')
fib_lvl_line_width = input.int(2, '', minval = 1, group = 'Fib Long TF', inline = 'fibactive')
fib_lvl_line_style_active = fib_lvl_line_style_activeI == 'Solid' ? line.style_solid : fib_lvl_line_style_activeI == 'Dashed' ? line.style_dashed : line.style_dotted
fib_lvl_line_style_inactiveI = input.string('Dotted', 'Inactive Line', options = ['Solid', 'Dashed', 'Dotted'], group = 'Fib Long TF', inline = 'fibinactive')
fib_lvl_line_width_inactive = input.int(1, '', minval = 1, group = 'Fib Long TF', inline = 'fibinactive')
fib_lvl_line_style_inactive = fib_lvl_line_style_inactiveI == 'Solid' ? line.style_solid : fib_lvl_line_style_inactiveI == 'Dashed' ? line.style_dashed : line.style_dotted
fib_lvl_line_length_left = input.int(20, 'Size: Left', minval = 0, group = 'Fib Long TF', inline = 'fibsizerow1')
fib_lvl_line_length_right = input.int(10, 'Right', minval = 0, group = 'Fib Long TF', inline = 'fibsizerow1')
//
// -- FIB SMALL
show_fib_next_far_short = input.int(1, 'Short TF far levels shown', minval = 0, maxval = 6, group = 'Fib Short TF')
fib_lvl_line_style_activeI_sm = input.string('Solid', 'Active Line', options = ['Solid', 'Dashed', 'Dotted'], group = 'Fib Short TF', inline = 'fibactive')
fib_lvl_line_width_sm = input.int(2, '', minval = 1, group = 'Fib Short TF', inline = 'fibactive')
fib_lvl_line_style_active_sm = fib_lvl_line_style_activeI_sm == 'Solid' ? line.style_solid : fib_lvl_line_style_activeI_sm == 'Dashed' ? line.style_dashed : line.style_dotted
fib_lvl_line_style_inactiveI_sm = input.string('Dotted', 'Inactive Line', options = ['Solid', 'Dashed', 'Dotted'], group = 'Fib Short TF', inline = 'fibinactive')
fib_lvl_line_width_inactive_sm = input.int(1, '', minval = 1, group = 'Fib Short TF', inline = 'fibinactive')
fib_lvl_line_style_inactive_sm = fib_lvl_line_style_inactiveI_sm == 'Solid' ? line.style_solid : fib_lvl_line_style_inactiveI_sm == 'Dashed' ? line.style_dashed : line.style_dotted
fib_lvl_line_length_left_s = input.int(10, 'Size: Left', minval = 0, group = 'Fib Short TF', inline = 'fibsizerow2')
fib_lvl_line_length_right_s = input.int(20, 'Right', minval = 0, group = 'Fib Short TF', inline = 'fibsizerow2')
// }}}
// }}}

// FUNCTIONS {{{

candle_size_ms = time - time[1] // milliseconds of a candle

// -- COORDS {{{

timetostring(tms) => // {{{
    // / 100 = seconds
    // / seconds * 60 minutes
    d_ = math.floor(tms / 86400)
    h_ = math.floor((tms - d_ * 86400) / 3600)
    m_ = math.floor((tms - d_ * 86400 - h_ * 3600) / 60)
    s_ = math.floor(tms - d_ * 86400 - h_ * 3600 - m_ * 60)
    ret = d_ > 0 ? str.tostring(d_) + ' D ' : ''
    ret := ret + (h_ > 0 ? str.tostring(h_) + ' H ' : '')
    ret := ret + (m_ > 0 ? str.tostring(m_) + ' m ' : '')
    if d_ == 0
        ret := ret + (s_ > 0 ? str.tostring(s_) + ' s ' : '')
        ret
    ret
    // }}}


add_to_bag(bag_id, value, barTime, barPrice) => // {{{
    array.unshift(bag_id, barPrice)
    array.unshift(bag_id, barTime)
    array.unshift(bag_id, value)
    if array.size(bag_id) > max_array_size // {{{
        array.pop(bag_id)
        array.pop(bag_id)
        array.pop(bag_id)
        // }}}
        // }}}

update_bag(bag_id, value, barTime, barPrice, direction) => // {{{
    // if bag empty add first ball
    if array.size(bag_id) == 0 // {{{
        add_to_bag(bag_id, value, barTime, barPrice)
    // }}}
    else // {{{ if new is higher or lower than previous in current direction, swap ball 1
        if direction == 1 and value > array.get(bag_id, 0) or direction == -1 and value < array.get(bag_id, 0) // {{{
            array.set(bag_id, 0, value)
            array.set(bag_id, 1, barTime)
            array.set(bag_id, 2, barPrice)
        // }}}
        0
        // }}}
        // }}}

calcMidpoint(x1, y1, x2, y2) => // [ x, y ] {{{
    var int x = na
    var float y = na
    x := (x1 + x2) / 2
    y := (y1 + y2) / 2
    [x, y]
    // }}}

getDirection(v1, v2) => // ( 1, 0, -1 ) {{{
    v1 < v2 ? 1 : v1 > v2 ? -1 : 0
    // }}}

coordLabelInfo(x, y, v, prex, prey, id, lgroup, pos, type) => // text {{{
    // group,
    // id
    // --
    // x time format
    // x time to new coord
    x_timeFormat = str.tostring(x)
    x_barsAfterPrev = (x - prex) / candle_size_ms
    x_barsAfterPrevString = str.tostring(x_barsAfterPrev)
    x_barsAgoTimeFormat = timetostring((x - prex) / 1000)
    // --
    // price
    // price diff % with arrow up/down
    y_priceFormat = str.tostring(y, '#.##')
    y_priceDiff = str.tostring(math.abs(y - prey), '#.##')
    // % increase = Increase ÷ Original Number × 100.
    y_priceDiffPercent = str.tostring(math.abs((y - prey) / prey) * 100, '#.###') + ' %'
    y_diffSpeed = str.tostring(math.abs((y - prey) / x_barsAfterPrev), '#.##')
    y_diffSpeedPercent = str.tostring(math.abs((y - prey) / x_barsAfterPrev / prey * 100), '#.###') + ' %'
    diffSign = y > prey ? '+ ' : '- '
    // --
    // % move per candle ( speed )
    // "\n| (X)  Time: " + x_timeFormat +
    text_1 = ' ' + lgroup + ' ' + str.tostring(id) + ' | $' + y_priceFormat + '\n x: ' + str.tostring(x) + '\n y: ' + str.tostring(y) + '\n v: ' + str.tostring(v) + '\n----------------------' + '\n Time since last coord:' + '\n ' + x_barsAgoTimeFormat + '\n ' + x_barsAfterPrevString + ' bars' + '\n----------------------' + '\n Value diff to last coord:' + '\n ' + diffSign + y_priceDiff + '\n ' + diffSign + y_priceDiffPercent + '\n----------------------' + '\n Change per bar: ' + '\n ' + diffSign + y_diffSpeed + '\n ' + diffSign + y_diffSpeedPercent + '\n-------------------------'
    text_1
    // }}}

coordLabel(show, x, y, v, id, lgroup, pos, type, prex, prey) => // {{{

// pos ( top line / bottom line )
// type for color
// px, py for previous values

    _yloc = pos == 1 ? yloc.abovebar : yloc.belowbar
    _style = type == 1 ? label.style_label_down : label.style_label_up
    _dir = pos == 1 ? '\n▼' : '▲\n'
    _id = pos == 1 ? str.tostring(id) + _dir : _dir + str.tostring(id)
    txtinfo = coordLabelInfo(x, y, v, prex, prey, id, lgroup, pos, type)

    label.new(x = show ? x : na, y = show ? y : na, xloc = xloc.bar_time, yloc = _yloc, color = color.new(color.black, 100), textcolor = type > 1 ? type == 2 ? color.blue : color.yellow : color.white, style = _style, size = size.small, text = _id, tooltip = txtinfo, force_overlay = true)
    // }}}

// }}}

// -- FIBS {{{
// states: ----------------------------------
// 0 = resistance actively moving up
// 1 = resistance far / crossed
// 2 = resistance next
// 3 = support next
// 4 = support far
// 5 = support actively moving down
//-------------------------------------------
buildArray(v1, v2, v3, v4, v5, v6, v7) => // [array] {{{
    _arr = array.new_float(0)
    array.push(_arr, v1)
    array.push(_arr, v2)
    array.push(_arr, v3)
    array.push(_arr, v4)
    array.push(_arr, v5)
    array.push(_arr, v6)
    array.push(_arr, v7)
    _arr
    // }}}

fibLevel(H, L, F) => // {{{
    fib_reverse ? (H - L) * F + L : H - (H - L) * F
    // }}}

getFibRetracements(dir, L, H) => // [fib array] {{{
    // 1, 23.6%, 38.2%, 50%, 61.8%, and 78.6%, 0
    _fibs = array.new_float(0)
    array.push(_fibs, H)
    array.push(_fibs, fibLevel(H, L, 23.6 / 100))
    array.push(_fibs, fibLevel(H, L, 38.2 / 100))
    array.push(_fibs, fibLevel(H, L, 50.0 / 100))
    array.push(_fibs, fibLevel(H, L, 61.8 / 100))
    array.push(_fibs, fibLevel(H, L, 78.6 / 100))
    array.push(_fibs, L)
    _fibs
    // }}}

getFibState(dir, prevlvl, thislvl, nextlvl) => // {{{
    state = dir == 1 and prevlvl == -1 ? thislvl == high ? 0 : close > thislvl ? 3 : close < nextlvl ? 1 : 2 : dir == 1 and nextlvl == -1 ? close < thislvl ? 2 : close > nextlvl ? 4 : 3 : dir == 1 ? close >= thislvl and close <= prevlvl ? 3 : close >= thislvl and close >= prevlvl ? 4 : close <= thislvl and close >= nextlvl ? 2 : close <= thislvl and close <= nextlvl ? 1 : -1 : dir == -1 and nextlvl == -1 ? close > thislvl ? 3 : close < prevlvl ? 1 : 2 : dir == -1 and prevlvl == -1 ? thislvl == low ? 5 : close < thislvl ? 2 : close > nextlvl ? 4 : 3 : dir == -1 ? close >= thislvl and close <= nextlvl ? 3 : close >= thislvl and close >= nextlvl ? 4 : close <= thislvl and close >= prevlvl ? 2 : close <= thislvl and close <= prevlvl ? 1 : -1 : -1
    state
    // source up top
    // source up bottom
    // source up non-edge ( towards next )
    // next support    ( $ > T and $ < Prev ) 3
    // far support     ( $ > T and $ > Prev ) 4
    // next resistance ( $ < T and $ > Next ) 2
    // far resistance  ( $ < T and $ < Next ) 1
    // source down top
    // source down bottom
    // source down non-edge ( towards prev )
    // next support    ( $ > T and $ < Prev ) 3
    // far support     ( $ > T and $ > Prev ) 4
    // next resistance ( $ < T and $ > Next ) 2
    // far resistance  ( $ < T and $ < Next ) 1
    // }}}

drawFibLvLine(id, v, state, nxtup, nxtdn) => // {{{
    //
    // id, v, state + nxtup, nxtdn
    //
    // show_fib_next_far_long
    // show_fib_next_far_short
    //
    // pass in the id of the current next level up / next level down
    // so that if current id is within nextup + configNextLevels, we show it
    //
    isLG = id >= 1 and id <= 7
    isSM = id >= 8 and id <= 14
    // 
    nxtupMax = isLG ? nxtup + show_fib_next_far_long : nxtup + show_fib_next_far_short
    nxtdnMax = isLG ? nxtdn - show_fib_next_far_long : nxtdn - show_fib_next_far_short
    drawFar = id >= nxtup and id <= nxtupMax or id >= nxtdnMax and id <= nxtdn
    drawlvl = drawFar or state == 2 or state == 3 ? true : false
    //
    // drawlvl = show_fib_farlines or (state == 2 or state == 3) ? true : false
    tfrom = id >= 1 and id <= 7 ? time - candle_size_ms * fib_lvl_line_length_left : time - candle_size_ms * fib_lvl_line_length_left_s
    tto = id >= 1 and id <= 7 ? time + candle_size_ms * fib_lvl_line_length_right : time + candle_size_ms * fib_lvl_line_length_right_s
    state_width = isLG ? state == 2 or state == 3 ? fib_lvl_line_width : fib_lvl_line_width_inactive : state == 2 or state == 3 ? fib_lvl_line_width_sm : fib_lvl_line_width_inactive_sm
    state_style = isLG ? state == 2 or state == 3 or state == 0 ? fib_lvl_line_style_active : fib_lvl_line_style_inactive : state == 2 or state == 3 or state == 0 ? fib_lvl_line_style_active_sm : fib_lvl_line_style_inactive_sm
    state_color = fib_color_style == 'Multi' and id == 1 ? fib_color_0 : fib_color_style == 'Multi' and id == 2 ? fib_color_236 : fib_color_style == 'Multi' and id == 3 ? fib_color_382 : fib_color_style == 'Multi' and id == 4 ? fib_color_50 : fib_color_style == 'Multi' and id == 5 ? fib_color_618 : fib_color_style == 'Multi' and id == 6 ? fib_color_786 : fib_color_style == 'Multi' and id == 7 ? fib_color_1 : fib_color_style == 'Multi' and id == 8 ? sm_fib_color_0 : fib_color_style == 'Multi' and id == 9 ? sm_fib_color_236 : fib_color_style == 'Multi' and id == 10 ? sm_fib_color_382 : fib_color_style == 'Multi' and id == 11 ? sm_fib_color_50 : fib_color_style == 'Multi' and id == 12 ? sm_fib_color_618 : fib_color_style == 'Multi' and id == 13 ? sm_fib_color_786 : fib_color_style == 'Multi' and id == 14 ? sm_fib_color_1 : fib_color_style == 'Default' and id >= 1 and id <= 7 ? fib_color_default : fib_color_style == 'Default' and id >= 8 and id <= 14 ? fib_color_default_s : fib_color_style == 'Kind' and state == 0 ? fib_color_default : fib_color_style == 'Kind' and state == 1 ? fib_color_resistance : fib_color_style == 'Kind' and state == 2 ? fib_color_resistance : fib_color_style == 'Kind' and state == 3 ? fib_color_support : fib_color_style == 'Kind' and state == 4 ? fib_color_support : fib_color_style == 'Kind' and state == 5 ? fib_color_default : fib_color_default

    line.new(x1 = drawlvl ? tfrom : na, y1 = drawlvl ? v : na, x2 = drawlvl ? tto : na, y2 = drawlvl ? v : na, xloc = xloc.bar_time, style = state_style, color = state_color, width = state_width, extend = extend.none, force_overlay = true)
    // }}}

drawFibLvLabel(id, dir, pos, flvl, plvl, state, nxtup, nxtdn) => // {{{
    isLG = id >= 1 and id <= 7
    isSM = id >= 8 and id <= 14
    // 
    nxtupMax = isLG ? nxtup + show_fib_next_far_long : nxtup + show_fib_next_far_short
    nxtdnMax = isLG ? nxtdn - show_fib_next_far_long : nxtdn - show_fib_next_far_short
    drawFar = id >= nxtup and id <= nxtupMax or id >= nxtdnMax and id <= nxtdn
    drawlvl = show_fib_farlabels and drawFar or state == 2 or state == 3 ? true : false
    // drawlvl = show_fib_farlabels or (state == 2 or state == 3) ? true : false
    state_color = fib_color_style == 'Multi' and id == 1 ? fib_color_0 : fib_color_style == 'Multi' and id == 2 ? fib_color_236 : fib_color_style == 'Multi' and id == 3 ? fib_color_382 : fib_color_style == 'Multi' and id == 4 ? fib_color_50 : fib_color_style == 'Multi' and id == 5 ? fib_color_618 : fib_color_style == 'Multi' and id == 6 ? fib_color_786 : fib_color_style == 'Multi' and id == 7 ? fib_color_1 : fib_color_style == 'Multi' and id == 8 ? sm_fib_color_0 : fib_color_style == 'Multi' and id == 9 ? sm_fib_color_236 : fib_color_style == 'Multi' and id == 10 ? sm_fib_color_382 : fib_color_style == 'Multi' and id == 11 ? sm_fib_color_50 : fib_color_style == 'Multi' and id == 12 ? sm_fib_color_618 : fib_color_style == 'Multi' and id == 13 ? sm_fib_color_786 : fib_color_style == 'Multi' and id == 14 ? sm_fib_color_1 : fib_color_style == 'Default' and isLG ? fib_color_default : fib_color_style == 'Default' and isSM ? fib_color_default_s : fib_color_style == 'Kind' and state == 0 ? fib_color_default : fib_color_style == 'Kind' and state == 1 ? fib_color_resistance : fib_color_style == 'Kind' and state == 2 ? fib_color_resistance : fib_color_style == 'Kind' and state == 3 ? fib_color_support : fib_color_style == 'Kind' and state == 4 ? fib_color_support : fib_color_style == 'Kind' and state == 5 ? fib_color_default : fib_color_default
    txtdetails = show_fib_src_label_info == 'Ratio' ? flvl : show_fib_src_label_info == 'Order' ? isLG ? str.tostring(id) : str.tostring(id - 7) : ''
    // "⁌ • ⚊ ⚟ ⚬ ❮ ↤ ⥰ "
    group = isLG ? ' L' : ' S'
    tri = dir == -1 ? '▲ ' : '▼ '
    lblnext = tri + txtdetails + (show_fib_labelsgroup ? group : '')
    lblfar = tri + txtdetails + (show_fib_labelsgroup ? group : '')
    lbltxt = state == 3 or state == 2 ? lblnext : lblfar
    tx = id >= 1 and id <= 7 ? time - candle_size_ms * fib_lvl_line_length_left : time + candle_size_ms * fib_lvl_line_length_right_s
    tal = id >= 1 and id <= 7 ? text.align_right : text.align_left
    lblstyle = id >= 1 and id <= 7 ? label.style_label_right : label.style_label_left

    label.new(x = drawlvl ? tx : na, y = plvl, text = lbltxt, xloc = xloc.bar_time, yloc = yloc.price, color = color.new(color.white, 100), style = lblstyle, textcolor = state_color, size = size.normal, textalign = tal, tooltip = (isLG ? 'Long TF [ ' + str.tostring(id) + ' ]' : 'Short TF [ ' + str.tostring(id - 7) + ' ]') + '\nRatio: ' + flvl + '\nPrice: $' + str.tostring(int(plvl)), force_overlay = true)
    // }}}

drawFibSrcLine(dir, x1, y1, x2, y2) => // {{{
    _H = math.max(y1, y2) == y1 ? y1 : y2
    _L = math.min(y1, y2) == y1 ? y1 : y2
    xH = _H == y1 ? x1 : x2
    yH = _H == y1 ? y1 : y2
    xL = _L == y1 ? x1 : x2
    yL = _L == y1 ? y1 : y2
    //
    col = fib_color_style == 'Kind' ? dir == 1 ? fib_color_support : fib_color_resistance : fib_color_default
    // 
    line.new(dir == 1 ? xL : xH, dir == 1 ? yL : yH, dir == 1 ? xH : xL, dir == 1 ? yH : yL, extend = extend.none, xloc = xloc.bar_time, color = col, style = line.style_dotted, width = 3, force_overlay = true)
    // }}}

drawFibSrcLabel(tf, pos, x, y) => // {{{
    _txtcol = fib_color_style == 'Kind' ? pos == 'H' ? fib_color_resistance : fib_color_support : fib_color_default
    _text = pos == 'H' ? 'H\n▼' : '▲\nL'
    _yloc = pos == 'H' ? yloc.abovebar : yloc.belowbar
    _style = pos == 'H' ? label.style_label_down : label.style_label_up
    _ttH = tf + ' Fib High \n$( ' + str.tostring(y) + ' )'
    _ttL = tf + ' Fib Low \n$( ' + str.tostring(y) + ' )'
    _tooltip = pos == 'H' ? _ttH : _ttL
    _clear = color.new(color.black, 100)
    //
    label.new(x, y, xloc = xloc.bar_time, yloc = _yloc, color = _clear, textcolor = _txtcol, style = _style, size = size.small, text = _text, tooltip = _tooltip, force_overlay = true)
    // }}}

getFibNextId(nextdir, tfgroup, statesArr) => // id {{{
    // LG = 1 - 7  matching i + 1 on long
    // SM = 8 - 14 matching i + 8 on short
    // 2 = resistance next / 3 = support next
    match = nextdir == 'UP' ? array.indexof(statesArr, 2) : array.indexof(statesArr, 3)
    result = tfgroup == 'SM' ? match + 8 : match + 1
    result
    // }}}

// }}}

// -- HTF {{{

tftostring(tf) => /// {{{
    tfa = str.split(tf, '')
    tfalast = array.get(tfa, array.size(tfa) - 1)
    tfalastIsNum = na(str.tonumber(tfalast)) ? false : true
    txt = tfalastIsNum ? timetostring(str.tonumber(tf) * 60) : tf
    txt
    // }}}

htfLabel(htfy, tf, col) => // label {{{
    txt = tftostring(tf)
    htftxt = 'ᐊ ' + txt
    htftip = 'HTF  [ ' + txt + ' ] ' + str.tostring(htfy, '#.##')
    label.new(x = time + candle_size_ms * 2, y = htfy, xloc = xloc.bar_time, yloc = yloc.price, color = color.new(color.black, 100), textcolor = col, style = label.style_label_left, size = size.normal, text = htftxt, tooltip = htftip, force_overlay = true)
    // }}}

// }}}

// }}}

// ----------------------------------------------- COORDENATES {{{

// -----> FIND COORDS - MD {{{

// MD - Declarations {{{
md_coord_src = src
md_coord_period = medium_period
var float md_high_coord = na
var float md_low_coord = na
var bool md_is_new_md_high_coord = false
var bool md_is_new_md_low_coord = false
var md_coord_direction = 0
var md_bag = array.new_float(0)
var bool md_b1_changed = false
// var bool md_b2_changed = false
// var bool md_b3_changed = false
// var bool md_b4_changed = false
// var bool md_b5_changed = false
// var bool md_b6_changed = false
// var bool md_b7_changed = false
var bool md_bag_ready = false
var int md_now_x = na
var float md_now_y = na
var float md_b1_v = na
var int md_b1_x = na
var float md_b1_y = na
var float md_b2_v = na
var int md_b2_x = na
var float md_b2_y = na
var float md_b3_v = na
var int md_b3_x = na
var float md_b3_y = na
var float md_b4_v = na
var int md_b4_x = na
var float md_b4_y = na
var float md_b5_v = na
var int md_b5_x = na
var float md_b5_y = na
var float md_b6_v = na
var int md_b6_x = na
var float md_b6_y = na
var float md_b7_v = na
var int md_b7_x = na
var float md_b7_y = na
// }}}

// MD - Find new coord {{{
md_now_x := time
md_now_y := src
hicsrc = trend_data == 'Source' ? src : high
locsrc = trend_data == 'Source' ? src : low
md_high_coord := ta.highestbars(hicsrc, md_coord_period) == 0 ? hicsrc : na
md_low_coord := ta.lowestbars(locsrc, md_coord_period) == 0 ? locsrc : na

md_is_new_md_high_coord := not na(md_high_coord) and na(md_low_coord)
md_is_new_md_low_coord := not na(md_low_coord) and na(md_high_coord)
md_coord_direction := md_is_new_md_high_coord ? 1 : md_is_new_md_low_coord ? -1 : md_coord_direction
// }}}

// MD - Update Bag {{{
md_coord_direction_changed = ta.change(md_coord_direction)
if bool(md_coord_direction_changed)
    add_to_bag(md_bag, md_coord_direction == 1 ? md_high_coord : md_low_coord, time, src)
else
    update_bag(md_bag, md_coord_direction == 1 ? md_high_coord : md_low_coord, time, src, md_coord_direction)
    // }}}

// MD - Grab coords {{{
md_bag_ready := array.size(md_bag) > 18 ? true : false
md_b1_v := md_bag_ready ? array.get(md_bag, 0) : na
md_b1_x := md_bag_ready ? math.round(array.get(md_bag, 1)) : na
md_b1_y := md_bag_ready ? array.get(md_bag, 2) : na
md_b2_v := md_bag_ready ? array.get(md_bag, 3) : na
md_b2_x := md_bag_ready ? math.round(array.get(md_bag, 4)) : na
md_b2_y := md_bag_ready ? array.get(md_bag, 5) : na
md_b3_v := md_bag_ready ? array.get(md_bag, 6) : na
md_b3_x := md_bag_ready ? math.round(array.get(md_bag, 7)) : na
md_b3_y := md_bag_ready ? array.get(md_bag, 8) : na
md_b4_v := md_bag_ready ? array.get(md_bag, 9) : na
md_b4_x := md_bag_ready ? math.round(array.get(md_bag, 10)) : na
md_b4_y := md_bag_ready ? array.get(md_bag, 11) : na
md_b5_v := md_bag_ready ? array.get(md_bag, 12) : na
md_b5_x := md_bag_ready ? math.round(array.get(md_bag, 13)) : na
md_b5_y := md_bag_ready ? array.get(md_bag, 14) : na
md_b6_v := md_bag_ready ? array.get(md_bag, 15) : na
md_b6_x := md_bag_ready ? math.round(array.get(md_bag, 16)) : na
md_b6_y := md_bag_ready ? array.get(md_bag, 17) : na
md_b7_v := md_bag_ready ? array.get(md_bag, 18) : na
md_b7_x := md_bag_ready ? math.round(array.get(md_bag, 19)) : na
md_b7_y := md_bag_ready ? array.get(md_bag, 20) : na
// }}}

// MD - Watch changes {{{
md_b1_changed := bool(ta.change(md_b1_y)) or bool(ta.change(md_b1_x)) or bool(ta.change(md_b1_v)) ? true : false
// md_b2_changed := (change(md_b2_y) or change(md_b2_x) or change(md_b2_v)) ? true : false
// md_b3_changed := (change(md_b3_y) or change(md_b3_x) or change(md_b3_v)) ? true : false
// md_b4_changed := (change(md_b4_y) or change(md_b4_x) or change(md_b4_v)) ? true : false
// md_b5_changed := (change(md_b5_y) or change(md_b5_x) or change(md_b5_v)) ? true : false
// md_b6_changed := (change(md_b6_y) or change(md_b6_x) or change(md_b6_v)) ? true : false
// md_b7_changed := (change(md_b7_y) or change(md_b7_x) or change(md_b7_v)) ? true : false
// }}}

// }}}

// -----> FIND COORDS - SM {{{

// SM - Declarations {{{
sm_coord_src = src
sm_coord_period = small_period
var float sm_high_coord = na
var float sm_low_coord = na
var bool sm_is_new_sm_high_coord = false
var bool sm_is_new_sm_low_coord = false
var sm_coord_direction = 0
var sm_bag = array.new_float(0)
var bool sm_b1_changed = false
// var bool sm_b2_changed = false
// var bool sm_b3_changed = false
// var bool sm_b4_changed = false
// var bool sm_b5_changed = false
// var bool sm_b6_changed = false
// var bool sm_b7_changed = false
var bool sm_bag_ready = false
var float sm_b1_v = na
var int sm_b1_x = na
var float sm_b1_y = na
var float sm_b2_v = na
var int sm_b2_x = na
var float sm_b2_y = na
var float sm_b3_v = na
var int sm_b3_x = na
var float sm_b3_y = na
var float sm_b4_v = na
var int sm_b4_x = na
var float sm_b4_y = na
var float sm_b5_v = na
var int sm_b5_x = na
var float sm_b5_y = na
var float sm_b6_v = na
var int sm_b6_x = na
var float sm_b6_y = na
var float sm_b7_v = na
var int sm_b7_x = na
var float sm_b7_y = na
var float sm_now_v = na
var int sm_now_x = na
var float sm_now_y = na
// }}}

// SM - Find New coords {{{
// sm_now_v := sm_coord_src
sm_now_x := time
sm_now_y := close
// sm_high_coord := highestbars(sm_now_v, sm_coord_period) == 0 ? sm_now_v : na
// sm_low_coord := lowestbars(sm_now_v, sm_coord_period) == 0 ? sm_now_v : na
sm_high_coord := ta.highestbars(trend_data == 'Source' ? src : high, sm_coord_period) == 0 ? trend_data == 'Source' ? src : high : na
sm_low_coord := ta.lowestbars(trend_data == 'Source' ? src : low, sm_coord_period) == 0 ? trend_data == 'Source' ? src : low : na
sm_is_new_sm_high_coord := bool(sm_high_coord) and na(sm_low_coord)
sm_is_new_sm_low_coord := bool(sm_low_coord) and na(sm_high_coord)
sm_coord_direction := sm_is_new_sm_high_coord ? 1 : sm_is_new_sm_low_coord ? -1 : sm_coord_direction
// }}}

// SM - Update bag {{{
sm_coord_direction_changed = ta.change(sm_coord_direction)
if bool(sm_coord_direction_changed)
    add_to_bag(sm_bag, sm_coord_direction == 1 ? sm_high_coord : sm_low_coord, time, src)
else
    update_bag(sm_bag, sm_coord_direction == 1 ? sm_high_coord : sm_low_coord, time, src, sm_coord_direction)
    // }}}

// SM - Grab coords {{{
sm_bag_ready := array.size(sm_bag) > 18 ? true : false
sm_b1_v := sm_bag_ready ? array.get(sm_bag, 0) : na
sm_b1_x := sm_bag_ready ? math.round(array.get(sm_bag, 1)) : na
sm_b1_y := sm_bag_ready ? array.get(sm_bag, 2) : na
sm_b2_v := sm_bag_ready ? array.get(sm_bag, 3) : na
sm_b2_x := sm_bag_ready ? math.round(array.get(sm_bag, 4)) : na
sm_b2_y := sm_bag_ready ? array.get(sm_bag, 5) : na
sm_b3_v := sm_bag_ready ? array.get(sm_bag, 6) : na
sm_b3_x := sm_bag_ready ? math.round(array.get(sm_bag, 7)) : na
sm_b3_y := sm_bag_ready ? array.get(sm_bag, 8) : na
sm_b4_v := sm_bag_ready ? array.get(sm_bag, 9) : na
sm_b4_x := sm_bag_ready ? math.round(array.get(sm_bag, 10)) : na
sm_b4_y := sm_bag_ready ? array.get(sm_bag, 11) : na
sm_b5_v := sm_bag_ready ? array.get(sm_bag, 12) : na
sm_b5_x := sm_bag_ready ? math.round(array.get(sm_bag, 13)) : na
sm_b5_y := sm_bag_ready ? array.get(sm_bag, 14) : na
sm_b6_v := sm_bag_ready ? array.get(sm_bag, 15) : na
sm_b6_x := sm_bag_ready ? math.round(array.get(sm_bag, 16)) : na
sm_b6_y := sm_bag_ready ? array.get(sm_bag, 17) : na
sm_b7_v := sm_bag_ready ? array.get(sm_bag, 18) : na
sm_b7_x := sm_bag_ready ? math.round(array.get(sm_bag, 19)) : na
sm_b7_y := sm_bag_ready ? array.get(sm_bag, 20) : na
// }}}

// SM - Watch changes {{{
sm_b1_changed := bool(ta.change(sm_b1_y)) or bool(ta.change(sm_b1_x)) or bool(ta.change(sm_b1_v)) ? true : false
// sm_b2_changed := (change(sm_b2_y) or change(sm_b2_x) or change(sm_b2_v)) ? true : false
// sm_b3_changed := (change(sm_b3_y) or change(sm_b3_x) or change(sm_b3_v)) ? true : false
// sm_b4_changed := (change(sm_b4_y) or change(sm_b4_x) or change(sm_b4_v)) ? true : false
// sm_b5_changed := (change(sm_b5_y) or change(sm_b5_x) or change(sm_b5_v)) ? true : false
// sm_b6_changed := (change(sm_b6_y) or change(sm_b6_x) or change(sm_b6_v)) ? true : false
// sm_b7_changed := (change(sm_b7_y) or change(sm_b7_x) or change(sm_b7_v)) ? true : false

// }}}

// }}}

// =====> DRAW Coord Labels {{{

// Declare {{{
var int b_offset_main = 2
var int b_offset_front = 3
var label b1_label_sm = na
var label b2_label_sm = na
var label b3_label_sm = na
var label b4_label_sm = na
var label b5_label_sm = na
var label b6_label_sm = na
var label b7_label_sm = na
var label b1_label_md = na
var label b2_label_md = na
var label b3_label_md = na
var label b4_label_md = na
var label b5_label_md = na
var label b6_label_md = na
var label b7_label_md = na
// }}}
// Delete {{{
label.delete(b1_label_sm)
label.delete(b2_label_sm)
label.delete(b3_label_sm)
label.delete(b4_label_sm)
label.delete(b5_label_sm)
label.delete(b6_label_sm)
label.delete(b7_label_sm)
label.delete(b1_label_md)
label.delete(b2_label_md)
label.delete(b3_label_md)
label.delete(b4_label_md)
label.delete(b5_label_md)
label.delete(b6_label_md)
label.delete(b7_label_md)
// }}}
// Print {{{

// SM Labels
smb1p = sm_b1_y > sm_b2_y ? 1 : 2
smb2p = smb1p == 1 ? 2 : 1
smb3p = smb2p == 1 ? 2 : 1
smb4p = smb3p == 1 ? 2 : 1
smb5p = smb4p == 1 ? 2 : 1
smb6p = smb5p == 1 ? 2 : 1
smb7p = smb6p == 1 ? 2 : 1
b1_label_sm := coordLabel(show_sm_coord_labels, sm_b1_x, sm_b1_y, sm_b1_v, 1, 'Short', smb1p, 1, sm_b2_x, sm_b2_y)
b2_label_sm := coordLabel(show_sm_coord_labels, sm_b2_x, sm_b2_y, sm_b2_v, 2, 'Short', smb2p, 1, sm_b3_x, sm_b3_y)
b3_label_sm := coordLabel(show_sm_coord_labels, sm_b3_x, sm_b3_y, sm_b3_v, 3, 'Short', smb3p, 1, sm_b4_x, sm_b4_y)
b4_label_sm := coordLabel(show_sm_coord_labels, sm_b4_x, sm_b4_y, sm_b4_v, 4, 'Short', smb4p, 1, sm_b5_x, sm_b5_y)
b5_label_sm := coordLabel(show_sm_coord_labels, sm_b5_x, sm_b5_y, sm_b5_v, 5, 'Short', smb5p, 1, sm_b6_x, sm_b6_y)
b6_label_sm := coordLabel(show_sm_coord_labels, sm_b6_x, sm_b6_y, sm_b6_v, 6, 'Short', smb6p, 1, sm_b7_x, sm_b7_y)
b7_label_sm := coordLabel(show_sm_coord_labels, sm_b7_x, sm_b7_y, sm_b7_v, 7, 'Short', smb7p, 1, -1, -1)
// MD Labels
mdb1p = md_b1_y > md_b2_y ? 1 : 2
mdb2p = mdb1p == 1 ? 2 : 1
mdb3p = mdb2p == 1 ? 2 : 1
mdb4p = mdb3p == 1 ? 2 : 1
mdb5p = mdb4p == 1 ? 2 : 1
mdb6p = mdb5p == 1 ? 2 : 1
mdb7p = mdb6p == 1 ? 2 : 1
b1_label_md := coordLabel(show_md_coord_labels, md_b1_x, md_b1_y, md_b1_v, 1, 'Long', mdb1p, 3, md_b2_x, md_b2_y)
b2_label_md := coordLabel(show_md_coord_labels, md_b2_x, md_b2_y, md_b2_v, 2, 'Long', mdb2p, 3, md_b3_x, md_b3_y)
b3_label_md := coordLabel(show_md_coord_labels, md_b3_x, md_b3_y, md_b3_v, 3, 'Long', mdb3p, 3, md_b4_x, md_b4_y)
b4_label_md := coordLabel(show_md_coord_labels, md_b4_x, md_b4_y, md_b4_v, 4, 'Long', mdb4p, 3, md_b5_x, md_b5_y)
b5_label_md := coordLabel(show_md_coord_labels, md_b5_x, md_b5_y, md_b5_v, 5, 'Long', mdb5p, 3, md_b6_x, md_b6_y)
b6_label_md := coordLabel(show_md_coord_labels, md_b6_x, md_b6_y, md_b6_v, 6, 'Long', mdb6p, 3, md_b7_x, md_b7_y)
b7_label_md := coordLabel(show_md_coord_labels, md_b7_x, md_b7_y, md_b7_v, 7, 'Long', mdb7p, 3, -1, -1)

// }}}

// }}}

// =====> DRAW Trend Lines {{{

// Declare {{{
var line s1_second_line = na
var line s1_second_line2 = na
var line s1_first_line = na
var line s2_first_line = na
var line s1_first_line2 = na
var line s2_first_line2 = na
var line s2_second_line = na
var line s2_second_line2 = na
var line head_eyesight_line = na
var line head_eyesight_line2 = na
var line s3_second_line = na
var line s3_second_line2 = na
var line s3_first_line = na
var line s3_first_line2 = na

// }}}
// Delete {{{
line.delete(s1_first_line)
line.delete(s2_first_line)
line.delete(s1_second_line)
line.delete(s1_first_line2)
line.delete(s2_first_line2)
line.delete(s1_second_line2)
line.delete(s2_second_line)
line.delete(s2_second_line2)
line.delete(head_eyesight_line)
line.delete(head_eyesight_line2)
line.delete(s3_second_line)
line.delete(s3_second_line2)
line.delete(s3_first_line)
line.delete(s3_first_line2)
// }}}

getCoordSelection(trend, pos, sel) => // [x, y] {{{
    x1 = sel == 'Front' ? trend == 'SM' ? sm_b1_x : md_b1_x : sel == 'Mid' ? trend == 'SM' ? sm_b3_x : md_b3_x : trend == 'SM' ? sm_b5_x : md_b5_x // "Back"

    x2 = sel == 'Front' ? trend == 'SM' ? sm_b2_x : md_b2_x : sel == 'Mid' ? trend == 'SM' ? sm_b4_x : md_b4_x : trend == 'SM' ? sm_b6_x : md_b6_x // "Back"

    y1 = trend_data == 'Source' ? sel == 'Front' ? trend == 'SM' ? sm_b1_y : md_b1_y : sel == 'Mid' ? trend == 'SM' ? sm_b3_y : md_b3_y : trend == 'SM' ? sm_b5_y : md_b5_y : sel == 'Front' ? trend == 'SM' ? sm_b1_v : md_b1_v : sel == 'Mid' ? trend == 'SM' ? sm_b3_v : md_b3_v : trend == 'SM' ? sm_b5_v : md_b5_v

    y2 = trend_data == 'Source' ? sel == 'Front' ? trend == 'SM' ? sm_b2_y : md_b2_y : sel == 'Mid' ? trend == 'SM' ? sm_b4_y : md_b4_y : trend == 'SM' ? sm_b6_y : md_b6_y : sel == 'Front' ? trend == 'SM' ? sm_b2_v : md_b2_v : sel == 'Mid' ? trend == 'SM' ? sm_b4_v : md_b4_v : trend == 'SM' ? sm_b6_v : md_b6_v

    sely = pos == 'top' ? math.max(y1, y2) : math.min(y1, y2)
    selx = sely == y1 ? x1 : x2
    //
    [selx, sely]
    // }}}


// -----------------------------------------------------> SECTION 1 {{{

// get trend coords

// top
[s1T_fx, s1T_fy] = getCoordSelection('SM', 'top', trend_s1_top_from)
[s1T_tx, s1T_ty] = getCoordSelection('SM', 'top', trend_s1_top_to)

// bottom
[s1B_fx, s1B_fy] = getCoordSelection('SM', 'bottom', trend_s1_bottom_from)
[s1B_tx, s1B_ty] = getCoordSelection('SM', 'bottom', trend_s1_bottom_to)

// get middles
[s1Mid_fx, s1Mid_fy] = calcMidpoint(s1T_fx, s1T_fy, s1B_fx, s1B_fy)
[s1Mid_tx, s1Mid_ty] = calcMidpoint(s1T_tx, s1T_ty, s1B_tx, s1B_ty)

// triangle dir
sTriDir = s1Mid_ty > s1Mid_fy ? 1 : -1

// -- s1 line top {{{

s1_first_line := line.new(sm_bag_ready ? s1T_fx : na, sm_bag_ready ? s1T_fy : na, sm_bag_ready ? s1T_tx : na, sm_bag_ready ? s1T_ty : na, extend = extend.none, xloc = xloc.bar_time, color = trend_s1_use_colors == false ? trend_s1_color_default : sTriDir == 1 ? trend_s1_line_color_up : trend_s1_line_color_dn, style = trend_s1_line_style, width = trend_s1_line_width, force_overlay = true)
// (s1T_ty > s1T_fy) ? trend_s1_line_color_up : trend_s1_line_color_dn,

s1_first_line2 := trend_s1_line_extend ? line.new(sm_bag_ready ? s1T_fx : na, sm_bag_ready ? s1T_fy : na, sm_bag_ready ? s1T_tx : na, sm_bag_ready ? s1T_ty : na, extend = extend.right, xloc = xloc.bar_time, color = trend_s1_use_colors == false ? trend_s1_color_default : sTriDir == 1 ? trend_s1_line_color_up : trend_s1_line_color_dn, style = trend_s1_xline_style, width = trend_s1_xline_width, force_overlay = true) : na
//  }}}

// -- s1 line bottom {{{

s1_second_line := line.new(sm_bag_ready ? s1B_fx : na, sm_bag_ready ? s1B_fy : na, sm_bag_ready ? s1B_tx : na, sm_bag_ready ? s1B_ty : na, extend = extend.none, xloc = xloc.bar_time, color = trend_s1_use_colors == false ? trend_s1_color_default : sTriDir == 1 ? trend_s1_line_color_up : trend_s1_line_color_dn, style = trend_s1_line_style, width = trend_s1_line_width, force_overlay = true)

s1_second_line2 := trend_s1_line_extend ? line.new(md_bag_ready ? s1B_fx : na, md_bag_ready ? s1B_fy : na, sm_bag_ready ? s1B_tx : na, sm_bag_ready ? s1B_ty : na, extend = extend.right, xloc = xloc.bar_time, color = trend_s1_use_colors == false ? trend_s1_color_default : sTriDir == 1 ? trend_s1_line_color_up : trend_s1_line_color_dn, style = trend_s1_xline_style, width = trend_s1_xline_width, force_overlay = true) : na
// }}}

// EYE 1 {{{
[head_eye_x, head_eye_y] = calcMidpoint(sm_b3_x, sm_b3_y, sm_b4_x, sm_b4_y)
eye_direction = getDirection(head_eye_y, sm_now_y)

// s1B_ty / bottom to y
// sm_now_y / sight to
// if lower, red regardless, if higher then green
// sm_now_y < s1B_ty ? down
// ** need to get future cross y for this, next update

head_eyesight_line := line.new(show_sight_small ? head_eye_x : na, show_sight_small ? head_eye_y : na, sm_now_x, sm_now_y, xloc = xloc.bar_time, extend = extend.right, color = trend_s1_use_colors == false ? trend_s1_color_default : eye_direction == 1 ? trend_s1_line_color_up : trend_s1_line_color_dn, style = sight_small_style, width = sight_small_width, force_overlay = true)
// }}}

// }}}

// -----------------------------------------------------> SECTION 2 {{{

// get trend coords

// top
[s2T_fx, s2T_fy] = getCoordSelection('MD', 'top', trend_s2_top_from)
[s2T_tx, s2T_ty] = getCoordSelection('MD', 'top', trend_s2_top_to)

// bottom
[s2B_fx, s2B_fy] = getCoordSelection('MD', 'bottom', trend_s2_bottom_from)
[s2B_tx, s2B_ty] = getCoordSelection('MD', 'bottom', trend_s2_bottom_to)

// get middles
[s2Mid_fx, s2Mid_fy] = calcMidpoint(s2T_fx, s2T_fy, s2B_fx, s2B_fy)
[s2Mid_tx, s2Mid_ty] = calcMidpoint(s2T_tx, s2T_ty, s2B_tx, s2B_ty)

// triangle dir
mTriDir = s2Mid_ty > s2Mid_fy ? 1 : -1

// -- s2 line 1 {{{

s2_first_line := line.new(md_bag_ready ? s2T_fx : na, md_bag_ready ? s2T_fy : na, md_bag_ready ? s2T_tx : na, md_bag_ready ? s2T_ty : na, extend = extend.none, xloc = xloc.bar_time, color = trend_s2_use_colors == false ? trend_s2_color_default : mTriDir == 1 ? trend_s2_line_color_up : trend_s2_line_color_dn, style = trend_s2_line_style, width = trend_s2_line_width, force_overlay = true)

// line extension
s2_first_line2 := trend_s2_line_extend ? line.new(md_bag_ready ? s2T_fx : na, md_bag_ready ? s2T_fy : na, md_bag_ready ? s2T_tx : na, md_bag_ready ? s2T_ty : na, extend = extend.right, xloc = xloc.bar_time, color = trend_s2_use_colors == false ? trend_s2_color_default : mTriDir == 1 ? trend_s2_line_color_up : trend_s2_line_color_dn, style = trend_s2_xline_style, width = trend_s2_xline_width, force_overlay = true) : na
//  }}}

// -- s2 line 2 {{{

s2_second_line := line.new(md_bag_ready ? s2B_fx : na, md_bag_ready ? s2B_fy : na, md_bag_ready ? s2B_tx : na, md_bag_ready ? s2B_ty : na, extend = extend.none, xloc = xloc.bar_time, color = trend_s2_use_colors == false ? trend_s2_color_default : mTriDir == 1 ? trend_s2_line_color_up : trend_s2_line_color_dn, style = trend_s2_line_style, width = trend_s2_line_width, force_overlay = true)

// extension
s2_second_line2 := trend_s2_line_extend ? line.new(md_bag_ready ? s2B_fx : na, md_bag_ready ? s2B_fy : na, md_bag_ready ? s2B_tx : na, md_bag_ready ? s2B_ty : na, extend = extend.right, xloc = xloc.bar_time, color = trend_s2_use_colors == false ? trend_s2_color_default : mTriDir == 1 ? trend_s2_line_color_up : trend_s2_line_color_dn, style = trend_s2_xline_style, width = trend_s2_xline_width, force_overlay = true) : na
// }}}

// EYE 2 {{{
[head_eye_x2, head_eye_y2] = calcMidpoint(md_b6_x, md_b6_y, md_b5_x, md_b5_y)
eye_direction2 = getDirection(head_eye_y2, sm_now_y)

head_eyesight_line2 := line.new(show_sight_medium ? head_eye_x2 : na, show_sight_medium ? head_eye_y2 : na, sm_now_x, sm_now_y, xloc = xloc.bar_time, extend = extend.right, color = trend_s2_use_colors == false ? trend_s2_color_default : eye_direction2 == 1 ? trend_s2_line_color_up : trend_s2_line_color_dn, style = sight_medium_style, width = sight_medium_width, force_overlay = true)
// }}}

// }}}

// -----------------------------------------------------> SECTION 3 {{{

// -- s3 line 1 {{{

// top
topFrom = trend_s3_top_from_group == 'Long' ? 'MD' : 'SM'
topTo = trend_s3_top_to_group == 'Long' ? 'MD' : 'SM'
[s3T_fx, s3T_fy] = getCoordSelection(topFrom, 'top', trend_s3_top_from_pair)
[s3T_tx, s3T_ty] = getCoordSelection(topTo, 'top', trend_s3_top_to_pair)

s3_first_line := line.new(trend_s3_show_top and md_bag_ready ? s3T_fx : na, trend_s3_show_top and md_bag_ready ? s3T_fy : na, trend_s3_show_top and md_bag_ready ? s3T_tx : na, trend_s3_show_top and md_bag_ready ? s3T_ty : na, extend = extend.none, xloc = xloc.bar_time, color = trend_s3_use_colors == false ? trend_s3_color_default : s3T_ty > s3T_fy ? trend_s3_line_color_up : trend_s3_line_color_dn, style = trend_s3_line_style, width = trend_s3_line_width, force_overlay = true)

// line extension
s3_first_line2 := trend_s3_line_extend ? line.new(trend_s3_show_top and md_bag_ready ? s3T_fx : na, trend_s3_show_top and md_bag_ready ? s3T_fy : na, trend_s3_show_top and md_bag_ready ? s3T_tx : na, trend_s3_show_top and md_bag_ready ? s3T_ty : na, extend = extend.right, xloc = xloc.bar_time, color = trend_s3_use_colors == false ? trend_s3_color_default : s3T_ty > s3T_fy ? trend_s3_line_color_up : trend_s3_line_color_dn, style = trend_s3_xline_style, width = trend_s3_xline_width, force_overlay = true) : na
//  }}}

// -- s3 line 2 {{{

// bottom
bottomFrom = trend_s3_bottom_from_group == 'Long' ? 'MD' : 'SM'
bottomTo = trend_s3_bottom_to_group == 'Long' ? 'MD' : 'SM'
[s3B_fx, s3B_fy] = getCoordSelection(bottomFrom, 'bottom', trend_s3_bottom_from_pair)
[s3B_tx, s3B_ty] = getCoordSelection(bottomTo, 'bottom', trend_s3_bottom_to_pair)

s3_second_line := line.new(trend_s3_show_btm and md_bag_ready ? s3B_fx : na, trend_s3_show_btm and md_bag_ready ? s3B_fy : na, trend_s3_show_btm and md_bag_ready ? s3B_tx : na, trend_s3_show_btm and md_bag_ready ? s3B_ty : na, extend = extend.none, xloc = xloc.bar_time, color = trend_s3_use_colors == false ? trend_s3_color_default : s3B_ty > s3B_fy ? trend_s3_line_color_up : trend_s3_line_color_dn, style = trend_s3_line_style, width = trend_s3_line_width, force_overlay = true)

// extension
s3_second_line2 := trend_s3_line_extend ? line.new(trend_s3_show_btm and md_bag_ready ? s3B_fx : na, trend_s3_show_btm and md_bag_ready ? s3B_fy : na, trend_s3_show_btm and md_bag_ready ? s3B_tx : na, trend_s3_show_btm and md_bag_ready ? s3B_ty : na, extend = extend.right, xloc = xloc.bar_time, color = trend_s3_use_colors == false ? trend_s3_color_default : s3B_ty > s3B_fy ? trend_s3_line_color_up : trend_s3_line_color_dn, style = trend_s3_xline_style, width = trend_s3_xline_width, force_overlay = true) : na
// }}}

// }}}

// }}}

// }}}

// ----------------------------------------------- FIBONACCIS {{{

// MD

// -- GET FIB SOURCE - MD {{{
md_values = buildArray(md_b1_y, md_b2_y, md_b3_y, md_b4_y, md_b5_y, md_b6_y, md_b7_y)
// md max
md_max_y = array.max(md_values)
md_max_idx = array.indexof(md_values, md_max_y) + 1
md_max_x = md_max_idx == 1 ? md_b1_x : md_max_idx == 2 ? md_b2_x : md_max_idx == 3 ? md_b3_x : md_max_idx == 4 ? md_b4_x : md_max_idx == 5 ? md_b5_x : md_max_idx == 6 ? md_b6_x : md_max_idx == 7 ? md_b7_x : na
// md min
md_min_y = array.min(md_values)
md_min_idx = array.indexof(md_values, md_min_y) + 1
md_min_x = md_min_idx == 1 ? md_b1_x : md_min_idx == 2 ? md_b2_x : md_min_idx == 3 ? md_b3_x : md_min_idx == 4 ? md_b4_x : md_min_idx == 5 ? md_b5_x : md_min_idx == 6 ? md_b6_x : md_min_idx == 7 ? md_b7_x : na
// md fib config dir
md_fib_dir = md_min_x < md_max_x ? 1 : md_min_x > md_max_x ? -1 : 0
// }}}

// -- DRAW FIB SOURCE - MD {{{
var line mdfibconfig_line = na
line.delete(mdfibconfig_line)
mdfibconfig_line := show_fib_src_line ? drawFibSrcLine(md_fib_dir, md_min_x, md_min_y, md_max_x, md_max_y) : na

var label mdfibconfig_label_low = na
label.delete(mdfibconfig_label_low)
mdfibconfig_label_low := show_fib_src_label ? drawFibSrcLabel('MD', 'L', md_min_x, md_min_y) : na

var label mdfibconfig_label_high = na
label.delete(mdfibconfig_label_high)
mdfibconfig_label_high := show_fib_src_label ? drawFibSrcLabel('MD', 'H', md_max_x, md_max_y) : na
// }}}

// -- GET FIB LEVEL VALUES - MD {{{

var fibs_md_values = array.new_float(0)
if md_bag_ready and md_b1_changed // {{{
    array.clear(fibs_md_values)
    fibs_md_values := getFibRetracements(md_fib_dir, md_fib_dir == 1 ? md_min_y : md_max_y, md_fib_dir == 1 ? md_max_y : md_min_y)
    fibs_md_values
    // }}}

// }}}

// -- GET FIB LEVEL STATES - MD {{{

fib0_state = array.size(fibs_md_values) >= 1 ? getFibState(md_fib_dir, -1, array.get(fibs_md_values, 0), array.get(fibs_md_values, 1)) : 0

fib236_state = array.size(fibs_md_values) >= 2 ? getFibState(md_fib_dir, array.get(fibs_md_values, 0), array.get(fibs_md_values, 1), array.get(fibs_md_values, 2)) : 0

fib382_state = array.size(fibs_md_values) >= 3 ? getFibState(md_fib_dir, array.get(fibs_md_values, 1), array.get(fibs_md_values, 2), array.get(fibs_md_values, 3)) : 0

fib50_state = array.size(fibs_md_values) >= 4 ? getFibState(md_fib_dir, array.get(fibs_md_values, 2), array.get(fibs_md_values, 3), array.get(fibs_md_values, 4)) : 0

fib618_state = array.size(fibs_md_values) >= 5 ? getFibState(md_fib_dir, array.get(fibs_md_values, 3), array.get(fibs_md_values, 4), array.get(fibs_md_values, 5)) : 0

fib786_state = array.size(fibs_md_values) >= 6 ? getFibState(md_fib_dir, array.get(fibs_md_values, 4), array.get(fibs_md_values, 5), array.get(fibs_md_values, 6)) : 0

fib1_state = array.size(fibs_md_values) >= 7 ? getFibState(md_fib_dir, array.get(fibs_md_values, 5), array.get(fibs_md_values, 6), -1) : 0

// }}}

// SM

// -- GET FIB SOURCE - sm {{{
sm_values = buildArray(sm_b1_y, sm_b2_y, sm_b3_y, sm_b4_y, sm_b5_y, sm_b6_y, sm_b7_y)
// sm max
sm_max_y = array.max(sm_values)
sm_max_idx = array.indexof(sm_values, sm_max_y) + 1
sm_max_x = sm_max_idx == 1 ? sm_b1_x : sm_max_idx == 2 ? sm_b2_x : sm_max_idx == 3 ? sm_b3_x : sm_max_idx == 4 ? sm_b4_x : sm_max_idx == 5 ? sm_b5_x : sm_max_idx == 6 ? sm_b6_x : sm_max_idx == 7 ? sm_b7_x : na
// sm min
sm_min_y = array.min(sm_values)
sm_min_idx = array.indexof(sm_values, sm_min_y) + 1
sm_min_x = sm_min_idx == 1 ? sm_b1_x : sm_min_idx == 2 ? sm_b2_x : sm_min_idx == 3 ? sm_b3_x : sm_min_idx == 4 ? sm_b4_x : sm_min_idx == 5 ? sm_b5_x : sm_min_idx == 6 ? sm_b6_x : sm_min_idx == 7 ? sm_b7_x : na
// sm fib config dir
sm_fib_dir = sm_min_x < sm_max_x ? 1 : sm_min_x > sm_max_x ? -1 : 0
// }}}

// -- DRAW FIB SOURCE - sm {{{
var line smfibconfig_line = na
line.delete(smfibconfig_line)
smfibconfig_line := show_fib_src_line ? drawFibSrcLine(sm_fib_dir, sm_min_x, sm_min_y, sm_max_x, sm_max_y) : na

var label smfibconfig_label_low = na
label.delete(smfibconfig_label_low)
smfibconfig_label_low := show_fib_src_label ? drawFibSrcLabel('SM', 'L', sm_min_x, sm_min_y) : na

var label smfibconfig_label_high = na
label.delete(smfibconfig_label_high)
smfibconfig_label_high := show_fib_src_label ? drawFibSrcLabel('SM', 'H', sm_max_x, sm_max_y) : na
// }}}

// -- GET FIB LEVEL VALUES - sm {{{

var fibs_sm_values = array.new_float(0)
if sm_bag_ready and sm_b1_changed // {{{
    array.clear(fibs_sm_values)
    fibs_sm_values := getFibRetracements(sm_fib_dir, sm_fib_dir == 1 ? sm_min_y : sm_max_y, sm_fib_dir == 1 ? sm_max_y : sm_min_y)
    fibs_sm_values
    // }}}

// }}}

// -- GET FIB LEVEL STATES - sm {{{

sm_fib0_state = array.size(fibs_sm_values) >= 1 ? getFibState(sm_fib_dir, -1, array.get(fibs_sm_values, 0), array.get(fibs_sm_values, 1)) : 0

sm_fib236_state = array.size(fibs_sm_values) >= 2 ? getFibState(sm_fib_dir, array.get(fibs_sm_values, 0), array.get(fibs_sm_values, 1), array.get(fibs_sm_values, 2)) : 0

sm_fib382_state = array.size(fibs_sm_values) >= 3 ? getFibState(sm_fib_dir, array.get(fibs_sm_values, 1), array.get(fibs_sm_values, 2), array.get(fibs_sm_values, 3)) : 0

sm_fib50_state = array.size(fibs_sm_values) >= 4 ? getFibState(sm_fib_dir, array.get(fibs_sm_values, 2), array.get(fibs_sm_values, 3), array.get(fibs_sm_values, 4)) : 0

sm_fib618_state = array.size(fibs_sm_values) >= 5 ? getFibState(sm_fib_dir, array.get(fibs_sm_values, 3), array.get(fibs_sm_values, 4), array.get(fibs_sm_values, 5)) : 0

sm_fib786_state = array.size(fibs_sm_values) >= 6 ? getFibState(sm_fib_dir, array.get(fibs_sm_values, 4), array.get(fibs_sm_values, 5), array.get(fibs_sm_values, 6)) : 0

sm_fib1_state = array.size(fibs_sm_values) >= 7 ? getFibState(sm_fib_dir, array.get(fibs_sm_values, 5), array.get(fibs_sm_values, 6), -1) : 0

// }}}

//
// Get next states {{{
fibStatesLG = buildArray(fib0_state, fib236_state, fib382_state, fib50_state, fib618_state, fib786_state, fib1_state)

nextUpLG = getFibNextId('UP', 'LG', fibStatesLG)
nextDownLG = getFibNextId('DN', 'LG', fibStatesLG)

fibStatesSM = buildArray(sm_fib0_state, sm_fib236_state, sm_fib382_state, sm_fib50_state, sm_fib618_state, sm_fib786_state, sm_fib1_state)

nextUpSM = getFibNextId('UP', 'SM', fibStatesSM)
nextDownSM = getFibNextId('DN', 'SM', fibStatesSM)
// }}}
// 

// == DRAW FIB LEVEL LINES / LABELS - MD {{{

// declare {{{
var line fib0 = na
var line fib236 = na
var line fib382 = na
var line fib50 = na
var line fib618 = na
var line fib786 = na
var line fib1 = na
var label fib0_label = na
var label fib236_label = na
var label fib382_label = na
var label fib50_label = na
var label fib618_label = na
var label fib786_label = na
var label fib1_label = na
// }}}

// delete {{{
line.delete(fib0)
line.delete(fib236)
line.delete(fib382)
line.delete(fib50)
line.delete(fib618)
line.delete(fib786)
line.delete(fib1)
label.delete(fib0_label)
label.delete(fib236_label)
label.delete(fib382_label)
label.delete(fib50_label)
label.delete(fib618_label)
label.delete(fib786_label)
label.delete(fib1_label)
// }}}

// draw lines {{{
fib0 := array.size(fibs_md_values) >= 1 ? drawFibLvLine(1, array.get(fibs_md_values, 0), fib0_state, nextUpLG, nextDownLG) : na

fib236 := array.size(fibs_md_values) >= 2 ? drawFibLvLine(2, array.get(fibs_md_values, 1), fib236_state, nextUpLG, nextDownLG) : na

fib382 := array.size(fibs_md_values) >= 3 ? drawFibLvLine(3, array.get(fibs_md_values, 2), fib382_state, nextUpLG, nextDownLG) : na

fib50 := array.size(fibs_md_values) >= 4 ? drawFibLvLine(4, array.get(fibs_md_values, 3), fib50_state, nextUpLG, nextDownLG) : na

fib618 := array.size(fibs_md_values) >= 5 ? drawFibLvLine(5, array.get(fibs_md_values, 4), fib618_state, nextUpLG, nextDownLG) : na

fib786 := array.size(fibs_md_values) >= 6 ? drawFibLvLine(6, array.get(fibs_md_values, 5), fib786_state, nextUpLG, nextDownLG) : na

fib1 := array.size(fibs_md_values) >= 7 ? drawFibLvLine(7, array.get(fibs_md_values, 6), fib1_state, nextUpLG, nextDownLG) : na

// }}}

// draw labels {{{

fib0_label := array.size(fibs_md_values) >= 1 ? drawFibLvLabel(1, md_fib_dir, md_fib_dir == 1 ? 0 : 6, '0', array.get(fibs_md_values, 0), fib0_state, nextUpLG, nextDownLG) : na

fib236_label := array.size(fibs_md_values) >= 2 ? drawFibLvLabel(2, md_fib_dir, md_fib_dir == 1 ? 1 : 5, '.236', array.get(fibs_md_values, 1), fib236_state, nextUpLG, nextDownLG) : na

fib382_label := array.size(fibs_md_values) >= 3 ? drawFibLvLabel(3, md_fib_dir, md_fib_dir == 1 ? 2 : 4, '.382', array.get(fibs_md_values, 2), fib382_state, nextUpLG, nextDownLG) : na

fib50_label := array.size(fibs_md_values) >= 4 ? drawFibLvLabel(4, md_fib_dir, 3, '.5', array.get(fibs_md_values, 3), fib50_state, nextUpLG, nextDownLG) : na

fib618_label := array.size(fibs_md_values) >= 5 ? drawFibLvLabel(5, md_fib_dir, md_fib_dir == 1 ? 4 : 3, '.618', array.get(fibs_md_values, 4), fib618_state, nextUpLG, nextDownLG) : na

fib786_label := array.size(fibs_md_values) >= 6 ? drawFibLvLabel(6, md_fib_dir, md_fib_dir == 1 ? 5 : 2, '.768', array.get(fibs_md_values, 5), fib786_state, nextUpLG, nextDownLG) : na

fib1_label := array.size(fibs_md_values) >= 7 ? drawFibLvLabel(7, md_fib_dir, md_fib_dir == 1 ? 6 : 0, '1', array.get(fibs_md_values, 6), fib1_state, nextUpLG, nextDownLG) : na
// }}}

// }}}

// == DRAW FIB LEVEL LINES / LABELS - SM {{{

// declare {{{
var line sm_fib0 = na
var line sm_fib236 = na
var line sm_fib382 = na
var line sm_fib50 = na
var line sm_fib618 = na
var line sm_fib786 = na
var line sm_fib1 = na
var label sm_fib0_label = na
var label sm_fib236_label = na
var label sm_fib382_label = na
var label sm_fib50_label = na
var label sm_fib618_label = na
var label sm_fib786_label = na
var label sm_fib1_label = na
// }}}

// delete {{{
line.delete(sm_fib0)
line.delete(sm_fib236)
line.delete(sm_fib382)
line.delete(sm_fib50)
line.delete(sm_fib618)
line.delete(sm_fib786)
line.delete(sm_fib1)
label.delete(sm_fib0_label)
label.delete(sm_fib236_label)
label.delete(sm_fib382_label)
label.delete(sm_fib50_label)
label.delete(sm_fib618_label)
label.delete(sm_fib786_label)
label.delete(sm_fib1_label)
// }}}

// draw lines {{{
sm_fib0 := array.size(fibs_sm_values) >= 1 ? drawFibLvLine(8, array.get(fibs_sm_values, 0), sm_fib0_state, nextUpSM, nextDownSM) : na

sm_fib236 := array.size(fibs_sm_values) >= 2 ? drawFibLvLine(9, array.get(fibs_sm_values, 1), sm_fib236_state, nextUpSM, nextDownSM) : na

sm_fib382 := array.size(fibs_sm_values) >= 3 ? drawFibLvLine(10, array.get(fibs_sm_values, 2), sm_fib382_state, nextUpSM, nextDownSM) : na

sm_fib50 := array.size(fibs_sm_values) >= 4 ? drawFibLvLine(11, array.get(fibs_sm_values, 3), sm_fib50_state, nextUpSM, nextDownSM) : na

sm_fib618 := array.size(fibs_sm_values) >= 5 ? drawFibLvLine(12, array.get(fibs_sm_values, 4), sm_fib618_state, nextUpSM, nextDownSM) : na

sm_fib786 := array.size(fibs_sm_values) >= 6 ? drawFibLvLine(13, array.get(fibs_sm_values, 5), sm_fib786_state, nextUpSM, nextDownSM) : na

sm_fib1 := array.size(fibs_sm_values) >= 7 ? drawFibLvLine(14, array.get(fibs_sm_values, 6), sm_fib1_state, nextUpSM, nextDownSM) : na

// }}}

// draw labels {{{

sm_fib0_label := array.size(fibs_sm_values) >= 1 ? drawFibLvLabel(8, sm_fib_dir, sm_fib_dir == 1 ? 0 : 6, '0', array.get(fibs_sm_values, 0), sm_fib0_state, nextUpSM, nextDownSM) : na

sm_fib236_label := array.size(fibs_sm_values) >= 2 ? drawFibLvLabel(9, sm_fib_dir, sm_fib_dir == 1 ? 1 : 5, '.236', array.get(fibs_sm_values, 1), sm_fib236_state, nextUpSM, nextDownSM) : na

sm_fib382_label := array.size(fibs_sm_values) >= 3 ? drawFibLvLabel(10, sm_fib_dir, sm_fib_dir == 1 ? 2 : 4, '.382', array.get(fibs_sm_values, 2), sm_fib382_state, nextUpSM, nextDownSM) : na

sm_fib50_label := array.size(fibs_sm_values) >= 4 ? drawFibLvLabel(11, sm_fib_dir, 3, '.5', array.get(fibs_sm_values, 3), sm_fib50_state, nextUpSM, nextDownSM) : na

sm_fib618_label := array.size(fibs_sm_values) >= 5 ? drawFibLvLabel(12, sm_fib_dir, sm_fib_dir == 1 ? 4 : 3, '.618', array.get(fibs_sm_values, 4), sm_fib618_state, nextUpSM, nextDownSM) : na

sm_fib786_label := array.size(fibs_sm_values) >= 6 ? drawFibLvLabel(13, sm_fib_dir, sm_fib_dir == 1 ? 5 : 2, '.768', array.get(fibs_sm_values, 5), sm_fib786_state, nextUpSM, nextDownSM) : na

sm_fib1_label := array.size(fibs_sm_values) >= 7 ? drawFibLvLabel(14, sm_fib_dir, sm_fib_dir == 1 ? 6 : 0, '1', array.get(fibs_sm_values, 6), sm_fib1_state, nextUpSM, nextDownSM) : na
// }}}

// }}}

// }}}

// ----------------------------------------------- HTF Levels {{{

// HTF1 {{{
htf1 = request.security(syminfo.tickerid, htf1_timeframe, ta.ema(htf1_source, htf1_length), gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

plot(htf1_show ? htf1 : na, 'HTF 1', color = htf1_color, linewidth = math.max(1, htf1_width), style = htf1_style, show_last = htf1_size, force_overlay = true)

var label htf1lbl = na
label.delete(htf1lbl)
htf1lbl := htf1_label ? htfLabel(htf1, htf1_timeframe, htf1_color) : na
// }}}

// HTF2 {{{

htf2 = request.security(syminfo.tickerid, htf2_timeframe, ta.ema(htf2_source, htf2_length), gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

plot(htf2_show ? htf2 : na, 'HTF 1', color = htf2_color, linewidth = math.max(1, htf2_width), style = htf2_style, show_last = htf2_size, force_overlay = true)

var label htf2lbl = na
label.delete(htf2lbl)
htf2lbl := htf2_label ? htfLabel(htf2, htf2_timeframe, htf2_color) : na

// }}}

// HTF3 {{{
htf3 = request.security(syminfo.tickerid, htf3_timeframe, ta.ema(htf3_source, htf3_length), gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

plot(htf3_show ? htf3 : na, 'HTF 1', color = htf3_color, linewidth = math.max(1, htf3_width), style = htf3_style, show_last = htf3_size, force_overlay = true)

var label htf3lbl = na
label.delete(htf3lbl)
htf3lbl := htf3_label ? htfLabel(htf3, htf3_timeframe, htf3_color) : na

// }}}

// }}}




























// ############# WaveTrend Oscillator Plus #####################

// Tick Volume
tick = syminfo.mintick
rng = close - open
tickrng = tick
tickrng := math.abs(rng) < tick ? nz(tickrng[1]) : rng
tickvol = math.abs(tickrng) / tick
volumen = nz(volume) != 0 ? volume : tickvol

enhanced_vwma(_series, _length) =>
    vol = volumen
    vmp = _series * vol
    VWMA = math.sum(vmp, _length) / math.sum(vol, _length)
    VWMA

// ALMA - Arnaud Legoux Moving Average of @kurtsmock
enhanced_alma(_series, _length, _offset, _sigma) =>
    length = int(_length) // Floating point protection
    numerator = 0.0
    denominator = 0.0
    m = _offset * (length - 1)
    s = length / _sigma
    for i = 0 to length - 1 by 1
        weight = math.exp(-((i - m) * (i - m)) / (2 * s * s))
        numerator := numerator + weight * _series[length - 1 - i]
        denominator := denominator + weight
        denominator
    numerator / denominator

//T3 Moving Average based on the article 'Smoothing Techniques For More Accurate Signals' by Tim Tillson
f_t3(srcww, len) =>
    x1 = ta.ema(srcww, len) //(hlcc, 8)
    x2 = ta.ema(x1, len)
    x3 = ta.ema(x2, len)
    x4 = ta.ema(x3, len)
    x5 = ta.ema(x4, len)
    x6 = ta.ema(x5, len)
    b = 0.7 //Volume Factor
    c1 = -math.pow(b, 3)
    c2 = 3 * math.pow(b, 2) + 3 * math.pow(b, 3)
    c3 = -6 * math.pow(b, 2) - 3 * b - 3 * math.pow(b, 3)
    c4 = 1 + 3 * b + math.pow(b, 3) + 3 * math.pow(b, 2)
    c1 * x6 + c2 * x5 + c3 * x4 + c4 * x3

// Kaufman's Adaptive Moving Average - Fast and Slow Ends
kama(x, t) =>
    fastK = 0.666 // KAMA Fast End
    slowK = 0.0645 // KAMA Slow End
    dist = math.abs(x[0] - x[1])
    signal_x = math.abs(x - x[t])
    noise = math.sum(dist, t)
    effr = noise != 0 ? signal_x / noise : 1
    sc = math.pow(effr * (fastK - slowK) + slowK, 2)
    KAma = x
    KAma := nz(KAma[1]) + sc * (x - nz(KAma[1]))
    KAma

// Jurik Moving Average of @everget
jma(srcww, length, power, phase) =>
    phaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5
    beta = 0.45 * (length - 1) / (0.45 * (length - 1) + 2)
    alpha = math.pow(beta, power)
    Jma = 0.0
    e0 = 0.0
    e0 := (1 - alpha) * srcww + alpha * nz(e0[1])
    e1 = 0.0
    e1 := (srcww - e0) * (1 - beta) + beta * nz(e1[1])
    e2 = 0.0
    e2 := (e0 + phaseRatio * e1 - nz(Jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
    Jma := e2 + nz(Jma[1])
    Jma

// VAMA - Volume Adjusted Moving Average of @allanster
vama(_src, _len, _fct, _rul, _nvb) => // vama(source,length,factor,rule,sample)
    tvb = 0 // total volume bars used in sample            
    tvb := _nvb == 0 ? nz(tvb[1]) + 1 : _nvb
    tvs = _nvb == 0 ? ta.cum(volumen) : math.sum(volumen, _nvb) // total volume in sample
    v2i = volumen / (tvs / tvb * _fct) // ratio of volume to increments of volume                                                  
    wtd = _src * v2i // weighted prices 
    nmb = 1 // initialize number of bars summed back               
    wtdSumB = 0.0 // initialize weighted prices summed back
    v2iSumB = 0.0 // initialize ratio of volume to increments of volume summed back
    for i = 1 to _len * 10 by 1 // set artificial cap for strict to VAMA length * 10 to help reduce edge case timeout errors
        strict = _rul ? false : i == _len // strict rule N bars' v2i ratios >= vama length, else <= vama length
        wtdSumB := wtdSumB + nz(wtd[i - 1]) // increment number of bars' weighted prices summed back
        v2iSumB := v2iSumB + nz(v2i[i - 1]) // increment number of bars' v2i's summed back
        if v2iSumB >= _len or strict // if chosen rule met
            break // break (exit loop)
        nmb := nmb + 1 // increment number of bars summed back counter
        nmb
    nmb // number of bars summed back to fulfill volume requirements or vama length
    wtdSumB // number of bars' weighted prices summed back
    v2iSumB // number of bars' v2i's summed back
    vama = (wtdSumB - (v2iSumB - _len) * _src[nmb]) / _len // volume adjusted moving average
    vama

// https://www.tradingview.com/script/X67OSwqc-TASC-2024-04-The-Ultimate-Smoother/
// @function      The UltimateSmoother is a filter created
//                by subtracting the response of a high-pass 
//                filter from that of an all-pass filter.
// @param src     Source series.
// @param period  Critical period.
// @returns       Smoothed series.
UltimateSmoother(float srcww, int period) =>
    float a1 = math.exp(-1.414 * math.pi / period)
    float c2 = 2.0 * a1 * math.cos(1.414 * math.pi / period)
    float c3 = -a1 * a1
    float c1 = (1.0 + c2 - c3) / 4.0
    float us = srcww
    if bar_index >= 4
        us := (1.0 - c1) * srcww + (2.0 * c1 - c2) * srcww[1] - (c1 + c3) * srcww[2] + c2 * nz(us[1]) + c3 * nz(us[2])
        us
    us

ma(_type, _source, _length) =>
    switch _type
        'SMA' => ta.sma(_source, _length)
        'EMA' => ta.ema(_source, _length)
        'WMA' => ta.wma(_source, _length)
        'D_WMA' => ta.wma(ta.wma(_source, _length), _length) // Double Weighted Moving Average
        'D_EMA' => ta.ema(ta.ema(_source, _length), _length)
        'D_SMA' => ta.sma(ta.sma(_source, _length), _length)
        'VWMA' => enhanced_vwma(_source, _length)
        'D_VWMA' => enhanced_vwma(enhanced_vwma(_source, _length), _length)
        'ALMA' => enhanced_alma(_source, _length, 0.85, 6)
        'Wilder' => 
    	    wild = _source // Wilder's moving average
    	    wild := nz(wild[1]) + (_source - nz(wild[1])) / _length
    	    wild
        'T3' => f_t3(_source, _length)
        'HMA' => ta.hma(_source, _length)
        'VAMA' => vama(_source, _length, 0.67, true, 0)
        'KAMA' => kama(_source, _length)
        'JMA' => jma(_source, _length, 2, 50)
        'Ultimate Smoother' => UltimateSmoother(_source, _length)

type bar
	float o = open
	float h = high
	float l = low
	float c = close

type osc
	float o = na
	float s = na
	float h = na

type alerts
	bool s = false
	bool b = false
	bool u = false
	bool d = false
	bool x = false
	bool y = false

type prompt
	string s = ''
	bool c = false

method notify(prompt p) =>
    if p.c
        alert(p.s, alert.freq_once_per_bar_close)

method any(alerts a) =>
    string s = switch 
        a.s => 'OS Signal'
        a.b => 'OB Signal'
        a.u => 'Bullish Trend'
        a.d => 'Bearish Trend'
        a.x => 'Bullish Swing'
        a.y => 'Bearish Swing'

        => na

    prompt.new(s, not na(s))

method src(bar b, simple string srcww) =>
    float x = switch srcww
        'open' => b.o
        'high' => b.h
        'low' => b.l
        'close' => b.c
        'oc2' => math.avg(b.o, b.c)
        'hl2' => math.avg(b.h, b.l)
        'hlc3' => math.avg(b.h, b.l, b.c)
        'ohlc4' => math.avg(b.o, b.h, b.l, b.c)
        'hlcc4' => math.avg(b.h, b.l, b.c, b.c)
        'vwap(Close)' => ta.vwap(b.c)
        'vwap(Open)' => ta.vwap(b.o)
        'vwap(High)' => ta.vwap(b.h)
        'vwap(Low)' => ta.vwap(b.l)
    x

method stdev(float srcww, simple int len) =>
    float sq = 0.
    float psq = 0.
    float sum = 0.

    for k = 0 to len - 1 by 1
        val = nz(srcww[k])
        psq := sq
        sq := sq + (val - sq) / (1 + k)
        sum := sum + (val - sq) * (val - psq)
        sum

    math.sqrt(sum / (len - 1))

method wave(bar b, simple string srcww, simple int clen, simple int alen, simple int slen, string _type) =>
    float x = b.src(srcww)
    float m = ma(_type, x, clen) //ta.ema(x, clen)
    float d = x.stdev(clen)
    float o = ma(_type, (x - m) / d * 100, alen) //ta.ema((x - m) / d * 100, alen)
    float s = ta.sma(o, slen)

    osc.new(o, s, o - s)

f_getWT(fuente, clen, alen, slen) =>
    esa = ta.ema(fuente, clen)
    dev_st = stdev(fuente, clen)
    com = (fuente - esa) / dev_st * 100
    wt1 = ta.ema(com, alen)
    wt2 = ta.sma(wt1, slen)
    [wt1, wt2]

// Indicators activation section
show_WT = input.bool(true, '↪ Show WaveTrend ↩  ', inline = 'w0')
midL = input.bool(true, '▶ Show Midline', inline = 'w0')
show_black = input.bool(false, 'Use Black Background', inline = 'w0')
revb = input.bool(true, '', inline = 'reve')
revt = input.int(100, '》Reversion Threshold [75, 125]', 75, 125, inline = 'reve')
char_dn = input.string('💀', 'Overbought Symbol', inline = 'reve2')
char_up = input.string('🚀', 'Oversold Symbol', inline = 'reve2')
colb = input.string('Extremities', '》Background Color', ['None', 'Midline Cross', 'Extremities', 'Reversions', 'Slope'], inline = 'reve3')
show_cross = input.bool(false, 'Show the crossings', inline = 'reve3')
compare = input.bool(false, 'Compare with Symbol', inline = 'CPR')
symbol = input.symbol('CME_MINI:ES1!', '', inline = 'CPR')
extSrc = request.security(symbol, timeframe.period, hlc3, barmerge.gaps_off, barmerge.lookahead_on)

show_mom = input.bool(false, '↪ Show Momentum ↩ ', inline = 'mom0')
mom_mode = input.string('Histogram', 'Plot', options = ['Columns', 'Area', 'Histogram'], inline = 'mom0')
mode = mom_mode == 'Columns' ? plot.style_columns : mom_mode == 'Area' ? plot.style_area : plot.style_histogram
show_mom_sig = input.bool(false, 'Use Signal Line', inline = 'stren')
show_strength = input.bool(false, 'Show Strength(MOM)', inline = 'stren')
show_arrows = input.bool(false, 'Show ▲ ▼ ', inline = 'stren')
char_sqz = input.string('✪', 'Squeeze symbol', inline = 'sqz0')
tooltip_sqz = 'The Squeeze Indicator measures the relationship between Bollinger Bands and Keltner\'s Channels to help identify consolidations and signal when prices are likely to break out (whether up or down). ' + 'The Squeeze Indicator finds sections of the Bollinger Bands which fall inside the Keltner\'s Channels and in this case the market is said to be in a squeeze (indicator turns off, displayed with grey dot shapes in this study). ' + 'When the volatility increases, so does the distance between the bands, conversely, when the volatility declines, the distance also decreases and in such cases the squeeze is said to be released (indicator turns on, displayed with triangle up or triangle down shapes)'
show_sqz = input.bool(true, '▶ Show Squeeze Indicator  ', tooltip = tooltip_sqz, inline = 'sqz0')

show_EWO = input.bool(false, '↪ Show EWO ↩  ', inline = '0_ewo')
show_bands = input.bool(true, 'Use Breaking Bands', inline = '0_ewo')
show_signal = input.bool(false, 'Use Signal Line', inline = '0_ewo')
candles_XTL = input.bool(false, '↪ The Expert Trend Locator [Bars Color] ↩ ')

// Inputs : WaveTrend Oscillator {
const string gw = '⎆⎆ WaveTrend Oscillator'
type_wt = input.string('EMA', 'Type', inline = 'w1', group = gw, options = ['Ultimate Smoother', 'ALMA', 'T3', 'WMA', 'EMA', 'SMA', 'Wilder', 'D_WMA', 'D_SMA', 'D_EMA', 'VWMA', 'D_VWMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
srcww = input.string('hlc3', 'Source', inline = 'w1', group = gw, options = ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'])
clen = input.int(10, 'Channel Length', 3, 55, 1, inline = 'w2', group = gw)
alen = input.int(21, 'Average Length', 3, 55, 1, inline = 'w2', group = gw)
slen = input.int(4, 'Signal  Length', 2, 20, 1, inline = 'w3', group = gw)
// }

// Inputs : Squeeze Momentum Indicator {
const string gm = '⎆⎆ Squeeze Momentum Indicator'
momLength = input.int(20, 'Length', minval = 1, inline = 'mom2', group = gm)
src_mom = input.string('close', 'Source', ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'], inline = 'mom2', group = gm)
signalLength = input.int(5, 'Signal Length', minval = 2, inline = 's0', group = gm)
type_signal = input.string('SMA', 'Type', inline = 's0', group = gm, options = ['Ultimate Smoother', 'T3', 'WMA', 'EMA', 'SMA', 'Wilder', 'D_WMA', 'ALMA', 'VWMA', 'HMA'])
sqzLength = input.int(20, 'Squeeze (KC|BB) Length', minval = 1, group = gm)
bbMult = input.float(2.0, 'Bollinger Bands MultFactor', step = 0.05, minval = 0.25, group = gm)
kcMult = input.float(1.25, 'Keltner\'s Channel MultFactor', step = 0.05, minval = 0.25, group = gm)
useTrueRange = input.bool(true, 'Use TrueRange (Keltner\'s Channel)', group = gm)
// }

// Inputs : Elliott Wave Oscillator (EWO) Breaking Bands {
const string g_ewo = '⎆⎆ Elliott Wave Oscillator'
SRC_x = input.string('hl2', ' 》Source', inline = 'ewo0', group = g_ewo, options = ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'])
bg_EWO = input.bool(false, 'Background', inline = 'ewo0', group = g_ewo)
color_bar_ewo = input.bool(false, 'Bar color', inline = 'ewo0', group = g_ewo)
ma_fast = input.int(5, 'Fast MA', inline = 'F', group = g_ewo)
type_fast = input.string('SMA', 'Fast MA Type', inline = 'F', group = g_ewo, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
ma_slow = input.int(34, 'Slow MA', inline = 'S', group = g_ewo)
type_slow = input.string('SMA', 'Slow MA Type', inline = 'S', group = g_ewo, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
Len_signal = input.int(7, 'Signal Length', minval = 1, inline = 'signal', group = g_ewo)
ewo_signal = input.string('EMA', 'Type', inline = 'signal', group = g_ewo, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'HMA', 'JMA', 'VAMA', 'KAMA'])
show_L_S = input.bool(false, 'Show ▲Long/Short▼', inline = 'ls', group = g_ewo)
threshold = input.int(13, ' Strength Threshold', minval = 1, inline = 'ls', group = g_ewo)
const color col_grow_above = #00FF6B
const color col_fall_above = #00682C
const color col_grow_below = #FE5200
const color col_fall_below = #822A00
// }

// Inputs : The Expert Trend Locator - XTL {
const string g_xtl = '⎆⎆ Expert Trend Locator [XTL]'
period_xtl = input.int(26, 'Length', minval = 2, inline = 'xtl', group = g_xtl)
MA_Type2 = input.string('D_VWMA', 'Type', inline = 'xtl', group = g_xtl, options = ['Ultimate Smoother', 'T3', 'SMA', 'EMA', 'WMA', 'D_WMA', 'VWMA', 'ALMA', 'Wilder', 'D_SMA', 'D_EMA', 'D_VWMA', 'HMA'])
src_xtl = input.string('hlc3', 'Source', inline = 'xtl', group = g_xtl, options = ['open', 'high', 'low', 'close', 'oc2', 'hl2', 'hlc3', 'ohlc4', 'hlcc4', 'vwap(Close)', 'vwap(Open)', 'vwap(High)', 'vwap(Low)'])
fixed_Value = input.int(37, 'Threshold Level', minval = 10, group = g_xtl, inline = 'xtl2')
uTrad = input.bool(false, 'Use the traditional CCI formula', group = g_xtl, inline = 'xtl2')
detect_bull = input.bool(false, '◁ Alert: Bullish Trend', inline = 'alert_xtl', group = g_xtl)
detect_bear = input.bool(false, '◁ Alert: Bearish Trend', inline = 'alert_xtl', group = g_xtl)
// }

// Inputs : Divergence {
right = input.int(10, 'Divergence Look Right', minval = 0, group = 'Divergence')
left = input.int(15, 'Divergence Look Left', minval = 0, group = 'Divergence')
upper_range = input.int(100, 'Maximum Lookback', minval = 0, group = 'Divergence')
lower_range = input.int(5, 'Minimum Lookback', minval = 0, group = 'Divergence')
labels = input.string('Disabled', 'Show Labels', ['Disabled', 'Symbol', 'Text'], group = 'Divergence')
enable_regular_bullish = input.bool(true, 'Regular Bullish', group = 'Divergence', inline = 'bld')
enable_hidden_bullish = input.bool(false, 'Hidden Bullish', group = 'Divergence', inline = 'bld')
enable_regular_bearish = input.bool(true, 'Regular Bearish', group = 'Divergence', inline = 'brd')
enable_hidden_bearish = input.bool(false, 'Hidden Bearish', group = 'Divergence', inline = 'brd')
regular_bullish_color = input.color(#00FFFF, 'Bullish Colors', group = 'Divergence', inline = 'blc')
hidden_bullish_color = input.color(#46c47a, '', group = 'Divergence', inline = 'blc')
regular_bearish_color = input.color(#FF055D, 'Bearish Colors', group = 'Divergence', inline = 'brc')
hidden_bearish_color = input.color(#f82e2e, '', group = 'Divergence', inline = 'brc')
//}

// Enhanced WaveTrend Oscillator {
// Based on "WaveTrend Oscillator" - Author: @LazyBear - Modified by @EliCobra and @dgtrd
// https://www.tradingview.com/script/2KE8wTuF-Indicator-WaveTrend-Oscillator-WT/
// https://www.tradingview.com/script/9GmOkVyH-Enhanced-WaveTrend-Oscillator/
// https://www.tradingview.com/script/cYG1lqRI-WaveTrend-LazyBear-vX-by-DGT/
bar b = bar.new()
osc wt = b.wave(srcww, clen, alen, slen, type_wt)
[wt1x, wt2x] = f_getWT(extSrc, clen, alen, slen)

const color colup = #00FFFF
const color coldn = #FF055D
const color colhu = #8080FF
const color colhd = #FF8080
const color colnt = #EFEFBF

color color_wt = wt.o > wt.s ? colup : coldn
color color_wtx = wt1x > wt2x ? #00FF6B : #FE5200
color color_wtx2 = wt1x > wt2x ? #00682C : #822A00
color colof = wt.o > wt.s ? color.new(colup, 50) : color.new(coldn, 50)
field_0 = wt.h
field_1 = wt.h
color colh = wt.h > 0 ? wt.h > field_0[1] ? color.new(colhu, 40) : color.new(colhu, 60) : wt.h < field_1[1] ? color.new(colhd, 40) : color.new(colhd, 60)

hline(midL ? 0 : na, 'Mid Line', color.new(colnt, 50), hline.style_dotted)
max = hline(show_WT ? +150 : na, display = display.none)
hh = hline(show_WT ? +125 : na, display = display.none)
lh = hline(show_WT ? +100 : na, display = display.none)
min = hline(show_WT ? -150 : na, display = display.none)
ll = hline(show_WT ? -125 : na, display = display.none)
hl = hline(show_WT ? -100 : na, display = display.none)
h = plot(show_WT ? wt.h * 2 : na, 'WT Histogram', colh, 1, plot.style_columns)
w = plot(show_WT ? wt.o : na, 'WaveTrend', color_wt, 1, plot.style_line)
s = plot(show_WT ? wt.s : na, display = display.none)
char_cross = '●'
plotchar(show_cross and ta.cross(wt.o, wt.s) ? wt.s : na, 'Crossing in the WT', char_cross, location.absolute, color_wt, size = size.tiny)

plot(compare ? wt1x : na, 'WaveTrend 2', color_wtx, 1, plot.style_line)
plot(compare ? wt2x : na, 'Signal(WaveTrend 2)', color_wtx2, 1, plot.style_circles)

//@type               A custom type containing information about a ticker.
//@field description  The symbol's description.
//@field tickerType   The type of ticker.
type TickerInfo
	string description
	string tickerType
	//@variable A `TickerInfo` object containing current data.
info = TickerInfo.new(syminfo.description, syminfo.type)
//@variable The `info` requested from the specified `symbol`.
TickerInfo requestedInfo = request.security(symbol, timeframe.period, info)
//@variable The text to display inside the `infoLabel`.
string infoText = na(requestedInfo) ? '' : str.format('{0}\nType: {1}', requestedInfo.description, requestedInfo.tickerType)

if barstate.islast
    label_text = compare ? infoText : na
    label.new(x = time, y = wt1x, text = label_text, xloc = xloc.bar_time, yloc = yloc.price, color = color.rgb(0, 0, 0, 100), style = label.style_label_left, textcolor = color_wtx, size = size.small)

fill(lh, hh, color.new(colhd, 86))
fill(hh, max, color.new(colhd, 79))
fill(ll, hl, color.new(colhu, 87))
fill(ll, min, color.new(colhu, 80))
fill(w, s, colof)

alerts a = alerts.new(ta.crossover(wt.o, wt.s) and wt.o < -revt, ta.crossunder(wt.o, wt.s) and wt.o > revt, ta.crossover(wt.o, 0), ta.crossunder(wt.o, 0), ta.crossover(wt.o, wt.s), ta.crossunder(wt.o, wt.s))

// alertcondition(a.b, 'Overbought', 'WaveTrend : OB Signal')
// alertcondition(a.s, 'Oversold  ', 'WaveTrend : OS Signal')
// alertcondition(a.u, 'Midline Crossover ', 'WaveTrend : Bullish Trend')
// alertcondition(a.d, 'Midline Crossunder', 'WaveTrend : Bearish Trend')
// alertcondition(a.x, 'Oscillator Up', 'WaveTrend : Bullish Swing')
// alertcondition(a.y, 'Oscillator Down', 'WaveTrend : Bearish Swing')

a.any().notify()

bgcolor(show_black ? color.new(#000000, 25) : na, title = 'Black background')
color col = switch colb
    'Midline Cross' => wt.o > 0 ? color.new(colup, 90) : color.new(coldn, 90)
    'Extremities' => wt.o > revt ? color.new(colup, 80) : wt.o < -revt ? color.new(coldn, 80) : na
    'Reversions' => a.b ? color.new(coldn, 70) : a.s ? color.new(colup, 70) : na
    'Slope' => wt.o > wt.s ? color.new(colup, 90) : color.new(coldn, 90)
    'None' => na
bgcolor(col)
// }

// Elliott Wave Oscillator (EWO) Breaking Bands {
// Based on "EWO Breaking Bands & XTL" || https://www.tradingview.com/script/UcBJKm4O/
src_ewo = b.src(SRC_x)
ewo1 = ma(type_fast, src_ewo, ma_fast) - ma(type_slow, src_ewo, ma_slow)
AvgEWO = ma(ewo_signal, ewo1, Len_signal)

UpperBand = ewo1
UpperBand := nz(UpperBand[1])
if ewo1 > 0
    UpperBand := UpperBand[1] + 0.0555 * (ewo1 - UpperBand[1])
    UpperBand

LowerBand = ewo1
LowerBand := nz(LowerBand[1])
if ewo1 < 0
    LowerBand := LowerBand[1] + 0.0555 * (ewo1 - LowerBand[1])
    LowerBand

color_in = ewo1 > LowerBand and ewo1 < 0 ? col_fall_below : ewo1 > 0 and ewo1 < UpperBand ? col_fall_above : na
background = ewo1 > 0 ? color.new(#00FF6B, 90) : color.new(#FE5200, 90)

color_ewo = ewo1 > UpperBand ? col_grow_above : ewo1 < LowerBand ? col_grow_below : color_in
color_ewo2 = ewo1 >= 0 ? ewo1[1] < ewo1 ? col_grow_above : col_fall_above : ewo1[1] > ewo1 ? col_grow_below : col_fall_below
plot(show_EWO ? ewo1 : na, title = 'EWO', color = show_bands ? color_ewo : color_ewo2, style = plot.style_columns)

color_sig = AvgEWO > AvgEWO[1] ? #5200FE : #FE0052
plot(show_EWO and show_signal ? AvgEWO : na, title = 'Signal(EWO)', color = color_sig, linewidth = 2)

plot(show_EWO and show_bands ? UpperBand : na, title = 'Upper', color = color.new(#EFEFBF, 10))
plot(show_EWO and show_bands ? LowerBand : na, title = 'Lower', color = color.new(#EFEFBF, 10))
//hline(show_EWO ? 0 : na, title="Zero Line", linestyle=hline.style_dotted, color=white)
bgcolor(bg_EWO ? background : na, title = 'EWO Background')
barcolor(color_bar_ewo ? color_ewo : na, title = 'EWO barcolor')

// Elliott Wave Oscillator Signals by @dgtrd ═════════════════════════════════════════
// https://www.tradingview.com/script/3twfvd3k-Elliott-Wave-Oscillator-Signals-by-DGT/
ewo2 = (ma(type_fast, src_ewo, ma_fast) / ma(type_slow, src_ewo, ma_slow) - 1) * 100
ewoSignal = ma(ewo_signal, ewo2, Len_signal)
longAlertCondition = ta.crossover(ewo2, ewoSignal)
shortAlertCondition = ta.crossunder(ewo2, ewoSignal)

plotshape(show_L_S and longAlertCondition and ewo2 < -threshold, 'Strong Long', shape.triangleup, location.bottom, col_grow_above, size = size.tiny, show_last = 252)
plotshape(show_L_S and longAlertCondition and ewo2 > -threshold, 'Long', shape.triangleup, location.bottom, col_fall_above, size = size.tiny, show_last = 252)
plotshape(show_L_S and shortAlertCondition and ewo2 > threshold, 'Strong Short', shape.triangledown, location.top, col_grow_below, size = size.tiny, show_last = 252)
plotshape(show_L_S and shortAlertCondition and ewo2 < threshold, 'Short', shape.triangledown, location.top, col_fall_below, size = size.tiny, show_last = 252)

alertcondition(longAlertCondition, 'Long : Early Warning', 'EWO - Not Confirmed Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
alertcondition(longAlertCondition[1], 'Long : Trading Opportunity', 'EWO - Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')

alertcondition(shortAlertCondition, 'Short : Early Warning', 'EWO - Not Confirmed Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
alertcondition(shortAlertCondition[1], 'Short : Trading Opportunity', 'EWO - Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
//}

// The Expert Trend Locator - XTL {
// Based on "Double CCI" || https://www.tradingview.com/script/4vIRtqeP/
media = ma(MA_Type2, b.src(src_xtl), period_xtl)
cciNT = (b.src(src_xtl) - media) / (0.015 * ta.dev(b.src(src_xtl), period_xtl))
cciT = (b.src(src_xtl) - media) / (0.015 * ta.dev(math.abs(b.src(src_xtl) - media), period_xtl))
values = uTrad ? cciT : cciNT

var color color_XTL = na
if values < -fixed_Value
    color_XTL := #FF8C00 //#FF4000 // Bear
    color_XTL
if -fixed_Value <= values and values <= fixed_Value
    color_XTL := #EFEFBF // Neutral
    color_XTL
if values > fixed_Value
    color_XTL := #008CFF //#00BFFF // Bull
    color_XTL

cond_bull_xtl = detect_bull and ta.crossover(values, fixed_Value)
cond_bear_xtl = detect_bear and ta.crossunder(values, -fixed_Value)

if cond_bull_xtl
    alert('Symbol = (' + syminfo.tickerid + ') \n TimeFrame = (' + timeframe.period + ') \n Current Price (' + str.tostring(close) + ') \n Bullish Trend [XTL].', alert.freq_once_per_bar_close)
if cond_bear_xtl
    alert('Symbol = (' + syminfo.tickerid + ') \n TimeFrame = (' + timeframe.period + ') \n Current Price (' + str.tostring(close) + ') \n Bearish Trend [XTL].', alert.freq_once_per_bar_close)

barcolor(candles_XTL ? color_XTL : na, title = 'XLT barcolor')
// }

// Squeeze Momentum Indicator {
//___________________________________________________________________________________________________
// "Squeeze Momentum Indicator" - Author: @LazyBear
// @KivancOzbilgic: https://www.tradingview.com/script/NVzKGYFJ/
// @dgtrd: https://www.tradingview.com/script/Dsr7B2xE-Squeeze-Momentum-Indicator-LazyBear-vX-by-DGT/
// @OskarGallard: https://www.tradingview.com/script/3mQBizyn/
//___________________________________________________________________________________________________
// Calculations
float source = b.src(src_mom)
[_, bbUpper, bbLower] = ta.bb(source, sqzLength, bbMult)
[_, kcUpper, kcLower] = ta.kc(source, sqzLength, kcMult, useTrueRange)

sqzOn = bbLower > kcLower and bbUpper < kcUpper
sqzOff = bbLower < kcLower and bbUpper > kcUpper
noSqz = sqzOn == false and sqzOff == false

momOsc = ta.linreg(source - math.avg(math.avg(ta.highest(high, momLength), ta.lowest(low, momLength)), ta.sma(source, momLength)), momLength, 0)
signal = ma(type_signal, momOsc, signalLength)
momentum_strength = momOsc - signal

// Plotting 
color color_mom = momOsc >= 0 ? momOsc >= momOsc[1] ? color.new(#15FF00, 0) : color.new(#335E33, 0) : momOsc < momOsc[1] ? color.new(#F44336, 0) : color.new(#B71C1C, 0)
color color_up = color.new(#05FFA6, 0)
color color_dn = color.new(#FF9900, 0) //#FF0AE2 #FF1C0D

plot(show_mom ? momOsc : na, 'Momentum', color_mom, 2, mode)
plot(show_mom_sig ? signal : na, 'Signal(Mom)', signal > signal[1] ? #00FFBB : #FF1100)

mom_up = sqzOff and momentum_strength >= 0 or not show_sqz and momentum_strength >= 0
mom_dn = sqzOff and momentum_strength < 0 or not show_sqz and momentum_strength < 0
plotshape(show_arrows and mom_up, 'Squeeze Release', shape.triangleup, location.top, color_up)
plotshape(show_arrows and mom_dn, 'Squeeze Release', shape.triangledown, location.top, color_dn)
plotchar(show_sqz and (sqzOn or noSqz) ? true : false, 'In Squeeze', char_sqz, location.top, #EFEFBF)

color_strength = momentum_strength > 0 ? color_up : color_dn
color_strength_cloud = momentum_strength > 0 ? color.new(color_up, 85) : color.new(color_dn, 85)
plot(show_strength ? momentum_strength * 2 : na, 'Momentum Strength', color_strength_cloud, 1, plot.style_columns, display = display.pane)
plot(show_strength ? momentum_strength * 2 : na, 'Momentum Strength', color_strength, 1, plot.style_line, join = true)
// }

// Divergence {
in_range(cond, lower_range, upper_range) =>
    bars = ta.barssince(cond == true)
    lower_range <= bars and bars <= upper_range

color text_color = #111122
float source_div = show_WT ? wt.o : show_mom ? momOsc : show_EWO ? ewo1 : na

divergence(float source, int right, int left, int upper_range, int lower_range, bool enable_regular_bullish, color regular_bullish_color, bool enable_hidden_bullish, color hidden_bullish_color, bool enable_regular_bearish, color regular_bearish_color, bool enable_hidden_bearish, color hidden_bearish_color, string labels, color text_color) =>
    repaint = barstate.ishistory or barstate.isconfirmed

    pl = na(ta.pivotlow(source, left, right)) ? false : true
    ph = na(ta.pivothigh(source, left, right)) ? false : true

    source_hl = source[right] > ta.valuewhen(pl, source[right], 1) and in_range(pl[1], lower_range, upper_range)
    price_ll = low[right] < ta.valuewhen(pl, low[right], 1)
    bullish_condition = enable_regular_bullish and price_ll and source_hl and pl and repaint

    oscLL = source[right] < ta.valuewhen(pl, source[right], 1) and in_range(pl[1], lower_range, upper_range)
    priceHL = low[right] > ta.valuewhen(pl, low[right], 1)
    hidden_bullish_condition = enable_hidden_bullish and priceHL and oscLL and pl and repaint

    oscLH = source[right] < ta.valuewhen(ph, source[right], 1) and in_range(ph[1], lower_range, upper_range)
    priceHH = high[right] > ta.valuewhen(ph, high[right], 1)
    bearish_condition = enable_regular_bearish and priceHH and oscLH and ph and repaint

    oscHH = source[right] > ta.valuewhen(ph, source[right], 1) and in_range(ph[1], lower_range, upper_range)
    priceLH = high[right] < ta.valuewhen(ph, high[right], 1)
    hidden_bearish_condition = enable_hidden_bearish and priceLH and oscHH and ph and repaint

    offset = -right

    var float current_bullish_value = 0
    var int current_bull_idx = 0
    var float last_bullish_value = 0
    var int last_bullish_idx = 0
    var float current_hidden_bullish_value = 0
    var int current_hidden_bullish_idx = 0
    var float last_hidden_bullish_value = 0
    var int last_hidden_bullish_idx = 0
    var float current_bearish_value = 0
    var int current_bearish_idx = 0
    var float last_bearish_value = 0
    var int last_bearish_idx = 0
    var float current_hidden_bearish_value = 0
    var int current_hidden_bearish_idx = 0
    var float last_hidden_bearish_idx = 0
    var int last_hidden_bearish_value = 0

    if pl
        last_bullish_value := current_bullish_value
        last_bullish_idx := current_bull_idx
        current_bullish_value := source[right]
        current_bull_idx := bar_index - right
        last_hidden_bullish_value := current_hidden_bullish_value
        last_hidden_bullish_idx := current_hidden_bullish_idx
        current_hidden_bullish_value := source[right]
        current_hidden_bullish_idx := bar_index - right
        current_hidden_bullish_idx

    if ph
        last_bearish_value := current_bearish_value
        last_bearish_idx := current_bearish_idx
        current_bearish_value := source[right]
        current_bearish_idx := bar_index - right
        last_hidden_bearish_idx := current_hidden_bearish_value
        last_hidden_bearish_value := current_hidden_bearish_idx
        current_hidden_bearish_value := source[right]
        current_hidden_bearish_idx := bar_index - right
        current_hidden_bearish_idx

    label_style_bullish = switch labels
        'Text' => label.style_label_up
        'Symbol' => label.style_triangleup
        => label.style_none

    label_style_bearish = switch labels
        'Text' => label.style_label_down
        'Symbol' => label.style_triangledown
        => label.style_none

    size = switch labels
        'Text' => size.small
        'Symbol' => size.tiny
        => size.auto

    source_atr = ta.sma(ta.rma(ta.highest(source, 10) - ta.lowest(source, 10), 50) / (labels == 'Text' ? 4 : 1), 10)

    if bullish_condition
        line.new(last_bullish_idx, last_bullish_value, current_bull_idx, current_bullish_value, width = 2, color = regular_bullish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] - source_atr, labels == 'Text' ? 'R' : '', color = regular_bullish_color, textcolor = text_color, style = label_style_bullish, size = size)
    if hidden_bullish_condition
        line.new(last_hidden_bullish_idx, last_hidden_bullish_value, current_hidden_bullish_idx, current_hidden_bullish_value, width = 2, color = hidden_bullish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] - source_atr, labels == 'Text' ? 'H' : '', color = hidden_bullish_color, textcolor = text_color, style = label_style_bullish, size = size)
    if bearish_condition
        line.new(last_bearish_idx, last_bearish_value, current_bearish_idx, current_bearish_value, width = 2, color = regular_bearish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] + source_atr, labels == 'Text' ? 'R' : '', color = regular_bearish_color, textcolor = text_color, style = label_style_bearish, size = size)
    if hidden_bearish_condition
        line.new(last_hidden_bearish_value, last_hidden_bearish_idx, current_hidden_bearish_idx, current_hidden_bearish_value, width = 2, color = hidden_bearish_color)
        if labels != 'Disabled'
            label.new(bar_index - right, source[right] + source_atr, labels == 'Text' ? 'H' : '', color = hidden_bearish_color, textcolor = text_color, style = label_style_bearish, size = size)
    [bullish_condition, hidden_bullish_condition, bearish_condition, hidden_bearish_condition]

min_max(source, min, max, enable, clamp) =>
    if enable != 'Disabled'
        if clamp
            (math.max(math.min(1, (source - min) / (max - min)), 0) - 0.5) * 200
        else
            ((source - min) / (max - min) - 0.5) * 200
    else
        source

[regular_bullish, hidden_bullish, regular_bearish, hidden_bearish] = divergence(source_div, right, left, upper_range, lower_range, enable_regular_bullish, regular_bullish_color, enable_hidden_bullish, hidden_bullish_color, enable_regular_bearish, regular_bearish_color, enable_hidden_bearish, hidden_bearish_color, labels, text_color)

alertcondition(regular_bullish, 'Regular Bullish Divergence', 'Regular bullish divergence detected!')
alertcondition(hidden_bullish, 'Hidden Bullish Divergence', 'Hidden bullish divergence detected!')
alertcondition(regular_bearish, 'Regular Bearish Divergence', 'Regular bearish divergence detected!')
alertcondition(hidden_bearish, 'Hidden Bearish Divergence', 'Hidden bearish divergence detected!')
//}

//Signal - Enhanced WaveTrend Oscillator {
plotchar(revb and a.b ? true : false, 'Overbought Signal', char_dn, location.top, coldn, size = size.tiny)
plotchar(revb and a.s ? true : false, 'Oversold Signal', char_up, location.bottom, colup, size = size.tiny)
// }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Inputs

//-----------------------------------------------------------------------------
//              Input | Settings
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------{
const string FREQ = alert.freq_once_per_bar_close
const color NO_COLOR = color.new(#000000, 100)

const string MAIN_INPUT = '🚀 Signal Line'
showMainLine = input.bool(true, 'Turn On/Off', group = MAIN_INPUT, inline = 'Main', display = display.none)
gColor = input.color(color.teal, '', group = MAIN_INPUT, inline = 'Main', display = display.none)
rColor = input.color(#da5b52, '', group = MAIN_INPUT, inline = 'Main', display = display.none)
rsiLen = input.int(14, 'Length', minval = 1, group = MAIN_INPUT, display = display.none)
smoothLen = input.int(2, 'Smooth', minval = 1, group = MAIN_INPUT, display = display.none)

const string HIST_INPUT = '📊 Histogram'
showHist = input.bool(true, 'Turn On/Off', group = HIST_INPUT, inline = 'hist', display = display.none)
histColorUp = input.color(#6de6f693, '', group = HIST_INPUT, inline = 'hist', display = display.none)
histColorDn = input.color(#f66d6d93, '', group = HIST_INPUT, inline = 'hist', display = display.none)
inputMfiLen = input.int(30, 'Length', minval = 5, group = HIST_INPUT, display = display.none)
smoothHist = input.int(2, 'Smooth', minval = 1, group = HIST_INPUT, display = display.none)
fastMfiLen = math.round(inputMfiLen / 1.33)
slowMfiLen = math.round(inputMfiLen * 1.33)

const string OTHER_INPUT = '💡 Other'
showDiv = input.bool(true, 'Show Divergence Line   ', group = OTHER_INPUT, inline = 'div', display = display.none)
bullDivColor = input.color(color.white, '', group = OTHER_INPUT, inline = 'div', display = display.none)
bearDivColor = input.color(color.white, '', group = OTHER_INPUT, inline = 'div', display = display.none)

showHidDiv = input.bool(false, 'Show Hidden Divergence', group = OTHER_INPUT, inline = 'hiddiv', display = display.none)
bullHidDivColor = input.color(#24baab, '', group = OTHER_INPUT, inline = 'hiddiv', display = display.none)
bearHidDivColor = input.color(#f77b73, '', group = OTHER_INPUT, inline = 'hiddiv', display = display.none)

showStatusLine = input.bool(true, 'Show Status Line       ', group = OTHER_INPUT, inline = 'Status', display = display.none)
gStatColor = input.color(color.teal, '', group = OTHER_INPUT, inline = 'Status', display = display.none)
rStatColor = input.color(#da5b52, '', group = OTHER_INPUT, inline = 'Status', display = display.none)

showTpSignal = input.bool(true, 'Show TP Signal         ', group = OTHER_INPUT, inline = 'tp', display = display.none)
gTpColor = input.color(color.teal, '', group = OTHER_INPUT, inline = 'tp', display = display.none)
rTpColor = input.color(#da5b52, '', group = OTHER_INPUT, inline = 'tp', display = display.none)

showReverseDots = input.bool(true, 'Show Reversal points    ', group = OTHER_INPUT, inline = 'rd', display = display.none)
gRdColor = input.color(color.teal, '', group = OTHER_INPUT, inline = 'rd', display = display.none)
rRdColor = input.color(#da5b52, '', group = OTHER_INPUT, inline = 'rd', display = display.none)

delOldDiv = input.bool(true, 'Delete Broken Divergence Lines', group = OTHER_INPUT, display = display.none)


//------------------------------------------------------------------------------}

//-----------------------------------------------------------------------------
//              Alerts
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------{

const string ALERT_INPUT = '🔔 ALERTS CUSTOMIZATION\n'

alertSigUp = input.bool(false, 'Signal Line Bull       ', inline = 'a1', group = ALERT_INPUT, display = display.none)
alertSigDn = input.bool(false, 'Bear', inline = 'a1', group = ALERT_INPUT, display = display.none)

alertBullTP = input.bool(false, 'TP Bull               ', inline = 'a2', group = ALERT_INPUT, display = display.none)
alertBearTP = input.bool(false, 'Bear', inline = 'a2', group = ALERT_INPUT, display = display.none)

alertStatusUp = input.bool(false, 'Status Bull            ', inline = 'a3', group = ALERT_INPUT, display = display.none)
alertStatusDn = input.bool(false, 'Bear', inline = 'a3', group = ALERT_INPUT, display = display.none)
alertStatusUpP = input.bool(false, 'Status Bull+           ', inline = 'a4', group = ALERT_INPUT, display = display.none)
alertStatusDnP = input.bool(false, 'Bear+', inline = 'a4', group = ALERT_INPUT, display = display.none)

alertBullDiv = input.bool(false, 'Divergence Bull       ', inline = 'a5', group = ALERT_INPUT, display = display.none)
alertBearDiv = input.bool(false, 'Bear', inline = 'a5', group = ALERT_INPUT, display = display.none)

alertBullHidDiv = input.bool(false, 'Hidden Divergence Bull ', inline = 'a6', group = ALERT_INPUT, display = display.none)
alertBearHidDiv = input.bool(false, 'Bear', inline = 'a6', group = ALERT_INPUT, display = display.none)

inputMsg = input.text_area('List of Supported Placeholders:\n{{trigger}} - Trigger name (\'Buy\', \'Bullish Take Profit\')\n{{indicator}} - Indicator Value\n{{exchange}} - Exchange (\'Binance\')\n{{ticker}} - Ticker (\'BTCUSD\')\n{{interval}} - Timeframe (\'1s\', \'1\', \'D\')\n{{open}}-{{close}}-{{high}}-{{low}} - Candle price values\n{{volume}} - Candle volume\n{{time}} - Candle open time in UTC timezone\n{{timenow}} - Signal time in UTC timezone\n{{syminfo.currency}} - \'USD\' for BTCUSD pair\n{{syminfo.basecurrency}} - \'BTC\' for BTCUSD pair', '', group = ALERT_INPUT, display = display.none)


getAlertMasg(string trigger, float ind = 0.0) =>
    alertMsg = str.replace_all(inputMsg, '{{exchange}}', syminfo.prefix)
    alertMsg := str.replace_all(alertMsg, '{{ticker}}', syminfo.ticker)
    alertMsg := str.replace_all(alertMsg, '{{volume}}', str.tostring(volume, format.volume))
    alertMsg := str.replace_all(alertMsg, '{{close}}', str.tostring(close, format.price))
    alertMsg := str.replace_all(alertMsg, '{{open}}', str.tostring(open, format.price))
    alertMsg := str.replace_all(alertMsg, '{{high}}', str.tostring(high, format.price))
    alertMsg := str.replace_all(alertMsg, '{{low}}', str.tostring(low, format.price))
    alertMsg := str.replace_all(alertMsg, '{{time}}', str.format_time(time, 'yyyy-MM-dd', 'Etc/UTC') + 'T' + str.format_time(time, 'HH:mm:ss', 'Etc/UTC') + 'Z')
    alertMsg := str.replace_all(alertMsg, '{{timenow}}', str.format_time(timenow, 'yyyy-MM-dd', 'Etc/UTC') + 'T' + str.format_time(timenow, 'HH:mm:ss', 'Etc/UTC') + 'Z')
    alertMsg := str.replace_all(alertMsg, '{{interval}}', timeframe.period)
    alertMsg := str.replace_all(alertMsg, '{{syminfo.currency}}', syminfo.currency)
    alertMsg := str.replace_all(alertMsg, '{{syminfo.basecurrency}}', syminfo.basecurrency)
    alertMsg := str.replace_all(alertMsg, '{{trigger}}', trigger)
    alertMsg := str.replace_all(alertMsg, '{{indicator}}', str.tostring(ind, '##.#'))
    alertMsg

//------------------------------------------------------------------------------}

//-----------------------------------------------------------------------------
//              Main
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------{
const int MFI_LEN = 7
const int STOCH_K = 2
const int STOCH_D = 5
const float SMOOTH_LEN = 1.75
const float STOCH_WEIGHT = 0.4
const float OVERBOUGHT = 60.0
const float EXTEND_MULT = 1
var float mfiWeight = 0.4

rsiSrc = hlc3

transform(srcww, mult = 1) =>
    tmp = (srcww / 100 - 0.5) * 2
    mult * 100 * (tmp > 0 ? 1 : -1) * math.pow(math.abs(tmp), 0.75)

//Histogram
fastMfi = ta.mfi(rsiSrc, fastMfiLen)
slowMfi = ta.mfi(rsiSrc, slowMfiLen)
resMfi = transform(ta.sma(fastMfi * 0.5 + slowMfi * 0.5, smoothHist), 0.7)

midLine = plot(0, color = histColorUp, editable = false, display = display.pane)
histColor = showHist ? resMfi >= 0 ? histColorUp : histColorDn : NO_COLOR
longterm = plot(resMfi, color = histColor, editable = false, display = display.pane) //20*macd/ta.highest(absMACD,20) + 50 
fill(longterm, midLine, resMfi, 0, histColor, NO_COLOR, editable = false)


// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)