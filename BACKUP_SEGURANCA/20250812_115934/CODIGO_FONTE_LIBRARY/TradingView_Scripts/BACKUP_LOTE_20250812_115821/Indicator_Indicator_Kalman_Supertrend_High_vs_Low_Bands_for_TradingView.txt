// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join our channel for more free tools: https://t.me/simpleforextools

//@version=5
indicator("Kalman Supertrend (High vs Low) Bands by Skyito", shorttitle="Kalman ST Bands [Skyito]", overlay=true, max_lines_count=500, max_labels_count=500)

// ===================== ORIGINAL INPUTS =====================
series float pricesource      = input.source(close, "Kalman Price Source", group = "Calculation")
simple float measurementNoise = input.float(3.0, title="Measurement Noise", group = "Calculation", step = 1.0)
simple float processNoise     = input.float(0.01, title="Process Noise", step = 0.01, group = "Calculation")

simple int   atrPeriod        = input.int(12, "ATR Period", group = "Supertrend", inline = "ST")
simple float factor           = input.float(1.7, "Factor", group = "Supertrend", inline = "ST", step = 0.01)

simple bool  showkalman       = input.bool(false, "Show Supertrend on chart?", group = "UI Settings")
simple bool  paintCandles     = input.bool(true, "Paint candles according to Trend?", group = "UI Settings")
simple bool  showlongshort    = input.bool(false, "Show Long and Short Signals {𝕃 + 𝕊}", group = "UI Settings")

color longColor  = input.color(#33ff00, "Long Color", group = "UI Settings", inline = "Col")
color shortColor = input.color(#ff0000, "Short Color", group = "UI Settings", inline = "Col")

// === NEW toggles for add-on ===
bool showHLBands     = input.bool(true,  "Show High/Low Bands", group="UI Settings")
bool showBandFill    = input.bool(true,  "Fill Between Bands",  group="UI Settings")
bool showBandSignals = input.bool(true,  "Show BB/SS (Whole Candle Outside)", group="UI Settings")
int  bandFillOpacity = input.int (85,    "Band Fill Opacity",   minval=0, maxval=100, group="UI Settings")
bool paintBandLive   = input.bool(true,  "Paint candles when live above/below bands", group="UI Settings")

// ===================== KALMAN FILTER =====================
N = 5
var float[] stateEstimate = array.new_float(N, na)
var float[] errorCovariance = array.new_float(N, 100.0)
f_init(series float pricesource) =>
    if na(array.get(stateEstimate, 0))
        for i = 0 to N-1
            array.set(stateEstimate, i, pricesource)
            array.set(errorCovariance, i, 1.0)

f_kalman(series float pricesource, float measurementNoise) =>
    predictedStateEstimate = array.new_float(N)
    predictedErrorCovariance = array.new_float(N)
    for i = 0 to N-1
        array.set(predictedStateEstimate, i, array.get(stateEstimate, i))
        array.set(predictedErrorCovariance, i, array.get(errorCovariance, i) + processNoise)
    for i = 0 to N-1
        kg = array.get(predictedErrorCovariance, i) / (array.get(predictedErrorCovariance, i) + measurementNoise)
        array.set(stateEstimate, i, array.get(predictedStateEstimate, i) + kg * (pricesource - array.get(predictedStateEstimate, i)))
        array.set(errorCovariance, i, (1 - kg) * array.get(predictedErrorCovariance, i))
    array.get(stateEstimate, 0)

f_init(pricesource)
kalmanFilteredPrice = f_kalman(pricesource, measurementNoise)

// ===================== HULL MOVING AVERAGE (KALMAN) =====================
KHMA(_src, _length) =>
    f_kalman(2 * f_kalman(_src, _length / 2) - f_kalman(_src, _length), math.round(math.sqrt(_length)))
kalmanHMA = KHMA(pricesource, measurementNoise)

// ===================== SUPERTREND =====================
supertrend(factor, atrPeriod, src) =>
    atr = ta.atr(atrPeriod)
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])
    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int direction = na
    float superTrend = na
    prevSuperTrend = superTrend[1]
    if na(atr[1])
        direction := 1
    else if prevSuperTrend == prevUpperBand
        direction := close > upperBand ? -1 : 1
    else
        direction := close < lowerBand ? 1 : -1
    superTrend := direction == -1 ? lowerBand : upperBand
    [superTrend, direction]

[superTrend, direction] = supertrend(factor, atrPeriod, kalmanHMA)

SupertrendLong  = ta.crossunder(direction, 0)
SupertrendShort = ta.crossover(direction, 0)
var Trend = 0
if SupertrendLong and not SupertrendShort
    Trend := 1
if SupertrendShort
    Trend := -1

var barColour = #ffffff
if Trend == 1
    barColour := longColor
if Trend == -1
    barColour := shortColor

plot(showkalman ? superTrend : na, "Kalman Hull ST", color = color.new(barColour, 40), linewidth = 4)
barcolor(paintCandles ? barColour : na)

plotshape(showlongshort ? SupertrendLong : na, offset=0, title="Long",  text="𝕃", style=shape.triangleup,   location=location.belowbar, color=barColour, textcolor=barColour, size = size.tiny)
plotshape(showlongshort ? SupertrendShort: na, offset=0, title="Short", text="𝕊", style=shape.triangledown, location=location.abovebar, color=barColour, textcolor=barColour, size = size.tiny)

alertcondition(SupertrendLong,  title="Kalman Hull ST Long",  message="Kalman Hull ST Long {{exchange}}:{{ticker}}")
alertcondition(SupertrendShort, title="Kalman Hull ST Short", message="Kalman Hull ST Short {{exchange}}:{{ticker}}")

// ===================== HIGH/LOW BANDS =====================
var float[] stateEstimateH    = array.new_float(N, na)
var float[] errorCovarianceH  = array.new_float(N, 100.0)
f_init_h(series float src) =>
    if na(array.get(stateEstimateH, 0))
        for i = 0 to N - 1
            array.set(stateEstimateH, i, src)
            array.set(errorCovarianceH, i, 1.0)

f_kalman_h(series float src, float measNoise) =>
    predictedStateEstimate = array.new_float(N)
    predictedErrorCovariance = array.new_float(N)
    for i = 0 to N - 1
        array.set(predictedStateEstimate, i, array.get(stateEstimateH, i))
        array.set(predictedErrorCovariance, i, array.get(errorCovarianceH, i) + processNoise)
    for i = 0 to N - 1
        pe = array.get(predictedErrorCovariance, i)
        kg = pe / (pe + measNoise)
        xp = array.get(predictedStateEstimate, i)
        x  = xp + kg * (src - xp)
        array.set(stateEstimateH, i, x)
        array.set(errorCovarianceH, i, (1 - kg) * pe)
    array.get(stateEstimateH, 0)

KHMA_h(_src, _len) =>
    f_kalman_h(2 * f_kalman_h(_src, _len / 2) - f_kalman_h(_src, _len), math.round(math.sqrt(_len)))

var float[] stateEstimateL    = array.new_float(N, na)
var float[] errorCovarianceL  = array.new_float(N, 100.0)
f_init_l(series float src) =>
    if na(array.get(stateEstimateL, 0))
        for i = 0 to N - 1
            array.set(stateEstimateL, i, src)
            array.set(errorCovarianceL, i, 1.0)

f_kalman_l(series float src, float measNoise) =>
    predictedStateEstimate = array.new_float(N)
    predictedErrorCovariance = array.new_float(N)
    for i = 0 to N - 1
        array.set(predictedStateEstimate, i, array.get(stateEstimateL, i))
        array.set(predictedErrorCovariance, i, array.get(errorCovarianceL, i) + processNoise)
    for i = 0 to N - 1
        pe = array.get(predictedErrorCovariance, i)
        kg = pe / (pe + measNoise)
        xp = array.get(predictedStateEstimate, i)
        x  = xp + kg * (src - xp)
        array.set(stateEstimateL, i, x)
        array.set(errorCovarianceL, i, (1 - kg) * pe)
    array.get(stateEstimateL, 0)

KHMA_l(_src, _len) =>
    f_kalman_l(2 * f_kalman_l(_src, _len / 2) - f_kalman_l(_src, _len), math.round(math.sqrt(_len)))

f_init_h(high)
f_init_l(low)
kalmanHMA_high = KHMA_h(high, measurementNoise)
kalmanHMA_low  = KHMA_l(low,  measurementNoise)

[stHigh, dirHigh] = supertrend(factor, atrPeriod, kalmanHMA_high)
[stLow,  dirLow ] = supertrend(factor, atrPeriod, kalmanHMA_low)

pHigh = plot(showHLBands ? stHigh : na, title="Kalman ST (High)", color=color.new(shortColor, 0), linewidth=2)
pLow  = plot(showHLBands ? stLow  : na, title="Kalman ST (Low)",  color=color.new(longColor,  0), linewidth=2)

bandFillColor = Trend == 1 ? color.new(longColor, bandFillOpacity) : Trend == -1 ? color.new(shortColor, bandFillOpacity) : color.new(color.gray, bandFillOpacity)
fill(pHigh, pLow, color = (showHLBands and showBandFill) ? bandFillColor : color.new(color.gray, 100), title="High–Low Kalman ST Zone")

// ===== BB/SS one-shot, whole-candle outside =====
bandTop    = math.max(stHigh, stLow)
bandBottom = math.min(stHigh, stLow)

// Live band-based candle coloring (global scope)
liveAbove = paintBandLive and close > bandTop
liveBelow = paintBandLive and close < bandBottom
barcolor(liveAbove ? longColor : liveBelow ? shortColor : na)

bbNow   = low  > bandTop
ssNow   = high < bandBottom
bbPrev  = low[1]  > bandTop[1]
ssPrev  = high[1] < bandBottom[1]
bbEvent = bbNow and not bbPrev
ssEvent = ssNow and not ssPrev

var int bandRegime = 0
bbSignal = showBandSignals and barstate.isconfirmed and bbEvent and bandRegime != 1
ssSignal = showBandSignals and barstate.isconfirmed and ssEvent and bandRegime != -1

if bbSignal
    bandRegime := 1
else if ssSignal
    bandRegime := -1
else
    bandRegime := nz(bandRegime[1], 0)

plotshape(bbSignal, title="Band Buy (BB)", text="BB", style=shape.labelup,   location=location.belowbar, size=size.large, color=longColor,  textcolor=color.white)
plotshape(ssSignal, title="Band Sell (SS)", text="SS", style=shape.labeldown, location=location.abovebar, size=size.large, color=shortColor, textcolor=color.white)

alertcondition(bbSignal, title="Kalman High/Low ST BB", message="BB: whole candle ABOVE band — {{exchange}}:{{ticker}}")
alertcondition(ssSignal, title="Kalman High/Low ST SS", message="SS: whole candle BELOW band — {{exchange}}:{{ticker}}")


// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)