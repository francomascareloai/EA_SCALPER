//@version=5
indicator("NAS Ultimate Algo 2.0V", overlay=true, precision=0, explicit_plot_zorder=true, max_labels_count=500, max_bars_back=1200)

// Get user input
sensitivity = input.int(defval=4, title="Sensitivity", minval=1, maxval=20, group="BUY AND SELL SIGNALS SETTINGS")
optimize = input.bool(false, "Heikinashi Request", group="BUY AND SELL SIGNALS SETTINGS")
typeofMA = input.string(title="Type of Moving Average", defval="EMA", options=["RMA", "SMA", "EMA", "WMA", "VWMA", "SMMA", "TMA", "HullMA", "DEMA", "TEMA", "VWAP"], group="BUY AND SELL SIGNALS SETTINGS")
maperiod  = input.int(defval=13, title="MA Period", group="BUY AND SELL SIGNALS SETTINGS")

enCloud   = input.bool(true, 'Enable Trend Ribbon', group='Cloud')

// Risk Management
levels      = input.bool(false, "Show TP/SL Levels" , group = "Risk Management" , inline = "MMDB2")
lvlLines    = input.bool(false, "Show Lines ", inline="levels", group = "Risk Management")
linesStyle  = input.string("SOLID", "", ["SOLID", "DASHED", "DOTTED"], inline="levels", group = "Risk Management")
lvlDistance = input.int(1, "Distance", 1, inline="levels2", group = "Risk Management")
lvlDecimals = input.int(2, "   Decimals", 1, 8, inline="levels2", group = "Risk Management")
atrRisk     = input.int(1, "Risk % ", 1, group = "Risk Management" , inline="levels3")
atrLen      = input.int(14, "  ATR Length", 1, group = "Risk Management" , inline="levels3")
decimals  = lvlDecimals == 1 ? "#.#" : lvlDecimals == 2 ? "#.##" : lvlDecimals == 3 ? "#.###" : lvlDecimals == 4 ? "#.####" : lvlDecimals == 5 ? "#.#####" : lvlDecimals == 6 ? "#.######" : lvlDecimals == 7 ? "#.#######" : "#.########"

// Heikinashi Request
myTicker = ticker.heikinashi(syminfo.tickerid)
ha_open = optimize ? request.security(myTicker, timeframe.period, open, lookahead=barmerge.lookahead_off) : open
ha_close = optimize ? request.security(myTicker, timeframe.period, close, lookahead=barmerge.lookahead_off) : close
ha_Ohlc4 = optimize ? request.security(myTicker, timeframe.period, ohlc4, lookahead=barmerge.lookahead_off) : ohlc4
// Signal Generation
supertrend(_src, factor, atrLen) =>
	atr = ta.atr(atrLen)
	upperBand = _src + factor * atr
	lowerBand = _src - factor * atr
	prevLowerBand = nz(lowerBand[1])
	prevUpperBand = nz(upperBand[1])
	lowerBand := lowerBand > prevLowerBand or ha_close[1] < prevLowerBand ? lowerBand : prevLowerBand
	upperBand := upperBand < prevUpperBand or ha_close[1] > prevUpperBand ? upperBand : prevUpperBand
	int direction = na
	float superTrend = na
	prevSuperTrend = superTrend[1]
	if na(atr[1])
		direction := 1
	else if prevSuperTrend == prevUpperBand
		direction := ha_close > upperBand ? -1 : 1
	else
		direction := ha_close < lowerBand ? 1 : -1
	superTrend := direction == -1 ? lowerBand : upperBand
	[superTrend, direction] 
	

//
// SMA 
ocAvg       = math.avg(ha_open, ha_open)
sma4        = ta.sma(ha_close, 8)
sma5        = ta.sma(ha_close, 9)
psar        = ta.sar(0.02, 0.02, 0.2)

ma        =typeofMA == "EMA"? ta.sma(ha_close, maperiod ):na

//*in Easy Words Super Trend + SMA = Signals
[supertrend, direction] = supertrend(ha_close, sensitivity*2, 11)


source = close, period = 150

// Colors
green       = #2BBC4D, green2   = #00DD00
red         = #C51D0B, red2     = #DD0000

//barcolor(close > supertrend ? #2BE300 : red2)
// Candle Colouring By SpyDank
//TradingView standard RSI calculation
src = close
len = input.int(14, minval=1, title='RSI Length')
up = ta.rma(math.max(ta.change(src), 0), len)
down = ta.rma(-math.min(ta.change(src), 0), len)
rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - 100 / (1 + up / down)

//Defining ranges by 10% increments
tier1 = rsi <= 20
tier2 = rsi > 20 and rsi <= 21
tier3 = rsi > 21 and rsi <= 22
tier4 = rsi > 22 and rsi <= 23
tier5 = rsi > 23 and rsi <= 24
tier6 = rsi > 24 and rsi <= 25
tier7 = rsi > 25 and rsi <= 26
tier8 = rsi > 26 and rsi <= 27
tier9 = rsi > 27 and rsi <= 28
tier10 = rsi > 28 and rsi <=29
tier11 = rsi > 29 and rsi <=30
tier12 = rsi > 30 and rsi <=31
tier13 = rsi > 31 and rsi <=32
tier14 = rsi > 32 and rsi <=33
tier15 = rsi > 33 and rsi <=34
tier16 = rsi > 34 and rsi <=35
tier17 = rsi > 35 and rsi <=36
tier18 = rsi > 36 and rsi <=37
tier19 = rsi > 37 and rsi <=38
tier20 = rsi > 38 and rsi <=39
tier21 = rsi > 39 and rsi <=40
tier22 = rsi > 40 and rsi <=41
tier23 = rsi > 41 and rsi <=42
tier24 = rsi > 42 and rsi <=43
tier25 = rsi > 43 and rsi <=44
tier26 = rsi > 44 and rsi <=45
tier27 = rsi > 45 and rsi <=46
tier28 = rsi > 46 and rsi <=47
tier29 = rsi > 47 and rsi <=48
tier30 = rsi > 48 and rsi <=49
tier31 = rsi > 49 and rsi <=50
tier32 = rsi > 50 and rsi <=51
tier33 = rsi > 51 and rsi <=52
tier34 = rsi > 52 and rsi <=53
tier35 = rsi > 53 and rsi <=54
tier36 = rsi > 54 and rsi <=55
tier37 = rsi > 55 and rsi <=56
tier38 = rsi > 56 and rsi <=57
tier39 = rsi > 57 and rsi <=58
tier40 = rsi > 58 and rsi <=59
tier41 = rsi > 59 and rsi <=60
tier42 = rsi > 60 and rsi <=61
tier43 = rsi > 61 and rsi <=62
tier44 = rsi > 62 and rsi <=63
tier45 = rsi > 63 and rsi <=64
tier46 = rsi > 64 and rsi <=65
tier47 = rsi > 65 and rsi <=66
tier48 = rsi > 66 and rsi <=67
tier49 = rsi > 67 and rsi <=68
tier50 = rsi > 68 and rsi <=69
tier51 = rsi > 69 and rsi <=70
tier52 = rsi > 70 and rsi <=71
tier53 = rsi > 71 and rsi <=72
tier54 = rsi > 72 and rsi <=73
tier55 = rsi > 73 and rsi <=74
tier56 = rsi > 74 and rsi <=75
tier57 = rsi > 75 and rsi <=76
tier58 = rsi > 76 and rsi <=77
tier59 = rsi > 77 and rsi <=78
tier60 = rsi > 78 and rsi <=79
tier61 = rsi > 79 and rsi <=80


//Assign color based on range
color colorVar = na
colorVar := tier1 ? #FF0000 : 
             tier2 ? #FB0009 :
             tier3 ? #F2001A :
             tier4 ? #ED0023 :
             tier5 ? #E9002C :
             tier6 ? #E50035 :
             tier7 ? #E0003E :
             tier8 ? #DC0046 :
             tier9 ? #D7004F :
             tier10 ? #D30058 :
             tier11 ? #CE0061 :
             tier12 ? #CA006A :
             tier13 ? #C60072 :
             tier14 ? #C1007B :
             tier15 ? #BD0084 :
             tier16 ? #B8008D :
             tier17 ? #B40095 :
             tier18 ? #B0009E :
             tier19 ? #AB00A7 :
             tier20 ? #A700B0 :
             tier21 ? #A200B9 :
             tier22 ? #9E00C1 :
             tier23 ? #9900CA :
             tier24 ? #9500D3 :
             tier25 ? #9100DC :
             tier26 ? #8C00E5 :
             tier27 ? #8800ED :
             tier28 ? #8300F6 :
             tier29 ? #7F00FF :
             tier30 ? #7F00FF :
             tier31 ? #7B09F6 :
             tier32 ? #7612ED :
             tier33 ? #721AE5 :
             tier34 ? #6D23DC :
             tier35 ? #692CD3 :
             tier36 ? #6535CA :
             tier37 ? #603EC1 :
             tier38 ? #5C46B9 :
             tier39 ? #584FB0 :
             tier40 ? #5358A7 :
             tier41 ? #4F619E :
             tier42 ? #4A6A95 :
             tier43 ? #46728D :
             tier44 ? #427B84 :
             tier45 ? #3D847B :
             tier46 ? #398D72 :
             tier47 ? #35956A :
             tier48 ? #309E61 :
             tier48 ? #2CA758 :
             tier50 ? #27B04F :
             tier51 ? #23B946 :
             tier52 ? #1FC13E :
             tier53 ? #1ACA35 :
             tier54 ? #16D32C :
             tier55 ? #12DC23 :
             tier56 ? #0DE51A :
             tier57 ? #09ED12 :
             tier58 ? #04F609 :
             tier59 ? #00FF00 :
             na

barcolor(colorVar)




// High Lows
y1 = low - (ta.atr(30) * 6), y1B = low - ta.atr(30)
y2 = high + (ta.atr(30) * 6), y2B = high + ta.atr(30)

bull = ta.crossover(ha_close, supertrend) and ha_close >= ma
bear = ta.crossunder(ha_close, supertrend) and ha_close <= ma


// Plots

// ---------------------------- Fast ---------------------------- \\
candle  = ta.sma(close, 21)
reach   = ta.sma(close, 34)
candlep = plot(enCloud ? candle : na, color=color.new(color.white, 100))
reachp  = plot(enCloud ? reach  : na, color=color.new(color.white, 100))
fill(reachp, candlep, color= candle > reach ? color.new(#00CC00, 75) : color.new(#CC0000, 75))



buy  =  bull ? label.new(bar_index, y1, sma4 >= sma5 ? "Buy" : "Strong Buy", xloc.bar_index, yloc.price, #00CC00, label.style_label_up,color.white, size.normal) : na
sell =  bear ? label.new(bar_index, y2, sma4 <= sma5 ? "Sell" : "Strong Sell", xloc.bar_index, yloc.price, #CC0000, label.style_label_down, color.white, size.normal) : na

trigger2 = bull ? 1 : 0
countBull = ta.barssince(bull)
countBear = ta.barssince(bear)
trigger   = nz(countBull, bar_index) < nz(countBear, bar_index) ? 1 : 0
atrBand = ta.atr(atrLen) * atrRisk
atrStop = trigger == 1 ? low - atrBand : high + atrBand


lastTrade(src) => ta.valuewhen(bull or bear , src, 0)


entry = levels ? label.new(time, close, "ENTRY " + str.tostring(lastTrade(close), decimals), xloc.bar_time, yloc.price, color.rgb(0, 255, 251), label.style_label_left, color.white, size.normal) : na
label.set_x(entry, label.get_x(entry) + math.round(ta.change(time) * lvlDistance))
label.set_y(entry, lastTrade(close))
label.delete(entry[1])



stop_y = lastTrade(atrStop)
stop  = levels ? label.new(time, close, "SL " + str.tostring(stop_y, decimals), xloc.bar_time, yloc.price, red2, label.style_label_left, color.white, size.normal) : na
label.set_x(stop, label.get_x(stop) + math.round(ta.change(time) * lvlDistance))
label.set_y(stop, stop_y)
label.delete(stop[1])

tp1Rl_y = (lastTrade(close)-lastTrade(atrStop))*1 + lastTrade(close)
tp1Rl   = levels ? label.new(time, close, "1:1 TP " + str.tostring(tp1Rl_y, decimals), xloc.bar_time, yloc.price, green2, label.style_label_left, color.white, size.normal ) : na
label.set_x(tp1Rl, label.get_x(tp1Rl) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp1Rl, tp1Rl_y)
label.delete(tp1Rl[1])

tp2RL_y = (lastTrade(close)-lastTrade(atrStop))*2 + lastTrade(close)
tp2RL   = levels ? label.new(time, close, "2:1 TP " + str.tostring(tp2RL_y, decimals), xloc.bar_time, yloc.price, green2, label.style_label_left, color.white, size.normal) : na
label.set_x(tp2RL, label.get_x(tp2RL) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp2RL, tp2RL_y)
label.delete(tp2RL[1])

tp3RL_y = (lastTrade(close)-lastTrade(atrStop))*3 + lastTrade(close)
tp3RL   = levels ? label.new(time, close, "3:1 TP " + str.tostring(tp3RL_y, decimals), xloc.bar_time, yloc.price, green2, label.style_label_left, color.white, size.normal) : na
label.set_x(tp3RL, label.get_x(tp3RL) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp3RL, tp3RL_y)
label.delete(tp3RL[1])

style = linesStyle == "SOLID" ? line.style_solid : linesStyle == "DASHED" ? line.style_dashed : line.style_dotted
lineEntry = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), lastTrade(close), bar_index + lvlDistance, lastTrade(close), xloc.bar_index, extend.none, color.rgb(0, 255, 251), style, 2) : na, line.delete(lineEntry[1])
lineStop  = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), stop_y, bar_index + lvlDistance, stop_y, xloc.bar_index, extend.none, #CC0000, style, 2) : na, line.delete(lineStop[1])
lineTp1Rl   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp1Rl_y, bar_index + lvlDistance, tp1Rl_y, xloc.bar_index, extend.none, green2, style, 2) : na, line.delete(lineTp1Rl[1])
lineTp2RL   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp2RL_y, bar_index + lvlDistance, tp2RL_y, xloc.bar_index, extend.none, green2, style, 2) : na, line.delete(lineTp2RL[1])
lineTp3RL   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp3RL_y, bar_index + lvlDistance, tp3RL_y, xloc.bar_index, extend.none, green2, style, 2) : na, line.delete(lineTp3RL[1])



//alertcondition(bull, title='Buy Signal', message = "BUY")
//alertcondition(bear, title='Sell Signal', message = "Sell") 
alertcondition(bear or bull, title='Sell Or Buy Signal', message = "Sell Or Sell") 

var longHigh = 0.0
var label longLabel = na
var label shortLabel = na

if bull
    shortLabel := na
    longHigh := high
    longLabel := label.new(bar_index, high, str.tostring(high),style = label.style_label_down, color=color.new(green, 20))

if high > longHigh
    longHigh := high
    longLabel.set_x(bar_index)
    longLabel.set_text("Profits " + str.tostring(high))
    longLabel.set_y(high)
    label.set_textcolor(longLabel, color.white)

var shortLow = 0.0

if bear
    longLabel := na
    shortLow := low
    shortLabel := label.new(bar_index, low, str.tostring(low), style = label.style_label_up, color = color.new(red, 20))

if low < shortLow
    shortLow := low
    shortLabel.set_x(bar_index)
    shortLabel.set_text("Profits "+str.tostring(low))
    shortLabel.set_y(low)
    label.set_textcolor(shortLabel, color.white)

dashboard_position  = input.session("Top Right", "Posision", ["Top Right", "Bottom Right", "Top Left", "Bottom Left", "Top Center", "Bottom Center", "Middle Right"], group = 'Table Settings')
text_size = input.session('Small', "Size", options = ["Tiny", "Small", "Normal", "Large"], group = 'Table Settings')
show_1m = input(true, title = 'Show 1m', group = 'Timeframe Settings')
show_3m = input(true, title = 'Show 3m ', group = 'Timeframe Settings')
show_5m = input(true, title = 'Show 5m', group = 'Timeframe Settings')
show_8m = input(false, title = 'Show 8m', group = 'Timeframe Settings')
show_12m = input(false, title = 'Show 12m', group = 'Timeframe Settings')
show_15m = input(true, title = 'Show 15m', group = 'Timeframe Settings')
show_20m = input(false, title = 'Show 20m', group = 'Timeframe Settings')
show_30m = input(false, title = 'Show 30m', group = 'Timeframe Settings')
show_45m = input(false, title = 'Show 45m', group = 'Timeframe Settings')
show_1h = input(true, title = 'Show 1h', group = 'Timeframe Settings')
show_2h = input(false, title = 'Show 2h', group = 'Timeframe Settings')
show_3h = input(false, title = 'Show 3h', group = 'Timeframe Settings')
show_4h = input(true, title = 'Show 4h', group = 'Timeframe Settings')
show_D = input(false, title = 'Show D', group = 'Timeframe Settings')
show_W = input(false, title = 'Show W', group = 'Timeframe Settings')
show_M = input(false, title = 'Show M', group = 'Timeframe Settings')

//
text_color = #d1d4dc
table_color = color.gray
uptrend_indicator = "🟢"
downtrend_indicator = "🔴"
neutraltrend_indicator = "⚫️"
ema_length = 50
ema_src =close
max_table_size = 200
min_table_size = 10

var table_position = dashboard_position == 'Top Right' ? position.top_right :
  dashboard_position == 'Top Left' ? position.top_left :
  dashboard_position == 'Top Center' ? position.top_center :
  dashboard_position == 'Bottom Right' ? position.bottom_right :
  dashboard_position == 'Bottom Left' ? position.bottom_left :
  dashboard_position == 'Bottom Center' ? position.bottom_center :
  dashboard_position == 'Middle Right' ? position.middle_right :
  dashboard_position == 'Middle Left' ? position.middle_left : position.middle_right
  
var table_text_size = text_size == 'Normal' ? size.normal :
  text_size == 'Large' ? size.large :
  text_size == 'Tiny' ? size.tiny :
  text_size == 'Small' ? size.small : size.normal

var t = table.new(table_position, 15, math.abs(max_table_size - min_table_size) + 2,
  frame_color = table_color,
  frame_width = 2,
  border_color = table_color,
  border_width = 2)

calc_smma(src, len) =>
    var float smma = na
    smma := na(smma) ? ta.sma(src, len) : (smma[1] * (len - 1) + src) / len
    smma

calc_zlema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    d = ema1 - ema2
    ema1 + d

check_impulse() =>
    impulseLength = 34
    impulseStrength = 9

    hi = calc_smma(high, impulseLength)
    lo = calc_smma(low, impulseLength)
    mi = calc_zlema(hlc3, impulseLength)

    md = (mi > hi) ? (mi - hi) : (mi < lo) ? (mi - lo) : 0
    md_prev = (mi[1] > hi[1]) ? (mi[1] - hi[1]) : (mi[1] < lo[1]) ? (mi[1] - lo[1]) : 0

    sb = ta.sma(md, impulseStrength)
    sb_prev = ta.sma(md_prev, impulseStrength)

    sh = md - sb
    sh_prev = md_prev - sb_prev

    is_impulse = sh != 0 and sh_prev != 0
    is_impulse

get_candle_values() =>
    current_candle = ta.ema(ema_src, ema_length)
    previous_candle = current_candle[1]
    [current_candle, previous_candle, check_impulse()]

get_trend_indicator(current_candle, previous_candle, impulse) =>
  not impulse ? neutraltrend_indicator : current_candle > previous_candle ? uptrend_indicator : current_candle < previous_candle ? downtrend_indicator : neutraltrend_indicator

[current_1m, previous_1m, impulse_1m] = request.security(syminfo.tickerid, "1", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_3m, previous_3m, impulse_3m] = request.security(syminfo.tickerid, "3", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_5m, previous_5m, impulse_5m] = request.security(syminfo.tickerid, "5", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_8m, previous_8m, impulse_8m] = request.security(syminfo.tickerid, "8", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_12m, previous_12m, impulse_12m] = request.security(syminfo.tickerid, "12", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_15m, previous_15m, impulse_15m] = request.security(syminfo.tickerid, "15", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_20m, previous_20m, impulse_20m] = request.security(syminfo.tickerid, "20", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_30m, previous_30m, impulse_30m] = request.security(syminfo.tickerid, "30", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_45m, previous_45m, impulse_45m] = request.security(syminfo.tickerid, "45", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_1h, previous_1h, impulse_1h] = request.security(syminfo.tickerid, "60", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_2h, previous_2h, impulse_2h] = request.security(syminfo.tickerid, "120", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_3h, previous_3h, impulse_3h] = request.security(syminfo.tickerid, "180", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_4h, previous_4h, impulse_4h] = request.security(syminfo.tickerid, "240", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_D, previous_D, impulse_D] = request.security(syminfo.tickerid, "D", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_W, previous_W, impulse_W] = request.security(syminfo.tickerid, "W", get_candle_values(), lookahead = barmerge.lookahead_on)
[current_M, previous_M, impulse_M] = request.security(syminfo.tickerid, "M", get_candle_values(), lookahead = barmerge.lookahead_on)

if (barstate.islast)
    if (show_1m)
        table.cell(t, 1, 2, "1m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 2, get_trend_indicator(current_1m, previous_1m, impulse_1m), text_color = text_color, text_size = table_text_size)

    if (show_3m)
        table.cell(t, 1, 3, "3m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 3, get_trend_indicator(current_3m, previous_3m, impulse_3m), text_color = text_color, text_size = table_text_size)

    if (show_5m)
        table.cell(t, 1, 4, "5m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 4, get_trend_indicator(current_5m, previous_5m, impulse_5m), text_color = text_color, text_size = table_text_size)

    if (show_8m)
        table.cell(t, 1, 5, "8m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 5, get_trend_indicator(current_8m, previous_8m, impulse_8m), text_color = text_color, text_size = table_text_size)

    if (show_12m)
        table.cell(t, 1, 6, "12m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 6, get_trend_indicator(current_12m, previous_12m, impulse_12m), text_color = text_color, text_size = table_text_size)

    if (show_15m)
        table.cell(t, 1, 7, "15m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 7, get_trend_indicator(current_15m, previous_15m, impulse_15m), text_color = text_color, text_size = table_text_size)

    if (show_20m)
        table.cell(t, 1, 8, "20m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 8, get_trend_indicator(current_20m, previous_20m, impulse_20m), text_color = text_color, text_size = table_text_size)

    if (show_30m)
        table.cell(t, 1, 9, "30m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 9, get_trend_indicator(current_30m, previous_30m, impulse_30m), text_color = text_color, text_size = table_text_size)

    if (show_45m)
        table.cell(t, 1, 10, "45m", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 10, get_trend_indicator(current_45m, previous_45m, impulse_45m), text_color = text_color, text_size = table_text_size)

    if (show_1h)
        table.cell(t, 1, 11, "1h", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 11, get_trend_indicator(current_1h, previous_1h, impulse_1h), text_color = text_color, text_size = table_text_size)

    if (show_2h)
        table.cell(t, 1, 12, "2h", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 12, get_trend_indicator(current_2h, previous_2h, impulse_2h), text_color = text_color, text_size = table_text_size)

    if (show_3h)
        table.cell(t, 1, 13, "3h", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 13, get_trend_indicator(current_3h, previous_3h, impulse_3h), text_color = text_color, text_size = table_text_size)

    if (show_4h)
        table.cell(t, 1, 14, "4h", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 14, get_trend_indicator(current_4h, previous_4h, impulse_4h), text_color = text_color, text_size = table_text_size)

    if (show_D)
        table.cell(t, 1, 15, "D", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 15, get_trend_indicator(current_D, previous_D, impulse_D), text_color = text_color, text_size = table_text_size)

    if (show_W)
        table.cell(t, 1, 16, "W", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 16, get_trend_indicator(current_W, previous_W, impulse_W), text_color = text_color, text_size = table_text_size)

    if (show_M)
        table.cell(t, 1, 17, "M", text_color = text_color, text_size = table_text_size)
        table.cell(t, 5, 17, get_trend_indicator(current_M, previous_M, impulse_M), text_color = text_color, text_size = table_text_size)


confidence(pearsonR) =>
    switch
        pearsonR < 0.2  => "Extremely Weak"
        pearsonR < 0.3  => "Very Weak"
        pearsonR < 0.4  => "Weak"
        pearsonR < 0.5  => "Mostly Weak"
        pearsonR < 0.6  => "Somewhat Weak"
        pearsonR < 0.7  => "Moderately Weak"
        pearsonR < 0.8  => "Moderate"
        pearsonR < 0.9  => "Moderately Strong"
        pearsonR < 0.92 => "Mostly Strong"
        pearsonR < 0.94 => "Strong"
        pearsonR < 0.96 => "Very Strong"
        pearsonR < 0.98 => "Exceptionally Strong"
        =>                        "Ultra Strong"

getTablePosition(string pos) =>
    switch pos
        "Bottom Right"  => position.bottom_right
        "Bottom Center" => position.bottom_center        
        "Bottom Left"   => position.bottom_left
        "Top Right"     => position.top_right
        "Top Left"      => position.top_left
        "Top Center"    => position.top_center
        "Middle Right"  => position.middle_right
        =>                 position.middle_left // "Middle Left" - default

// Calculate deviations for given length
calcDev(float source, int length) =>
    float logSource  = math.log(source)
    var int period_1 = length - 1
    if barstate.islast
        float sumX  = 0.0
        float sumXX = 0.0
        float sumYX = 0.0
        float sumY  = 0.0
        for int i=1 to length
            float lSrc = logSource[i-1]
            sumX  += i
            sumXX += i * i
            sumYX += i * lSrc
            sumY  +=     lSrc
        float slope     = nz((length * sumYX - sumX * sumY) / (length * sumXX - sumX * sumX))
        float average   = sumY / length
        float intercept = average - (slope * sumX / length) + slope
        float sumDev = 0.0
        float sumDxx = 0.0
        float sumDyy = 0.0
        float sumDyx = 0.0
        float regres = intercept + slope * period_1 * 0.5
        float sumSlp = intercept
        for int i=0 to period_1
            float lSrc = logSource[i]
            float dxt  =   lSrc - average
            float dyt  = sumSlp - regres
            lSrc   -= sumSlp
            sumSlp += slope
            sumDxx +=  dxt * dxt
            sumDyy +=  dyt * dyt
            sumDyx +=  dxt * dyt
            sumDev += lSrc * lSrc
        float unStdDev = math.sqrt(sumDev / period_1) // unbiased
        float divisor  =    sumDxx * sumDyy
        float pearsonR = nz(sumDyx / math.sqrt(divisor))
        [unStdDev, pearsonR, slope, intercept]
    else
        [na, na, na, na]

string t1 = "In Long-Term Channel mode, if the channel is not visible, scroll back on the chart for additional historical data."
string t2 = "Pearson's R, a statistical measure in Adaptive Trend Finder, gauges the linear relationship between price and trend projection. A value closer to 1 indicates a strong positive correlation, reinforcing confidence in the trend direction based on historical price movements."

sourceInput = input.source(close, title="Source")

string group0 = "CHANNEL SETTINGS"
bool   periodMode       = input.bool  (         false, "Use Long-Term Channel", group=group0, tooltip=t1)
float  devMultiplier    = input.float (           2.0, "Deviation Multiplier:", group=group0, step=0.1)
color  colorInput       = input.color (  color.gray,             "", group=group0, inline=group0)
string lineStyle1       = input.string(       "Solid",             "", group=group0, inline=group0, options=["Solid", "Dotted", "Dashed"])
string extendStyle      = input.string("Extend Right",             "", group=group0, inline=group0, options=["Extend Right", "Extend Both", "Extend None", "Extend Left"])
int    fillTransparency = input.int   (            93, "Fill Transp:", group=group0, inline="mid", minval=0, maxval=100, step=1)
int channelTransparency = input.int   (            40, "Line Transp:", group=group0, inline="mid", minval=0, maxval=100, step=1)

string group1 = "MIDLINE SETTINGS"
int    transpInput  = input.int   (     100,      "Transp:", group=group1, inline=group1, minval=0, maxval=100, step=10)
int    lineWidth    = input.int   (       1,  "Line Width:", group=group1, inline=group1)
string midLineStyle = input.string("Solid",              "", group=group1, inline=group1, options=["Dotted", "Solid", "Dashed"])

var string EXTEND_STYLE = switch extendStyle
    "Extend Right" => extend.right
    "Extend Both"  => extend.both
    "Extend None"  => extend.none
    =>                extend.left

// Length Inputs
var array<int> Periods = periodMode ? array.from(na,100,150,200,250,300,350,400,450,500,550,600,650,700,750,800,850,900,950,1000) : array.from(na,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200)

// Calculate deviations, correlation, slope, and intercepts for different lengths
[stdDev01, pearsonR01, slope01, intercept01] = calcDev(sourceInput, Periods.get( 1))
[stdDev02, pearsonR02, slope02, intercept02] = calcDev(sourceInput, Periods.get( 2))
[stdDev03, pearsonR03, slope03, intercept03] = calcDev(sourceInput, Periods.get( 3))
[stdDev04, pearsonR04, slope04, intercept04] = calcDev(sourceInput, Periods.get( 4))
[stdDev05, pearsonR05, slope05, intercept05] = calcDev(sourceInput, Periods.get( 5))
[stdDev06, pearsonR06, slope06, intercept06] = calcDev(sourceInput, Periods.get( 6))
[stdDev07, pearsonR07, slope07, intercept07] = calcDev(sourceInput, Periods.get( 7))
[stdDev08, pearsonR08, slope08, intercept08] = calcDev(sourceInput, Periods.get( 8))
[stdDev09, pearsonR09, slope09, intercept09] = calcDev(sourceInput, Periods.get( 9))
[stdDev10, pearsonR10, slope10, intercept10] = calcDev(sourceInput, Periods.get(10))
[stdDev11, pearsonR11, slope11, intercept11] = calcDev(sourceInput, Periods.get(11))
[stdDev12, pearsonR12, slope12, intercept12] = calcDev(sourceInput, Periods.get(12))
[stdDev13, pearsonR13, slope13, intercept13] = calcDev(sourceInput, Periods.get(13))
[stdDev14, pearsonR14, slope14, intercept14] = calcDev(sourceInput, Periods.get(14))
[stdDev15, pearsonR15, slope15, intercept15] = calcDev(sourceInput, Periods.get(15))
[stdDev16, pearsonR16, slope16, intercept16] = calcDev(sourceInput, Periods.get(16))
[stdDev17, pearsonR17, slope17, intercept17] = calcDev(sourceInput, Periods.get(17))
[stdDev18, pearsonR18, slope18, intercept18] = calcDev(sourceInput, Periods.get(18))
[stdDev19, pearsonR19, slope19, intercept19] = calcDev(sourceInput, Periods.get(19))

if barstate.islast
    // Find the highest Pearson's R
    float highestPearsonR = math.max(pearsonR01, pearsonR02, pearsonR03, pearsonR04, pearsonR05, pearsonR06, pearsonR07, pearsonR08, pearsonR09, pearsonR10, pearsonR11, pearsonR12, pearsonR13, pearsonR14, pearsonR15, pearsonR16, pearsonR17, pearsonR18, pearsonR19)

    // Determine selected length, slope, intercept, and deviations
    int   detectedPeriod  = na
    float detectedSlope   = na
    float detectedIntrcpt = na
    float detectedStdDev  = na

    switch highestPearsonR
        pearsonR01 =>
            detectedPeriod  := Periods.get(1)
            detectedSlope   :=     slope01
            detectedIntrcpt := intercept01
            detectedStdDev  :=    stdDev01
        pearsonR02 =>
            detectedPeriod  := Periods.get(2)
            detectedSlope   :=     slope02
            detectedIntrcpt := intercept02
            detectedStdDev  :=    stdDev02
        pearsonR03 =>
            detectedPeriod  := Periods.get(3)
            detectedSlope   :=     slope03
            detectedIntrcpt := intercept03
            detectedStdDev  :=    stdDev03
        pearsonR04 =>
            detectedPeriod  := Periods.get(4)
            detectedSlope   :=     slope04
            detectedIntrcpt := intercept04
            detectedStdDev  :=    stdDev04
        pearsonR05 =>
            detectedPeriod  := Periods.get(5)
            detectedSlope   :=     slope05
            detectedIntrcpt := intercept05
            detectedStdDev  :=    stdDev05
        pearsonR06 =>
            detectedPeriod  := Periods.get(6)
            detectedSlope   :=     slope06
            detectedIntrcpt := intercept06
            detectedStdDev  :=    stdDev06
        pearsonR07 =>
            detectedPeriod  := Periods.get(7)
            detectedSlope   :=     slope07
            detectedIntrcpt := intercept07
            detectedStdDev  :=    stdDev07
        pearsonR08 =>
            detectedPeriod  := Periods.get(8)
            detectedSlope   :=     slope08
            detectedIntrcpt := intercept08
            detectedStdDev  :=    stdDev08
        pearsonR09 =>
            detectedPeriod  := Periods.get(9)
            detectedSlope   :=     slope09
            detectedIntrcpt := intercept09
            detectedStdDev  :=    stdDev09
        pearsonR10 => 
            detectedPeriod  := Periods.get(10)
            detectedSlope   :=     slope10
            detectedIntrcpt := intercept10
            detectedStdDev  :=    stdDev10
        pearsonR11 =>        
            detectedPeriod  := Periods.get(11)
            detectedSlope   :=     slope11
            detectedIntrcpt := intercept11
            detectedStdDev  :=    stdDev11
        pearsonR12 =>
            detectedPeriod  := Periods.get(12)
            detectedSlope   :=     slope12
            detectedIntrcpt := intercept12
            detectedStdDev  :=    stdDev12
        pearsonR13 =>
            detectedPeriod  := Periods.get(13)
            detectedSlope   :=     slope13
            detectedIntrcpt := intercept13
            detectedStdDev  :=    stdDev13
        pearsonR14 =>
            detectedPeriod  := Periods.get(14)
            detectedSlope   :=     slope14
            detectedIntrcpt := intercept14
            detectedStdDev  :=    stdDev14
        pearsonR15 =>
            detectedPeriod  := Periods.get(15)
            detectedSlope   :=     slope15
            detectedIntrcpt := intercept15
            detectedStdDev  :=    stdDev15
        pearsonR16 =>
            detectedPeriod  := Periods.get(16)
            detectedSlope   :=     slope16
            detectedIntrcpt := intercept16
            detectedStdDev  :=    stdDev16
        pearsonR17 =>
            detectedPeriod  := Periods.get(17)
            detectedSlope   :=     slope17
            detectedIntrcpt := intercept17
            detectedStdDev  :=    stdDev17
        pearsonR18 =>
            detectedPeriod  := Periods.get(18)
            detectedSlope   :=     slope18
            detectedIntrcpt := intercept18
            detectedStdDev  :=    stdDev18
        => // pearsonR19
            detectedPeriod  := Periods.get(19)
            detectedSlope   :=     slope19
            detectedIntrcpt := intercept19
            detectedStdDev  :=    stdDev19

    var line upperLine = na,   var linefill upperFill = na
    var line  baseLine = na
    var line lowerLine = na,   var linefill lowerFill = na

    // Calculate start and end price based on detected slope and intercept
    float startPrice = math.exp(detectedIntrcpt + detectedSlope * (detectedPeriod - 1))
    float   endPrice = math.exp(detectedIntrcpt)
    
    int         startAtBar = bar_index - detectedPeriod + 1
    var color ChannelColor = color.new(colorInput, channelTransparency)

    if na(baseLine)
        baseLine := line.new(startAtBar, startPrice, bar_index, endPrice,
                             width=lineWidth, extend=EXTEND_STYLE,
                             color=color.new(colorInput, transpInput),
                             style=midLineStyle == "Dotted" ? line.style_dotted :
                                   midLineStyle == "Dashed" ? line.style_dashed : line.style_solid)
    else
        line.set_xy1(baseLine, startAtBar, startPrice)
        line.set_xy2(baseLine,  bar_index,   endPrice)

    float upperStartPrice = startPrice * math.exp(devMultiplier * detectedStdDev)
    float upperEndPrice   =   endPrice * math.exp(devMultiplier * detectedStdDev)
    if na(upperLine)
        upperLine := line.new(startAtBar, upperStartPrice, bar_index, upperEndPrice,
                             width=1, extend=EXTEND_STYLE,
                             color=ChannelColor,
                             style=lineStyle1 == "Dotted" ? line.style_dotted :
                                   lineStyle1 == "Dashed" ? line.style_dashed : line.style_solid)
    else
        line.set_xy1  (upperLine, startAtBar, upperStartPrice)
        line.set_xy2  (upperLine,  bar_index,   upperEndPrice)
        line.set_color(upperLine, colorInput)

    float lowerStartPrice = startPrice / math.exp(devMultiplier * detectedStdDev)
    float   lowerEndPrice =   endPrice / math.exp(devMultiplier * detectedStdDev)
    if na(lowerLine)
        lowerLine := line.new(startAtBar, lowerStartPrice, bar_index, lowerEndPrice,
                             width=1, extend=EXTEND_STYLE,
                             color=ChannelColor,
                             style=lineStyle1 == "Dotted" ? line.style_dotted :
                                   lineStyle1 == "Dashed" ? line.style_dashed : line.style_solid)
    else
        line.set_xy1  (lowerLine, startAtBar, lowerStartPrice)
        line.set_xy2  (lowerLine,  bar_index,   lowerEndPrice)
        line.set_color(lowerLine, colorInput)

    if na(upperFill)
        upperFill := linefill.new(upperLine, baseLine, color=color.new(colorInput, fillTransparency))
    if na(lowerFill)
        lowerFill := linefill.new(baseLine, lowerLine, color=color.new(colorInput, fillTransparency))



len1 = input.int(14, minval=1, title='Length')
amplitude = input(title='Amplitude', defval=3)
channelDeviation = input(title='Channel Deviation', defval=2)
// Tralling Step
src5 = close
up2 = ta.rma(math.max(ta.change(src5), 0), len1)

var int trend = 0
var int nextTrend = 0
var float maxLowPrice = nz(low[1], low)
var float minHighPrice = nz(high[1], high)

var float up1 = 0.0
var float down1 = 0.0
float atrHigh = 0.0
float atrLow = 0.0
float arrowUp = na
float arrowDown = na

atr2 = ta.atr(100) / 2
dev = channelDeviation * atr2

highPrice1 = high[math.abs(ta.highestbars(amplitude))]
lowPrice1 = low[math.abs(ta.lowestbars(amplitude))]
highma = ta.sma(high, amplitude)
lowma = ta.sma(low, amplitude)

if nextTrend == 1
    maxLowPrice := math.max(lowPrice1, maxLowPrice)

    if highma < maxLowPrice and close < nz(low[1], low)
        trend := 1
        nextTrend := 0
        minHighPrice := highPrice1
        minHighPrice
else
    minHighPrice := math.min(highPrice1, minHighPrice)

    if lowma > minHighPrice and close > nz(high[1], high)
        trend := 0
        nextTrend := 1
        maxLowPrice := lowPrice1
        maxLowPrice

if trend == 0
    if not na(trend[1]) and trend[1] != 0
        up1 := na(down1[1]) ? down1 : down1[1]
        arrowUp := up - atr2
        arrowUp
    else
        up1 := na(up1[1]) ? maxLowPrice : math.max(maxLowPrice, up1[1])
        up1
    atrHigh := up1 + dev
    atrLow := up1 - dev
    atrLow
else
    if not na(trend[1]) and trend[1] != 1
        down1 := na(up1[1]) ? up1 : up1[1]
        arrowDown := down1 + atr2
        arrowDown
    else
        down1 := na(down1[1]) ? minHighPrice : math.min(minHighPrice, down1[1])
        down1
    atrHigh := down1 + dev
    atrLow := down1 - dev
    atrLow

ht = trend == 0 ? up1 : down1

var color buyColor = color.teal
var color sellColor = color.red

htColor = trend == 0 ? buyColor : sellColor
htPlot = plot(ht, title='ultra', linewidth=2, color=htColor)

utrend = ta.crossunder(trend, 1)
dtrend = ta.crossover(trend, 0)

