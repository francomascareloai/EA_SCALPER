//@version=5
indicator("Pro V3 [SMRT Algo]", overlay = true)

// ============================[INPUTS]============================ //
// Signal Inputs
signalMode = input.string("All", "Signal Mode", options=["All", "Normal", "Strong"], group="BUY/SELL", inline='1')
sigsensiviti = input.float(5, "Signal Sensitivity (1-15)", minval=1, maxval=15, tooltip="Changes the signal display frequency", group="BUY/SELL", inline='j') 
showCandleColors = input.bool(true, "Show Bar Colors", group="BUY/SELL", inline='ee')
bullishColor = input.color(#01d7ee, '', group="BUY/SELL", inline='ee')
bearishColor = input.color(#cd0542, '', group="BUY/SELL", inline='ee')
maFilter = input.bool(false, "MA Filter", group="BUY/SELL", inline='rr')
maType = input.string("SMA", "", options=["SMA", "EMA", "WMA", "VWMA", "HMA"], group="BUY/SELL", inline='rr')
maLength = input.int(200, "", minval=1, group="BUY/SELL", inline='rr')


trailing_stop_enabled = input.bool(false, title="Trailing Stop Loss", group = 'INDICATORS')
POIswitch   = input.bool (false, "Supply/Demand", group='INDICATORS')
powers_ema = input.bool(title="Power MA", defval=false, group = 'INDICATORS')
marketStructure = input.bool(false, 'Market Structure', inline = 'overlayLine5', group = 'INDICATORS')
enableSR   = input(false, 'S/R', inline = 'overlayLine9', group = 'INDICATORS')
reversal = input.bool(false, title="Reversals", group="INDICATORS")
reversalBandsEnabled = input.bool(false, title="Reversal Bands", group = "INDICATORS")
autoTL          = input.bool(false, "Trend Lines", group = "INDICATORS")
LongTrendAverage  = input(false, 'Trend Ribbon', group = "INDICATORS")
CirrusCloud       = input(false, 'Retest Zone', group = 'INDICATORS')







// TP/SL Inputs
riskmanage = input.string("No", "TP/SL", options=["Yes", "No"], inline='1', group="TP/SL")
riskmanage_bool = riskmanage == "Yes"
tpstrength = input.float(3, "Risk Management", tooltip="Multiplier for TP levels", group="TP/SL", minval=0.1, step=0.1)
slColor = input.color(#d00010, "SL Color", group="TP/SL")
entryColor = input.color(#9598a1, "Entry Color", group="TP/SL")
tp1Color = input.color(#16a000, "TP-1 Color", group="TP/SL")
tp2Color = input.color(#16a000, "TP-2 Color", group="TP/SL")
tp3Color = input.color(#16a000, "TP-3 Color", group="TP/SL")
longtp = input.color(#16a000, "TP-3 Color", group="TP/SL")
shorttp = input.color(#16a000, "TP-3 Color", group="TP/SL")
useTP1 = true
multTP1 = tpstrength
useTP2 = true
multTP2 = tpstrength * 2
useTP3 = true
multTP3 = tpstrength * 3

// Colors for TP breakout labels

supertrend(_src, factor, atrLen) =>
	atr = ta.atr(atrLen)
	upperBand = _src + factor * atr
	lowerBand = _src - factor * atr
	prevLowerBand = nz(lowerBand[1])
	prevUpperBand = nz(upperBand[1])
	lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
	upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
	int direction = na
	float superTrend = na
	prevSuperTrend = superTrend[1]
	if na(atr[1])
		direction := 1
	else if prevSuperTrend == prevUpperBand
		direction := close > upperBand ? -1 : 1
	else
		direction := close < lowerBand ? 1 : -1
	superTrend := direction == -1 ? lowerBand : upperBand
	[superTrend, direction]
lr_slope(_src, _len) =>
    x = 0.0, y = 0.0, x2 = 0.0, xy = 0.0
    for i = 0 to _len - 1
        val = _src[i]
        per = i + 1
        x += per
        y += val
        x2 += per * per
        xy += val * per
    _slp = (_len * xy - x * y) / (_len * x2 - x * x)
    _avg = y / _len
    _int = _avg - _slp * x / _len + _slp
    [_slp, _avg, _int]
lr_dev(_src, _len, _slp, _avg, _int) =>
    upDev = 0.0, dnDev = 0.0
    val = _int
    for j = 0 to _len - 1
        price = high[j] - val
        if price > upDev
            upDev := price
        price := val - low[j]
        if price > dnDev
            dnDev := price
        price := _src[j]
        val += _slp
    [upDev, dnDev]

barsL       = 10
barsR       = 10
pivotHigh = fixnan(ta.pivothigh(barsL, barsR)[1])
pivotLow = fixnan(ta.pivotlow(barsL, barsR)[1])
source = close, period = 150
[s1, a1, i1] = lr_slope(source, period)
[upDev, dnDev] = lr_dev(source, period, s1, a1, i1)

y1 = low - (ta.atr(30) * 2), y1B = low - ta.atr(30)
y2 = high + (ta.atr(30) * 2), y2B = high + ta.atr(30)
x1 = bar_index - period + 1, _y1 = i1 + s1 * (period - 1), x2 = bar_index, _y2 = i1



// ============================[MOVING AVERAGE FUNCTIONS]============================ //
hma(src, length) =>
    ta.wma(2 * ta.wma(src, length / 2) - ta.wma(src, length), math.round(math.sqrt(length)))

getMA(type, src, length) =>
    switch type
        "SMA" => ta.sma(src, length)
        "EMA" => ta.ema(src, length)
        "WMA" => ta.wma(src, length)
        "VWMA" => ta.vwma(src, length)
        "HMA" => hma(src, length)

// Calculate MA
selectedMA = getMA(maType, close, maLength)



// ============================[CALCULATIONS]============================ //
factor = 11
signals_show = true
emaLength = 200
emaSource = close
ema = ta.ema(emaSource, emaLength)

sma1 = ta.sma(close, 8)
sma2 = ta.sma(close, 9)
sma3 = ta.sma(close, 13)
[supertrend, direction] = supertrend(open, sigsensiviti, factor)

// Apply MA Filter
bull = ta.crossover(close, supertrend) and close >= sma3 and not (close[1] > ema and close > ema) and (not maFilter or close > selectedMA)
bear = ta.crossunder(close, supertrend) and close <= sma3 and not (not (close[1] > ema and close > ema)) and (not maFilter or close < selectedMA)
Sbull = ta.crossover(close, supertrend) and close >= sma3 and (close[1] > ema and close > ema) and (not maFilter or close > selectedMA)
Sbear = ta.crossunder(close, supertrend) and close <= sma3 and not (close[1] > ema and close > ema) and (not maFilter or close < selectedMA)

// Trend Signals with Display Mode Filter
showNormalBuy = signalMode == "All" or signalMode == "Normal"
showStrongBuy = signalMode == "All" or signalMode == "Strong"
showNormalSell = signalMode == "All" or signalMode == "Normal"
showStrongSell = signalMode == "All" or signalMode == "Strong"

// Filter signals based on signalMode
valid_bull = bull and showNormalBuy
valid_Sbull = Sbull and showStrongBuy
valid_bear = bear and showNormalSell
valid_Sbear = Sbear and showStrongSell

// ============================[POSITION AND TP BREAKOUT LOGIC]============================ //
// Position Direction
var float pos = 0.0
pos := valid_bull or valid_Sbull ? 1 : valid_bear or valid_Sbear ? -1 : pos[1]

// Track long and short position states and TP breakout states
var bool longPositionActive = false
var bool shortPositionActive = false
var bool longTp1Broken = false
var bool longTp2Broken = false
var bool longTp3Broken = false
var bool shortTp1Broken = false
var bool shortTp2Broken = false
var bool shortTp3Broken = false

// Update position states and reset TP flags
if valid_bull or valid_Sbull
    longPositionActive := true
    shortPositionActive := false
    longTp1Broken := false
    longTp2Broken := false
    longTp3Broken := false
    shortTp1Broken := false
    shortTp2Broken := false
    shortTp3Broken := false

if valid_bear or valid_Sbear
    shortPositionActive := true
    longPositionActive := false
    longTp1Broken := false
    longTp2Broken := false
    longTp3Broken := false
    shortTp1Broken := false
    shortTp2Broken := false
    shortTp3Broken := false

if pos == 0
    longPositionActive := false
    shortPositionActive := false
    longTp1Broken := false
    longTp2Broken := false
    longTp3Broken := false
    shortTp1Broken := false
    shortTp2Broken := false
    shortTp3Broken := false



// Combine signal-based and TP breakout-based candle colors


// Plot buy/sell signals
plotshape(signals_show and valid_bull ? true : na, title="buy", text='buy', style=shape.labelup, location=location.belowbar, color=#01d7ee, textcolor=color.white, size=size.small)
plotshape(signals_show and valid_bear ? true : na, title="sell", text='sell', style=shape.labeldown, color=#cd0542, textcolor=color.white, size=size.small)
plotshape(signals_show and valid_Sbull ? true : na, title="buy+", text='buy+', style=shape.labelup, location=location.belowbar, color=#01d7ee, textcolor=color.white, size=size.small)
plotshape(signals_show and valid_Sbear ? true : na, title="sell+", text='sell+', style=shape.labeldown, color=#cd0542, textcolor=color.white, size=size.small)

// ============================[CANDLE COLOR LOGIC]============================ //
// Variable to track the current signal state
var bool isBullish = false

// Update signal state based on signals
if valid_bull or valid_Sbull
    isBullish := true
if valid_bear or valid_Sbear
    isBullish := false

// Apply bar colors based on signal state
barcolor(showCandleColors and isBullish ? bullishColor : showCandleColors and not isBullish ? bearishColor : na)
// ============================[TP/SL LOGIC]============================ //
// Signal Type
var int signal_type = 0  // 0: None, 1: Bull, 2: Sbull, 3: Bear, 4: Sbear
signal_type := valid_bull ? 1 : valid_Sbull ? 2 : valid_bear ? 3 : valid_Sbear ? 4 : signal_type

// Get the entry price at the last valid signal
lastTrade(src) => ta.valuewhen(valid_bull or valid_Sbull or valid_bear or valid_Sbear, src, 0)
entry_y = lastTrade(close)

// Calculate direction: Long (1) for bull/Sbull, Short (-1) for bear/Sbear
direction1 = signal_type == 1 or signal_type == 2 ? 1 : signal_type == 3 or signal_type == 4 ? -1 : 0

// Calculate TP and SL based on direction
tp1_y = direction1 == 1 ? entry_y + (multTP1 * ta.atr(14)) : direction1 == -1 ? entry_y - (multTP1 * ta.atr(14)) : entry_y
tp2_y = direction1 == 1 ? entry_y + (multTP2 * ta.atr(14)) : direction1 == -1 ? entry_y - (multTP2 * ta.atr(14)) : entry_y
tp3_y = direction1 == 1 ? entry_y + (multTP3 * ta.atr(14)) : direction1 == -1 ? entry_y - (multTP3 * ta.atr(14)) : entry_y
// Detect first TP breakouts for long position
longTp1Breakout = ta.crossover(high, tp1_y) and longPositionActive and not longTp1Broken
longTp2Breakout = ta.crossover(high, tp2_y) and longPositionActive and not longTp2Broken
longTp3Breakout = ta.crossover(high, tp3_y) and longPositionActive and not longTp3Broken

// Detect first TP breakouts for short position
shortTp1Breakout = ta.crossunder(low, tp1_y) and shortPositionActive and not shortTp1Broken
shortTp2Breakout = ta.crossunder(low, tp2_y) and shortPositionActive and not shortTp2Broken
shortTp3Breakout = ta.crossunder(low, tp3_y) and shortPositionActive and not shortTp3Broken

// Set TP broken flags after first breakout
if longTp1Breakout
    longTp1Broken := true
if longTp2Breakout
    longTp2Broken := true
if longTp3Breakout
    longTp3Broken := true
if shortTp1Breakout
    shortTp1Broken := true
if shortTp2Breakout
    shortTp2Broken := true
if shortTp3Breakout
    shortTp3Broken := true

// Define candle color for TP breakouts (green for first TP1, TP2, or TP3 breakout)
candleColor1 = longTp1Breakout or longTp2Breakout or longTp3Breakout or shortTp1Breakout or shortTp2Breakout or shortTp3Breakout ? color.rgb(0, 255, 8) : na

// Determine Candle Color Based on Last Signal
var color candleColor = na
var bool hasSignal = false
if bull or Sbull
    candleColor := bullishColor
    hasSignal := true
else if bear or Sbear
    candleColor := bearishColor
    hasSignal := true
// Calculate SL based on TP1
slMultiplier = 1.0
stop_y = direction1 == 1 ? entry_y - (multTP1 * ta.atr(14) * slMultiplier) : direction1 == -1 ? entry_y + (multTP1 * ta.atr(14) * slMultiplier) : entry_y

// Add text labels above breakout candles for long positions
if longTp1Breakout
    label.new(
         bar_index, high, 
         text ="●", 
         color=color.rgb(0, 255, 8, 100), 
         textcolor=longtp, 
         style=label.style_label_down, 
         size=size.small
     )
if longTp2Breakout
    label.new(
         bar_index, high, 
         text="󠁯●", 
         color=color.rgb(0, 255, 8, 100), 
         textcolor=longtp, 
         style=label.style_label_down, 
         size=size.small
     )
if longTp3Breakout
    label.new(
         bar_index, high, 
         text="󠁯●", 
         color=color.rgb(0, 255, 8, 100), 
         textcolor=longtp, 
         style=label.style_label_down, 
         size=size.small
     )

// Add text labels below breakout candles for short positions
if shortTp1Breakout
    label.new(
         bar_index, low, 
         text="󠁯●", 
         color=color.rgb(0, 255, 8, 100), 
         textcolor=shorttp, 
         style=label.style_label_up, 
         size=size.small
     )
if shortTp2Breakout
    label.new(
         bar_index, low, 
         text="󠁯●", 
         color=color.rgb(0, 255, 8, 100), 
         textcolor=shorttp, 
         style=label.style_label_up, 
         size=size.small
     )
if shortTp3Breakout
    label.new(
         bar_index, low, 
         text="󠁯●", 
         color=color.rgb(0, 255, 8, 100), 
         textcolor=shorttp, 
         style=label.style_label_up, 
         size=size.small
     )

// Function to create labels
labelTpSl(cond, y, txt, bgColor, txtColor) =>
    var label labelTpSl = na
    if riskmanage_bool and cond
        labelTpSl := label.new(bar_index + 1, y, txt, xloc=xloc.bar_index, yloc=yloc.price, color=bgColor, style=label.style_label_left, textcolor=txtColor, size=size.small)
    label.delete(labelTpSl[1])

// Function to create lines
lineTpSl(cond, y, color, style) =>
    count = signal_type == 1 ? ta.barssince(valid_bull) : signal_type == 2 ? ta.barssince(valid_Sbull) : signal_type == 3 ? ta.barssince(valid_bear) : signal_type == 4 ? ta.barssince(valid_Sbear) : 0
    var line lineTpSl = na
    if riskmanage_bool and cond
        lineTpSl := line.new(bar_index - count, y, bar_index + 1, y, xloc=xloc.bar_index, extend=extend.none, color=color, style=style)
    line.delete(lineTpSl[1])

// Create labels and lines only when a valid signal is active
is_signal = signal_type != 0
linecolor = color.white
labelTpSl(is_signal, entry_y, "Entry : (" + str.tostring(math.round_to_mintick(entry_y)) + ")", entryColor, linecolor)
labelTpSl(is_signal, stop_y, "SL : (" + str.tostring(math.round_to_mintick(stop_y)) + ")", slColor, linecolor)
labelTpSl(is_signal and useTP1 and multTP1 != 0, tp1_y, "TP 1 : (" + str.tostring(math.round_to_mintick(tp1_y)) + ")", tp1Color, linecolor)
labelTpSl(is_signal and useTP2 and multTP2 != 0, tp2_y, "TP 2 : (" + str.tostring(math.round_to_mintick(tp2_y)) + ")", tp2Color, linecolor)
labelTpSl(is_signal and useTP3 and multTP3 != 0, tp3_y, "TP 3 : (" + str.tostring(math.round_to_mintick(tp3_y)) + ")", tp3Color, linecolor)

lineTpSl(is_signal, entry_y, entryColor, line.style_solid)
lineTpSl(is_signal, stop_y, slColor, line.style_solid)
lineTpSl(is_signal and useTP1 and multTP1 != 0, tp1_y, tp1Color, line.style_solid)
lineTpSl(is_signal and useTP2 and multTP2 != 0, tp2_y, tp2Color, line.style_solid)
lineTpSl(is_signal and useTP3 and multTP3 != 0, tp3_y, tp3Color, line.style_solid)


// Condition for TP1 breakout (price breaks above TP1 for long position)




// Inputs for Dashboard
enableDashboard = input.bool(true, "Dashboard", group="DASHBOARD SETTINGS")
locationDashboard = input.string("Bottom right", "Location", ["Top right", "Top left", "Middle right", "Middle left", "Bottom right", "Bottom left"], group="DASHBOARD SETTINGS")
sizeDashboard = input.string("Small", "Size", ["Tiny", "Small", "Normal"], group="DASHBOARD SETTINGS")
colorBackground = #2e2e2e
colorFrame = #000000
colorBorder = #2e2e2e

// EMA-based Trend Calculation
ema3 = ta.ema(close, 200)
emaBull = close > ema3

// Function to Fetch Trend Data for a Given Timeframe
securityNoRep(sym, res, src) =>
    bool bull3 = na
    bull3 := str.tonumber(res) == timeframe.multiplier ? src : bull3
    bull3 := str.tonumber(res) > timeframe.multiplier ? request.security(sym, res, src, barmerge.gaps_off, barmerge.lookahead_on) : bull3
    bull_array = request.security_lower_tf(syminfo.tickerid, str.tostring(timeframe.multiplier), src)
    if array.size(bull_array) > 1
        bull3 := array.pop(bull_array)
    array.clear(bull_array)
    bull3

// Trend Calculations for Different Timeframes
TF60Bull = securityNoRep(syminfo.tickerid, "60", emaBull)
TF120Bull = securityNoRep(syminfo.tickerid, "120", emaBull)
TF240Bull = securityNoRep(syminfo.tickerid, "240", emaBull)
TF720Bull = securityNoRep(syminfo.tickerid, "480", emaBull)
TFDBull = securityNoRep(syminfo.tickerid, "1440", emaBull)

// Determine Current Position Based on the Last Signal
var string currentPosition = na
var color positionBgColor = na
if bull or Sbull
    currentPosition := "Buy"
    positionBgColor := color.green
else if bear or Sbear
    currentPosition := "Sell"
    positionBgColor := color.red

// Dashboard Setup
var dashboard_loc = locationDashboard == "Top right" ? position.top_right : locationDashboard == "Top left" ? position.top_left : locationDashboard == "Middle right" ? position.middle_right : locationDashboard == "Middle left" ? position.middle_left : locationDashboard == "Bottom right" ? position.bottom_right : position.bottom_left
var dashboard_size = sizeDashboard == "Tiny" ? size.tiny : sizeDashboard == "Small" ? size.small : size.normal
var dashboard = table.new(dashboard_loc, 2, 18, colorBackground, colorFrame, 1, colorBorder, 1)

// Helper Functions for Dashboard Cells
dashboard_cell(column, row, txt, text_color) => table.cell(dashboard, column, row, txt, 0, 0, text_color, text_size=dashboard_size)
dashboard_cell_bg(column, row, col) => table.cell_set_bgcolor(dashboard, column, row, col)

// Populate Dashboard
if barstate.islast and enableDashboard
    dashboard_cell(0, 0, "SMRT Algo", color.white)
    dashboard_cell(1, 0, "Pro", color.white)
    table.merge_cells(dashboard, 0, 0, 0, 0)
    dashboard_cell(0, 1, "Current Position", color.white)
    dashboard_cell(1, 1, currentPosition == na ? "No Signal" : currentPosition, color.black), dashboard_cell_bg(1, 1, positionBgColor == na ? color.gray : positionBgColor)
    dashboard_cell(0, 2, "Current Trend", color.white)
    dashboard_cell(1, 2, emaBull ? "Bullish" : "Bearish", color.black), dashboard_cell_bg(1, 2, emaBull ? color.green : color.red)
    dashboard_cell(0, 7, "1 Hour", color.white)
    dashboard_cell(0, 8, "2 Hour", color.white)
    dashboard_cell(0, 9, "4 Hour", color.white)
    dashboard_cell(0, 10, "8 Hour", color.white)
    dashboard_cell(0, 11, "Daily", color.white)
    dashboard_cell(1, 7, TF60Bull ? "Bullish" : "Bearish", color.black), dashboard_cell_bg(1, 7, TF60Bull ? color.green : color.red)
    dashboard_cell(1, 8, TF120Bull ? "Bullish" : "Bearish", color.black), dashboard_cell_bg(1, 8, TF120Bull ? color.green : color.red)
    dashboard_cell(1, 9, TF240Bull ? "Bullish" : "Bearish", color.black), dashboard_cell_bg(1, 9, TF240Bull ? color.green : color.red)
    dashboard_cell(1, 10, TF720Bull ? "Bullish" : "Bearish", color.black), dashboard_cell_bg(1, 10, TF720Bull ? color.green : color.red)
    dashboard_cell(1, 11, TFDBull ? "Bullish" : "Bearish", color.black), dashboard_cell_bg(1, 11, TFDBull ? color.green : color.red)




upperTL1        = input.color(color.new(#787b86, 5), "Top Line", group="Trend Lines")
middleTL2       = input.color(color.new(#787b86, 5), "Middle Line", group="Trend Lines")
lowerTL3        = input.color(color.new(#787b86, 5), "Bottom Line", group="Trend Lines")
styleOption     = input.string(title="Line Style",options=["Solid ─", "Dotted ┈", "Dashed ╌"], defval="Dotted ┈", group = "Trend Lines")
lineWidth1      = input.int(0, title="Line Width", minval=0, maxval = 4, group = "Trend Lines")
expandTrend     = input(false, "Extand Trend Line", group = "Trend Lines")
// Wave
price           = plot(close, title="Close Line", linewidth=0, color=color.blue, editable=false, display = display.none)

// TREND
// Functions
lineStyle1    =   (styleOption == "Dotted ┈") ? line.style_dotted :
                  (styleOption == "Dashed ╌") ? line.style_dashed :
                  (styleOption == "Arrow Left ←") ? line.style_arrow_left :
                  (styleOption == "Arrow Right →") ? line.style_arrow_right :
                  (styleOption == "Arrows Both ↔") ? line.style_arrow_both :
                  line.style_solid








// ورودی‌های دیگر که مخفی شده‌اند (با استفاده از display.none)
length1 = input.int(80, minval=1, title="Length 1", display=display.none, group = 'reversal Bands')
length2 = input.int(80, minval=1, title="Length 2", display=display.none, group = 'reversal Bands')
length3 = input.int(80, minval=1, title="Length 3", display=display.none, group = 'reversal Bands')

mult1 = input.int(5, title="Multiplier 1", display=display.none, group = 'reversal Bands')
mult2 = input.int(7, title="Multiplier 2", display=display.none, group = 'reversal Bands')
mult3 = input.int(9, title="Multiplier 3", display=display.none, group = 'reversal Bands')

src1 = input(close, title="Source", display=display.none, group = 'reversal Bands')
exp = input.bool(false, title="Use Exponential MA", display=display.none, group = 'reversal Bands')
BandsStyle = input.string("Range", options=["Average True Range", "True Range", "Range"], title="Bands Style", display=display.none, group = 'reversal Bands')

atrlength1 = input.int(2000, title="ATR Length 1", display=display.none, group = 'reversal Bands')
atrlength2 = input.int(2000, title="ATR Length 2", display=display.none, group = 'reversal Bands')
atrlength3 = input.int(2000, title="ATR Length 3", display=display.none, group = 'reversal Bands')

// تابع محاسبه MA
esma(source, length)=>
    s = ta.sma(source, length)
    e = ta.ema(source, length)
    exp ? e : s

// محاسبه Keltner Channel اول
ma1 = esma(src1, length1)
rangema1 = BandsStyle == "True Range" ? ta.tr(true) : BandsStyle == "Average True Range" ? ta.atr(atrlength1) : ta.rma(high - low, length1)
upper1 = ma1 + rangema1 * mult1
lower1 = ma1 - rangema1 * mult1

// محاسبه Keltner Channel دوم
ma2 = esma(src1, length2)
rangema2 = BandsStyle == "True Range" ? ta.tr(true) : BandsStyle == "Average True Range" ? ta.atr(atrlength2) : ta.rma(high - low, length2)
upper2 = ma2 + rangema2 * mult2
lower2 = ma2 - rangema2 * mult2

// محاسبه Keltner Channel سوم
ma3 = esma(src1, length3)
rangema3 = BandsStyle == "True Range" ? ta.tr(true) : BandsStyle == "Average True Range" ? ta.atr(atrlength3) : ta.rma(high - low, length3)
upper3 = ma3 + rangema3 * mult3
lower3 = ma3 - rangema3 * mult3

// اگر گزینه Reversal Bands غیرفعال باشد، خطوط کلتنر چنل را مخفی می‌کنیم
plotKeltnerChannels = reversalBandsEnabled ? true : false

// رسم Keltner Channels فقط زمانی که Reversal Bands فعال است
u1 = plot(plotKeltnerChannels ? upper1 : na, color=#787b86, title="Upper Band 1", transp=70)
l1 = plot(plotKeltnerChannels ? lower1 : na, color=#787b86, title="Lower Band 1", transp=70)

u2 = plot(plotKeltnerChannels ? upper2 : na, color=#787b86, title="Upper Band 2", transp=70)
l2 = plot(plotKeltnerChannels ? lower2 : na, color=#787b86, title="Lower Band 2", transp=70)

u3 = plot(plotKeltnerChannels ? upper3 : na, color=#787b86, title="Upper Band 3", transp=70)
l3 = plot(plotKeltnerChannels ? lower3 : na, color=#787b86, title="Lower Band 3", transp=70)

// محاسبه رنگ ابر بر اساس فعال بودن Reversal Bands
colorUpper1 = reversalBandsEnabled ? color.new(#787b86, 85) : na
colorUpper2 = reversalBandsEnabled ? color.new(#787b86, 75) : na
colorLower1 = reversalBandsEnabled ? color.new(#787b86, 85) : na
colorLower2 = reversalBandsEnabled ? color.new(#787b86, 75) : na

// پر کردن فضای بین باندها (فقط زمانی که Reversal Bands فعال است)
fill(u1, u2, color=colorUpper1)
fill(u2, u3, color=colorUpper2)
fill(l1, l2, color=colorLower1)
fill(l2, l3, color=colorLower2)


bool show_all = input(false, title="TP/SL", group = 'TP/SL')
offset_input = input.float(30, title="Risk Management", minval=0.1, step=0.1, group = 'TP/SL')


       

        // EzAlgo SR

// Get user input
colorSup   = #00e5ff
colorRes   = #ff0066
strengthSR = input.int(2, "S&R Strength", 1, group="S/R")
useZones   = input(true, "SR Zones", group="S/R")
useHLZones = useZones
zoneWidth  = 2
expandSR   = true
// Functions
percWidth(len, perc) => (ta.highest(len) - ta.lowest(len)) * perc / 100
// Get components
rb            = 10
prd           = 284
ChannelW      = 10
label_loc     = 55
ph            = ta.pivothigh(rb, rb)
pl            = ta.pivotlow (rb, rb)
sr_levels     = array.new_float(21, na)
prdhighest    = ta.highest(prd)
prdlowest     = ta.lowest(prd)
cwidth        = percWidth(prd, ChannelW)
zonePerc      = percWidth(300, zoneWidth)
aas           = array.new_bool(41, true)
u11            = 0.0, u11 := nz(u11[1])
d1            = 0.0, d1 := nz(d1[1])
highestph     = 0.0, highestph := highestph[1]
lowestpl      = 0.0, lowestpl := lowestpl[1]
var sr_levs   = array.new_float(21, na)
var sr_lines  = array.new_line(21, na)
var sr_linesH = array.new_line(21, na)
var sr_linesL = array.new_line(21, na)
var sr_linesF = array.new_linefill(21, na)
var sr_labels = array.new_label(21, na)
if ph or pl
    for x = 0 to array.size(sr_levels) - 1
        array.set(sr_levels, x, na)
    highestph := prdlowest
    lowestpl := prdhighest
    countpp = 0
    for x = 0 to prd
        if na(close[x])
            break
        if not na(ph[x]) or not na(pl[x])
            highestph := math.max(highestph, nz(ph[x], prdlowest), nz(pl[x], prdlowest))
            lowestpl := math.min(lowestpl, nz(ph[x], prdhighest), nz(pl[x], prdhighest))
            countpp += 1
            if countpp > 40
                break
            if array.get(aas, countpp)
                upl = (ph[x] ? high[x + rb] : low[x + rb]) + cwidth
                dnl = (ph[x] ? high[x + rb] : low[x + rb]) - cwidth
                u11 := countpp == 1 ? upl : u11
                d1 := countpp == 1 ? dnl : d1
                tmp = array.new_bool(41, true)
                cnt = 0
                tpoint = 0
                for xx = 0 to prd
                    if na(close[xx])
                        break
                    if not na(ph[xx]) or not na(pl[xx])
                        chg = false
                        cnt += 1
                        if cnt > 40
                            break
                        if array.get(aas, cnt)
                            if not na(ph[xx])
                                if high[xx + rb] <= upl and high[xx + rb] >= dnl
                                    tpoint += 1
                                    chg := true
                            if not na(pl[xx])
                                if low[xx + rb] <= upl and low[xx + rb] >= dnl
                                    tpoint += 1
                                    chg := true
                        if chg and cnt < 41
                            array.set(tmp, cnt, false)
                if tpoint >= strengthSR
                    for g = 0 to 40 by 1
                        if not array.get(tmp, g)
                            array.set(aas, g, false)
                    if ph[x] and countpp < 21
                        array.set(sr_levels, countpp, high[x + rb])
                    if pl[x] and countpp < 21
                        array.set(sr_levels, countpp, low[x + rb])
// Plot
var line highest_ = na, line.delete(highest_)
var line lowest_  = na, line.delete(lowest_)
var line highest_fill1 = na, line.delete(highest_fill1)
var line highest_fill2 = na, line.delete(highest_fill2)
var line lowest_fill1  = na, line.delete(lowest_fill1)
var line lowest_fill2  = na, line.delete(lowest_fill2)
hi_col = close >= highestph ? colorSup : colorRes
lo_col = close >= lowestpl  ? colorSup : colorRes
if enableSR

    if useHLZones
        highest_fill1 := line.new(bar_index - 311, highestph + zonePerc, bar_index, highestph + zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na)
        highest_fill2 := line.new(bar_index - 311, highestph - zonePerc, bar_index, highestph - zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na)
        lowest_fill1  := line.new(bar_index - 311, lowestpl + zonePerc , bar_index, lowestpl + zonePerc , xloc.bar_index, expandSR ? extend.both : extend.right, na)
        lowest_fill2  := line.new(bar_index - 311, lowestpl - zonePerc , bar_index, lowestpl - zonePerc , xloc.bar_index, expandSR ? extend.both : extend.right, na)
        linefill.new(highest_fill1, highest_fill2, color.new(hi_col, 80))
        linefill.new(lowest_fill1 , lowest_fill2 , color.new(lo_col, 80))
if ph or pl
    for x = 0 to array.size(sr_lines) - 1
        array.set(sr_levs, x, array.get(sr_levels, x))
for x = 0 to array.size(sr_lines) - 1
    line.delete(array.get(sr_lines, x))
    line.delete(array.get(sr_linesH, x))
    line.delete(array.get(sr_linesL, x))
    linefill.delete(array.get(sr_linesF, x))
    if array.get(sr_levs, x) and enableSR
        line_col = close >= array.get(sr_levs, x) ? colorSup : colorRes
        if useZones
            array.set(sr_linesH, x, line.new(bar_index - 355, array.get(sr_levs, x) + zonePerc, bar_index, array.get(sr_levs, x) + zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na))
            array.set(sr_linesL, x, line.new(bar_index - 355, array.get(sr_levs, x) - zonePerc, bar_index, array.get(sr_levs, x) - zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na))
            array.set(sr_linesF, x, linefill.new(array.get(sr_linesH, x), array.get(sr_linesL, x), color.new(line_col, 80)))

// Function Definitions
simple_filter(float source, int length, bool duel_filter) =>
    switch duel_filter
        false => ta.wma(source, length)
        true => ta.wma(ta.sma(source, length), length)

sr_ma(float source = close, int output_smoothing = 3, int trigger_smoothing = 1, int atr_length = 50, float multiplier = 1, string range_switch = "Body", bool duel_filter = false) =>
    candle_top = range_switch != "Body" ? high : math.max(open, close)
    candle_bottom = range_switch != "Body" ? low : math.min(open, close)

    smooth_top = ta.sma(candle_top, trigger_smoothing)
    smooth_bottom = ta.sma(candle_bottom, trigger_smoothing)

    tr = candle_top - candle_bottom
    atr = ta.sma(tr, atr_length)

    var float sr_ma = na
    var float current_range = na
    var float top_range = na
    var float bottom_range = na

    flag = smooth_top > top_range or smooth_bottom < bottom_range or na(current_range)

    if flag
        sr_ma := source
        current_range := atr * multiplier
        top_range := sr_ma + current_range
        bottom_range := sr_ma - current_range
        
    out = simple_filter(sr_ma, output_smoothing, duel_filter)
    smooth_top_range = simple_filter(top_range, output_smoothing, duel_filter)
    smooth_bottom_range = simple_filter(bottom_range, output_smoothing, duel_filter)

    [out, smooth_top_range, smooth_bottom_range]

///////////////////////////////////////////////////
//////// Zonas de Supply/Demand
//////////////////////////////////////////////////

G_POI = 'Supply/Demand'
POIATR = ta.atr(300)
ColorSupply = input.color(#9d0040, title = 'Supply', group = G_POI)
ColorSupplyOutline = input.color(color.new(color.white,100), title = 'Supply', group = G_POI)
ColorDemand = input.color(color.rgb(0, 138, 153, 65), title = 'Demand', group = G_POI)
ColorDemandOutline = input.color(color.new(color.white,100), title = 'Demand', group = G_POI)
SwingLength = input.int(10, title = 'High/Low Swing Length', group = G_POI, minval = 1, maxval = 50)
HistoryDemandKepp = input.int(21, title = 'History to maintain', minval = 5, maxval = 50, group = G_POI)
BoxWidth = input.float(10, title = 'Supply/Demand Box Width', group = G_POI, minval = 1, maxval = 10, step = 0.5)
ColorLabelPOI = input.color(#bdbdbd, title = 'POI', group = G_POI)
MaxExtention = input.bool(true, title = "Extend", group = G_POI)

//      FUNCTION TO ADD NEW AND Remove LAST IN ARRAY
ArrayAddPopF(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

//      FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
CheckOverlappingF(new_poi, box_array, POIATR) =>

    atr_threshold = POIATR * 2
    okay_to_draw = true

    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2

        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold

        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw


//      FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
SupplyDemandF(value_array, bn_array, box_array, label_array, box_type, POIATR) =>

    atr_buffer = POIATR * (BoxWidth / 10)
    box_left = array.get(bn_array, 0)
    box_right = bar_index

    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00


    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2

    okay_to_draw = CheckOverlappingF(poi, box_array, POIATR)

    //delete oldest box, and then create a new box and add it to the array
    if box_type == 1 and okay_to_draw and POIswitch
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        ArrayAddPopF(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = ColorSupplyOutline,
             bgcolor = ColorSupply, extend=MaxExtention?extend.right:extend.none, text = '', text_halign = text.align_center, text_valign = text.align_center, text_color = ColorLabelPOI, text_size = size.small, xloc = xloc.bar_index))
  
    else if box_type == -1 and okay_to_draw  and POIswitch
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        ArrayAddPopF(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = ColorDemandOutline,
             bgcolor = ColorDemand, extend=MaxExtention?extend.right:extend.none,  text = '', text_halign = text.align_center, text_valign = text.align_center, text_color = ColorLabelPOI, text_size = size.small, xloc = xloc.bar_index))
        

//      FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
BosSdF(box_array, bos_array, label_array, zone_type) =>

    if zone_type == 1  and POIswitch
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            if close >= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                ArrayAddPopF(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), '' )
                box.set_text_color( array.get(bos_array,0), color.new(color.white, 0))
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))


    if zone_type == -1  and POIswitch
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            if close <= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                ArrayAddPopF(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), '' )
                box.set_text_color( array.get(bos_array,0),  color.new(color.white, 0))
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

//      FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
BoxExtendEndPointF(box_array) =>

    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 90)

//      CALCULATE SWING HIGHS & SWING LOWS
SwingHigh = ta.pivothigh(high, SwingLength, SwingLength)
SwingLow = ta.pivotlow(low, SwingLength, SwingLength)

//      ARRAYS FOR SWING H/L & BN 
var SwingHighValHues = array.new_float(5,0.00)
var SwingLowValues = array.new_float(5,0.00)

var SwingHighBNS = array.new_int(5,0)
var SwingLowBNS = array.new_int(5,0)

//      ARRAYS FOR SUPPLY / DEMAND
var SupplyBoxCurrent = array.new_box(HistoryDemandKepp, na)
var DemandBoxCurrent = array.new_box(HistoryDemandKepp, na)

//      ARRAYS FOR SUPPLY / DEMAND POI LABELS
var SupplyPOICurrent = array.new_box(HistoryDemandKepp, na)
var DemandPOICurrent = array.new_box(HistoryDemandKepp, na)

//      ARRAYS FOR BOS
var BOSSupply = array.new_box(5, na)
var BOSDemand = array.new_box(5, na)
//
//END CALCULATIONS
//
//      NEW SWING HIGH
if not na(SwingHigh)

    //MANAGE SWING HIGH VALUES
    ArrayAddPopF(SwingHighValHues, SwingHigh)
    ArrayAddPopF(SwingHighBNS, bar_index[SwingLength])
    SupplyDemandF(SwingHighValHues, SwingHighBNS, SupplyBoxCurrent, SupplyPOICurrent, 1, POIATR)

//   NEW SWING LOW
else if not na(SwingLow)

    //MANAGE SWING LOW VALUES
    ArrayAddPopF(SwingLowValues, SwingLow)
    ArrayAddPopF(SwingLowBNS, bar_index[SwingLength])
    SupplyDemandF(SwingLowValues, SwingLowBNS, DemandBoxCurrent, DemandPOICurrent, -1, POIATR)

BosSdF(SupplyBoxCurrent, BOSSupply, SupplyPOICurrent, 1)
BosSdF(DemandBoxCurrent, BOSDemand, DemandPOICurrent, -1)

BoxExtendEndPointF(SupplyBoxCurrent)
BoxExtendEndPointF(DemandBoxCurrent)



// ورودی‌ها
initial_stop = input.float(0.1, "Initial Stop", group='Trailing Stop Loss')
risk_increment = input.float(0.01, "Risk Increment", group='Trailing Stop Loss')
max_risk = input.float(0.03, "Max Risk", group='Trailing Stop Loss')
zone_width = input.float(0.3, "Zone Width", group='Trailing Stop Loss')
  // ورودی برای روشن و خاموش کردن Trailing Stop

// محاسبات ATR
atrs = ta.atr(100) * zone_width

// محاسبات SAR در حالت عادی
sarone = ta.sar(initial_stop, risk_increment, max_risk)
sarzone = close > sarone ? sarone + atrs : sarone - atrs

// زمانی که trailing stop خاموش است، SAR را رسم نکن
sarone_plot = trailing_stop_enabled ? sarone : na
sarzone_plot = trailing_stop_enabled ? sarzone : na

// رسم نمودار SAR
p1 = plot(sarone_plot, "trail", color=color.new(close > sarone ? #00ff0a : #ff0014, transp=75), style=plot.style_circles)
p3 = plot(sarzone_plot, "Zone Line", color=color.new(close > sarone ? #00ff0a : #ff0014, transp=75), style=plot.style_circles)


// Constants
color CLEAR = color.rgb(0,0,0,100)
// Inputs
swingSize = input.int(45, 'Swing Length', group='Market Structure')
bosConfType = input.string('Candle Close', 'Confirmation', ['Candle Close', 'Wicks'], group='Market Structure')
// BOS Settings
bosColor = input.color(color.rgb(112, 114, 119), 'Color', group='Market Structure')
bosStyle = input.string('Dashed', 'Line Style', ['Solid', 'Dashed', 'Dotted'], group='Market Structure')
bosWidth = input.int(1, 'Width', minval=1, group='Market Structure')

// Functions
lineStyle(x) =>
    switch x
        'Solid' => line.style_solid
        'Dashed' => line.style_dashed
        'Dotted' => line.style_dotted

// Calculations

//Finding high and low pivots
pivHi = ta.pivothigh(high, swingSize, swingSize)
pivLo = ta.pivotlow(low, swingSize, swingSize)

//Tracking the previous swing levels to determine hh lh hl ll
var float prevHigh = na
var float prevLow = na
var int prevHighIndex = na
var int prevLowIndex = na

//Tracking whether previous levels have been breached
var bool highActive = false
var bool lowActive = false

bool hh = false
bool lh = false
bool hl = false
bool ll = false

//Variable to track the previous swing type, used later on to draw HH, LH, HL, LL
var int prevSwing = 0

if not na(pivHi)
    if pivHi >= prevHigh
        hh := true
        prevSwing := 2
    else
        lh := true
        prevSwing := 1
    prevHigh := pivHi
    highActive := true
    prevHighIndex := bar_index - swingSize

if not na(pivLo)
    if pivLo >= prevLow
        hl := true
        prevSwing := -1
    else
        ll := true
        prevSwing := -2
    prevLow := pivLo
    lowActive := true
    prevLowIndex := bar_index - swingSize

//Generating the breakout signals
bool highBroken = false
bool lowBroken = false

//Tracking prev breakout
var int prevBreakoutDir = 0

float highSrc = bosConfType == 'Candle Close' ? close : high
float lowSrc = bosConfType == 'Candle Close' ? close : low

if highSrc > prevHigh and highActive
    highBroken := true
    highActive := false
if lowSrc < prevLow and lowActive
    lowBroken := true
    lowActive := false

// Visual Output

//Swing level labels and BOS/CHoCH Lines (combined under Market Structure)
if marketStructure
    //Swing Points
    if hh
        label.new(bar_index - swingSize, pivHi, 'HH', color=CLEAR, style=label.style_label_down, textcolor=chart.fg_color, size = size.small)
    if lh
        label.new(bar_index - swingSize, pivHi, 'LH', color=CLEAR, style=label.style_label_down, textcolor=chart.fg_color, size = size.small)
    if hl
        label.new(bar_index - swingSize, pivLo, 'HL', color=CLEAR, style=label.style_label_up, textcolor=chart.fg_color, size = size.small)
    if ll
        label.new(bar_index - swingSize, pivLo, 'LL', color=CLEAR, style=label.style_label_up, textcolor=chart.fg_color, size = size.small)

    //Generating the BOS Lines
    if highBroken
        line.new(prevHighIndex, prevHigh, bar_index, prevHigh, color=bosColor, style=lineStyle(bosStyle), width=bosWidth)
        label.new(math.floor(bar_index - (bar_index - prevHighIndex) / 2), prevHigh, prevBreakoutDir == -1 ? 'CHoCH' : 'BOS', color=CLEAR, textcolor=bosColor, size=size.tiny)
        prevBreakoutDir := 1
    if lowBroken
        line.new(prevLowIndex, prevLow, bar_index, prevLow, color=bosColor, style=lineStyle(bosStyle), width=bosWidth)
        label.new(math.floor(bar_index - (bar_index - prevLowIndex) / 2), prevLow, prevBreakoutDir == 1 ? 'CHoCH' : 'BOS', color=CLEAR, textcolor=bosColor, style=label.style_label_up, size=size.tiny)
        prevBreakoutDir := -1
// Chart Features

smoothrng(x, t, m) =>
    wper  = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    smoothrng = ta.ema(avrng, wper) * m
    smoothrng
smrng     = smoothrng(close, 200, 200)

rngfilt(x, r) =>
    rngfilt = x
    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r
    rngfilt
filt = rngfilt(close, smrng)

// ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ 

upward = 0.0
upward := filt > filt[1] ? nz(upward[1]) + 1 : filt < filt[1] ? 0 : nz(upward[1])
downward = 0.0
downward := filt < filt[1] ? nz(downward[1]) + 1 : filt > filt[1] ? 0 : nz(downward[1])



// Chart Features

x11 = 22
x21 = 12

x3 = 20
x4 = 5



smoothrngX1(x, t, m) =>
    wper  = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    smoothrngX1 = ta.ema(avrng, wper) * m
    smoothrngX1
smrngx1x     = smoothrngX1(close, x11, x21)
smrngx1x2     = smoothrngX1(close, x3, x4)

rngfiltx1x1(x, r) =>
    rngfiltx1x1 = x
    rngfiltx1x1 := x > nz(rngfiltx1x1[1]) ? x - r < nz(rngfiltx1x1[1]) ? nz(rngfiltx1x1[1]) : x - r : x + r > nz(rngfiltx1x1[1]) ? nz(rngfiltx1x1[1]) : x + r
    rngfiltx1x1
filtx1 = rngfiltx1x1(close, smrngx1x)
filtx12 = rngfiltx1x1(close, smrngx1x2)

// ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ 

upwardx1 = 0.0
upwardx1 := filtx1 > filtx1[1] ? nz(upwardx1[1]) + 1 : filtx1 < filtx1[1] ? 0 : nz(upwardx1[1])
downwardx1 = 0.0
downwardx1 := filtx1 < filtx1[1] ? nz(downwardx1[1]) + 1 : filtx1 > filtx1[1] ? 0 : nz(downwardx1[1])


filtx1colorx1 = color.rgb(0, 187, 212, 100)
xxx1 = plot(CirrusCloud ? filtx1 : na, color=filtx1colorx1, linewidth=1, title='Trend Tracer', editable = false)
xxx2 = plot(CirrusCloud ? filtx12 : na, color=filtx1colorx1, linewidth=1, title='Trend Tracer', editable = false)

fill(xxx1, xxx2, color= filtx1 > filtx12 ? color.new(#9d0040, 50) : color.new(#00cce2, 50))


// Other initializations
avg_volume = ta.sma(volume, 20)
very_weak_multiplier = 0.5
weak_multiplier = 1
strong_multiplier = 1.5

// ورودی برای روشن یا خاموش کردن سیگنال‌های Diamond


// ثابت کردن تنظیمات
rsiPeriod = 14  // دوره ثابت برای RSI
rsiLevelLow = 30  // سطح ۳۰ برای بررسی
rsiLevelHigh = 70  // سطح ۷۰ برای بررسی

// محاسبه RSI
rsi = ta.rsi(close, rsiPeriod)

// بررسی اینکه آیا قیمت زیر خط 30 است
isBelow30 = rsi < rsiLevelLow

// بررسی اینکه آیا قیمت بالای خط 70 است
isAbove70 = rsi > rsiLevelHigh

// رسم علامت Diamond (الماس) زیر کندل‌ها زمانی که RSI زیر 30 باشد
plotshape(reversal and isBelow30, style=shape.diamond, location=location.belowbar, color=#00e5ff, size=size.tiny, title="Up Reversal", transp=70)

// رسم علامت Diamond (الماس) بالای کندل‌ها زمانی که RSI بالای 70 باشد
plotshape(reversal and isAbove70, style=shape.diamond, location=location.abovebar, color=#ff0066, size=size.tiny, title="Down Reversal", transp=70)


// Get user input



// Trend Cloud
tclength = 600
hullma = ta.wma(2*ta.wma(close, tclength/2)-ta.wma(close, tclength), math.floor(math.sqrt(tclength)))
plot(LongTrendAverage ? hullma : na, 'Trend Cloud', linewidth=4, color=close[8] > hullma ? color.new(#00b9cd, 10) : color.new(#ad0045, 10))

// Chart Features

x15 = 22
x25 = 9

x35 = 15
x45 = 5



smoothrngX15(x5, t5, m5) =>
    wper  = t5 * 2 - 1
    avrng = ta.ema(math.abs(x5 - x5[1]), t5)
    smoothrngX15 = ta.ema(avrng, wper) * m5
    smoothrngX15
smrngx1x5     = smoothrngX1(close, x15, x25)
smrngx1x25     = smoothrngX1(close, x35, x45)

rngfiltx1x15(x5, r5) =>
    rngfiltx1x15 = x5
    rngfiltx1x15 := x5 > nz(rngfiltx1x15[1]) ? x5 - r5 < nz(rngfiltx1x15[1]) ? nz(rngfiltx1x15[1]) : x5 - r5 : x5 + r5 > nz(rngfiltx1x15[1]) ? nz(rngfiltx1x15[1]) : x5 + r5
    rngfiltx1x15
filtx15 = rngfiltx1x15(close, smrngx1x5)
filtx125 = rngfiltx1x15(close, smrngx1x25)

// ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ 

upwardx15 = 0.0
upwardx15 := filtx15 > filtx15[1] ? nz(upwardx15[1]) + 1 : filtx15 < filtx15[1] ? 0 : nz(upwardx15[1])
downwardx15 = 0.0
downwardx15 := filtx15 < filtx15[1] ? nz(downwardx15[1]) + 1 : filtx15 > filtx15[1] ? 0 : nz(downwardx15[1])

// Other initializations
avg_volume5 = ta.sma(volume, 20)
very_weak_multiplier5 = 0.5
weak_multiplier5 = 1
strong_multiplier5 = 1.5



length = input(50)
highlightMovements = true
src2 = close


lag = math.floor((length - 1) / 2)


zlema = ta.ema(src2 + (src2 - src2[lag]), length)


zlemaColor = highlightMovements ? (zlema > zlema[1] ? #00e5ff : #ff0066) : color.red


zlemaPlot = powers_ema ? zlema : na


plot(zlemaPlot, title="ZLEMA", linewidth=2, color=zlemaColor, transp=0)
upperTL = autoTL ? line.new(x1, _y1 + upDev, x2, _y2 + upDev, xloc.bar_index, expandTrend ? extend.both : extend.none, width=lineWidth1, style = lineStyle1, color=upperTL1) : na
line.delete(upperTL[1])
middleTL = autoTL ? line.new(x1, _y1, x2, _y2, xloc.bar_index, expandTrend ? extend.both : extend.none, width=lineWidth1, style = lineStyle1, color=middleTL2) : na
line.delete(middleTL[1])
lowerTL = autoTL ? line.new(x1, _y1 - dnDev, x2, _y2 - dnDev, xloc.bar_index, expandTrend ? extend.both : extend.none, width=lineWidth1, style = lineStyle1, color=lowerTL3) : na
line.delete(lowerTL[1])
// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @free_fx_pro", bgcolor=color.blue, text_color=color.white, text_size=size.normal)