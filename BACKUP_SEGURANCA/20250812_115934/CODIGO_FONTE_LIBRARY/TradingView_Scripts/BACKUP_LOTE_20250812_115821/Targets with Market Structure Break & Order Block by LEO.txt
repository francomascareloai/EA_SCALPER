// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © Llopezf

//@version=5
indicator("Targets with Market Structure Break & Order Block by LEO", shorttitle = "Targets with MSB-OB by LEO", overlay = true, max_lines_count = 500, max_labels_count = 500, max_bars_back=4900, max_boxes_count=500)

//-----------------------------------------------------------------------------}
//Target 1
//-----------------------------------------------------------------------------{
showLabels = input(true, 'Show Target Labels', inline = 'style')
candleColoring = input(true, 'Candle Coloring', inline = 'style')

//Condition Rule
enableTarget1 = input(true, 'Enable Target'
  , inline    = 'enable'
  , group     = 'Target 1')

isLong1       = input(true, 'Long Position Target'
  , inline    = 'enable'
  , group     = 'Target 1')

_ = input.string('Source A', 'New Target Condition', options = ['Source A']
  , inline    = 'targetRule1'
  , group     = 'Target 1')

target1Condition = input.string('CrossOver', ''
  , options   = ['CrossOver', 'CrossUnder', 'Cross', 'Equal']
  , inline    = 'targetRule1'
  , group     = 'Target 1')

_ = input.string('Source B', '', options = ['Source B']
  , inline    = 'targetRule1'
  , group     = 'Target 1')  

//Source A
targetSource1A = input.string('External', 'Source A'
  , options   = ['External', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'A'
  , group     = 'Target 1')

targetExternal1A = input(close, 'External'
  , inline    = 'A'
  , group     = 'Target 1')

targetTiSettings1A = input.string('', 'Settings'
  , inline    = 'A'
  , group     = 'Target 1')

//Source B
targetSource1B = input.string('Supertrend', 'Source B'
  , options   = ['External', 'Value', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'B'
  , group     = 'Target 1')

targetExternal1B = input(open, 'External'
  , inline    = 'B'
  , group     = 'Target 1')

targetTiSettings1B = input.string('10,3', 'Settings'
  , inline    = 'B'
  , group     = 'Target 1')

targetValue1B = input(0, 'Source B Value'
  , inline    = 'B_'
  , group     = 'Target 1')

target1Css    = input(#089981c1, 'Target Color '
  , inline    = 'style'
  , group     = 'Target 1')

target1Style  = input.string('· · ·', '    Levels Style'
  , options   = ['──','- - -','· · ·']
  , inline    = 'style'
  , group     = 'Target 1')

showSource1   = input.bool(false, 'Show Source Values'
  , group     = 'Target 1')

//-----------------------------------------------------------------------------}
//Target 1 Logic
//-----------------------------------------------------------------------------{
waitTarget1   = input(false, 'Wait Until Reached'
  , group     = 'Target 1 Logic')

newTarget1    = input(false, 'New Target When Reached'
  , group     = 'Target 1 Logic')

useWicks1     = input(true, 'Evaluate Wicks'
  , group     = 'Target 1 Logic')

distTarget1   = input.float(3, 'Target Distance From Price'
  , inline    = 'dist1'
  , group     = 'Target 1 Logic')

distOptions1  = input.string('ATR', ''
  , options   = ['Currencies', '%', 'ATR', 'Ticks', 'External Value']
  , inline    = 'dist1'
  , group     = 'Target 1 Logic')

externalDist1 = input(close, 'External Distance Value'
  , group     = 'Target 1 Logic')

//-----------------------------------------------------------------------------}
//Target 2
//-----------------------------------------------------------------------------{
//Condition Rule
enableTarget2 = input(true, 'Enable Target'
  , inline    = 'enable'
  , group     = 'Target 2')

isLong2 = input(false, 'Long Position Target'
  , inline    = 'enable'
  , group     = 'Target 2')

_ = input.string('Source A', 'New Target Condition', options = ['Source A']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

target2Condition = input.string('CrossUnder', ''
  , options   = ['CrossOver', 'CrossUnder', 'Cross', 'Equal']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

_ = input.string('Source B', '', options = ['Source B']
  , inline    = 'targetRule2'
  , group     = 'Target 2')

//Source A
targetSource2A = input.string('External', 'Source A'
  , options   = ['External', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'A'
  , group     = 'Target 2')

targetExternal2A = input(close, 'External'
  , inline    = 'A'
  , group     = 'Target 2')

targetTiSettings2A = input.string('', 'Settings'
  , inline    = 'A'
  , group     = 'Target 2')

//Source B
targetSource2B = input.string('Supertrend', 'Source B'
  , options   = ['External', 'Value', 'ACCDIST', 'ATR', 'BB Middle', 'BB Upper', 'BB Lower', 'CCI', 'CMO', 'COG', 'DC High', 'DC Mid', 'DC Low'
              , 'DEMA', 'EMA', 'HMA', 'III', 'KC Middle', 'KC Upper', 'KC Lower', 'LINREG', 'MACD', 'MACD-signal', 'MACD-histogram', 'MEDIAN'
              , 'MFI', 'MODE', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'RMA', 'ROC', 'RSI', 'SMA', 'STOCH', 'Supertrend'
              , 'TEMA', 'VWAP', 'VWMA', 'WAD', 'WMA', 'WVAD', '%R']
  , inline    = 'B'
  , group     = 'Target 2')

targetExternal2B = input(open, 'External'
  , inline    = 'B'
  , group     = 'Target 2')

targetTiSettings2B = input.string('10,3', 'Settings'
  , inline    = 'B'
  , group     = 'Target 2')

targetValue2B = input(0, 'Source B Value'  
  , inline    = 'B_'
  , group     = 'Target 2')

target2Css    = input(#f23646c0, 'Target Color '
  , inline    = 'style'
  , group     = 'Target 2')

target2Style  = input.string('· · ·', '    Levels Style'
  , options   = ['──','- - -','· · ·']
  , inline    = 'style'
  , group     = 'Target 2')

showSource2   = input.bool(false, 'Show Source Values'
  , group     = 'Target 2')

//-----------------------------------------------------------------------------}
//Target 2 Logic
//-----------------------------------------------------------------------------{
waitTarget2   = input(false, 'Wait Until Reached'
  , group     = 'Target 2 Logic')

newTarget2    = input(false, 'New Target When Reached'
  , group     = 'Target 2 Logic')

useWicks2     = input(true, 'Evaluate Wicks'
  , group     = 'Target 2 Logic')

distTarget2   = input.float(3, 'Target Distance From Price'
  , inline    = 'dist1'
  , group     = 'Target 2 Logic')

distOptions2  = input.string('ATR', ''
  , options   = ['Currencies', '%', 'ATR', 'Ticks', 'External Value']
  , inline    = 'dist1'
  , group     = 'Target 2 Logic')

externalDist2 = input(close, 'External Distance Value   '
  , group     = 'Target 2 Logic')

//-----------------------------------------------------------------------------}
//Target 2 Logic
//-----------------------------------------------------------------------------{
showDash      = input.bool     (    false      , 'Show Dashboard'                                                     , group= 'Dashboard')
dashLoc       = input.string   (  'Top Right' , 'Location'  , options = ['Top Right', 'Bottom Right', 'Bottom Left'] , group= 'Dashboard')
textSize      = input.string   (   'Normal'   , 'Size'      , options =          ['Tiny', 'Small', 'Normal']         , group= 'Dashboard')

//-----------------------------------------------------------------------------}
//UDT
//-----------------------------------------------------------------------------{
type lshape
    line v
    line h

type target
    float  value
    int    loc
    bool   reached
    bool   islong
    bool   active
    lshape lines
    label  lbl

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
n = bar_index

INV = color.new(color.blue, 100)

aNoVisuals = array.from('ACCDIST', 'ATR', 'CCI', 'CMO', 'COG', 'III', 'MACD', 'MACD-signal', 'MACD-histogram', 'MFI', 'MOM', 'NVI', 'OBV', 'PVI', 'PVT', 'ROC', 'RSI', 'STOCH', 'WAD', 'WVAD', '%R')

a_1Val       = array.from( 'ATR'  ,  'CCI'  ,  'CMO'  ,  'COG'  , 'DC High', 'DC Mid', 'DC Low', 'DEMA'  ,  'EMA'  ,  'HMA'  , 'MEDIAN',  'MFI'  ,  'MODE' ,  'MOM'  ,  'RMA'  ,  'ROC'  ,  'RSI'  ,  'SMA'  , 'STOCH' , 'TEMA'  , 'VWMA'  ,  'WMA'  ,   '%R'  )
a_1ValValues = array.from('Length', 'Length', 'Length', 'Length', 'Length' , 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length', 'Length')

a_2Val       = array.from( 'BB Middle'     ,   'BB Upper'     ,   'BB Lower'     ,  'KC Middle'     ,   'KC Upper'     ,   'KC Lower'     ,    'LINREG'      ,     'Supertrend'    )
a_2ValValues = array.from('Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Mult'   , 'Length, Offset' , 'ATR Length, Factor')

a_3Val       = array.from(              'MACD'             ,           'MACD-signal'          ,         'MACD-histogram'         )
a_3ValValues = array.from('Short, Long & Signal EMA Length', 'Short, Long & Signal EMA Length', 'Short, Long & Signal EMA Length')

method set_target(target id, css, lstyle)=>
    style = switch lstyle
        '- - -' => line.style_dashed
        '· · ·' => line.style_dotted
        =>         line.style_solid
    
    id.lines := lshape.new(line.new(n, close, n, id.value, color = css, style = style),
      line.new(n, id.value, n, id.value, color = css, style = style))

method delete(target id)=>
    id.lines.v.delete()
    id.lines.h.delete()

method getSetting(array<string> id , idx) => int(str.tonumber(id.get(idx)))

method getStFloat(array<string> id , idx) =>     str.tonumber(id.get(idx))

method isString  (array<string> settings) =>
    isS = false 
    for s in settings 
        if na(str.tonumber(s) / 1)
            isS := true 
            break 
    txt = isS ? 'Please, use numbers' : ''

method ema(int len, float source) => 
    alpha = 2 / (len + 1)
    float ema = na
    sma = ta.sma(source, len)
    ema := alpha * source + (1 - alpha) * nz(ema[1], sma[1])

method rma(int len, float source) =>
    alpha = 1 / len, float sum = 0
    sum := na(sum[1]) ? ta.sma(source, len) : alpha * source + (1 - alpha) * nz(sum[1])

method value(string choice, array<string> setting, float targetExternal, float targetValue) => 
  
    sZ  =  setting.size() , float value = na
    int int1 = na 

    if sZ > 0
        for  i  = setting.size ( ) -1 to 0
            get = setting.get  (i) 
            if  get == ''   or get == ' '
             or get == '  ' or get == '   '
                setting.remove (i)

    isS = setting.isString()
    txt = switch 
        isS != '' => isS
        a_1Val.includes(choice) =>
            if setting.size() != 1
                str.format    (   'Please enter 1 value for {0}: {1}'        , choice, a_1ValValues.get(a_1Val.indexof(choice)))
            else 
                if setting.getSetting(0) - setting.getStFloat(0) != 0
                    str.format('{0} ({1}) -> Length must be an Integer value', choice, a_1ValValues.get(a_1Val.indexof(choice)))
        
        a_2Val.includes(choice) =>
            if setting.size() != 2
                str.format    (   'Please enter 2 values for {0}: {1}'       , choice, a_2ValValues.get(a_2Val.indexof(choice)))
            else 
                if setting.getSetting(0) - setting.getStFloat(0) != 0
                    str.format('{0} ({1}) -> Length must be an Integer value', choice, a_2ValValues.get(a_2Val.indexof(choice)))

        a_3Val.includes(choice) =>
            if setting.size() != 3
                str.format    (   'Please enter 3 values for {0}: {1}'       , choice, a_3ValValues.get(a_3Val.indexof(choice)))
            else                
                if  setting.getSetting(0) - setting.getStFloat(0) != 0                
                 or setting.getSetting(1) - setting.getStFloat(1) != 0
                 or setting.getSetting(2) - setting.getStFloat(2) != 0
                    'Each Number must be an Integer value'

    float shortEMA = na, float longEMA = na, float macd    = na, float signal  = na, float hist = na
    float BBmiddle = na, float BBupper = na, float BBlower = na
    float KCmiddle = na, float KCupper = na, float KClower = na

    if txt == '' 
        if str.contains(choice, 'BB')
            len           = setting.getSetting(0)
            BBmiddle     := ta.sma(close, len)
            float dev     = setting.getStFloat(1) * ta.stdev(close, len)
            BBupper      := BBmiddle + dev 
            BBlower      := BBmiddle - dev

        if str.contains(choice, 'KC')
            KCmiddle     := setting.getSetting(0).ema(close)
            KCrange       = setting.getSetting(0).ema(ta.tr) 
            KCupper      := KCmiddle + KCrange * setting.getStFloat(1)
            KClower      := KCmiddle - KCrange * setting.getStFloat(1)

        if str.contains(choice, 'MACD')
            shortEMA     := setting.getSetting(0).ema(close) 
            longEMA      := setting.getSetting(1).ema(close) 
            macd         := shortEMA - longEMA
            signal       := setting.getSetting(2).ema(macd)
            hist         := macd - signal 

        value := switch choice 

            'ACCDIST'        => ta.accdist

            'ATR'            => setting.getSetting(0).rma(ta.tr(true))

            'BB Middle'      => BBmiddle 
            'BB Upper'       => BBupper
            'BB Lower'       => BBlower

            'CCI'            => ta.cci(close, setting.getSetting(0))

            'CMO'            => ta.cmo(close, setting.getSetting(0))

            'COG'            => ta.cog(close, setting.getSetting(0))

            'DC High'        =>                                             ta.highest(setting.getSetting(0))             
            'DC Mid'         => math.avg(ta.highest(setting.getSetting(0)), ta.lowest (setting.getSetting(0)))
            'DC Low'         =>                                             ta.lowest (setting.getSetting(0)) 

            'DEMA'           =>  
                len  = setting.getSetting(0)
                ema1 = len.ema(close)
                ema2 = len.ema(ema1 )
                2    * ema1 -  ema2       

            'EMA'            => setting.getSetting(0).ema(close)

            'External'       => targetExternal

            'HMA'            => 
                len = setting.getSetting(0)
                ta.wma(2 * ta.wma(close, math.floor(len / 2)) - ta.wma(close, len), math.floor(math.sqrt(len)))

            'III'            => ta.iii 

            'KC Middle'      => KCmiddle
            'KC Upper'       => KCupper
            'KC Lower'       => KClower

            'LINREG'         => 
                len = setting.getSetting(0), off = setting.getSetting(1)
                float sX     = 0, float sY = 0, float sXSqr = 0, float sXY = 0
                for i = 1   to len
                    val      = close[len-i], per = i+1, sX += per, sY += val
                    sXSqr   += math.pow(per, 2), sXY += val * per
                slope        = (sXY * len - sX * sY) / (sXSqr * len - math.pow(sX, 2))
                intcp        = ta.sma(close, len) - slope * sX / len + slope
                intcp + slope * (len - off)

            'MACD'           => macd 
            'MACD-signal'    => signal
            'MACD-histogram' => hist

            'MEDIAN'         => ta.median(close, setting.getSetting(0))

            'MFI'            => ta.mfi(close, setting.getSetting(0))  

            'MODE'           => ta.mode(close, setting.getSetting(0))

            'MOM'            => ta.mom(close, setting.getSetting(0))  

            'NVI'            => ta.nvi

            'OBV'            => ta.obv

            'PVI'            => ta.pvi

            'PVT'            => ta.pvt 

            'SMA'            => ta.sma(close, setting.getSetting(0))

            'RMA'            => setting.getSetting(0).rma(close)

            'ROC'            => ta.roc(close, setting.getSetting(0))

            'RSI'            => 
                len  = setting.getSetting(0), var num = 0., var den = 0., d = nz(close - close[1])
                num += (math.max(d, 0) - num) / len, den += (math.abs(d   ) - den) / len
                num / den * 100        

            'STOCH'          => ta.stoch(close, high, low, setting.getSetting(0))

            'Supertrend'     => 
                len          = setting.getSetting(0), factor    = setting.getStFloat(1)
                var atr      = 0. , var upper = high, var lower = low, var float trend = na
                atr         += (nz(ta.tr) - atr)  / len
                up           = hl2 + atr * factor   , dn = hl2 - atr * factor
                upper       := close[1] < upper ? math.min(up, upper) : up
                lower       := close[1] > lower ? math.max(dn, lower) : dn
                trend       := close    > upper ? 1 : close < lower ? 0 : trend
                trend       == 1 ? lower : upper

            'TEMA'           => 
                len  = setting.getSetting(0)
                ema1 = len.ema(close)
                ema2 = len.ema(ema1 )
                ema3 = len.ema(ema2 )
                (3 * ema1) - (3 * ema2) + ema3

            'Value'          => targetValue

            'VWAP'           => ta.vwap(close)

            'VWMA'           => ta.vwma(close, setting.getSetting(0))
            
            'WAD'            => ta.wad 

            'WMA'            => ta.wma(close, setting.getSetting(0))

            'WVAD'           => ta.wvad

            '%R'             => ta.wpr(setting.getSetting(0))

    [txt, value]

//-----------------------------------------------------------------------------}
//Set target 1
//-----------------------------------------------------------------------------{
var color css            = na
bool      isNewTarget1   = false
bool      isTgReached1   = false

var int countTargets1   = 0
var int countTgReached1 = 0

var target1_object      = target.new(reached = true, active = false)

var setting1A           = str.split(targetTiSettings1A, ',')
var setting1B           = str.split(targetTiSettings1B, ',')

[txt1A, source1A] = targetSource1A.value(setting1A, targetExternal1A,       na     )
[txt1B, source1B] = targetSource1B.value(setting1B, targetExternal1B, targetValue1B)

target1_condition = switch target1Condition
    'CrossOver'  => ta.crossover (source1A, source1B)
    'CrossUnder' => ta.crossunder(source1A, source1B)
    'Cross'      => ta.cross     (source1A, source1B)
    'Equal'      => source1A == source1B

//Distance
dist1 = switch distOptions1
    'Currencies' => distTarget1
    '%' => close + distTarget1 / 100 * close
    'ATR' => nz(ta.atr(50)) * distTarget1
    'Ticks' => syminfo.mintick * distTarget1
    'External Value' => externalDist1 * distTarget1

if target1_object.active and target1_object.reached == false
    target1_object.lines.h.set_x2(n)
    target1_object.lbl.set_x(n)

if (isLong1 ? (useWicks1 ? high : close) > target1_object.value : (useWicks1 ? low : close) < target1_object.value) and target1_object.active 
    target1_object.reached := true
    target1_object.active  := false 
    isTgReached1           := true
    countTgReached1        += 1
    css := na
    target1_object.lbl.set_color(target1Css)

if enableTarget1 and 
 (
  (target1_condition and (waitTarget1 ? target1_object.reached : true)) 
  or 
  (newTarget1 and target1_object.reached)
 ) 
    target_value = close + (isLong1 ? dist1 : -dist1)

    //Delete label if reached and creating new target
    if newTarget1 and target1_object.reached and showLabels
        target1_object.lbl.delete()

    //Create new target
    target1_object := target.new(target_value, n, false, isLong1, active = true)

    if showLabels
        target1_object.lbl := label.new(n, target_value, 'Target'
          , color = color.new(target1Css, 50)
          , textcolor = color.white
          , size = size.tiny
          , style = label.style_label_left
          , tooltip = str.tostring(target_value, format.mintick))

    css := target1Css

    target1_object.set_target(target1Css, target1Style)

    isNewTarget1  := true 
    countTargets1 += 1

//-----------------------------------------------------------------------------}
//Set target 2
//-----------------------------------------------------------------------------{
bool     isNewTarget2   = false
bool     isTgReached2   = false

var int countTargets2   = 0
var int countTgReached2 = 0

var target2_object      = target.new(reached = true, active = false)

var setting2A           = str.split(targetTiSettings2A, ',')
var setting2B           = str.split(targetTiSettings2B, ',')

[txt2A, source2A] = targetSource2A.value(setting2A, targetExternal2A,       na     )
[txt2B, source2B] = targetSource2B.value(setting2B, targetExternal2B, targetValue2B)

target2_condition = switch target2Condition
    'CrossOver'  => ta.crossover (source2A, source2B)
    'CrossUnder' => ta.crossunder(source2A, source2B)
    'Cross'      => ta.cross     (source2A, source2B)
    'Equal'      => source2A == source2B

//Distance
dist2 = switch distOptions2
    'Currencies' => distTarget2
    '%' => close + distTarget2 / 100 * close
    'ATR' => nz(ta.atr(50)) * distTarget2
    'Ticks' => syminfo.mintick * distTarget2
    'External Value' => externalDist2 * distTarget2

if target2_object.active and target2_object.reached == false
    target2_object.lines.h.set_x2(n)
    target2_object.lbl.set_x(n)

if (isLong2 ? (useWicks2 ? high : close) > target2_object.value : (useWicks2 ? low : close) < target2_object.value) and target2_object.active 
    target2_object.reached := true
    target2_object.active  := false 
    isTgReached2           := true
    countTgReached2        += 1
    css := na
    target2_object.lbl.set_color(target2Css)

if enableTarget2     and
 (
  (target2_condition and (waitTarget2 ? target2_object.reached : true)) 
  or 
  (newTarget2 and target2_object.reached)
 ) 
    target_value = close + (isLong2 ? dist2 : -dist2)

    //Delete label if reached and creating new target
    if newTarget2 and target2_object.reached and showLabels
        target2_object.lbl.delete()

    //Create new target
    target2_object := target.new(target_value, n, false, isLong2, active = true)

    if showLabels
        target2_object.lbl := label.new(n, target_value, 'Target'
          , color = color.new(target2Css, 50)
          , textcolor = color.white
          , size = size.tiny
          , style = label.style_label_left
          , tooltip = str.tostring(target_value, format.mintick))
    
    css := target2Css

    target2_object.set_target(target2Css, target2Style)

    isNewTarget2  := true 
    countTargets2 += 1

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
noVisuals1 = array.includes(aNoVisuals, targetSource1A) or array.includes(aNoVisuals, targetSource1B) 
noVisuals2 = array.includes(aNoVisuals, targetSource2A) or array.includes(aNoVisuals, targetSource2B) 

plot(showSource1 and enableTarget1 and not noVisuals1 ? source1A : na, 'Target 1, source A', color=#089981)
plot(showSource1 and enableTarget1 and not noVisuals1 ? source1B : na, 'Target 1, source B', color=#2157f3)

plot(showSource2 and enableTarget2 and not noVisuals2 ? source2A : na, 'Target 2, source A', color=#ffe400)
plot(showSource2 and enableTarget2 and not noVisuals2 ? source2B : na, 'Target 2, source B', color=#ff1100)

barcolor(candleColoring ? css : na, title = 'Candle Coloring')

//-----------------------------------------------------------------------------}
//Dashboard
//-----------------------------------------------------------------------------{
var table_position = dashLoc == 'Bottom Left' ? position.bottom_left 
  : dashLoc == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = textSize == 'Tiny' ? size.tiny 
  : textSize == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 3, 8 // 4 + countErrors
  , bgcolor      = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color  = #373a46
  , frame_width  = 1)

countErrors  = 0
countErrors += txt1A != '' ? 1 : 0
countErrors += txt1B != '' ? 1 : 0
countErrors += txt2A != '' ? 1 : 0
countErrors += txt2B != '' ? 1 : 0

if showDash

    if barstate.isfirst
        if enableTarget1 or enableTarget2
            tb.cell(0, 0,             ''           , text_color = color.white, text_size = table_size)
            tb.cell(1, 0,          'Count'         , text_color = color.white, text_size = table_size)
            tb.cell(2, 0,    'Target\nReached'     , text_color = color.white, text_size = table_size)
            tb.cell(0, 3,         'Total'          , text_color = color.white, text_size = table_size)

        if enableTarget1
            tb.cell(0, 1,        'Target 1'        , text_color = color.white, text_size = table_size)
        if enableTarget2
            tb.cell(0, 2,        'Target 2'        , text_color = color.white, text_size = table_size)
        
        if enableTarget1 and txt1A != '' 
            tb.merge_cells(0, 4, 2, 4)
            tb.cell(0, 4, str.format("Target 1, Source A: {0}\n", txt1A), text_color=#FF0000, text_halign=text.align_left)
        if enableTarget1 and txt1B != '' 
            tb.merge_cells(0, 5, 2, 5)
            tb.cell(0, 5, str.format("Target 1, Source B: {0}\n", txt1B), text_color=#FF0000, text_halign=text.align_left)
        if enableTarget2 and txt2A != '' 
            tb.merge_cells(0, 6, 2, 6)
            tb.cell(0, 6, str.format("Target 2, Source A: {0}\n", txt2A), text_color=#FF0000, text_halign=text.align_left)
        if enableTarget2 and txt2B != '' 
            tb.merge_cells(0, 7, 2, 7)
            tb.cell(0, 7, str.format("Target 2, Source B: {0}\n", txt2B), text_color=#FF0000, text_halign=text.align_left)

    if barstate.islast

        totT = countTargets1   + countTargets2        
        totR = countTgReached1 + countTgReached2
 
        if enableTarget1
            tb.cell(1, 1, str.tostring(countTargets1)                                                                       , text_color = color.white, text_size = table_size)
            tb.cell(2, 1, str.format  ('{0} ({1}%)', countTgReached1 , math.round(100 / countTargets1 * countTgReached1, 1)), text_color = color.white, text_size = table_size)
        if enableTarget2
            tb.cell(1, 2, str.tostring(countTargets2)                                                                       , text_color = color.white, text_size = table_size)
            tb.cell(2, 2, str.format  ('{0} ({1}%)', countTgReached2 , math.round(100 / countTargets2 * countTgReached2, 1)), text_color = color.white, text_size = table_size)
        if enableTarget1 or enableTarget2
            tb.cell(1, 3, str.tostring(     totT    )                                                                       , text_color = color.white, text_size = table_size)
            tb.cell(2, 3, str.format  ('{0} ({1}%)',       totR      , math.round(100 /      totT     *       totR     , 1)), text_color = color.white, text_size = table_size)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
alertcondition(isNewTarget1, "Target 1 New"    , "Target 1 New"    )
alertcondition(isTgReached1, 'Target 1 Reached', 'Target 1 Reached')

alertcondition(isNewTarget2, "Target 2 New"    , "Target 2 New"    )
alertcondition(isTgReached2, 'Target 2 Reached', 'Target 2 Reached')


//-----------------------------------------------------------------------------}
//Market Structure Break & Order Block
//-----------------------------------------------------------------------------{
settings = "Settings"
zigzag_len = input.int(9, "ZigZag Length", group=settings)
show_zigzag = input.bool(false, "Show Zigzag", group=settings)
fib_factor = input.float(0.273, "Fib Factor for breakout confirmation", 0, 1, 0.01, group=settings)

text_size = input.string(size.tiny, "Text Size", [size.tiny, size.small, size.normal, size.large, size.huge], group=settings)

delete_boxes = input.bool(true, "Delete Old/Broken Boxes", group=settings)

bu_ob_inline_color = "Bu-OB Colors"
be_ob_inline_color = "Be-OB Colors"
bu_bb_inline_color = "Bu-BB Colors"
be_bb_inline_color = "Be-BB Colors"

bu_ob_display_settings = "Bu-OB Display Settings"
bu_ob_color = input.color(color.new(color.green, 70), "Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_border_color = input.color(color.rgb(76, 175, 79, 70), "Border Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_text_color = input.color(color.rgb(76, 175, 79, 70), "Text Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)

be_ob_display_settings = "Be-OB Display Settings"
be_ob_color = input.color(color.new(color.red, 70), "Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_border_color = input.color(color.rgb(255, 82, 82, 70), "Border Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_text_color = input.color(color.rgb(255, 82, 82, 70), "Text Color", group=be_ob_display_settings, inline=be_ob_inline_color)

bu_bb_display_settings = "Bu-BB & Bu-MB Display Settings"
bu_bb_color = input.color(color.new(color.green, 70), "Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_border_color = input.color(color.rgb(76, 175, 79, 70), "Border Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_text_color = input.color(color.rgb(76, 175, 79, 70), "Text Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)

be_bb_display_settings = "Be-BB & Be-MB Display Settings"
be_bb_color = input.color(color.new(color.red, 70), "Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_border_color = input.color(color.rgb(255, 82, 82, 70), "Border Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_text_color = input.color(color.rgb(255, 82, 82, 70), "Text Color", group=be_bb_display_settings, inline=be_bb_inline_color)


var float[] high_points_arr = array.new_float(5)
var int[] high_index_arr = array.new_int(5)
var float[] low_points_arr = array.new_float(5)
var int[] low_index_arr = array.new_int(5)

var box[] bu_ob_boxes = array.new_box(5)
var box[] be_ob_boxes = array.new_box(5)
var box[] bu_bb_boxes = array.new_box(5)
var box[] be_bb_boxes = array.new_box(5)

to_up = high >= ta.highest(zigzag_len)
to_down = low <= ta.lowest(zigzag_len)

trend = 1
trend := nz(trend[1], 1)
trend := trend == 1 and to_down ? -1 : trend == -1 and to_up ? 1 : trend

last_trend_up_since = ta.barssince(to_up[1])
low_val = ta.lowest(nz(last_trend_up_since > 0 ? last_trend_up_since : 1, 1))
low_index = bar_index - ta.barssince(low_val == low)

last_trend_down_since = ta.barssince(to_down[1])
high_val = ta.highest(nz(last_trend_down_since > 0 ? last_trend_down_since : 1, 1))
high_index = bar_index - ta.barssince(high_val == high)

if ta.change(trend) != 0
    if trend == 1
        array.push(low_points_arr, low_val)
        array.push(low_index_arr, low_index)
    if trend == -1
        array.push(high_points_arr, high_val)
        array.push(high_index_arr, high_index)


f_get_high(ind) =>
    [array.get(high_points_arr, array.size(high_points_arr) - 1 - ind), array.get(high_index_arr, array.size(high_index_arr) - 1 - ind)]


f_get_low(ind) =>
    [array.get(low_points_arr, array.size(low_points_arr) - 1 - ind), array.get(low_index_arr, array.size(low_index_arr) - 1 - ind)]


f_delete_box(box_arr) =>
    if delete_boxes
        box.delete(array.shift(box_arr))
    else
        array.shift(box_arr)
    0


[h0, h0i] = f_get_high(0)
[h1, h1i] = f_get_high(1)

[l0, l0i] = f_get_low(0)
[l1, l1i] = f_get_low(1)

if ta.change(trend) != 0 and show_zigzag
    if trend == 1
        line.new(h0i, h0, l0i, l0)
    if trend == -1
        line.new(l0i, l0, h0i, h0)

market = 1
market := nz(market[1], 1)
// market := market == 1 and close < l0 and low < l0 - math.abs(h0 - l0) * fib_factor ? -1 : market == -1 and close > h0 and high > h0 + math.abs(h0 - l0) * fib_factor ? 1 : market
last_l0 = ta.valuewhen(ta.change(market) != 0, l0, 0)
last_h0 = ta.valuewhen(ta.change(market) != 0, h0, 0)
market := last_l0 == l0 or last_h0 == h0 ? market : market == 1 and l0 < l1 and l0 < l1 - math.abs(h0 - l1) * fib_factor ? -1 : market == -1 and h0 > h1 and h0 > h1 + math.abs(h1 - l0) * fib_factor ? 1 : market

bu_ob_index = bar_index
bu_ob_index := nz(bu_ob_index[1], bar_index)
for i=h1i to l0i[zigzag_len]
    index = bar_index - i 
    if open[index] > close[index]
        bu_ob_index := bar_index[index]

bu_ob_since = bar_index - bu_ob_index

be_ob_index = bar_index
be_ob_index := nz(be_ob_index[1], bar_index)
for i=l1i to h0i[zigzag_len]
    index = bar_index - i 
    if open[index] < close[index]
        be_ob_index := bar_index[index]

be_ob_since = bar_index - be_ob_index

be_bb_index = bar_index
be_bb_index := nz(be_bb_index[1], bar_index)
for i=h1i - zigzag_len to l1i
    index = bar_index - i
    if open[index] > close[index]
        be_bb_index := bar_index[index]

be_bb_since = bar_index - be_bb_index

bu_bb_index = bar_index
bu_bb_index := nz(bu_bb_index[1], bar_index)
for i=l1i - zigzag_len to h1i
    index = bar_index - i
    if open[index] < close[index]
        bu_bb_index := bar_index[index]

bu_bb_since = bar_index - bu_bb_index

if ta.change(market) != 0
    if market == 1
        line.new(h1i, h1, h0i, h1, color=color.rgb(76, 175, 79, 100), width=1)
        label.new(int(math.avg(h1i, l0i)), h1, "MSB", color=color.new(color.black, 100), style=label.style_label_down, textcolor=color.rgb(76, 175, 79, 100), size=size.small)
        bu_ob = box.new(bu_ob_index, high[bu_ob_since], bar_index + 10, low[bu_ob_since], bgcolor=bu_ob_color, border_color=bu_ob_border_color, text="Bu-OB", text_color=bu_ob_text_color, text_halign=text.align_right, text_size=text_size)
        bu_bb = box.new(bu_bb_index, high[bu_bb_since], bar_index + 10, low[bu_bb_since], bgcolor=bu_bb_color, border_color=bu_bb_border_color, text=l0 < l1 ? "Bu-BB" : "Bu-MB", text_color=bu_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(bu_ob_boxes, bu_ob)
        array.push(bu_bb_boxes, bu_bb)
    if market == -1
        line.new(l1i, l1, l0i, l1, color=color.rgb(255, 82, 82, 100), width=1)
        label.new(int(math.avg(l1i, h0i)), l1, "MSB", color=color.new(color.black, 100), style=label.style_label_up, textcolor=color.rgb(255, 82, 82, 100), size=size.small)
        be_ob = box.new(be_ob_index, high[be_ob_since], bar_index + 10, low[be_ob_since], bgcolor=be_ob_color, border_color=be_ob_border_color, text="Be-OB", text_color=be_ob_text_color, text_halign=text.align_right, text_size=text_size)
        be_bb = box.new(be_bb_index, high[be_bb_since], bar_index + 10, low[be_bb_since], bgcolor=be_bb_color, border_color=be_bb_border_color, text=h0 > h1 ? "Be-BB" : "Be-MB", text_color=be_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(be_ob_boxes, be_ob)
        array.push(be_bb_boxes, be_bb)

for bull_ob in bu_ob_boxes
    bottom = box.get_bottom(bull_ob)
    top = box.get_top(bull_ob)
    if close < bottom
        f_delete_box(bu_ob_boxes)
    else if close < top
        alert("Price in the BU-OB zone")
    else
        box.set_right(bull_ob, bar_index + 10)
    
for bear_ob in be_ob_boxes
    top = box.get_top(bear_ob)
    bottom = box.get_bottom((bear_ob))
    if close > top
        f_delete_box(be_ob_boxes)
    if close > bottom
        alert("Price in the BE-OB zone")
    else
        box.set_right(bear_ob, bar_index + 10)
        
for bear_bb in be_bb_boxes
    top = box.get_top(bear_bb)
    bottom = box.get_bottom(bear_bb)
    if close > top
        f_delete_box(be_bb_boxes)
    else if close > bottom
        alert("Price in the BE-BB zone")
    else
        box.set_right(bear_bb, bar_index + 10)
        
for bull_bb in bu_bb_boxes
    bottom = box.get_bottom(bull_bb)
    top = box.get_top(bull_bb)
    if close < bottom
        f_delete_box(bu_bb_boxes)
    else if close < top
        alert("Price in the BU-BB zone")
    else
        box.set_right(bull_bb, bar_index + 10)


alertcondition(ta.change(market) != 0, "MSB", "MSB")

//-----------------------------------------------------------------------------}
//SUPPLY AND DEMAND
//-----------------------------------------------------------------------------{
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
per = input.float(10., 'Threshold %', minval = 0, maxval = 100)
div = input.int(50, 'Resolution'    , minval = 2, maxval = 500)
tf  = input.timeframe('', 'Intrabar TF')

//Colors
showSupply = input(true ,'Supply        ', inline = 'supply', group = 'Style')
supplyCss  = input(#2156f321, ''         , inline = 'supply', group = 'Style')
supplyArea = input(true ,'Area'          , inline = 'supply', group = 'Style')
supplyAvg  = input(true ,'Average'       , inline = 'supply', group = 'Style')
supplyWavg = input(true ,'Weighted'      , inline = 'supply', group = 'Style')

showEqui   = input(false ,'Equilibrium'   , inline = 'equi'  , group = 'Style')
equiCss    = input(color.gray, ''      , inline = 'equi'  , group = 'Style')
equiAvg    = input(true ,'Average'       , inline = 'equi'  , group = 'Style')
equiWavg   = input(true ,'Weighted'      , inline = 'equi'  , group = 'Style')

showDemand = input(true ,'Demand    '    , inline = 'demand', group = 'Style')
demandCss  = input(#ff5e0020, ''         , inline = 'demand', group = 'Style')
demandArea = input(true ,'Area'          , inline = 'demand', group = 'Style')
demandAvg  = input(true ,'Average'       , inline = 'demand', group = 'Style')
demandWavg = input(true ,'Weighted'      , inline = 'demand', group = 'Style')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type bin
    float lvl
    float prev
    float sum
    float prev_sum
    float csum
    float avg
    bool isreached

type area
    box  bx
    line avg 
    line wavg 

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{

get_hlv()=> [high, low, volume]

method set_area(area id, x1, top, btm, avg, wavg, showArea, showAvg, showWavg)=>
    if showArea
        id.bx.set_lefttop(x1, top)
        id.bx.set_rightbottom(n, btm)    
    
    if showAvg
        id.avg.set_xy1(x1, avg)
        id.avg.set_xy2(n, avg)
    
    if showWavg
        id.wavg.set_xy1(x1, wavg)
        id.wavg.set_xy2(n, wavg)

//-----------------------------------------------------------------------------}
//Main variables
//-----------------------------------------------------------------------------{
var max1  = 0. 
var min1  = 0.
var x1   = 0
var csum = 0.

//Intrabar data
[h, l, v] = request.security_lower_tf(syminfo.tickerid, tf, get_hlv())

//Init on left bar
if time == chart.left_visible_bar_time
    max1 := high
    min1 := low
    csum := volume
    x1 := n
else //Accumulate
    max1 := math.max(high, max1)
    min1 := math.min(low, min1)
    csum += volume

//-----------------------------------------------------------------------------}
//Set zones
//-----------------------------------------------------------------------------{
var supply_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(supplyCss, 90))
  , line.new(na, na, na, na, color = supplyCss)
  , line.new(na, na, na, na, color = supplyCss, style = line.style_dashed))

var demand_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(demandCss, 90))
  , line.new(na, na, na, na, color = demandCss)
  , line.new(na, na, na, na, color = demandCss, style = line.style_dashed))

var equi  = line.new(na, na, na, na, color = equiCss)
var wequi = line.new(na, na, na, na, color = equiCss, style = line.style_dashed)

var float supply_wavg = na
var float demand_wavg = na

if time == chart.right_visible_bar_time
    r = (max1 - min1) / div
    supply = bin.new(max1, max1, 0, 0, 0, 0, false)
    demand = bin.new(min1, min1, 0, 0, 0, 0, false)

    //Loop trough intervals
    for i = 0 to div-1
        supply.lvl -= r
        demand.lvl += r

        //Accumulated volume column
        if not supply.isreached and showSupply and supplyArea
            box.new(x1, supply.prev, x1 + int(supply.sum / csum * (n - x1)), supply.lvl, na
              , bgcolor = color.new(supplyCss, 50))
        
        if not demand.isreached and showDemand and demandArea
            box.new(x1, demand.lvl, x1 + int(demand.sum / csum * (n - x1)), demand.prev, na
              , bgcolor = color.new(demandCss, 50))
        
        //Loop trough bars
        for j = 0 to (n - x1)-1
            //Loop trough intrabars
            for k = 0 to (v[j]).size()-1
                //Accumulate if within upper internal
                supply.sum      += (h[j]).get(k) > supply.lvl and (h[j]).get(k) < supply.prev ? (v[j]).get(k) : 0
                supply.avg      += supply.lvl * (supply.sum - supply.prev_sum)
                supply.csum     += supply.sum - supply.prev_sum
                supply.prev_sum := supply.sum

                //Accumulate if within lower interval
                demand.sum      += (l[j]).get(k) < demand.lvl and (l[j]).get(k) > demand.prev ? (v[j]).get(k) : 0
                demand.avg      += demand.lvl * (demand.sum - demand.prev_sum)
                demand.csum     += demand.sum - demand.prev_sum
                demand.prev_sum := demand.sum
                
            //Test if supply accumulated volume exceed threshold and set box
            if supply.sum / csum * 100 > per and not supply.isreached
                avg = math.avg(max1, supply.lvl)
                supply_wavg := supply.avg / supply.csum

                //Set Box/Level coordinates
                if showSupply
                    supply_area.set_area(x1, max1, supply.lvl, avg, supply_wavg, supplyArea, supplyAvg, supplyWavg)

                supply.isreached := true
            
            //Test if demand accumulated volume exceed threshold and set box
            if demand.sum / csum * 100 > per and not demand.isreached and showDemand
                avg = math.avg(min1, demand.lvl)
                demand_wavg := demand.avg / demand.csum
                
                //Set Box/Level coordinates
                if showDemand
                    demand_area.set_area(x1, demand.lvl, min1, avg, demand_wavg, demandArea, demandAvg, demandWavg)

                demand.isreached := true
            
            if supply.isreached and demand.isreached
                break
        
        if supply.isreached and demand.isreached and showEqui
            //Set equilibrium
            if equiAvg
                avg = math.avg(max1, min1)
                equi.set_xy1(x1, avg)
                equi.set_xy2(n, avg)
            
            //Set weighted equilibrium
            if equiWavg
                wavg = math.avg(supply_wavg, demand_wavg)
                wequi.set_xy1(x1, wavg)
                wequi.set_xy2(n, wavg)

            break
        
        supply.prev := supply.lvl
        demand.prev := demand.lvl

//-----------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------}
//MACD Based Price Forecasting
//---------------------------------------------------------------------------------------------------------------------{
//---------------------------------------------------------------------------------------------------------------------}
//Settings
//---------------------------------------------------------------------------------------------------------------------{
//MACD
fast = input.int(12, 'Fast Length', minval = 2, group = 'MACD')
slow = input.int(26, 'Slow Length', minval = 2, group = 'MACD')
sigLen = input.int(9, 'Signal Length', minval = 2, group = 'MACD')

trend1 = input.string('MACD - Signal', 'Trend Determination',
  options = ['MACD', 'MACD - Signal'],
  group = 'MACD')

//Forecast
maxMemory = input.int(50, 'Maximum Memory', minval = 2, group = 'Forecast')
fcast = input.int(100, 'Forecasting Length', minval = 1, group = 'Forecast')
upPer = input(80, 'Top Percentile', group = 'Forecast')
midPer = input(50, 'Average Percentage', group = 'Forecast')
dnPer = input(20, 'Bottom Percentile', group = 'Forecast')

//Style
upLine = input(#3179f5, 'Line Color', inline = 'css', group = 'Style')
dnLine = input(#ff5d00, '', inline = 'css', group = 'Style')

upArea = input(color.new(#3179f5, 80), 'Areas', inline = 'areas', group = 'Style')
dnArea = input(color.new(#ff5d00, 80), '', inline = 'areas', group = 'Style')

signalArea = input(true, 'Signal Area', inline = 'signal', group = 'Style')
signalBull = input(color.new(#089981, 50), '', inline = 'signal', group = 'Style')
signalBear = input(color.new(#f23645, 50), '', inline = 'signal', group = 'Style')

//---------------------------------------------------------------------------------------------------------------------}
//Types
//---------------------------------------------------------------------------------------------------------------------{
type vector
    array<float> id

type holder
    array<vector> id

//---------------------------------------------------------------------------------------------------------------------}
//Methods/Functions
//---------------------------------------------------------------------------------------------------------------------{

method populate(holder get_holder, idx, init_price)=>
    if get_holder.id.size() < idx+1
        get_holder.id.push(vector.new(array.new<float>(0)))

    get_holder.id.get(idx).id.unshift(close - init_price)
    
    //Remove last element if array size is greater than specified limit
    if get_holder.id.get(idx).id.size() > maxMemory
        get_holder.id.get(idx).id.pop()

method forecast(holder get_holder, idx, init_price, upper_coords, mid_coords, lower_coords)=>
    max_horizon = get_holder.id.size()

    x = 0
    for i = idx-1 to math.min(idx+fcast, max_horizon-1)
        get_vector = get_holder.id.get(i)
        
        //Compute forecasts
        upper = init_price + get_vector.id.percentile_linear_interpolation(upPer)
        mid   = init_price + get_vector.id.percentile_linear_interpolation(midPer)
        lower = init_price + get_vector.id.percentile_linear_interpolation(dnPer)

        //Append coordinates
        upper_coords.push(chart.point.from_index(n+x, upper))
        mid_coords.push(chart.point.from_index(n+x, mid))
        lower_coords.unshift(chart.point.from_index(n+x, lower))
        x += 1

//---------------------------------------------------------------------------------------------------------------------}
//Calculations
//---------------------------------------------------------------------------------------------------------------------{
var memory = map.new<int, holder>()
var up_idx = 0
var dn_idx = 0
var uptrend_init_price = close
var downtrend_init_price = close

//Compute MACD
[macd, signal, _] = ta.macd(close, fast, slow, sigLen)

//Populate map
if barstate.isfirst
    memory.put(1, holder.new(array.new<vector>(0)))
    memory.put(0, holder.new(array.new<vector>(0)))

trigger = switch trend1
    'MACD' => ta.cross(macd, 0)
    => ta.cross(macd, signal)

uptrend = trend1 == 'MACD' ? macd > 0 : macd > signal
downtrend = trend1 == 'MACD' ? macd < 0 : macd < signal

//Reference prices
uptrend_init_price := uptrend and not uptrend[1] ? close : uptrend_init_price
downtrend_init_price := downtrend and not downtrend[1] ? close : downtrend_init_price
init_value = uptrend ? uptrend_init_price : downtrend_init_price

//Uptrend
if uptrend
    get_holder = memory.get(1)
    get_holder.populate(up_idx, uptrend_init_price)

//Downtrend
if downtrend
    get_holder = memory.get(0)
    get_holder.populate(dn_idx, downtrend_init_price)

//Indices
up_idx := not uptrend ? 0 : up_idx + 1
dn_idx := not downtrend ? 0 : dn_idx + 1

if trigger
    upper_coords = array.new<chart.point>(0)
    mid_coords = array.new<chart.point>(0)
    lower_coords = array.new<chart.point>(0)

    if uptrend
        get_holder = memory.get(1)
        get_holder.forecast(up_idx, uptrend_init_price, upper_coords, mid_coords, lower_coords)
    else
        get_holder = memory.get(0)
        get_holder.forecast(dn_idx, downtrend_init_price, upper_coords, mid_coords, lower_coords)
    
    polyline.delete(polyline.new(mid_coords, line_color = uptrend ? upLine : dnLine)[1])

    //Area
    polyline.delete(polyline.new(array.concat(upper_coords, lower_coords)
      , line_color = na
      , fill_color = uptrend ? upArea : dnArea)
      [1])

//---------------------------------------------------------------------------------------------------------------------}
//Plots
//---------------------------------------------------------------------------------------------------------------------{
init_plot = plot(init_value, "Reference Price", init_value != init_value[1] ? na : color.rgb(120, 123, 134, 80))
price_plot = plot(close, editable = false, display = display.none)

top_css = not signalArea ? na : uptrend ? signalBull : color.new(chart.bg_color, 100)
btm_css = not signalArea ? na : uptrend ? color.new(chart.bg_color, 100) : signalBear

//Price to Reference Area
fill(init_plot, price_plot,
  top_value = math.max(close, uptrend ? uptrend_init_price : downtrend_init_price),
  bottom_value = math.min(close, uptrend ? uptrend_init_price : downtrend_init_price),
  top_color = top_css,
  bottom_color = btm_css)

//---------------------------------------------------------------------------------------------------------------------}
//---------------------------------------------------------------------------------------------------------------------}
//Market Structure with Inducements & Sweeps
//---------------------------------------------------------------------------------------------------------------------{
//---------------------------------------------------------------------------------------------------------------------}
//Settings
//---------------------------------------------------------------------------------------------------------------------{
len = input(50, 'CHoCH Detection Period')
shortLen = input(3, 'IDM Detection Period')

//Styling
bullCss = input(#08998100, 'Bullish Elements', group = 'Style')
bearCss = input(#ff525200, 'Bearish Elements', group = 'Style')

showChoch = input(false, "Show CHoCH", group = 'Style')
showBos = input(false, "Show BOS", group = 'Style')

showIdm = input(false, "Show Inducements", inline = 'idm', group = 'Style')
idmCss = input(color.gray, "", inline = 'idm', group = 'Style')

showSweeps = input(false, "Show Sweeps", inline = 'sweeps', group = 'Style')
sweepsCss = input(color.gray, "", inline = 'sweeps', group = 'Style')

showCircles = input(true, "Show Swings", group = 'Style')

//---------------------------------------------------------------------------------------------------------------------}
//Functions
//---------------------------------------------------------------------------------------------------------------------{
//Swings detection/measurements

swings(len)=>
    var os = 0
    var int topx = na
    var int btmx = na
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : na
    topx := os == 0 and os[1] != 0 ? n[len] : topx

    btm = os == 1 and os[1] != 1 ? low[len] : na
    btmx := os == 1 and os[1] != 1 ? n[len] : btmx

    [top, topx, btm, btmx]

//---------------------------------------------------------------------------------------------------------------------}
//Swings
//---------------------------------------------------------------------------------------------------------------------{
[top, topx, btm, btmx] = swings(len)
[stop, stopx, sbtm, sbtmx] = swings(shortLen)

var os = 0
var top_crossed = false
var btm_crossed = false

var float max = na
var float min = na

var int max_x1 = na
var int min_x1 = na

var float topy = na
var float btmy = na
var stop_crossed = false
var sbtm_crossed = false    

//---------------------------------------------------------------------------------------------------------------------}
//CHoCH Detection
//---------------------------------------------------------------------------------------------------------------------{
if top
    topy := top
    top_crossed := false
if btm
    btmy := btm
    btm_crossed := false

//Test for CHoCH
if close > topy and not top_crossed
    os := 1
    top_crossed := true
if close < btmy and not btm_crossed
    os := 0
    btm_crossed := true

//Display CHoCH
if os != os[1]
    max := high
    min := low
    max_x1 := n
    min_x1 := n
    stop_crossed := false
    sbtm_crossed := false

    if os == 1 and showChoch
        line.new(topx, topy, n, topy, color = bullCss, style = line.style_dashed)
        label.new(int(math.avg(n, topx)), topy, 'CHoCH', color = color(na), style = label.style_label_down, textcolor = bullCss, size = size.tiny)
    else if showChoch
        line.new(btmx, btmy, n, btmy, color = bearCss, style = line.style_dashed)
        label.new(int(math.avg(n, btmx)), btmy, 'CHoCH', color = color(na), style = label.style_label_up, textcolor = bearCss, size = size.tiny)

stopy = fixnan(stop)
sbtmy = fixnan(sbtm)

//---------------------------------------------------------------------------------------------------------------------}
//Bullish BOS
//---------------------------------------------------------------------------------------------------------------------{
//IDM
if low < sbtmy and not sbtm_crossed and os == 1 and sbtmy != btmy
    if showIdm
        line.new(sbtmx, sbtmy, n, sbtmy, color = color.gray, style = line.style_dotted)
        label.new(int(math.avg(n, sbtmx)), sbtmy, 'IDM', color = color(na), style = label.style_label_up, textcolor = color.gray, size = size.tiny)
    
    sbtm_crossed := true

//BOS
if close > max and sbtm_crossed and os == 1
    if showBos
        line.new(max_x1, max, n, max, color = bullCss)
        label.new(int(math.avg(n, max_x1)), max, 'BOS', color = color(na), style = label.style_label_down, textcolor = bullCss, size = size.tiny)
    
    sbtm_crossed := false

//---------------------------------------------------------------------------------------------------------------------}
//Bearish BOS
//---------------------------------------------------------------------------------------------------------------------{
//IDM
if high > stopy and not stop_crossed and os == 0 and stopy != topy
    if showIdm
        line.new(stopx, stopy, n, stopy, color = color.gray, style = line.style_dotted)
        label.new(int(math.avg(n, stopx)), stopy, 'IDM', color = color(na), style = label.style_label_down, textcolor = color.gray, size = size.tiny)
    
    stop_crossed := true

//BOS
if close < min and stop_crossed and os == 0
    if showBos
        line.new(min_x1, min, n, min, color = bearCss)
        label.new(int(math.avg(n, min_x1)), min, 'BOS', color = color(na), style = label.style_label_up, textcolor = bearCss, size = size.tiny)
    
    stop_crossed := false

//---------------------------------------------------------------------------------------------------------------------}
//Sweeps
//---------------------------------------------------------------------------------------------------------------------{
if high > max and close < max and os == 1 and n - max_x1 > 1 and showSweeps
    line.new(max_x1, max, n, max, color = color.gray, style = line.style_dotted)
    label.new(int(math.avg(n, max_x1)), max, 'x', color = color(na), style = label.style_label_down, textcolor = color.gray)

if low < min and close > min and os == 0 and n - min_x1 > 1 and showSweeps
    line.new(min_x1, min, n, min, color = color.gray, style = line.style_dotted)
    label.new(int(math.avg(n, min_x1)), min, 'x', color = color(na), style = label.style_label_up, textcolor = color.gray)

//Trailing max/min
max := math.max(high, max)
min := math.min(low, min)

if max > max[1]
    max_x1 := n
if min < min[1]
    min_x1 := n

//---------------------------------------------------------------------------------------------------------------------}
//Extensions
//---------------------------------------------------------------------------------------------------------------------{
var ext_choch = line.new(na,na,na,na, style = line.style_dashed)
var ext_bos   = line.new(na,na,na,na)
var ext_idm   = line.new(na,na,na,na, style = line.style_dotted, color = idmCss)

var ext_choch_lbl = label.new(na,na, 'CHoCH', color = color(na), size = size.tiny)
var ext_bos_lbl   = label.new(na,na, 'BOS'  , color = color(na), size = size.tiny)
var ext_idm_lbl   = label.new(na,na, 'IDM'  , color = color(na), size = size.tiny, textcolor = idmCss)

if barstate.islast
    if os == 1
        ext_choch.set_xy1(btmx, btmy), ext_choch.set_xy2(n, btmy), ext_choch.set_color(bearCss)    
        ext_choch_lbl.set_xy(n, btmy), ext_choch_lbl.set_style(label.style_label_up), ext_choch_lbl.set_textcolor(bearCss)
        
        ext_bos.set_xy1(max_x1, max), ext_bos.set_xy2(n, max), ext_bos.set_color(bullCss)    
        ext_bos_lbl.set_xy(n, max), ext_bos_lbl.set_style(label.style_label_down), ext_bos_lbl.set_textcolor(bullCss)
        
        if not sbtm_crossed
            ext_idm.set_xy1(sbtmx, sbtmy), ext_idm.set_xy2(n+15, sbtmy)   
            ext_idm_lbl.set_xy(n+15, sbtmy), ext_idm_lbl.set_style(label.style_label_up)
            ext_idm.set_color(idmCss), ext_idm_lbl.set_textcolor(idmCss)
        else
            ext_idm.set_color(na)
            ext_idm_lbl.set_textcolor(na)
    else
        ext_choch.set_xy1(topx, topy), ext_choch.set_xy2(n, topy), ext_choch.set_color(bullCss)    
        ext_choch_lbl.set_xy(n, topy), ext_choch_lbl.set_style(label.style_label_down), ext_choch_lbl.set_textcolor(bullCss)
        
        ext_bos.set_xy1(min_x1, min), ext_bos.set_xy2(n, min), ext_bos.set_color(bearCss)    
        ext_bos_lbl.set_xy(n, min), ext_bos_lbl.set_style(label.style_label_up), ext_bos_lbl.set_textcolor(bearCss)

        if not stop_crossed
            ext_idm.set_xy1(stopx, stopy), ext_idm.set_xy2(n+15, stopy)   
            ext_idm_lbl.set_xy(n+15, stopy), ext_idm_lbl.set_style(label.style_label_down)
            ext_idm.set_color(idmCss), ext_idm_lbl.set_textcolor(idmCss)
        else
            ext_idm.set_color(na)
            ext_idm_lbl.set_textcolor(na)

//---------------------------------------------------------------------------------------------------------------------}
//Plots
//---------------------------------------------------------------------------------------------------------------------{
plot(showCircles ? top : na, 'Swing High', color.new(signalBear, 50), 5, plot.style_circles, offset = -len)
plot(showCircles ? btm : na, 'Swing Low', color.new(signalBull, 50), 5, plot.style_circles, offset = -len)

//---------------------------------------------------------------------------------------------------------------------}
// Oscillators Overlay w/ Divergencies //
// ----------------------------------------------------------------------------------- //

ma(_source, _length, _type) => 
    switch _type
        "SMA"  => ta.sma (_source, _length)
        "EMA"  => ta.ema (_source, _length)
        "RMA"  => ta.rma (_source, _length)
        "WMA"  => ta.wma (_source, _length)
        "VWMA" => ta.vwma(_source, _length)

alarm(_osc, _message) => 
    alert(syminfo.ticker + ' ' + _osc + ' : ' + _message + ', price (' + str.tostring(close, format.mintick) + ')')

// ---------------------------------------------------------------------------------------------- //
// Inputs  -------------------------------------------------------------------------------------- //

oscType       = input.string("Distance Oscillator", "Pick an Oscillator", 
                             options=[
                                      "Awesome Oscillator (AO)",
                                      "Chaikin Oscillator (Chaikin Osc)",
                                      "Commodity Channel Index (CCI)",
                                      "Distance Oscillator",
                                      "Elder-Ray Bear and Bull Power",
                                      "Elliott Wave Oscillator (EWO)",
                                      "Klinger Oscillator",
                                      "Money Flow Index (MFI)",
                                      "Moving Average Convergence Divergence (MACD)",
                                      "Rate Of Change (ROC)",
                                      "Relative Strength Index (RSI)",
                                      "Stochastic (Stoch)",
                                      "Stochastic RSI (Stoch RSI)",
                                      "Volume Oscillator (Volume Osc)",
                                      "Wave Trend [LazyBear]"
                                      ])

group_ocs         = 'Plotting Settings - General  ================'
oscLookbackLength = input.int(200, 'Display Length', minval = 10, step = 10, maxval = 250, group=group_ocs) 
oscPlacement      = input.string('Bottom', 'Placement', options = ['Top', 'Bottom'], group=group_ocs)
oscHight          = 11 - input.int(7, 'Hight' , minval = 1, maxval = 10 , group=group_ocs )
oscVerticalOffset = input.int(3, "Vertical Offset", minval = -3, maxval = 10, group=group_ocs) / 10

group_diver       = 'Divergence Settings - General  =============='
lbR               = input(5, "Pivot Lookback Right", group=group_diver)
lbL               = input(5, "Pivot Lookback Left", group=group_diver)
rangeUpper        = input(60, "Max of Lookback Range", group=group_diver)
rangeLower        = input(5, "Min of Lookback Range", group=group_diver)
plotBull          = input(true, "Plot Bullish  |  Hidden Bullish", inline = 'bull', group=group_diver)
plotHiddenBull    = input(false, "", inline='bull', group=group_diver)
plotBear          = input(true, "Plot Bearish |  Hidden Bearish", inline = 'bear', group=group_diver)
plotHiddenBear    = input(false, "", inline = 'bear', group=group_diver)

group_alert       = 'Alert Settings - General  ==================='
signalCross       = input(true, "Signal Line Crosses", group=group_alert)
centerCross       = input(false, "Center Line Crosses", group=group_alert)
osobCross         = input(true, "Overbought/Oversold Crosses", group=group_alert)
histChange        = input(true, "Histogram Color Changes", group=group_alert)
oscDivergece      = input(true, "Divergence Detection", group=group_alert)

group_Chaikin     = 'Chaikin Osc Settings  ======================='
chaikinShort      = input.int(3, minval=1, title="Fast Length", group=group_Chaikin)
chaikinLong       = input.int(10, minval=1, title="Slow Length", group=group_Chaikin)

group_cci         = 'CCI Settings   ==============================='
cciLength         = input.int(20, 'Length', minval=1, group=group_cci)
cciSource         = input(hlc3, "Source", group=group_cci)
cciUpperBand      = input.int(100, 'Upper Band', group=group_cci)
cciLowerBand      = input.int(-100, 'Lower Band', group=group_cci)
cciSmoothing      = input.bool(false, 'Oscillator MA', inline = 'CCI', group=group_cci)
cciMaType         = input.string(title = "", defval = "SMA", options=["SMA", "EMA", "RMA", "WMA", "VWMA"], inline = 'CCI',group=group_cci)
cciSmoothLength   = input.int(5, "Oscillator MA Length", minval = 1, maxval = 100, group=group_cci)

group_pma         = 'Distance Osc Settings ======================='
pmaSource         = input.source(close, "Source", group = group_pma)
pmaLength         = input.int(20,    "Oscillator Length", minval = 2, maxval = 50, group = group_pma)
pmaMaType         = input.string("SMA", "Oscillator MA Type" , options=["SMA", "EMA"], group=group_pma)
pmaSignalLength   = input.int(9,    "Signal Line MA Length", minval = 2, maxval = 50, group = group_pma)
pmaSignalMA       = input.string("EMA", "Signal Line MA Type", options=["SMA", "EMA"], group=group_pma)

group_ewo         = 'EWO Settings   =============================='
ewoSiganl         = input.bool(true, 'Signal Line', inline = 'EWO', group=group_ewo)
ewoSignalMAType   = input.string("SMA", "", options=["SMA", "EMA", "RMA", "WMA", "VWMA"], inline = 'EWO', group=group_ewo)
ewoSignalLength   = input.int(5 , "Signal Smoothing",  minval = 1, maxval = 50       , group=group_ewo)

group_mfi         = 'MFI Settings  ================================'
mfiLegth          = input.int(14, "Length", minval=1, maxval=2000, group=group_mfi)
mfiUpperBand      = input.int(80, 'Upper Band', group=group_mfi)
mfiLowerBand      = input.int(20, 'Lower Band', group=group_mfi)

group_macd        = 'MACD Settings  =============================='
macdFastLength    = input.int(12, "Fast Length", minval = 1, group=group_macd)
macdSlowLength    = input.int(26, "Slow Length", minval = 1, group=group_macd)
macdSource        = input(close , "Source", group=group_macd)
macdSignalLength  = input.int(9 , "Signal Smoothing",  minval = 1, maxval = 50       , group=group_macd)
macdSourceMA      = input.string("EMA", "Oscillator MA Type" , options=["SMA", "EMA"], group=group_macd)
macdSignalMA      = input.string("EMA", "Signal Line MA Type", options=["SMA", "EMA"], group=group_macd)

group_roc         = 'ROC Settings  ================================'
rocLength         = input.int(9, minval=1, group=group_roc)
rocSource         = input(close, "Source", group=group_roc)

group_rsi         = 'RSI Settings   ==============================='
rsiLength         = input.int(14, "Length", minval = 1, group=group_rsi)
rsiSource         = input.source(close, "Source", group=group_rsi)
rsiObThresh       = input.int(70, 'Overbought', minval=50, maxval=100, group=group_rsi)
rsiOsThresh       = input.int(30, 'Oversold' , minval=1 , maxval=50 , group=group_rsi)
rsiSmoothing      = input.bool(true, 'Oscillator MA', inline = 'RSI', group=group_rsi)
rsiMaType         = input.string("EMA", "", options=["SMA", "EMA", "RMA", "WMA", "VWMA"], inline = 'RSI', group=group_rsi)
rsiMaLength       = input.int(14, "Oscillator MA Length", group=group_rsi)

group_stoch       = 'Stochastic Settings  =========================='
stochPeriodK      = input.int(14, "%K Length", minval=1, group=group_stoch)
stochSmoothK      = input.int(1 , "%K Smoothing", minval=1, group=group_stoch)
stochPeriodD      = input.int(3 , "%D Smoothing", minval=1, group=group_stoch)
stochUpperBand    = input.int(80, 'Upper Band', group=group_stoch)
stochLowerBand    = input.int(20, 'Lower Band', group=group_stoch)

group_stochRsi    = 'Stochastic RSI Settings  ======================'
stochRSmoothK     = input.int(3 , "%K Smoothing", minval=1, group=group_stochRsi)
stochRPeriodD     = input.int(3 , "%D Smoothing", minval=1, group=group_stochRsi)
stochRsiLength    = input.int(14, "RSI Length", minval=1, group=group_stochRsi)
stochRLength      = input.int(14, "Stochastic Length", minval=1, group=group_stochRsi)
stochRSoruce      = input(close, "RSI Source", group=group_stochRsi)
stochRUpperBand   = input.int(80, 'Upper Band', group=group_stochRsi)
stochRLowerBand   = input.int(20, 'Lower Band', group=group_stochRsi)

group_volumeOsc   = 'Volume Osc Settings  =========================='
volShortLength    = input.int(5, "Short Length", minval = 1, group=group_volumeOsc)
volLongLength     = input.int(10, "Long Length", minval = 1, group=group_volumeOsc)

group_wave        = 'Wave Trend Settings   =========================='
waveChLength      = input.int(10, 'Channel Length', minval=1, group=group_wave)
waveAvgLength     = input.int(21, 'Average Length', minval=1, group=group_wave)
waveUpperBand     = input.int(53, 'Upper Band', group=group_wave)
waveLowerBand     = input.int(-53, 'Lower Band', group=group_wave)

// Inputs  -------------------------------------------------------------------------------------- //
// ---------------------------------------------------------------------------------------------- //
// Calculations  -------------------------------------------------------------------------------- //

nzVolume = nz(volume)

osc = switch oscType
    "Awesome Oscillator (AO)"                      => ma(hl2, 5, 'SMA') - ma(hl2, 34, 'SMA')
    "Chaikin Oscillator (Chaikin Osc)"             => ma(ta.accdist, chaikinShort, 'EMA') - ma(ta.accdist, chaikinLong, 'EMA')
    'Commodity Channel Index (CCI)'                => (cciSource - ma(cciSource, cciLength, 'SMA')) / (0.015 * ta.dev(cciSource, cciLength))
    "Distance Oscillator"                          => (pmaSource/ma(pmaSource, pmaLength, pmaMaType) - 1) * 100
    "Elder-Ray Bear and Bull Power"                => high - ma(close, 13, 'EMA')
    "Elliott Wave Oscillator (EWO)"                => ma(close, 5, 'SMA') - ma(close, 35, 'SMA')
    "Klinger Oscillator"                           => sv = ta.change(hlc3) >= 0 ? nzVolume : -nzVolume, ma(sv, 34, 'EMA') - ma(sv, 55, 'EMA')
    "Money Flow Index (MFI)"                       => ta.mfi(hlc3, mfiLegth)
    'Moving Average Convergence Divergence (MACD)' => ma(macdSource, macdFastLength, macdSourceMA) - ma(macdSource, macdSlowLength, macdSourceMA)
    "Rate Of Change (ROC)"                         => 100 * (rocSource - rocSource[rocLength])/rocSource[rocLength]
    'Relative Strength Index (RSI)'                => ta.rsi(rsiSource, rsiLength)
    'Stochastic (Stoch)'                           => ma(ta.stoch(close, high, low, stochPeriodK), stochSmoothK, 'SMA')
    'Stochastic RSI (Stoch RSI)'                   => rsix = ta.rsi(stochRSoruce, stochRsiLength), ma(ta.stoch(rsix, rsix, rsix, stochRLength), stochRSmoothK, 'SMA')
    "Volume Oscillator (Volume Osc)"               => 100 * (ma(nzVolume, volShortLength, 'EMA') - ma(nzVolume, volLongLength, 'EMA')) / ma(nzVolume, volLongLength, 'EMA')
    "Wave Trend [LazyBear]"                        => esa = ma(hlc3, waveChLength, 'EMA'), d = ma(math.abs(hlc3 - esa), waveChLength, 'EMA'), ci = (hlc3 - esa) / (0.015 * d), ma(ci, waveAvgLength, 'EMA')

signal1 = switch oscType
    'Commodity Channel Index (CCI)'                => cciSmoothing ? ma(osc, cciSmoothLength, cciMaType) : na
    "Distance Oscillator"                          => ma(osc, pmaSignalLength, pmaSignalMA)
    "Elder-Ray Bear and Bull Power"                => -(low  - ma(close, 13, 'EMA'))
    "Elliott Wave Oscillator (EWO)"                => ewoSiganl ? ma(osc, ewoSignalLength, ewoSignalMAType) : na
    "Klinger Oscillator"                           => ma(osc, 13, 'EMA')
    'Moving Average Convergence Divergence (MACD)' => ma(osc, macdSignalLength, macdSignalMA)
    'Relative Strength Index (RSI)'                => rsiSmoothing ? ma(osc, rsiMaLength, rsiMaType) : na
    'Stochastic (Stoch)'                           => ma(osc, stochPeriodD, 'SMA')
    'Stochastic RSI (Stoch RSI)'                   => ma(osc, stochRPeriodD, 'SMA')
    "Wave Trend [LazyBear]"                        => ma(osc, 4, 'SMA')

[plotHist, histogram] = switch oscType
    "Awesome Oscillator (AO)"                      => [true, ma(hl2, 5, 'SMA') - ma(hl2, 34, 'SMA')]
    "Distance Oscillator"                          => [true, osc - signal1]
    "Elliott Wave Oscillator (EWO)"                => [true, ma(close, 5, 'SMA') - ma(close, 35, 'SMA')]
    'Moving Average Convergence Divergence (MACD)' => [true, osc - signal1]
    "Wave Trend [LazyBear]"                        => [true, osc - signal1]
    => [false, 0.]

[oscColor, signalColor, fillColor, histColor] = switch oscType
    "Awesome Oscillator (AO)"                      => [#00000000, #00000000, #00000000, histogram - histogram[1] <= 0 ? #F44336 : #009688]
    "Chaikin Oscillator (Chaikin Osc)"             => [#EC407A, #00000000, #00000000, #00000000]
    'Commodity Channel Index (CCI)'                => [#2962ff, #f37f20, color.new(#2196f3, 90), #00000000]
    "Distance Oscillator"                          => [color.red, color.blue, #00000000, histogram > 0 ? color.new(color.green, 34) : color.new(color.red  , 34)]
    "Elder-Ray Bear and Bull Power"                => [color.green, color.red, #00000000, #00000000]
    "Elliott Wave Oscillator (EWO)"                => [#00000000, #FF6D00, #00000000, histogram >= 0 ? histogram[1] < histogram ? #006400 : color.green : histogram[1] < histogram ? color.red : #910000]
    "Klinger Oscillator"                           => [#2962FF, #43A047, #00000000, #00000000]
    "Money Flow Index (MFI)"                       => [#7E57C2, #00000000, color.new(#7e57c2, 90), #00000000]
    'Moving Average Convergence Divergence (MACD)' => [#2962FF, #FF6D00, #00000000, histogram >= 0 ? histogram[1] < histogram ? #26A69A : #B2DFDB : histogram[1] < histogram ? #FFCDD2 : #FF5252]
    "Rate Of Change (ROC)"                         => [#2962FF, #00000000, #00000000, #00000000]
    'Relative Strength Index (RSI)'                => [#7e57c2, #ffeb3b, color.new(#7e57c2, 90), #00000000]
    'Stochastic (Stoch)'                           => [#2962FF, #FF6D00, color.new(#2196f3, 90), #00000000]
    'Stochastic RSI (Stoch RSI)'                   => [#2962FF, #FF6D00, color.new(#2196f3, 90), #00000000]
    "Volume Oscillator (Volume Osc)"               => [#2962FF, #00000000, #00000000, #00000000]
    "Wave Trend [LazyBear]"                        => [#008000, #FF0000, #00000000, #0000FF50]
    
[plotTresh, upperBand, plotMidLile, midLine, lowerBand] = switch oscType
    "Chaikin Oscillator (Chaikin Osc)"             => [false, 0, true, 0, 0]
    'Commodity Channel Index (CCI)'                => [true, cciUpperBand, false,  0, cciLowerBand]
    "Money Flow Index (MFI)"                       => [true, mfiUpperBand, false,  0, mfiLowerBand]
    "Rate Of Change (ROC)"                         => [false, 0, true, 0, 0]
    'Relative Strength Index (RSI)'                => [true, rsiObThresh , true , 50, rsiOsThresh ]
    'Stochastic (Stoch)'                           => [true, stochUpperBand, false,  0, stochLowerBand]
    'Stochastic RSI (Stoch RSI)'                   => [true, stochRUpperBand, false,  0, stochRLowerBand]
    "Volume Oscillator (Volume Osc)"               => [false, 0, true, 0, 0]
    "Wave Trend [LazyBear]"                        => [true, waveUpperBand , false , 0, waveLowerBand ]
    => [false, 0., false, 0., 0.]

// Calculations  -------------------------------------------------------------------------------- //
// ---------------------------------------------------------------------------------------------- //
// Divergence  ---------------------------------------------------------------------------------- //

plFound = na(ta.pivotlow (osc, lbL, lbR)) ? false : true
phFound = na(ta.pivothigh(osc, lbL, lbR)) ? false : true
_inRange(cond) =>
	bars = ta.barssince(cond == true)
	rangeLower <= bars and bars <= rangeUpper

// Regular Bullish = Osc: Higher Low - Price: Lower Low
oscHL    = osc[lbR] > ta.valuewhen(plFound, osc[lbR], 1) and _inRange(plFound[1])
priceLL  = low[lbR] < ta.valuewhen(plFound, low[lbR], 1)
bullCond = plotBull and priceLL and oscHL and plFound
plot(plFound ? low[lbR] : na, offset=-lbR, title="Regular Bullish", linewidth=2, color=(bullCond ? color.rgb(76, 175, 79, 50) : na), show_last = oscLookbackLength)
plotshape(bullCond ? low[lbR] : na, offset=-lbR, title="Regular Bullish Label", text=" Bull ", style=shape.labelup, location=location.absolute, color=color.rgb(76, 175, 79, 50), textcolor=color.white, show_last = oscLookbackLength)

// Hidden Bullish = Osc: Lower Low - Price: Higher Low
oscLL          = osc[lbR] < ta.valuewhen(plFound, osc[lbR], 1) and _inRange(plFound[1])
priceHL        = low[lbR] > ta.valuewhen(plFound, low[lbR], 1)
hiddenBullCond = plotHiddenBull and priceHL and oscLL and plFound
plot(plFound ? low[lbR] : na, offset=-lbR, title="Hidden Bullish", linewidth=2, color=(hiddenBullCond ? color.new(color.green, 50) : na), show_last = oscLookbackLength)
plotshape(hiddenBullCond ? low[lbR] : na, offset=-lbR, title="Hidden Bullish Label", text=" H Bull ", style=shape.labelup, location=location.absolute, color=color.rgb(76, 175, 79, 50), textcolor=color.white, show_last = oscLookbackLength)

// Regular Bearish = Osc: Lower High - Price: Higher High
oscLH    = osc[lbR]  < ta.valuewhen(phFound, osc[lbR], 1) and _inRange(phFound[1])
priceHH  = high[lbR] > ta.valuewhen(phFound, high[lbR], 1)
bearCond = plotBear and priceHH and oscLH and phFound
plot(phFound ? high[lbR] : na, offset=-lbR, title="Regular Bearish", linewidth=2, color=(bearCond ? color.rgb(255, 82, 82, 50) : na), show_last = oscLookbackLength)
plotshape(bearCond ? high[lbR] : na, offset=-lbR, title="Regular Bearish Label", text=" Bear ", style=shape.labeldown, location=location.absolute, color=color.rgb(255, 82, 82, 50), textcolor=color.white, show_last = oscLookbackLength)

// Hidden Bearish = Osc: Higher High - Price: Lower High
oscHH          = osc[lbR]  > ta.valuewhen(phFound, osc[lbR], 1) and _inRange(phFound[1])
priceLH        = high[lbR] < ta.valuewhen(phFound, high[lbR], 1)
hiddenBearCond = plotHiddenBear and priceLH and oscHH and phFound
plot(phFound ? high[lbR] : na, offset=-lbR, title="Hidden Bearish", linewidth=2, color=(hiddenBearCond ? color.new(color.red, 50) : na), show_last = oscLookbackLength)
plotshape(hiddenBearCond ? high[lbR] : na, offset=-lbR, title="Hidden Bearish Label", text=" H Bear ", style=shape.labeldown, location=location.absolute, color=color.rgb(255, 82, 82, 50), textcolor=color.white, show_last = oscLookbackLength)

// Divergence  ---------------------------------------------------------------------------------- //
// ---------------------------------------------------------------------------------------------- //
// Alerts  -------------------------------------------------------------------------------------- //

if signalCross and ta.cross(osc, signal1)
    alarm(oscType, 'Signal Line Cross')

if histChange and ta.cross(ta.change(histogram), 0)
    alarm(oscType, 'Histogram Color Change')

if centerCross and ta.cross(osc, midLine)
    alarm(oscType, 'Center Line Cross') 
    
if osobCross and ta.cross(osc, upperBand)
    alarm(oscType, 'Overbought Band Cross') 

if osobCross and ta.cross(osc, lowerBand)
    alarm(oscType, 'Oversold Band Cross') 

if oscDivergece and (bullCond or bearCond)
    alarm(oscType, bullCond ? 'Bullish Divergence Detected' : 'Bearish Divergence Detected')

if oscDivergece and (hiddenBullCond or hiddenBearCond)
    alarm(oscType, hiddenBullCond ? 'Hidden Bullish Divergence Detected' : 'Hidden Bearish Divergence Detected')

// Alerts  -------------------------------------------------------------------------------------- //
// ---------------------------------------------------------------------------------------------- //
