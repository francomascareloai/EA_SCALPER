// Â© MEOW PURR (@MeowForex1)

//@version=6
indicator('Goal Arrows', overlay=true, max_labels_count=500)

show_tp_sl = input.bool(true, 'Display TP & SL', group='Technical', tooltip='Display the exact TP & SL price levels for BUY & SELL signals.')
rrr = input.string('1:2', 'Risk to Reward Ratio', group='Technical', options=['1:1', '2:3', '1:2', '1:4'], tooltip='Set a risk to reward ratio (RRR).')
tp_sl_multi = input.float(1, 'TP & SL Multiplier', 1, group='Technical',  tooltip='Multiplies both TP and SL by a chosen index. Higher - higher risk.')
tp_sl_prec = input.int(2, 'TP & SL Precision', 0, group='Technical')

// Support & Resistance Settings
show_sr = input.bool(true, 'Show Support & Resistance', group='Support & Resistance')
sr_length = input.int(20, 'S&R Pivot Length', minval=5, maxval=50, group='Support & Resistance')
sr_strength = input.int(2, 'S&R Minimum Touches', minval=1, maxval=5, group='Support & Resistance', tooltip='Minimum touches required for a level to be considered strong')
sr_break_buffer = input.float(0.5, 'S&R Break Buffer (ATR Multiple)', minval=0.1, maxval=2, group='Support & Resistance', tooltip='Buffer for detecting level breaks (in ATR multiples)')
sr_max_levels = input.int(5, 'Max S&R Levels', minval=1, maxval=10, group='Support & Resistance')

// Dashboard Settings
show_dashboard = input.bool(true, 'Show Dashboard', group='Dashboard')

candle_stability_index_param = 0.5
rsi_index_param = 70
candle_delta_length_param = 4
disable_repeating_signals_param = input.bool(true, 'Disable Repeating Signals', group='Technical', tooltip='Removes repeating signals. Useful for removing clusters of signals and general clarity.')

GREEN = color.rgb(29, 255, 40)
RED = color.rgb(255, 0, 0)
TRANSPARENT = color.rgb(0, 0, 0, 100)
BLUE = color.rgb(33, 150, 243)

label_style = input.string('text bubble', 'Label Style', ['text bubble', 'triangle', 'arrow'], group='Cosmetic')
buy_label_color = input(GREEN, 'BUY Label Color', inline='Highlight', group='Cosmetic')
sell_label_color = input(RED, 'SELL Label Color', inline='Highlight', group='Cosmetic')
label_text_color = input(color.white, 'Label Text Color', inline='Highlight', group='Cosmetic')
resistance_color = input(RED, 'Resistance Color', group='Cosmetic')
support_color = input(GREEN, 'Support Color', group='Cosmetic')

stable_candle = ta.tr > 0 ? math.abs(close - open) / ta.tr > candle_stability_index_param : false
rsi = ta.rsi(close, 14)
atr = ta.atr(14)

bullish_engulfing = close[1] < open[1] and close > open and close > open[1]
rsi_below = rsi < rsi_index_param
decrease_over = close < close[candle_delta_length_param]

// Modified signal tracking logic
var int last_buy_bar = na
var int last_sell_bar = na
var tp = 0.
var sl = 0.

// Signal conditions
bull_state = bullish_engulfing and stable_candle and rsi_below and decrease_over

// Improved repeating signal logic
bull_signal_allowed = not disable_repeating_signals_param or na(last_buy_bar) or (bar_index - last_buy_bar) >= 5 or not na(last_sell_bar) and (bar_index - last_sell_bar) >= 1
bull = bull_state and bull_signal_allowed

bearish_engulfing = close[1] > open[1] and close < open and close < open[1]
rsi_above = rsi > 100 - rsi_index_param
increase_over = close > close[candle_delta_length_param]

bear_state = bearish_engulfing and stable_candle and rsi_above and increase_over

// Improved repeating signal logic
bear_signal_allowed = not disable_repeating_signals_param or na(last_sell_bar) or (bar_index - last_sell_bar) >= 5 or not na(last_buy_bar) and (bar_index - last_buy_bar) >= 1
bear = bear_state and bear_signal_allowed

// Support & Resistance Levels
var float[] resistance_levels = array.new<float>()
var line[] resistance_lines = array.new<line>()
var float[] support_levels = array.new<float>()
var line[] support_lines = array.new<line>()

// Calculate pivot points
pivot_high = ta.pivothigh(high, sr_length, sr_length)
pivot_low = ta.pivotlow(low, sr_length, sr_length)

// Function to check if level already exists (with tolerance)
level_exists(level, levels_array) =>
    exists = false
    if array.size(levels_array) > 0
        for i = 0 to array.size(levels_array) - 1
            if math.abs(array.get(levels_array, i) - level) <= atr * 0.1
                exists := true
                break
    exists

// Function to count touches near a level
count_touches(level, lookback = 100) =>
    touches = 0
    if bar_index >= lookback
        for i = 1 to lookback
            if math.abs(high[i] - level) <= atr * 0.3 or math.abs(low[i] - level) <= atr * 0.3
                touches += 1
    touches

// Add resistance levels
if not na(pivot_high) and show_sr
    resistance_level = high[sr_length]
    touches = count_touches(resistance_level)
    
    if touches >= sr_strength and not level_exists(resistance_level, resistance_levels) and array.size(resistance_levels) < sr_max_levels
        array.push(resistance_levels, resistance_level)
        new_line = line.new(bar_index - sr_length, resistance_level, bar_index + 20, resistance_level, 
                          color=resistance_color, width=2, style=line.style_dashed, extend=extend.right)
        array.push(resistance_lines, new_line)

// Add support levels
if not na(pivot_low) and show_sr
    support_level = low[sr_length]
    touches = count_touches(support_level)
    
    if touches >= sr_strength and not level_exists(support_level, support_levels) and array.size(support_levels) < sr_max_levels
        array.push(support_levels, support_level)
        new_line = line.new(bar_index - sr_length, support_level, bar_index + 20, support_level, 
                          color=support_color, width=2, style=line.style_dashed, extend=extend.right)
        array.push(support_lines, new_line)

// Check for broken levels and remove them
if show_sr and barstate.isconfirmed
    // Check resistances
    if array.size(resistance_levels) > 0
        for i = array.size(resistance_levels) - 1 to 0
            if i < array.size(resistance_levels)  // Double check bounds
                level = array.get(resistance_levels, i)
                if close > level + (atr * sr_break_buffer)
                    if i < array.size(resistance_lines)
                        line.delete(array.get(resistance_lines, i))
                        array.remove(resistance_lines, i)
                    array.remove(resistance_levels, i)
    
    // Check supports
    if array.size(support_levels) > 0
        for i = array.size(support_levels) - 1 to 0
            if i < array.size(support_levels)  // Double check bounds
                level = array.get(support_levels, i)
                if close < level - (atr * sr_break_buffer)
                    if i < array.size(support_lines)
                        line.delete(array.get(support_lines, i))
                        array.remove(support_lines, i)
                    array.remove(support_levels, i)

// Clean old lines periodically (every 50 bars)
if bar_index % 50 == 0 and show_sr
    // Extend existing lines
    if array.size(resistance_lines) > 0
        for i = 0 to array.size(resistance_lines) - 1
            line.set_x2(array.get(resistance_lines, i), bar_index + 20)
    if array.size(support_lines) > 0
        for i = 0 to array.size(support_lines) - 1
            line.set_x2(array.get(support_lines, i), bar_index + 20)

round_up(number, decimals) =>
    factor = math.pow(10, decimals)
    math.ceil(number * factor) / factor

if bull
    last_buy_bar := bar_index
    dist = atr * tp_sl_multi
    tp_dist = rrr == '2:3' ? dist / 2 * 3 : rrr == '1:2' ? dist * 2 : rrr == '1:4' ? dist * 4 : dist
    tp := round_up(close + tp_dist, tp_sl_prec)
    sl := round_up(close - dist, tp_sl_prec)

    if label_style == 'text bubble'
        label.new(bar_index, low, 'BUY', color=buy_label_color, style=label.style_label_up, textcolor=label_text_color, size=size.normal)
    else if label_style == 'triangle'
        label.new(bar_index, low, 'BUY', yloc=yloc.belowbar, color=buy_label_color, style=label.style_triangleup, textcolor=TRANSPARENT, size=size.normal)
    else if label_style == 'arrow'
        label.new(bar_index, low, 'BUY', yloc=yloc.belowbar, color=buy_label_color, style=label.style_arrowup, textcolor=TRANSPARENT, size=size.normal)

    if show_tp_sl
        label.new(bar_index, low, 'TP: ' + str.tostring(tp) + '\nSL: ' + str.tostring(sl), yloc=yloc.price, color=color.gray, style=label.style_label_down, textcolor=label_text_color, size=size.small)

if bear
    last_sell_bar := bar_index
    dist = atr * tp_sl_multi
    tp_dist = rrr == '2:3' ? dist / 2 * 3 : rrr == '1:2' ? dist * 2 : rrr == '1:4' ? dist * 4 : dist
    tp := round_up(close - tp_dist, tp_sl_prec)
    sl := round_up(close + dist, tp_sl_prec)

    if label_style == 'text bubble'
        label.new(bar_index, high, 'SELL', color=sell_label_color, style=label.style_label_down, textcolor=label_text_color, size=size.normal)
    else if label_style == 'triangle'
        label.new(bar_index, high, 'SELL', yloc=yloc.abovebar, color=sell_label_color, style=label.style_triangledown, textcolor=TRANSPARENT, size=size.normal)
    else if label_style == 'arrow'
        label.new(bar_index, high, 'SELL', yloc=yloc.abovebar, color=sell_label_color, style=label.style_arrowdown, textcolor=TRANSPARENT, size=size.normal)

    if show_tp_sl
        label.new(bar_index, high, 'TP: ' + str.tostring(tp) + '\nSL: ' + str.tostring(sl), yloc=yloc.price, color=color.gray, style=label.style_label_up, textcolor=label_text_color, size=size.small)

// Dashboard
if show_dashboard and barstate.islast
    var table dashboard = table.new(position.top_right, 2, 5, bgcolor=color.new(color.black, 80), border_width=1, border_color=color.gray)
    
    // Header
    table.cell(dashboard, 0, 0, "Goal Arrows", text_color=color.white, text_size=size.normal, bgcolor=color.new(BLUE, 20))
    table.cell(dashboard, 1, 0, "v2.0", text_color=color.white, text_size=size.small, bgcolor=color.new(BLUE, 20))
    
    // Author Info
    table.cell(dashboard, 0, 1, "Author:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 1, "MEOW PURR", text_color=color.yellow, text_size=size.small)
    
    table.cell(dashboard, 0, 2, "Telegram:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 2, "@MeowForex1", text_color=color.aqua, text_size=size.small)
    
    // Stats
    table.cell(dashboard, 0, 3, "RSI:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 3, str.tostring(math.round(rsi, 1)), text_color=rsi > 70 ? color.red : rsi < 30 ? color.lime : color.white, text_size=size.small)
    
    table.cell(dashboard, 0, 4, "ATR:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 4, str.tostring(math.round(atr, 5)), text_color=color.white, text_size=size.small)

alertcondition(bull or bear, 'BUY & SELL Signals', 'New signal!')
alertcondition(bull, 'BUY Signals (Only)', 'New signal: BUY')
alertcondition(bear, 'SELL Signals (Only)', 'New signal: SELL')