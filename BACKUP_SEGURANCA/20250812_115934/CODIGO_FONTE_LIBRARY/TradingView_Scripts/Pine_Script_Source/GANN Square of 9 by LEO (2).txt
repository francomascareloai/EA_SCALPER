//@version=5
indicator("GANN Square of 9 by LEO", overlay=true,max_boxes_count=500, max_lines_count=500, max_labels_count = 500)


// Parámetros para seleccionar si es horario de verano o invierno en Nueva York
Summer_time = input.bool(true, "Is Summer Time?")

// Obtener la hora actual en Nueva York (horario estándar)
ny_hour = hour(time) + 16 // Ajuste de la diferencia horaria (5 horas)
ny_hour := ny_hour < 0 ? ny_hour + 24 : ny_hour // Asegurar que la hora esté dentro del rango 0-23
ny_hour := ny_hour > 23 ? ny_hour - 24 : ny_hour

// Si la opción es horario de verano en Nueva York (segundo domingo de marzo al primer domingo de noviembre)
is_dst = Summer_time and (
         (year > 0 and month == 3 and dayofweek == 1 and dayofmonth >= 8 and dayofmonth <= 14 and hour >= 7) or
         (year > 0 and month > 3 and month < 11) or
         (year > 0 and month == 11 and dayofweek == 1 and dayofmonth >= 1 and dayofmonth <= 7 and hour < 6)
         )

// Ajustar la hora actual en Nueva York según el horario de verano
ny_hour := is_dst ? ny_hour + 1 : ny_hour

// Asegurar que la hora esté dentro del rango 0-23
ny_hour := ny_hour < 0 ? ny_hour + 24 : ny_hour
ny_hour := ny_hour > 23 ? ny_hour - 24 : ny_hour

// Condición para mostrar en pantalla cuando es medianoche del día en curso en Nueva York
is_midnight_candle = ny_hour == 18 and minute(time) == 0


// Obtener la hora actual en UTC
//utc_hour = hour(time)
//utc_minute = minute(time)

// Convertir la hora actual a UTC-4
//utc_minus_4_hour = utc_hour - 1
//if (utc_minus_4_hour < 0)
    //utc_minus_4_hour := utc_minus_4_hour + 24

// Determinar si es la vela de medianoche en UTC-4
//is_midnight_candle = utc_minus_4_hour == 0 and utc_minute == 0

var float midnight_open = na
var float midnight_high = na
var float midnight_low = na
var float midnight_close = na

// Si es la vela de medianoche en UTC-7, almacenar los valores de OHLC
if is_midnight_candle
    midnight_open := open
    midnight_high := high
    midnight_low := low
    midnight_close := close

// Calcular la operación matemática
midnight_open_sqrt = math.sqrt(midnight_open)
operation_Resistance = math.pow(midnight_open_sqrt + 0.0625, 2)
operation_Resistance2 = math.pow(midnight_open_sqrt + 0.125, 2)
operation_Resistance3 = math.pow(midnight_open_sqrt + 0.2, 2)
operation_Resistance4 = math.pow(midnight_open_sqrt + 0.25, 2)
operation_Resistance5 = math.pow(midnight_open_sqrt + 0.375, 2)
operation_Resistance6 = math.pow(midnight_open_sqrt + 0.5, 2)
operation_Support = math.pow(midnight_open_sqrt - 0.0625, 2)
operation_Support2 = math.pow(midnight_open_sqrt - 0.125, 2)
operation_Support3 = math.pow(midnight_open_sqrt - 0.2, 2)
operation_Support4 = math.pow(midnight_open_sqrt - 0.25, 2)
operation_Support5 = math.pow(midnight_open_sqrt - 0.375, 2)
operation_Support6 = math.pow(midnight_open_sqrt - 0.5, 2)

// Determinar tamaño de las celdas
sizeOption = input.string(title="Text Size", 
     options=["Normal", "Small"],
     defval="Small")
     
txtSize= (sizeOption == "Small") ? size.small :  size.normal

//BUY/Sell confirmation line
// Today's Session Start timestamp
y = year(timenow)
m = month(timenow)
d = dayofmonth(timenow)

// Start & End time for 
showLineOnSameDay=input(true, title="Show Lines on same Day")
dd=showLineOnSameDay?d:d+1
start = timestamp(y, m, dd, hour)
end = start + 86400000

// Dibujar líneas horizontales en los valores de tabla
tom_start = start
tom_end = end
colorLabl=input.color(color.black,"Label Text color")

var lbl3 = label.new(na, na, "T1", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl4 = label.new(na, na, "T2", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl5 = label.new(na, na, "T3", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl6 = label.new(na, na, "T4", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl7 = label.new(na, na, "T5", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl8 = label.new(na, na, "T6", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl9 = label.new(na, na, "T1", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl10 = label.new(na, na, "T2", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl11 = label.new(na, na, "T3", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl12 = label.new(na, na, "T4", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl13 = label.new(na, na, "T5", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl14 = label.new(na, na, "T6", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)
var lbl15 = label.new(na, na, "Price Start", color = color(na), style = label.style_label_left,size = txtSize, textcolor = colorLabl)


colorBuy=input.color(color.green,"Buy Above Lines color")
colorSell=input.color(color.red,"Sell Below Lines color")
colorStart=input.color(color.blue,"Buy Above, Sell Below")

var lin3 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorBuy)
var lin4 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorBuy)
var lin5 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorBuy)
var lin6 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorBuy)
var lin7 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorBuy)
var lin8 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorBuy)
var lin9 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorSell)
var lin10 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorSell)
var lin11 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorSell)
var lin12 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorSell)
var lin13 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorSell)
var lin14 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorSell)
var lin15 = line.new(na, na, na, na, xloc = xloc.bar_time, style = line.style_solid,color=colorStart,width = 2)


//T1
line.set_xy1(lin3, tom_start, operation_Resistance)
line.set_xy2(lin3, tom_end,operation_Resistance)
label.set_xy(lbl3, bar_index, operation_Resistance)
//T2
line.set_xy1(lin4, tom_start, operation_Resistance2)
line.set_xy2(lin4, tom_end,operation_Resistance2)
label.set_xy(lbl4, bar_index, operation_Resistance2)
//T3
line.set_xy1(lin5, tom_start, operation_Resistance3)
line.set_xy2(lin5, tom_end,operation_Resistance3)
label.set_xy(lbl5, bar_index, operation_Resistance3)
//T4
line.set_xy1(lin6, tom_start, operation_Resistance4)
line.set_xy2(lin6, tom_end,operation_Resistance4)
label.set_xy(lbl6, bar_index, operation_Resistance4)
//T5
line.set_xy1(lin7, tom_start, operation_Resistance5)
line.set_xy2(lin7, tom_end,operation_Resistance5)
label.set_xy(lbl7, bar_index, operation_Resistance5)
//T6
line.set_xy1(lin8, tom_start, operation_Resistance6)
line.set_xy2(lin8, tom_end,operation_Resistance6)
label.set_xy(lbl8, bar_index, operation_Resistance6)

//S1
line.set_xy1(lin9, tom_start, operation_Support)
line.set_xy2(lin9, tom_end,operation_Support)
label.set_xy(lbl9, bar_index, operation_Support)
//S2
line.set_xy1(lin10, tom_start, operation_Support2)
line.set_xy2(lin10, tom_end,operation_Support2)
label.set_xy(lbl10, bar_index, operation_Support2)
//S3
line.set_xy1(lin11, tom_start, operation_Support3)
line.set_xy2(lin11, tom_end,operation_Support3)
label.set_xy(lbl11, bar_index, operation_Support3)
//S4
line.set_xy1(lin12, tom_start, operation_Support4)
line.set_xy2(lin12, tom_end,operation_Support4)
label.set_xy(lbl12, bar_index, operation_Support4)
//S5
line.set_xy1(lin13, tom_start, operation_Support5)
line.set_xy2(lin13, tom_end,operation_Support5)
label.set_xy(lbl13, bar_index, operation_Support5)
//S6
line.set_xy1(lin14, tom_start, operation_Support6)
line.set_xy2(lin14, tom_end,operation_Support6)
label.set_xy(lbl14, bar_index, operation_Support6)

//Buy Above
line.set_xy1(lin15, tom_start, midnight_open)
line.set_xy2(lin15, tom_end,midnight_open)
label.set_xy(lbl15, bar_index, midnight_open)


// Determinar colores base
color_g=#e6fce8
coor_r=#fce6ea
color_n=#bab8b8
color_rg=#ebe6ea
color_wh=color.white

txt_color_r=#f50a19
txt_color_g=#039458

// Determinar comentarios
trendingTimes="T4,T5,T6: On trending Times"
NormalTargets="T2,T3: Normal Targets"
tableToolTip="This table works well in a Trending Markets; in sideways market use it as Support and Resistance"

// Crear una tabla con los valores de la vela de medianoche y el resultado de la operación matemática
if is_midnight_candle
    var tableData = table.new(position.bottom_right,columns = 8, rows = 3, bgcolor = color.yellow, border_width = 1, border_color=color.white)
    
    table.cell(tableData, column = 0, row = 0, text = "@llopezf", bgcolor=color.white, text_size=txtSize,tooltip=tableToolTip)
    table.cell(tableData, column = 0, row = 1, text = "Resistance ", bgcolor=color.green ,text_size=txtSize)
    table.cell(tableData, column = 0, row = 2, text = "Support ", bgcolor=color.orange ,text_size=txtSize)

    table.cell(tableData, column = 1, row = 0, text = "Price " ,text_size=txtSize,tooltip="NY midnight opening candle")
    table.cell(tableData, column = 2, row = 0, text = "T1/12.5", bgcolor=color.white,text_size=txtSize)
    table.cell(tableData, column = 3, row = 0, text = "T2/22.5", bgcolor=color.gray,text_size=txtSize,tooltip=NormalTargets)
    table.cell(tableData, column = 4, row = 0, text = "T3/36", bgcolor=color.gray,text_size=txtSize,tooltip=NormalTargets)
    table.cell(tableData, column = 5, row = 0, text = "T4/45", bgcolor=color.green,text_size=txtSize,tooltip=trendingTimes)
    table.cell(tableData, column = 6, row = 0, text = "T5/67.5", bgcolor=color.green,text_size=txtSize,tooltip=trendingTimes)
    table.cell(tableData, column = 7, row = 0, text = "T6/90", bgcolor=color.green,text_size=txtSize,tooltip=trendingTimes)

    table.cell(tableData, column = 1, row = 1, text = str.tostring(midnight_open), bgcolor=color_g ,text_size=txtSize, text_color=txt_color_r)
    table.cell(tableData, column = 2, row = 1, text = str.tostring(math.round(operation_Resistance, 2)), bgcolor=color_wh,text_size=txtSize, text_color=txt_color_r)
    table.cell(tableData, column = 3, row = 1, text = str.tostring(math.round(operation_Resistance2, 2)), bgcolor=color_n,text_size=txtSize, text_color=txt_color_r)
    table.cell(tableData, column = 4, row = 1, text = str.tostring(math.round(operation_Resistance3, 2)), bgcolor=color_n,text_size=txtSize, text_color=txt_color_r)
    table.cell(tableData, column = 5, row = 1, text = str.tostring(math.round(operation_Resistance4, 2)), bgcolor=color_g,text_size=txtSize, text_color=txt_color_r)
    table.cell(tableData, column = 6, row = 1, text = str.tostring(math.round(operation_Resistance5, 2)), bgcolor=color_g,text_size=txtSize, text_color=txt_color_r)
    table.cell(tableData, column = 7, row = 1, text = str.tostring(math.round(operation_Resistance6, 2)), bgcolor=color_g,text_size=txtSize, text_color=txt_color_r)

    table.cell(tableData, column = 1, row = 2, text = str.tostring(midnight_open) , bgcolor=coor_r,text_size=txtSize,text_color=txt_color_g)
    table.cell(tableData, column = 2, row = 2, text = str.tostring(math.round(operation_Support, 2)), bgcolor=color_wh,text_size=txtSize,text_color=txt_color_g)
    table.cell(tableData, column = 3, row = 2, text = str.tostring(math.round(operation_Support2, 2)), bgcolor=color_rg,text_size=txtSize,text_color=txt_color_g)
    table.cell(tableData, column = 4, row = 2, text = str.tostring(math.round(operation_Support3, 2)), bgcolor=color_rg,text_size=txtSize,text_color=txt_color_g)
    table.cell(tableData, column = 5, row = 2, text = str.tostring(math.round(operation_Support4, 2)), bgcolor=coor_r,text_size=txtSize,text_color=txt_color_g)
    table.cell(tableData, column = 6, row = 2, text = str.tostring(math.round(operation_Support5, 2)), bgcolor=coor_r,text_size=txtSize,text_color=txt_color_g)
    table.cell(tableData, column = 7, row = 2, text = str.tostring(math.round(operation_Support6, 2)), bgcolor=coor_r,text_size=txtSize,text_color=txt_color_g)

// Mostrar una flecha roja en el gráfico para indicar la vela de medianoche en UTC-7
plotshape(series=is_midnight_candle, color=color.red, style=shape.triangleup, location=location.belowbar, size=size.small, text = "6PM NY")

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Premium Liquidity Hunter Algo
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

// Inputs
swingSizeR       = input.int(10, 'Bars Right-Left', inline='brl')
swingSizeL       = input.int(15, '-', inline='brl')
showBoxes        = input.bool(false, 'Show Boxes ', inline='aa')
showSwingLines   = input.bool(false, 'Show Lines', inline='aa')
showBubbles      = input.bool(false, 'Show Labels ', inline='bb')
showVol          = input.bool(false, 'Show Volume', inline='bb')
showOId          = input.bool(false, 'Show OI ?   ', inline='cc')
extendtilfilled  = input.bool(true, 'Extend Until Fill', inline='cc')

// Conditions
hidefilled       = input.bool(false, 'Hide Filled', group='Conditions')
voltresh = input.int(0, 'Volume >', group='Conditions')
oitresh  = input.int(0, 'OI ? (abs.) >',  group='Conditions')
pnoid   = input.string('/', 'Only Swings With', options = ['Positive OI Delta', 'Negative OI Delta', '/'], group='Conditions')
// Appearance inputs
showhighs        = input.bool(true, '', inline='sh', group='Appearance')
showlows         = input.bool(true, '', inline='sl', group='Appearance')
sellcol          = input.color(#aa2430, 'Lows (Line - Label - Box)', inline = 'sh', group='Appearance')
buycol           = input.color(#66bb6a, 'Highs (Line - Label - Box)', inline='sl', group='Appearance')
sellcolB         = input.color(#aa2430, '', inline='sh', group='Appearance')
buycolB          = input.color(#66bb6a, '', inline = 'sl', group='Appearance')
sellboxCol       = input.color(#80192231, '', inline = 'sh', group='Appearance')
buyboxCol        = input.color(#66bb6a31, '', inline='sl', group='Appearance')
lineStyle        = input.string('Dotted', 'Line Style + Width', ['Solid', 'Dashed', 'Dotted'], inline='l', group='Appearance')
lineWid          = input.int(1, '', inline='l', group='Appearance')
boxWid           = input.float(0.7, 'Box Width + Type ', step=0.1, inline='xx', group='Appearance')
boxStyle         = input.string('TYPE 1', '', options=['TYPE 1', 'TYPE 2'], inline='xx', group='Appearance')
labelsize        = input.string('Size: Tiny', 'Text Style        ', options = ['Size: Normal','Size: Large', 'Size: Small', 'Size: Tiny', 'Size: Auto' ], inline='txt', group = 'Appearance' )
texthalign       = input.string('Right','', options = ['Middle', 'Right', 'Left'], inline='txt', group = 'Appearance')
lookback         = input.bool(false, '', inline='lb')
daysBack         = input.float(150, 'Lookback (D)               ',inline='lb')
// OI Data
binance   = input.bool(false, 'Binance USDT.P', inline = 'src',  group = 'Open Interest')
binance2  = input.bool(false, 'Binance USD.P',  inline = 'src',  group = 'Open Interest')
binance3  = input.bool(false, 'Binance BUSD.P', inline = 'src2', group = 'Open Interest')
bitmex    = input.bool(false, 'BitMEX USD.P',   inline = 'src2', group = 'Open Interest')
bitmex2   = input.bool(false, 'BitMEX USDT.P ', inline = 'src3', group = 'Open Interest')
kraken    = input.bool(false, 'Kraken USD.P',   inline = 'src3', group = 'Open Interest')

// Calculating inRange, used for lookback in days
MSPD             = 24 * 60 * 60 * 1000
lastBarDate      = timestamp(year(timenow), month(timenow), dayofmonth(timenow), hour(timenow), minute(timenow), second(timenow))
thisBarDate      = timestamp(year, month, dayofmonth, hour, minute, second)
daysLeft         = math.abs(math.floor((lastBarDate - thisBarDate) / MSPD))
inRange          = lookback ? (daysLeft < daysBack) : true

//Pivot calculations
int prevHighIndex= na, int prevLowIndex= na, bool highActive= false, bool lowActive= false, bool h= false, bool l= false
pivHi            = ta.pivothigh(high, swingSizeL, swingSizeR)
pivLo            = ta.pivotlow(low, swingSizeL, swingSizeR)

if not na(pivHi)
    h := true
    prevHighIndex := bar_index - swingSizeR
if not na(pivLo)
    l := true
    prevLowIndex  := bar_index - swingSizeR

// Getting OI data
mex =  syminfo.basecurrency=='BTC' ? 'XBT' : string(syminfo.basecurrency)
oid1 = nz(request.security('BINANCE' + ":" + string(syminfo.basecurrency) + 'USDT.P_OI',  timeframe.period,  close-close[1], ignore_invalid_symbol = true), 0)
oid2 = nz(request.security('BINANCE' + ":" + string(syminfo.basecurrency) + 'USD.P_OI',   timeframe.period,  close-close[1], ignore_invalid_symbol = true), 0)
oid3 = nz(request.security('BINANCE' + ":" + string(syminfo.basecurrency) + 'BUSD.P_OI',  timeframe.period,  close-close[1], ignore_invalid_symbol = true), 0)
oid4 = nz(request.security('BITMEX'  + ":" + mex                          + 'USD.P_OI',   timeframe.period,  close-close[1], ignore_invalid_symbol = true), 0)
oid5 = nz(request.security('BITMEX'  + ":" + mex                          + 'USDT.P_OI',  timeframe.period,  close-close[1], ignore_invalid_symbol = true), 0)
oid6 = nz(request.security('KRAKEN'  + ":" + string(syminfo.basecurrency) + 'USD.P_OI',   timeframe.period,  close-close[1], ignore_invalid_symbol = true), 0)

deltaOI   = (binance ? nz(oid1,0) : 0)   +   (binance2 ? nz(oid2,0)/close : 0)   +    (binance3 ? nz(oid3,0) : 0)    +   (bitmex ? nz(oid4,0)/close : 0)   +   (bitmex2 ? nz(oid5,0)/close : 0)   +   (kraken ? nz(oid6,0)/close : 0)




//Volume, OI, box width
vol         = volume[swingSizeR]

oitreshcond = oitresh > 0 ? math.abs(deltaOI[swingSizeR])>oitresh : true
voltreshcond = voltresh > 0 ? vol > voltresh : true
oicond = pnoid=='Positive OI Delta' ? deltaOI[swingSizeR]>0 : pnoid=='Negative OI Delta' ? deltaOI[swingSizeR]<0 : true

color CLEAR = color.rgb(0,0,0,100)
boxWid1     = 0.001 * boxWid


// Styles
boxStyle(x) =>
    switch x
        'TYPE 1' => h ? pivHi : l ? pivLo : na
        'TYPE 2' => h ? pivHi * (1 - boxWid1) : l ? pivLo * (1 + boxWid1) : na
lineStyle(x) =>
    switch x
        'Solid'  => line.style_solid
        'Dashed' => line.style_dashed
        'Dotted' => line.style_dotted
switchtextsize(textsize) =>
    switch textsize
        'Size: Normal'  => size.normal
        'Size: Small'   => size.small
        'Size: Tiny'    => size.tiny
        'Size: Auto'    => size.auto
        'Size: Large'   => size.large
switchhalign(texthalign) =>
    switch texthalign
        'Middle'        => text.align_center
        'Right'         => text.align_right
        'Left'          => text.align_left

//Swing level labels
var levelBoxes = array.new_box(), var levelLines = array.new_line()
if h and inRange and showhighs and oitreshcond and voltreshcond and oicond
    hBox    = box.new(prevHighIndex, pivHi * (1 + boxWid1), bar_index, boxStyle(boxStyle), border_color = na, bgcolor = showBoxes ? sellboxCol : CLEAR, text= (showVol ? str.tostring(vol, format.volume) : na) +' '+ (showOId ? str.tostring(deltaOI[swingSizeR], format.volume) : ''),text_halign=switchhalign(texthalign),text_valign=text.align_center,text_color=chart.fg_color, text_size=switchtextsize(labelsize))
    hLine   = line.new(prevHighIndex, pivHi, bar_index, pivHi, color = showSwingLines ? sellcol : CLEAR, style=lineStyle(lineStyle), width=lineWid)
    array.push(levelBoxes, hBox)
    array.push(levelLines, hLine)
if l and inRange and showhighs and oitreshcond and voltreshcond and oicond
    lBox    = box.new(prevLowIndex, pivLo * (1 - boxWid1), bar_index, boxStyle(boxStyle), border_color = na, bgcolor = showBoxes ? buyboxCol : CLEAR, text= (showVol ? str.tostring(vol, format.volume) : na) +' '+ (showOId ? str.tostring(deltaOI[swingSizeR], format.volume) : ''),text_halign=switchhalign(texthalign),text_valign=text.align_center,text_color=chart.fg_color, text_size=switchtextsize(labelsize))
    lLine   = line.new(prevLowIndex, pivLo, bar_index, pivLo, color = showSwingLines ? buycol : CLEAR, style=lineStyle(lineStyle), width=lineWid)
    array.push(levelBoxes, lBox)
    array.push(levelLines, lLine)

// Looping over the full array of lines and updating them, and deleting them if they have been touched
size = array.size(levelBoxes)
if size > 0
    for i = 0 to size - 1
        j = size - 1 - i
        box = array.get(levelBoxes, j)
        line = array.get(levelLines, j)
        level = line.get_y2(line)
        filled = (high >= level and low <= level)

        if filled and extendtilfilled and not hidefilled
            array.remove(levelLines, j)
            array.remove(levelBoxes, j)
            continue 

        box.set_right(box, bar_index+1)
        line.set_x2(line, bar_index+1)
        if filled and hidefilled
            array.remove(levelLines, j)
            array.remove(levelBoxes, j)
            line.delete(line)
            box.delete(box)

        if not filled and not extendtilfilled
            array.remove(levelLines, j)
            array.remove(levelBoxes, j)
            continue 
            box.set_right(box, bar_index[0]+4)
            line.set_x2(line, bar_index[0]+4)


// Deleting the oldest lines if array is too big 
if array.size(levelBoxes) >= 500
    int i = 0
    while array.size(levelBoxes) >= 500
        box = array.get(levelBoxes, i)
        line = array.get(levelLines, i)
        box.delete(box)
        line.delete(line)
        array.remove(levelBoxes, i)
        array.remove(levelLines, i)
        i += 1 
        
// Plotting circle labels
plotshape(showhighs and showBubbles and h and oitreshcond and voltreshcond and oicond ? high[swingSizeR] : na, style=shape.circle, location = location.absolute, offset = -swingSizeR, color=sellcolB, size = size.tiny)
plotshape(showlows and showBubbles and l and oitreshcond and voltreshcond and oicond ? low[swingSizeR] : na, style=shape.circle, location = location.absolute, offset = -swingSizeR, color=buycolB, size = size.tiny)

//////////////////////////////////////////////////////////////////////-------------------/////////////////////////////////////////////////

//Option to show Liquidity lines on the chart
show_liquidity = input(false,"Show Liquidity? (Daily, Weekly, Monthly)",inline='Show Liquidity'
 , group = 'Configuration')

var gStartOffset = 0
var gEndOffset  = 25

color_text_prev_high_low = input.color(#f65454de, 'Color of previous day high and low'
  , group = 'Configuration')

english_language_selected = input(true, 'Show Labels in English'
  , group = 'Configuration')



// DEFINE COLORS of the lines displayed on the chart
// --> Blue lines: Daily liquidity
// --> Yellow lines: Weekly Liquidity
// --> Purple lines: Monthly liquidity
//daily liquidity
gIsDailyEnabled  = true
gDailyAboveLiquidityColor = color.new(#4987d3, 13)
gDailyBelowLiquidityColor = color.new(#4987d3, 13)
gDailyWidth = 1 

//weekly liquidity
gIsWeeklyEnabled = true
gWeeklyAboveLiquidityColor = color.new(#f6eb54, 13)
gWeeklyBelowLiquidityColor = color.new(#f6eb54, 13)
gWeeklyWidth  = 1

//month liquidity
gIsMonthlyEnabled              = true
gMonthlyAboveLiquidityColor    = color.new(#f66ecf, 13)
gMonthlyBelowLiquidityColor    = color.new(#f66ecf, 13)
gMonthlyWidth                  = 1

cleanedLevelColor              = color.new(#ffffff, 100)
cleanedLevelStyle              = "Dashed"


var highArray                  = array.new_float()
var lowArray                   = array.new_float()
var highLinesArray             = array.new_line()
var lowLinesArray              = array.new_line()
var purgedLinesArray           = array.new_line()

[prevDayHigh, prevDayLow]       = request.security(syminfo.tickerid, "D",   [high[1], low[1]], lookahead=barmerge.lookahead_on)
[prevWeekHigh, prevWeekLow]     = request.security(syminfo.tickerid, "W",   [high[1], low[1]], lookahead=barmerge.lookahead_on)
[prevMonthHigh, prevMonthLow]   = request.security(syminfo.tickerid, "M",   [high[1], low[1]], lookahead=barmerge.lookahead_on)
[prev4HHigh, prev4HLow]         = request.security(syminfo.tickerid, "240", [high[1], low[1]], lookahead=barmerge.lookahead_on)
[prev1HHigh, prev1HLow]         = request.security(syminfo.tickerid, "60",  [high[1], low[1]], lookahead=barmerge.lookahead_on)


//Set Labels text according language selected (English or Portuguese)
demand_lbl_txt = ""
if (english_language_selected == false)
    demand_lbl_txt := "Zona de Compra"
else
    demand_lbl_txt := "Demand/Buy Zone"    

supply_lbl_txt = ""
if (english_language_selected == false)
    supply_lbl_txt := "Zona de Venta"
else
    supply_lbl_txt := "Supply/Sell Zone"

strong_high_lbl = ""
if (english_language_selected == false)
    strong_high_lbl := "Fuerte Subida"
else
    strong_high_lbl := "Strong High"

strong_low_lbl = ""
if (english_language_selected == false)
    strong_low_lbl := "Fuerte Bajada"
else
    strong_low_lbl := "Strong Low"


weak_low_lbl = ""
if (english_language_selected == false)
    weak_low_lbl := "Debil Bajada"
else
    weak_low_lbl := "Weak Low"

weak_high_lbl = ""
if (english_language_selected == false)
    weak_high_lbl := "Debil Subida"
else
    weak_high_lbl := "Weak High"

previous_day_high_lbl = ""
if (english_language_selected == false)
    previous_day_high_lbl := "Precio más alto del día anterior"
else
    previous_day_high_lbl := "Previous Day Highest Price"

previous_day_low_lbl = ""
if (english_language_selected == false)
    previous_day_low_lbl := "Precio minimo del día anterior"
else
    previous_day_low_lbl := "Previous Day Lowest Price"

//       Functions 
f_drawLine(_y, _c, _w=1) => line.new(bar_index, _y, bar_index, _y, color=_c, width=_w)

f_create(_high, _low, _upperColor, _lowerColor, _linewidth) =>
    array.push(highArray, _high)
    array.push(lowArray, _low)
    array.push(highLinesArray, f_drawLine(_high, _upperColor, _linewidth))
    array.push(lowLinesArray, f_drawLine(_low, _lowerColor, _linewidth))

f_updateStickyLevels(_levels) =>
    for _line in _levels
        line.set_x1(_line, bar_index + gStartOffset)
        line.set_x2(_line, bar_index + gEndOffset)

f_moveLevel(_from, _to, _level, _index) =>
    array.push(_to, _level)
    array.remove(_from, _index)

f_highlightPurgedLevel(_level) =>
    _style = cleanedLevelStyle == "Solid" ? line.style_solid : cleanedLevelStyle == "Dashed" ? line.style_dashed : line.style_dotted
    line.set_color(_level, cleanedLevelColor)
    line.set_style(_level, _style)

f_updateUpperLevels(_high, _highs, _levels, _purgedLevels) =>
    while array.min(_highs) < _high
        for [_index, _value] in _highs
            if _high > _value
                _line = array.get(_levels, _index)
                f_highlightPurgedLevel(_line)
                f_moveLevel(_levels, _purgedLevels, _line, _index)
                array.remove(_highs, _index)
f_updateLowerLevels(_low, _lows, _levels, _purgedLevels) =>
    while array.max(_lows) > _low
        for [_index, _value] in _lows
            if _low < _value
                _line = array.get(_levels, _index)
                f_highlightPurgedLevel(_line)
                f_moveLevel(_levels, _purgedLevels, _line, _index)
                array.remove(_lows, _index)

f_clearLevels(_levels) =>
    while array.size(_levels) > 0
        for [_index, _line] in _levels
            line.delete(array.remove(_levels, _index))

f_isHigherTimeframe(_timeframe) => timeframe.in_seconds() <= timeframe.in_seconds(_timeframe)


//Draw Lines if  liquidity is enabled
if show_liquidity
    if gIsDailyEnabled and f_isHigherTimeframe("D") and ta.change(time("D"))
        f_create(prevDayHigh, prevDayLow, gDailyAboveLiquidityColor, gDailyBelowLiquidityColor, gDailyWidth)

    if gIsWeeklyEnabled and f_isHigherTimeframe("W") and ta.change(time("W"))
        f_create(prevWeekHigh, prevWeekLow, gWeeklyAboveLiquidityColor, gWeeklyBelowLiquidityColor, gWeeklyWidth)

    if gIsMonthlyEnabled and f_isHigherTimeframe("M") and ta.change(time("M"))
        f_create(prevMonthHigh, prevMonthLow, gMonthlyAboveLiquidityColor, gMonthlyBelowLiquidityColor, gMonthlyWidth)


if barstate.islast
    f_updateStickyLevels(highLinesArray)
    f_updateStickyLevels(lowLinesArray)
    f_updateStickyLevels(purgedLinesArray)

// Highlight the levels that got their liquidity taken

f_updateUpperLevels(high, highArray, highLinesArray, purgedLinesArray)
f_updateLowerLevels(low, lowArray, lowLinesArray, purgedLinesArray)

// Clean the levels that had their liquidity taken on a daily basis
if ta.change(time("D"))
    f_clearLevels(purgedLinesArray)

color TRANSP_COLOR = #ffffff00

//Tooltips
string TOOLTIP       = 'Allows to display historical Structure'
string STYLE        = 'color theme'
string COLOR_CANDLES = 'Display additional candles'


mode = 'Historical'
style = 'Colored'
show_trend = false


//Internal Structure
show_internals = false
show_ibull =  'All'
swing_ibull_css =#5ef8d727


//Bear Structure
show_ibear = 'All'
swing_ibear_css = #c40d0d5b
ifilter_confluence = false


//Swing Structure
show_Structure = true

//Bull Structure
show_bull = 'All'
swing_bull_css = #0dea7f63

//Bear Structure
show_bear = 'All'
swing_bear_css =  #c40d0de8

//Swings
show_swings = true
length = 50
show_hl_swings = true


//Order Blocks Variables

show_iob = false
iob_showlast = 5
show_ob = true
ob_showlast = 5
ob_filter = 'Atr'
ibull_ob_css = #0bf6841f
ibear_ob_css = color.new(#e64444, 80)
bull_ob_css = #0bf6841f
bear_ob_css = color.new(#e64444, 80)


//Imbalances / Gaps

show_fvg = false
fvg_auto = true
fvg_tf = ''
bull_fvg_css = color.new(#b980ef4d, 70)
bear_fvg_css = color.new(#b980ef4d, 70)
fvg_extend = 5


//Previous day/week high/low

//Daily
show_pdhl = true
pdhl_style = '    '
pdhl_css = #ffffff

//Premium and Discount zones

show_sd = true
premium_css = #e616169c
discount_css = #0899445d

//Functions
n = bar_index

atr = ta.atr(200)
cmean_range = ta.cum(high - low) / n

//HL Output function
hl() => [high, low]

//Get ohlc values function
get_ohlc()=> [close[1], open[1], high, low, high[2], low[2]]

//Display Structure function
display_Structure(x, y, txt, css, dashed, down, lbl_size)=>
    structure_line = line.new(x, y, n, y
      , color = css
      , style = dashed ? line.style_dashed : line.style_solid)

    structure_lbl = label.new(int(math.avg(x, n)), y, txt
      , color = TRANSP_COLOR
      , textcolor = css
      , style = down ? label.style_label_down : label.style_label_up
      , size = lbl_size)

    if mode == 'Present'
        line.delete(structure_line[1])
        label.delete(structure_lbl[1])

//Swings detection/measurements
swings_calc(len)=>
    var os = 0
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : 0
    btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]

//Order block coordinates function
ob_coord(use_max, loc, target_top, target_btm, target_left, target_type)=>
    min = 99999999.
    max = 0.
    idx = 1

    ob_threshold = ob_filter == 'Atr' ? atr : cmean_range 

    //Search for highest/lowest high within the structure interval and get range
    if use_max
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                max := math.max(high[i], max)
                min := max == high[i] ? low[i] : min
                idx := max == high[i] ? i : idx
    else
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                min := math.min(low[i], min)
                max := min == low[i] ? high[i] : max
                idx := min == low[i] ? i : idx

    array.unshift(target_top, max)
    array.unshift(target_btm, min)
    array.unshift(target_left, time[idx])
    array.unshift(target_type, use_max ? -1 : 1)

//Set order blocks
display_ob(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    for i = 0 to math.min(show_last-1, size-1)
        get_box = array.get(boxes, i)

        box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
        box.set_rightbottom(get_box, array.get(target_left, i), array.get(target_btm, i))
        box.set_extend(get_box, extend.right)

        color css = na
        
        if swing 
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
                border_css = array.get(target_type, i) == 1 ? #b2b5be : #5d606b
            else
                css := array.get(target_type, i) == 1 ? bull_ob_css : bear_ob_css
                

            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
        else
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
            else
                css := array.get(target_type, i) == 1 ? ibull_ob_css : ibear_ob_css
            
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
        
//Line Style function
get_line_style(style) =>
    out = switch style
        '???'  => line.style_solid
        '----' => line.style_dashed
        '    ' => line.style_dotted

//Set line and labels for previous high and lows
define_previous_days_prices(h, l, tf, css)=>
    var line high_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label high_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format(previous_day_high_lbl, tf)
      , color = TRANSP_COLOR
      , textcolor = color_text_prev_high_low
      , size = size.small
      , style = label.style_label_left)

    var line low_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label low_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format(previous_day_low_lbl, tf)
      , color = TRANSP_COLOR
      , textcolor = color_text_prev_high_low
      , size = size.small
      , style = label.style_label_left)

    hy = ta.valuewhen(h != h[1], h, 1)
    hx = ta.valuewhen(h == high, time, 1)

    ly = ta.valuewhen(l != l[1], l, 1)
    lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        ext = time + (time - time[1])*20

        //High
        line.set_xy1(high_line, hx, hy)
        line.set_xy2(high_line, ext, hy)

        label.set_xy(high_lbl, ext, hy)

        //Low
        line.set_xy1(low_line, lx, ly)
        line.set_xy2(low_line, ext, ly)

        label.set_xy(low_lbl, ext, ly)

//-----------------------------------------------------------------------------}
//Global variables
//-----------------------------------------------------------------------------{
var trend = 0, var itrend = 0

var top_y = 0., var top_x = 0
var btm_y = 0., var btm_x = 0

var itop_y = 0., var itop_x = 0
var ibtm_y = 0., var ibtm_x = 0

var trail_up = high, var trail_dn = low
var trail_up_x = 0,  var trail_dn_x = 0

var top_cross = true,  var btm_cross = true
var itop_cross = true, var ibtm_cross = true

var txt_top = '',  var txt_btm = ''

//Alerts
bull_choch_alert = false 
bull_bos_alert   = false 

bear_choch_alert = false 
bear_bos_alert   = false 

bull_ichoch_alert = false 
bull_ibos_alert   = false 

bear_ichoch_alert = false 
bear_ibos_alert   = false 

bull_iob_break = false 
bear_iob_break = false

bull_ob_break = false 
bear_ob_break = false

eqh_alert = false 
eql_alert = false 

//Structure colors
var bull_css = style == 'Monochrome' ? #b2b5be 
  : swing_bull_css

var bear_css = style == 'Monochrome' ? #b2b5be 
  : swing_bear_css

var ibull_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibull_css

var ibear_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibear_css

//Swings
[top, btm] = swings_calc(length)

[itop, ibtm] = swings_calc(5)

//-----------------------------------------------------------------------------}
//Pivot High
//-----------------------------------------------------------------------------{
var line extend_top = na

var label extend_top_lbl = label.new(na, na
  , color = TRANSP_COLOR
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.small)

if top
    top_cross := true
    txt_top := top > top_y ? 'HH' : 'LH'

    if show_swings
        top_lbl = label.new(n-length, top, txt_top
          , color = TRANSP_COLOR
          , textcolor = #ff990000
          , style = label.style_label_down
          , size = size.small)

        if mode == 'Present'
            label.delete(top_lbl[1])

    //Extend recent top to last bar
    line.delete(extend_top[1])
    extend_top := line.new(n-length, top, n, top
      , color = bear_css)

    top_y := top
    top_x := n - length

    trail_up := top
    trail_up_x := n - length

if itop
    itop_cross := true

    itop_y := itop
    itop_x := n - 5

//Trailing maximum
trail_up := math.max(high, trail_up)
trail_up_x := trail_up == high ? n : trail_up_x

//Set top extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_top, trail_up_x, trail_up)
    line.set_xy2(extend_top, n + 20, trail_up)

    label.set_x(extend_top_lbl, n + 20)
    label.set_y(extend_top_lbl, trail_up)
    label.set_text(extend_top_lbl, trend < 0 ? strong_high_lbl : weak_high_lbl)

//-----------------------------------------------------------------------------}
//Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSP_COLOR
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.small)

if btm
    btm_cross := true
    txt_btm := btm < btm_y ? 'LL' : 'HL'
    
    if show_swings
        btm_lbl = label.new(n - length, btm, txt_btm
          , color = TRANSP_COLOR
          , textcolor = #4caf4f00
          , style = label.style_label_up
          , size = size.small)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    //Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(n - length, btm, n, btm
      , color = bull_css)

    btm_y := btm
    btm_x := n-length

    trail_dn := btm
    trail_dn_x := n-length

if ibtm
    ibtm_cross := true

    ibtm_y := ibtm
    ibtm_x := n - 5

//Trailing minimum
trail_dn := math.min(low, trail_dn)
trail_dn_x := trail_dn == low ? n : trail_dn_x

//Set btm extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_btm, trail_dn_x, trail_dn)
    line.set_xy2(extend_btm, n + 20, trail_dn)

    label.set_x(extend_btm_lbl, n + 20)
    label.set_y(extend_btm_lbl, trail_dn)
    label.set_text(extend_btm_lbl, trend > 0 ? strong_low_lbl : weak_low_lbl)

//-----------------------------------------------------------------------------}
//Order Blocks Arrays
//-----------------------------------------------------------------------------{
var iob_top = array.new_float(0)
var iob_btm = array.new_float(0)
var iob_left = array.new_int(0)
var iob_type = array.new_int(0)

var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)

//-----------------------------------------------------------------------------}
//Pivot High BOS and Choch
//-----------------------------------------------------------------------------{
//Filtering
var bull_concordant = true

if ifilter_confluence
    bull_concordant := high - math.max(close, open) > math.min(close, open - low)

//Detect internal bullish Structure
if ta.crossover(close, itop_y) and itop_cross and top_y != itop_y and bull_concordant
    bool choch = na
    
    if itrend < 0
        choch := true
        bull_ichoch_alert := true
    else 
        bull_ibos_alert := true
    
    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'Altera  o de Car ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'Change of Character' : 'Break of Structure'    

    if show_internals
        if show_ibull == 'All' or (show_ibull == 'BOS' and not choch) or (show_ibull == 'CHoCH' and choch)
            display_Structure(itop_x, itop_y, txt, ibull_css, true, true, size.tiny)
    
    itop_cross := false
    itrend := 1
    
    //Internal Order Block
    if show_iob
        ob_coord(false, itop_x, iob_top, iob_btm, iob_left, iob_type)

//Detect bullish Structure
if ta.crossover(close, top_y) and top_cross
    bool choch = na
    
    if trend < 0
        choch := true
        bull_choch_alert := true
    else 
        bull_bos_alert := true

    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'Altera  o de Car ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'Change of Character' : 'Break of Structure'    
    //txt = choch ? 'Altera  o de Car ter' : 'Quebra Estrutura'
    
    if show_Structure
        if show_bull == 'All' or (show_bull == 'BOS' and not choch) or (show_bull == 'CHoCH' and choch)
            display_Structure(top_x, top_y, txt, #0ddc67d0, true, true, size.small)
    
    //Order Block
    if show_ob
        ob_coord(false, top_x, ob_top, ob_btm, ob_left, ob_type)

    top_cross := false
    trend := 1

//-----------------------------------------------------------------------------}
//Pivot Low BOS and CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if ifilter_confluence
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

//Detect internal bearish Structure
if ta.crossunder(close, ibtm_y) and ibtm_cross and btm_y != ibtm_y and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
        bear_ichoch_alert := true
    else 
        bear_ibos_alert := true
    
    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'Altera  o de Car ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'Change of Character' : 'Break of Structure'    
    //txt = choch ? 'Altera  o de Car ter' : 'QUEBRA DE ESTRUTURA'

    if show_internals
        if show_ibear == 'All' or (show_ibear == 'BOS' and not choch) or (show_ibear == 'CHoCH' and choch)
            display_Structure(ibtm_x, ibtm_y, txt, ibear_css, true, false, size.small)
    
    ibtm_cross := false
    itrend := -1
    
    //Internal Order Block
    if show_iob
        ob_coord(true, ibtm_x, iob_top, iob_btm, iob_left, iob_type)

//Detect bearish Structure
if ta.crossunder(close, btm_y) and btm_cross
    bool choch = na
    
    if trend > 0
        choch := true
        bear_choch_alert := true
    else 
        bear_bos_alert := true

    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'Altera  o de Car ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'Change of Character' : 'Break of Structure'    
    
    //txt = choch ? 'Altera  o de Car ter' : 'QUEBRA DE ESTRUTURA'
    
    if show_Structure
        if show_bear == 'All' or (show_bear == 'BOS' and not choch) or (show_bear == 'CHoCH' and choch)
            display_Structure(btm_x, btm_y, txt, #dc0d0dd0, true, false, size.small)
    
    //Order Block
    if show_ob
        ob_coord(true, btm_x, ob_top, ob_btm, ob_left, ob_type)

    btm_cross := false
    trend := -1

//-----------------------------------------------------------------------------}
//Order Blocks
//-----------------------------------------------------------------------------{
//Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

//Delete internal order blocks box coordinates if top/bottom is broken
for element in iob_type
    index = array.indexof(iob_type, element)

    if close < array.get(iob_btm, index) and element == 1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index) 
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bull_iob_break := true

    else if close > array.get(iob_top, index) and element == -1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index)
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bear_iob_break := true

//Delete internal order blocks box coordinates if top/bottom is broken
for element in ob_type
    index = array.indexof(ob_type, element)

    if close < array.get(ob_btm, index) and element == 1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index) 
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bull_ob_break := true

    else if close > array.get(ob_top, index) and element == -1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index)
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bear_ob_break := true

iob_size = array.size(iob_type)
ob_size = array.size(ob_type)

if barstate.isfirst
    if show_iob
        for i = 0 to iob_showlast-1
            array.push(iob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
    if show_ob
        for i = 0 to ob_showlast-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))

if iob_size > 0
    if barstate.islast
        display_ob(iob_boxes, iob_top, iob_btm, iob_left, iob_type, iob_showlast, false, iob_size)

if ob_size > 0
    if barstate.islast
        display_ob(ob_boxes, ob_top, ob_btm, ob_left, ob_type, ob_showlast, true, ob_size)


//-----------------------------------------------------------------------------}
//Imbalances
//-----------------------------------------------------------------------------{
var bullish_fvg_max = array.new_box(0)
var bullish_fvg_min = array.new_box(0)

var bearish_fvg_max = array.new_box(0)
var bearish_fvg_min = array.new_box(0)

float bullish_fvg_avg = na
float bearish_fvg_avg = na

bullish_fvg_cnd = false
bearish_fvg_cnd = false

[src_c1, src_o1, src_h, src_l, src_h2, src_l2] =
  request.security(syminfo.tickerid, fvg_tf, get_ohlc())

if show_fvg
    delta_per = (src_c1 - src_o1) / src_o1 * 100

    change_tf = timeframe.change(fvg_tf)

    threshold = fvg_auto ? ta.cum(math.abs(change_tf ? delta_per : 0)) / n * 2 
      : 0

    //FVG conditions
    bullish_fvg_cnd := src_l > src_h2
      and src_c1 > src_h2 
      and delta_per > threshold
      and change_tf

    bearish_fvg_cnd := src_h < src_l2 
      and src_c1 < src_l2 
      and -delta_per > threshold
      and change_tf

    //FVG Areas
    if bullish_fvg_cnd
        array.unshift(bullish_fvg_max, box.new(n-1, src_l, n + fvg_extend, math.avg(src_l, src_h2)
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
        
        array.unshift(bullish_fvg_min, box.new(n-1, math.avg(src_l, src_h2), n + fvg_extend, src_h2
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
    
    if bearish_fvg_cnd
        array.unshift(bearish_fvg_max, box.new(n-1, src_h, n + fvg_extend, math.avg(src_h, src_l2)
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))
        
        array.unshift(bearish_fvg_min, box.new(n-1, math.avg(src_h, src_l2), n + fvg_extend, src_l2
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))

    for bx in bullish_fvg_min
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullish_fvg_max, array.indexof(bullish_fvg_min, bx)))
    
    for bx in bearish_fvg_max
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearish_fvg_min, array.indexof(bearish_fvg_max, bx)))

//-----------------------------------------------------------------------------}
//Previous day/week high/lows
//-----------------------------------------------------------------------------{
//Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, 'D', hl()
  , lookahead = barmerge.lookahead_on)


//Display Daily
if show_pdhl
    define_previous_days_prices(pdh, pdl, 'D', pdhl_css)



//Premium and Discount Zones

var premium = box.new(na, na, na, na
  , bgcolor = color.new(premium_css, 80)
  , border_color = na)

var premium_lbl = label.new(na, na
  , text = supply_lbl_txt
  , color = TRANSP_COLOR
  , textcolor = #e43e3ee5
  , style = label.style_label_down
  , size = size.normal)

var discount = box.new(na, na, na, na
  , bgcolor = color.new(discount_css, 80)
  , border_color = na)

var discount_lbl = label.new(na, na
  , text = demand_lbl_txt
  , color = TRANSP_COLOR
  , textcolor = #13b667
  , style = label.style_label_up
  , size = size.normal)

//Show Premium and Discount Areas
if barstate.islast and show_sd
    avg = math.avg(trail_up, trail_dn)

    box.set_lefttop(premium, math.max(top_x, btm_x), trail_up)
    box.set_rightbottom(premium, n, .95 * trail_up + .05 * trail_dn)

    label.set_xy(premium_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_up)
    
    box.set_lefttop(discount, math.max(top_x, btm_x), .95 * trail_dn + .05 * trail_up)
    box.set_rightbottom(discount, n, trail_dn)
    label.set_xy(discount_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_dn)

//-----------------------------------------------------------------------------}
//Trend Definition
//-----------------------------------------------------------------------------{
var color trend_css = na



if style == 'Colored'
    trend_css := itrend == 1 ? bull_css : bear_css
else if style == 'Monochrome'
    trend_css := itrend == 1 ? #b2b5be : #5d606b


//-----------------------------------------------------------------------------}
//Trend Channels With Liquidity Breaks
//-----------------------------------------------------------------------------{
length4 = input.int(8, "Length")
show   = input.bool(true, "Show Last Channel")
wait   = input.bool(true, "Wait for Break")
extend1 = input.bool(false, "Extend Line")
enable_liquid = input.bool(false, "Volume BG")
top_color = input.color(color.rgb(51, 124, 79, 80), "Colors", inline = "Colors")
center_color = input.color(color.rgb(120, 123, 134, 100), "", inline = "Colors")
bottom_color = input.color(color.rgb(165, 45, 45, 80), "", inline = "Colors")

source_high = high
source_low  = low

// variables to store the latest and previous pivot values 
var float prev_pivot_high = na
var int prev_pivot_high_index = na
var float last_pivot_high = na
var int last_pivot_high_index = na

var float prev_pivot_low = na
var int prev_pivot_low_index = na
var float last_pivot_low = na
var int last_pivot_low_index = na

atan2(y, x) =>
    var float angle = 0.0
    if x > 0
        angle := math.atan(y / x)
    else
        if x < 0 and y >= 0
            angle := math.atan(y / x) + math.pi
        else
            if x < 0 and y < 0
                angle := math.atan(y / x) - math.pi
            else
                if x == 0 and y > 0
                    angle := math.pi / 2
                else
                    if x == 0 and y < 0
                        angle := -math.pi / 2
    angle

min_max_volume(src) =>
    out = (src - ta.lowest(src, 100))/(ta.highest(src, 100) - ta.lowest(src, 100)) * 100
    math.max(math.min(100, out), 0)

volume_normalized()=>
    min_max_volume(ta.wma(volume, 21))

simple_moving_average(source)=>
    var float sum = na
    var int count = na
    count := nz(count[1]) + 1
    sum := nz(sum[1]) + source 
    sum/count

liquidity_break()=>
    vol = volume_normalized()
    avg = simple_moving_average(vol)
    rank = ta.percentile_nearest_rank(vol, 75, 100)
    avg_rank = simple_moving_average(rank)
    colour = vol < avg ? "LB" : (vol > avg and vol < avg_rank ? "MB" : "HB")


// Pivot high calculation
ph3 = ta.pivothigh(source_high, length4, length4)
if (not na(ph3))
    // Update the previous pivot high to the last pivot high before we update the last pivot high
    prev_pivot_high := last_pivot_high
    prev_pivot_high_index := last_pivot_high_index
    // Update the last pivot high
    last_pivot_high := ph3
    last_pivot_high_index := bar_index

// Pivot low calculation
pl3 = ta.pivotlow(source_low, length4, length4)
if (not na(pl3))
    // Update the previous pivot low to the last pivot low before we update the last pivot low
    prev_pivot_low := last_pivot_low
    prev_pivot_low_index := last_pivot_low_index
    // Update the last pivot low
    last_pivot_low := pl3
    last_pivot_low_index := bar_index

volume_score = volume_normalized()

var down_trend_top = line.new(na, na, na, na, color = na, width = 1)
var down_trend_bottom = line.new(na, na, na, na, color = na, width = 1)
var down_trend_top_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_bottom_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_top_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_bottom_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var down_trend_center = line.new(na, na, na, na, color = na, width = 1, style = line.style_dashed)
var down_break_label = label.new(na, na, na, textcolor = color.new(#ffffff, 0))
linefill.new(down_trend_top, down_trend_top_zone_mid, color.new(top_color, 80))
linefill.new(down_trend_bottom, down_trend_bottom_zone_mid, color.new(bottom_color, 80))
down_trend_top_zone_mid_fill = linefill.new(down_trend_top_zone_mid, down_trend_top_zone, color.new(top_color, 90))
down_trend_bottom_zone_mid_fill = linefill.new(down_trend_bottom_zone_mid, down_trend_bottom_zone, color.new(bottom_color, 90))
var up_trend_top = line.new(na, na, na, na, color = na, width = 1)
var up_trend_bottom = line.new(na, na, na, na, color = na, width = 1)
var up_trend_top_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_bottom_zone = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_top_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_bottom_zone_mid = line.new(na, na, na, na, color = color.new(color.black, 100), width = 1)
var up_trend_center = line.new(na, na, na, na, color = na, width = 1, style = line.style_dashed)
linefill.new(up_trend_top, up_trend_top_zone_mid, color.new(top_color, 80))
linefill.new(up_trend_bottom, up_trend_bottom_zone_mid, color.new(bottom_color, 80))
top_trend_top_zone_mid_fill = linefill.new(up_trend_top_zone_mid, up_trend_top_zone, color.new(top_color, 90))
top_trend_bottom_zone_mid_fill = linefill.new(up_trend_bottom_zone_mid, up_trend_bottom_zone, color.new(bottom_color, 90))
var up_break_label = label.new(na, na, na, textcolor = color.new(#ffffff, 0), style = label.style_label_up)

if extend1
    line.set_extend(down_trend_top, extend.right)
    line.set_extend(down_trend_bottom, extend.right)
    line.set_extend(down_trend_top_zone, extend.right)
    line.set_extend(down_trend_bottom_zone, extend.right)
    line.set_extend(down_trend_center, extend.right)
    line.set_extend(up_trend_top, extend.right)
    line.set_extend(up_trend_bottom, extend.right)
    line.set_extend(up_trend_top_zone, extend.right)
    line.set_extend(up_trend_bottom_zone, extend.right)
    line.set_extend(up_trend_center, extend.right)
    line.set_extend(down_trend_top_zone_mid, extend.right)
    line.set_extend(down_trend_bottom_zone_mid, extend.right)
    line.set_extend(up_trend_top_zone_mid, extend.right)
    line.set_extend(up_trend_bottom_zone_mid, extend.right)
else
    line.set_extend(down_trend_top, extend.none)
    line.set_extend(down_trend_bottom, extend.none)
    line.set_extend(down_trend_top_zone, extend.none)
    line.set_extend(down_trend_bottom_zone, extend.none)
    line.set_extend(down_trend_center, extend.none)
    line.set_extend(up_trend_top, extend.none)
    line.set_extend(up_trend_bottom, extend.none)
    line.set_extend(up_trend_top_zone, extend.none)
    line.set_extend(up_trend_bottom_zone, extend.none)
    line.set_extend(up_trend_center, extend.none)
    line.set_extend(down_trend_top_zone_mid, extend.none)
    line.set_extend(down_trend_bottom_zone_mid, extend.none)
    line.set_extend(up_trend_top_zone_mid, extend.none)
    line.set_extend(up_trend_bottom_zone_mid, extend.none)

var down_dydx = 0.
var up_dydx = 0.

atr_10 = ta.atr(10) * 6
var down_count = 0
var up_count = 0

// Plot the trendlines if we have enough pivots
if (not na(prev_pivot_high)
 and not na(last_pivot_high)) 
 and prev_pivot_high != prev_pivot_high[1] 
 and atan2(last_pivot_high - prev_pivot_high, last_pivot_high_index - prev_pivot_high_index) <= 0 
 and down_count == 0 
 and (wait ? up_count != 1 : true)
 and barstate.isconfirmed
    down_count := 1
    offset = atr_10
    line.set_xy1(down_trend_top, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high + offset/7))
    line.set_xy2(down_trend_top, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high + offset/7))
    line.set_color(down_trend_top, top_color)
    line.set_xy1(down_trend_top_zone, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset/7))
    line.set_xy2(down_trend_top_zone, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset/7))
    line.set_xy1(down_trend_top_zone_mid, prev_pivot_high_index - length4, prev_pivot_high)
    line.set_xy2(down_trend_top_zone_mid, last_pivot_high_index - length4, last_pivot_high)
    down_dydx := (last_pivot_high - prev_pivot_high) / (last_pivot_high_index - prev_pivot_high_index)
    line.set_xy1(down_trend_bottom, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset - offset/7))
    line.set_xy2(down_trend_bottom, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset - offset/7))
    line.set_color(down_trend_bottom, bottom_color)
    line.set_xy1(down_trend_bottom_zone, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset + offset/7))
    line.set_xy2(down_trend_bottom_zone, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset + offset/7))
    line.set_xy1(down_trend_bottom_zone_mid, prev_pivot_high_index - length4, math.round_to_mintick(prev_pivot_high - offset))
    line.set_xy2(down_trend_bottom_zone_mid, last_pivot_high_index - length4, math.round_to_mintick(last_pivot_high - offset))

    // Set center line for down trend
    line.set_xy1(down_trend_center, prev_pivot_high_index - length4, math.round_to_mintick((prev_pivot_high + prev_pivot_high - offset) / 2))
    line.set_xy2(down_trend_center, last_pivot_high_index - length4, math.round_to_mintick((last_pivot_high + last_pivot_high - offset) / 2))
    line.set_color(down_trend_center, center_color)
    label.set_text(down_break_label, "")
    label.set_color(down_break_label, color.new(color.black, 100))
    // Blank previous channel
    if not show
        line.set_xy1(up_trend_bottom, na, na)
        line.set_xy2(up_trend_bottom, na, na)
        line.set_xy1(up_trend_top, na, na)
        line.set_xy2(up_trend_top, na, na)
        line.set_xy1(up_trend_center, na, na)
        line.set_xy2(up_trend_center, na, na)
        line.set_xy1(up_trend_bottom_zone, na, na)
        line.set_xy2(up_trend_bottom_zone, na, na)
        line.set_xy1(up_trend_bottom_zone_mid, na, na)
        line.set_xy2(up_trend_bottom_zone_mid, na, na)
        line.set_xy1(up_trend_top_zone, na, na)
        line.set_xy2(up_trend_top_zone, na, na)
        line.set_xy1(up_trend_top_zone_mid, na, na)
        line.set_xy2(up_trend_top_zone_mid, na, na)
        label.set_text(up_break_label, "")
        label.set_color(up_break_label, color.new(color.black, 100))

if (not na(prev_pivot_low)
 and not na(last_pivot_low)) 
 and prev_pivot_low != prev_pivot_low[1] 
 and atan2(last_pivot_low - prev_pivot_low, last_pivot_low_index - prev_pivot_low_index) >= 0 
 and up_count == 0 
 and (wait ? down_count != 1 : true)
 and barstate.isconfirmed
    up_count := 1
    offset = atr_10
    line.set_xy1(up_trend_top, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset + offset/7))
    line.set_xy2(up_trend_top, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset + offset/7))
    line.set_color(up_trend_top, top_color)
    line.set_xy1(up_trend_top_zone, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset - offset/7))
    line.set_xy2(up_trend_top_zone, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset - offset/7))
    line.set_xy1(up_trend_top_zone_mid, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset))
    line.set_xy2(up_trend_top_zone_mid, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset))
    line.set_xy1(up_trend_bottom, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low - offset/7))
    line.set_xy2(up_trend_bottom, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low - offset/7))
    line.set_color(up_trend_bottom, bottom_color)
    line.set_xy1(up_trend_bottom_zone, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low + offset/7))
    line.set_xy2(up_trend_bottom_zone, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low + offset/7))
    line.set_xy1(up_trend_bottom_zone_mid, prev_pivot_low_index - length4, math.round_to_mintick(prev_pivot_low))
    line.set_xy2(up_trend_bottom_zone_mid, last_pivot_low_index - length4, math.round_to_mintick(last_pivot_low))
    up_dydx := (last_pivot_low - prev_pivot_low) / (last_pivot_low_index - prev_pivot_low_index)
    // Set center line for up trend
    line.set_xy1(up_trend_center, prev_pivot_low_index - length4, math.round_to_mintick((prev_pivot_low + prev_pivot_low + offset) / 2))
    line.set_xy2(up_trend_center, last_pivot_low_index - length4, math.round_to_mintick((last_pivot_low + last_pivot_low + offset) / 2))
    line.set_color(up_trend_center, center_color)
    label.set_text(up_break_label, "")
    label.set_color(up_break_label, color.new(color.black, 100))
    // Blank previous channel
    if not show
        line.set_xy1(down_trend_bottom, na, na)
        line.set_xy2(down_trend_bottom, na, na)
        line.set_xy1(down_trend_top, na, na)
        line.set_xy2(down_trend_top, na, na)
        line.set_xy1(down_trend_center, na, na)
        line.set_xy2(down_trend_center, na, na)
        line.set_xy1(down_trend_bottom_zone, na, na)
        line.set_xy2(down_trend_bottom_zone, na, na)
        line.set_xy1(down_trend_bottom_zone_mid, na, na)
        line.set_xy2(down_trend_bottom_zone_mid, na, na)
        line.set_xy1(down_trend_top_zone, na, na)
        line.set_xy2(down_trend_top_zone, na, na)
        line.set_xy1(down_trend_top_zone_mid, na, na)
        line.set_xy2(down_trend_top_zone_mid, na, na)
        label.set_text(down_break_label, "")
        label.set_color(down_break_label, color.new(color.black, 100))

liquidity_score = liquidity_break()
volume_color_high = color.new(top_color, 60 + (100 - volume_score)/5)
volume_color_low = color.new(bottom_color, 60 + (100 - volume_score)/5)

atr_20 = ta.atr(20)/1.5
if down_count == 1
    if enable_liquid    
        linefill.set_color(down_trend_top_zone_mid_fill, volume_color_high)
        linefill.set_color(down_trend_bottom_zone_mid_fill, volume_color_low)
    if not extend1
        line.set_y2(down_trend_top, line.get_y2(down_trend_top) + down_dydx)
        line.set_y2(down_trend_bottom, line.get_y2(down_trend_bottom) + down_dydx)
        line.set_y2(down_trend_top_zone, line.get_y2(down_trend_top_zone) + down_dydx)
        line.set_y2(down_trend_bottom_zone, line.get_y2(down_trend_bottom_zone) + down_dydx)
        line.set_y2(down_trend_top_zone_mid, line.get_y2(down_trend_top_zone_mid) + down_dydx)
        line.set_y2(down_trend_bottom_zone_mid, line.get_y2(down_trend_bottom_zone_mid) + down_dydx)
        line.set_y2(down_trend_center, line.get_y2(down_trend_center) + down_dydx)
        line.set_x2(down_trend_top, bar_index)
        line.set_x2(down_trend_bottom, bar_index)
        line.set_x2(down_trend_top_zone, bar_index)
        line.set_x2(down_trend_bottom_zone, bar_index)
        line.set_x2(down_trend_top_zone_mid, bar_index)
        line.set_x2(down_trend_bottom_zone_mid, bar_index)
        line.set_x2(down_trend_center, bar_index)

    if low > line.get_price(down_trend_top, bar_index)
        down_count := 0
        label.set_text(down_break_label, liquidity_score)
        label.set_color(down_break_label, top_color)
        label.set_style(down_break_label, label.style_label_up)
        label.set_xy(down_break_label, bar_index, line.get_y2(down_trend_top) - atr_20)
    if high < line.get_price(down_trend_bottom, bar_index)
        down_count := 0
        label.set_text(down_break_label, liquidity_score)
        label.set_color(down_break_label, bottom_color)
        label.set_style(down_break_label, label.style_label_down)
        label.set_xy(down_break_label, bar_index, line.get_y2(down_trend_bottom) + atr_20)

if up_count == 1
    if enable_liquid
        linefill.set_color(top_trend_top_zone_mid_fill, volume_color_high)
        linefill.set_color(top_trend_bottom_zone_mid_fill, volume_color_low)
    if not extend1
        line.set_y2(up_trend_top, line.get_y2(up_trend_top) + up_dydx)
        line.set_y2(up_trend_bottom, line.get_y2(up_trend_bottom) + up_dydx)
        line.set_y2(up_trend_top_zone, line.get_y2(up_trend_top_zone) + up_dydx)
        line.set_y2(up_trend_bottom_zone, line.get_y2(up_trend_bottom_zone) + up_dydx)
        line.set_y2(up_trend_top_zone_mid, line.get_y2(up_trend_top_zone_mid) + up_dydx)
        line.set_y2(up_trend_bottom_zone_mid, line.get_y2(up_trend_bottom_zone_mid) + up_dydx)
        line.set_y2(up_trend_center, line.get_y2(up_trend_center) + up_dydx)
        line.set_x2(up_trend_top, bar_index)
        line.set_x2(up_trend_bottom, bar_index)
        line.set_x2(up_trend_top_zone, bar_index)
        line.set_x2(up_trend_bottom_zone, bar_index)
        line.set_x2(up_trend_top_zone_mid, bar_index)
        line.set_x2(up_trend_bottom_zone_mid, bar_index)
        line.set_x2(up_trend_center, bar_index)

    if low > line.get_price(up_trend_top, bar_index) and barstate.isconfirmed
        up_count := 0
        label.set_text(up_break_label, liquidity_score)
        label.set_color(up_break_label, top_color)
        label.set_style(up_break_label, label.style_label_up)
        label.set_xy(up_break_label, bar_index, line.get_y2(up_trend_top) - atr_20)
    if high < line.get_price(up_trend_bottom, bar_index) and barstate.isconfirmed
        up_count := 0
        label.set_text(up_break_label, liquidity_score)
        label.set_color(up_break_label, bottom_color)
        label.set_style(up_break_label, label.style_label_down)
        label.set_xy(up_break_label, bar_index, line.get_y2(up_trend_bottom) + atr_20)

//-----------------------------------------------------------------------------}
//COBRA ALGO
//-----------------------------------------------------------------------------{
len=input(14,"Heiken Range",group= "Heiken MA")
emLength = input(2,"Heiken Smooth",group= "Heiken MA")
atrPeriod = input(2, "ATR Length",group="SuperTrend")
factor = input.float(2.0, "Factor", step = 0.01,group="SuperTrend")

openn=ta.ema(open,len)
closee=ta.ema(close,len)
highh=ta.ema(high,len)
loww=ta.ema(low,len)
kclose = (openn+highh+loww+closee)/4
var float kopen = 0
kopen := na(kopen[1]) ? (openn + closee)/2 : (kopen[1] + kclose[1]) / 2
khigh = math.max (highh, math.max(kopen,kclose))
klow = math.min (loww, math.min(kopen,kclose))

lineVal = klow + ((khigh - klow) / 2)

col=kopen>kclose ? #ff0057 : #20a505
heikenLine = ta.ema(lineVal,emLength)
plot(heikenLine,color=col,linewidth=3 )

/////////////////////////////////////////////////////

[supertrend, direction] = ta.supertrend(factor, atrPeriod)


heikenLong = kopen<kclose
heikenShort = kopen>kclose
superLong = direction < 0
superShort = direction > 0

var pos = 0

longSig = heikenLong and superLong
shortSig = heikenShort and superShort

if longSig and not longSig[1] and not pos != 1
    pos := 1
if shortSig and not shortSig[1] and pos != -1
    pos := -1

plotshape(pos == -1 and pos != pos[1], location=location.abovebar, style=shape.labeldown, color=#ff0057, size=size.tiny, text="Sell", textcolor=color.white, transp=0)
plotshape(pos == 1 and pos != pos[1], location=location.belowbar, style=shape.labelup, color=#20a505, size=size.tiny, text="Buy", textcolor=color.white, transp=0)

//------------------------------------------------------------------------------
//  Gann Square of 9 
//------------------------------------------------------------------------------
var bool RedGan = input.bool(true, title="On/Off Red line")
var bool BlueGan = input.bool(true, title="On/Off Blue line")
var bool labelOn = input.bool(true, title="On/Off Label")
var color LabelColor = input.color(title="Label color", defval=color.black)
var color BlueLineColor = input.color(title="Blue Line color", defval=color.blue)
var color RedLineColor = input.color(title="Red  Line color", defval=color.red)
var string Extend = input.string(defval="true", title="Extend line")
var int PriceLevel = input.int(3, title="Price Level", options=[3, 5])

// Variables
var label rl1 = na
var label rl2 = na
var label sl1 = na
var label bl1 = na
var label bl2 = na
label.delete(rl1)
label.delete(rl2)
label.delete(sl1)
label.delete(bl1)
label.delete(bl2)

// Función para dibujar líneas
drawLine(resistance, start, end, extend, linecolor) =>
    gannLine = line.new(x1=start, y1=resistance, x2=end, y2=resistance)
    line.set_color(gannLine, linecolor)
    if extend
        line.set_extend(id=gannLine, extend=extend.left)
    gannLine
// Función para dibujar etiquetas
drawLabel(x, y, labelText) =>
    GannLabel = label.new(x, y, labelText, xloc=xloc.bar_time, style=label.style_none)
    GannLabel

// Variables y cálculos
var int max = 20
var int rangeMin = 0
var float[] GannNum = array.new_float(0)
dt = time - time[1]
labelPosition = time + 3 * dt

// Condiciones de última barra
if barstate.islast
    for min = rangeMin to max
        for i = 0 to 3
            var float gNum = 0
            if min == rangeMin and i == 0
                gNum := min + (min+2)
            else if min > rangeMin and i == 0
                gNum := math.round(array.get(GannNum, array.size(GannNum)-1)) + (min+1) + min
            else
                gNum := math.round(array.get(GannNum, array.size(GannNum)-1)) + (min+2) + min
            array.push(GannNum, gNum)

    var int maxItem = array.size(GannNum)-1
    var int next = 0
    var float denomenator = 0.0
    if close[0] >= 10000
        denomenator := 0.01
    else if close[0] >= 1000
        denomenator := 0.1
    else if close[0] >= 100
        denomenator := 1
    else if close[0] >=10
        denomenator := 10
    else if close[0] >=0.05
        denomenator := 100
    else 
        denomenator := 1000
        
    var float price = close[0] * denomenator
    var float resistance = 0.0
    var float support = 0.0
    var float blueGannPrice1 = 0.0
    var int GannPos = 0
    for i = 0 to array.size(GannNum)-1
        if i == maxItem
            next := i
        else 
            next := i + 1
            
        if array.get(GannNum, i) <= price and array.get(GannNum, next) > price
            resistance := array.get(GannNum, next) / denomenator
            support := array.get(GannNum, i) / denomenator
            blueGannPrice1 := (support + resistance) / 2
            GannPos := i
            break
    
    var int startLine = bar_index[0]
    var int endLine = bar_index[10]
    var int GannWeightPosition = close[0] >= blueGannPrice1 ? 2 : -1
    
    if RedGan
        resistance1 = drawLine(resistance, startLine, endLine, Extend == "true", RedLineColor)
        support1 = drawLine(support, startLine, endLine, Extend == "true", RedLineColor)
    if labelOn
        rl1 := drawLabel(labelPosition, resistance, "R1 = " + str.tostring(resistance))
        sl1 := drawLabel(labelPosition, support, "S1 = " + str.tostring(support))
        label.set_textcolor(sl1, LabelColor)
    if PriceLevel == 5
        resistancePrice2 = array.get(GannNum, GannPos+GannWeightPosition) / denomenator
        resistance2 = drawLine(resistancePrice2, startLine, endLine, Extend == "true", RedLineColor)
        if labelOn
            resistanceText2 = GannWeightPosition > 0 ? "R2 = " : "S2 = "
            rl2 := drawLabel(labelPosition, resistancePrice2, resistanceText2 + str.tostring(resistancePrice2))
            label.set_textcolor(rl2, LabelColor)
    if BlueGan
        var line blueGann1 = drawLine(blueGannPrice1, startLine, endLine, Extend == "true", BlueLineColor)
        if labelOn
            BlueText1 = close[0] >= blueGannPrice1 ? "S1 = " : "R1 = "
            bl1 := drawLabel(labelPosition, blueGannPrice1, BlueText1 + str.tostring(blueGannPrice1))
            label.set_textcolor(bl1, LabelColor)
        if PriceLevel == 5
            var float BlueGannPrice2 = GannWeightPosition > 0 ? (array.get(GannNum, GannPos+1) + array.get(GannNum, GannPos+2)) / 2 : (array.get(GannNum, GannPos-1) + array.get(GannNum, GannPos)) / 2
            BlueGannPrice2 := BlueGannPrice2 / denomenator
            var line blueGann2 = drawLine(BlueGannPrice2, startLine, endLine, Extend == "true", BlueLineColor)
            if labelOn
                BlueText2 = GannWeightPosition > 0 ? "R1 = " : "S1 = "
                bl2 := drawLabel(labelPosition, BlueGannPrice2, BlueText2 + str.tostring(BlueGannPrice2))
                label.set_textcolor(bl2, LabelColor)