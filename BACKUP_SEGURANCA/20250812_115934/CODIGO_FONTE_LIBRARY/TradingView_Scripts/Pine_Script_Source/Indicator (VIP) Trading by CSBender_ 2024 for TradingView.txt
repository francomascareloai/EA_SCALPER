// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join our channel for more free tools: https://t.me/simpleforextools

//@version=5
indicator("(VIP) Trading by CSBender_ 2024", shorttitle="(VIP) Trading by CSBender_ 2024",overlay=true,max_labels_count=500,max_lines_count=500,max_bars_back=5000, max_boxes_count = 500, precision=4)

currentPrice = request.security(syminfo.tickerid, "15", close)
takeprofitValueL = input.float(title="TakeProfit Long ( ▲ 1.03 = 1.7%)", defval=1.06, minval=1.03, maxval=1.15, group = 'LONG % SHORT')
takeprofitValueS = input.float(title="TakeProfit Short ( ▼ 0.96 = 1.7%)", defval=0.93, minval=0.9, maxval=0.97, group = 'LONG % SHORT') 
// Define los valores para las celdas
valorCelda1 = currentPrice * 0.987// ▼ SL 1.7%
valorCelda3 = currentPrice * takeprofitValueL // ▲ TP 5.93% == 1.06
valorCelda2 = currentPrice
valorCelda4 = currentPrice * 1.012 // ▲ SL 1.7%
valorCelda5 = currentPrice * takeprofitValueS // ▼ TP 7.1% == 0.93

// Dibuja un cuadro en la parte superior izquierda del gráfico
var box_x = ta.highest(high, 20)
var int box_y = int(ta.highest(high[20], 20))
var int box_width = 150
var int box_height = 80

var myTable3 = table.new(position = position.top_right, columns = 4, rows = 4, bgcolor = color.white, border_width = 1, frame_color = color.black, frame_width = 2, border_color = color.black)
//table.cell(table_id = myTable3, column = 0, row = 0, text = "TP 3%", text_size = size.small, text_color = color.black, bgcolor = color.yellow)
//table.cell(table_id = myTable3, column = 0, row = 1, text = "LONG", text_size = size.small, text_color = color.black, bgcolor = color.white)
//table.cell(table_id = myTable3, column = 0, row = 2, text = "SL 1.7%", text_size = size.small, text_color = color.black, bgcolor = color.blue)
//table.cell(table_id = myTable3, column = 1, row = 0, text = str.tostring(valorCelda3), text_size = size.small, text_color = color.black, bgcolor = color.yellow)
//table.cell(table_id = myTable3, column = 1, row = 1, text = str.tostring(valorCelda2), text_size = size.small, text_color = color.black, bgcolor = color.white)
//table.cell(table_id = myTable3, column = 1, row = 2, text = str.tostring(valorCelda1), text_size = size.small, text_color = color.black, bgcolor = color.blue)

var myTable4 = table.new(position = position.bottom_right, columns = 4, rows = 4, bgcolor = color.white, border_width = 1, frame_color = color.black, frame_width = 2, border_color = color.black)
//table.cell(table_id = myTable4, column = 0, row = 0, text = "SL 1.7%", text_size = size.small, text_color = color.black, bgcolor = color.red)
//table.cell(table_id = myTable4, column = 0, row = 1, text = "SHORT", text_size = size.small, text_color = color.black, bgcolor = color.white)
//table.cell(table_id = myTable4, column = 0, row = 2, text = "TP 3%", text_size = size.small, text_color = color.black, bgcolor = color.lime)
//table.cell(table_id = myTable4, column = 1, row = 0, text = str.tostring(valorCelda4), text_size = size.small, text_color = color.black, bgcolor = color.red)
//table.cell(table_id = myTable4, column = 1, row = 1, text = str.tostring(valorCelda2), text_size = size.small, text_color = color.black, bgcolor = color.white)
//table.cell(table_id = myTable4, column = 1, row = 2, text = str.tostring(valorCelda5), text_size = size.small, text_color = color.black, bgcolor = color.lime)

show_TPSL_LONG  = input.bool(false,'Enable Auto TP and SL in Long',inline='inline1', group = 'LONG % SHORT')
show_TPSL_SHORT  = input.bool(false,'Enable Auto TP and SL in Short',inline='inline1', group = 'LONG % SHORT')
if show_TPSL_LONG
    // Variables para las líneas horizontales
    var line1 = line.new(x1=bar_index, y1=valorCelda1, x2=bar_index[1], y2=valorCelda1,  color=color.blue, width=1, extend = extend.left)
    var line3 = line.new(x1=bar_index, y1=valorCelda3, x2=bar_index[1], y2=valorCelda3, color=color.yellow, width=1, extend = extend.left)
    var labelSL_LONG = label.new(x=na, y=na, text="SL", color=color.blue, textcolor=color.white,style=label.style_label_up)
    var labelTP_LONG = label.new(x=na, y=na, text="TP", color=color.yellow, textcolor=color.black,style=label.style_label_down)

    // Actualiza el valor de las líneas
    line.set_xy1(line1, bar_index, valorCelda1)
    line.set_xy2(line1, bar_index[1], valorCelda1)
    
    line.set_xy1(line3, bar_index, valorCelda3)
    line.set_xy2(line3, bar_index[1], valorCelda3)

    label.set_xy(labelSL_LONG, x=bar_index[1], y=valorCelda1)
    label.set_xy(labelTP_LONG, x=bar_index[1], y=valorCelda3)

    label.set_text(labelSL_LONG, text="SL: " + str.tostring(valorCelda1))
    label.set_text(labelTP_LONG, text="TP: " + str.tostring(valorCelda3))
    
if show_TPSL_SHORT
    // Variables para las líneas horizontales
    var line4 = line.new(x1=bar_index, y1=valorCelda4, x2=bar_index[1], y2=valorCelda4, color=color.red, width=1, extend = extend.left)
    var line5 = line.new(x1=bar_index, y1=valorCelda5, x2=bar_index[1], y2=valorCelda5, color=color.green, width=1, extend = extend.left)
    var labelSL_SHORT = label.new(x=na, y=na, text="SL", color=color.red, textcolor=color.white,style=label.style_label_down)
    var labelTP_SHORT = label.new(x=na, y=na, text="TP", color=color.green, textcolor=color.white,style=label.style_label_up)

    // Actualiza el valor de las líneas
    line.set_xy1(line4, bar_index, valorCelda4)
    line.set_xy2(line4, bar_index[1], valorCelda4)

    line.set_xy1(line5, bar_index, valorCelda5)
    line.set_xy2(line5, bar_index[1], valorCelda5)

    label.set_xy(labelSL_SHORT, x=bar_index[1], y=valorCelda4)
    label.set_xy(labelTP_SHORT, x=bar_index[1], y=valorCelda5)

    label.set_text(labelSL_SHORT, text="SL: " + str.tostring(valorCelda4))
    label.set_text(labelTP_SHORT, text="TP: " + str.tostring(valorCelda5))


var  myTable = table.new(position = position.bottom_center, columns = 4, rows = 2, bgcolor = color.white, border_width = 1, frame_color = color.black, frame_width = 2, border_color = color.black)
table.cell(table_id = myTable, column = 0, row = 0, text = "EMA20", text_size = size.small, text_color = color.black, bgcolor = color.orange)
table.cell(table_id = myTable, column = 1, row = 0, text = "EMA50 ↑", text_size = size.small, text_color = color.black, bgcolor = color.lime)
//table.cell(table_id = myTable, column = 2, row = 0, text = "EMA100", text_size = size.small, text_color = color.black, bgcolor = color.blue)
table.cell(table_id = myTable, column = 3, row = 0, text = "EMA200", text_size = size.small, text_color = color.black, bgcolor = color.fuchsia)
table.cell(table_id = myTable, column = 0, row = 1, text = "EMA20", text_size = size.small, text_color = color.black, bgcolor = color.orange)
table.cell(table_id = myTable, column = 1, row = 1, text = "EMA50 ↓", text_size = size.small, text_color = color.black, bgcolor = color.red)
//table.cell(table_id = myTable, column = 2, row = 1, text = "EMA100", text_size = size.small, text_color = color.black, bgcolor = color.blue)
table.cell(table_id = myTable, column = 3, row = 1, text = "EMA200", text_size = size.small, text_color = color.black, bgcolor = color.fuchsia)



//============ Directional Projection (EMA50) ================================//
showema50 = input(defval = true, title="Directional Projection EMA50", group = 'EMA')
ema02 = ta.ema(close, 50)
direction2 = ta.rising(ema02, 2) ? +1 : ta.falling(ema02, 2) ? -1 : 0
plot_color2 = direction2 > 0  ? color.lime: direction2 < 0 ? color.rgb(247, 34, 34) : na
plot(showema50 and ema02 ? ema02 : na,  style=plot.style_line, linewidth=1, color = plot_color2)



//============ EMA 20/100/200/ ================================//
//showema100 = input(defval = false, title="Show EMA100", group = 'EMA')
showema200 = input(defval = true, title="Show EMA200", group = 'EMA')
//ema100 = ta.ema(close, 100)
ema200 = ta.ema(close, 200)
//plot(showema100 and ema100 ? ema100 : na, color = showema100 and ema100 ? color.blue : na, linewidth = 2)
plot(showema200 and ema200 ? ema200 : na, color = showema200 and ema200 ? color.fuchsia : na, linewidth = 2)



//====================colour bar=====================//
mysignal = ta.ema(close, 12) - ta.ema(close, 26)
barcolor(mysignal[0] > mysignal[1] ? color.green : color.red)



//====================   BREAKS AND TRENDLINES   =====================//
length = 24
n = bar_index
k      = 1.6
method = 'Atr'
show   = input(true,'Show Only Confirmed Breakouts', group = 'BREAKS AND TRENDLINES')
upper = 0.,lower = 0.
slope_ph = 0.,slope_pl = 0.
src = close
ph = ta.pivothigh(length,length)
pl = ta.pivotlow(length,length)
slope = switch method
    'Atr'      => ta.atr(length)/length*k
    'Stdev'    => ta.stdev(src,length)/length*k
    'Linreg'   => math.abs(ta.sma(src*bar_index,length)-ta.sma(src,length)*ta.sma(bar_index,length))/ta.variance(n,length)/2*k
slope_ph := ph ? slope : slope_ph[1]
slope_pl := pl ? slope : slope_pl[1]
upper := ph ? ph : upper[1] - slope_ph
lower := pl ? pl : lower[1] + slope_pl
single_upper = 0
single_lower = 0
single_upper := src[length] > upper ? 0 : ph ? 1 : single_upper[1]
single_lower := src[length] < lower ? 0 : pl ? 1 : single_lower[1]
upper_breakout = single_upper[1] and src[length] > upper and (show ? src > src[length] : 1)
lower_breakout = single_lower[1] and src[length] < lower and (show ? src < src[length] : 1)
plotshape(upper_breakout ? low[length] : na,"Upper Break",shape.labelup,location.absolute,#26a69a,-length,text="Buy OK",textcolor=color.white,size=size.tiny)
plotshape(lower_breakout ? high[length] : na,"Lower Break",shape.labeldown,location.absolute,#ef5350,-length,text="Sell OK",textcolor=color.white,size=size.tiny)
var line up_l = na
var line dn_l = na
var label recent_up_break = na
var label recent_dn_break = na
if ph[1]
    line.delete(up_l[1])
    label.delete(recent_up_break[1])
    up_l := line.new(n-length-1,ph[1],n-length,upper,color=#26a69a,
      extend=extend.right,style=line.style_dashed)
if pl[1]
    line.delete(dn_l[1])
    label.delete(recent_dn_break[1])
    dn_l := line.new(n-length-1,pl[1],n-length,lower,color=#ef5350,
      extend=extend.right,style=line.style_dashed)
if ta.crossover(src,upper-slope_ph*length)
    label.delete(recent_up_break[1])
    recent_up_break := label.new(n,low,'Buy Now',color=#26a69a,textcolor=color.white,style=label.style_label_up,size=size.small)
if ta.crossunder(src,lower+slope_pl*length)
    label.delete(recent_dn_break[1])
    recent_dn_break := label.new(n,high,'Sell Now',color=#ef5350,textcolor=color.white,style=label.style_label_down,size=size.small)
plot(upper,'Upper',color = ph ? na : #26a69a,offset=-length)
plot(lower,'Lower',color = pl ? na : #ef5350,offset=-length)
alerta1 = ta.crossover(src,upper-slope_ph*length)
alerta2 = ta.crossunder(src,lower+slope_pl*length)
Mensaje = 'El Precio ha roto la linea de tendencia'
if alerta1
    alert(Mensaje+" Superior.",alert.freq_once_per_bar)
else if alerta2
    alert(Mensaje+" Inferior.",alert.freq_once_per_bar)



//============ 'PIVOT POINTS') ===============//
length2 = 50
//n = bar_index
show_reg   = input.bool(true,'Regular Pivots',inline='inline1', group = 'PIVOT POINTS')
reg_ph_css = input.color(#ef5350,'High',inline='inline1', group = 'PIVOT POINTS')
reg_pl_css = input.color(#26a69a,'Low',inline='inline1', group = 'PIVOT POINTS')
show_miss   = input.bool(true,'Missed Pivots',inline='inline2', group = 'PIVOT POINTS')
miss_ph_css = input.color(#ef5350,'High',inline='inline2', group = 'PIVOT POINTS')
miss_pl_css = input.color(#26a69a,'Low',inline='inline2', group = 'PIVOT POINTS')
label_css = input.color(color.white,'Text Label Color', group = 'PIVOT POINTS')
var line zigzag = na
var line ghost_level = na
var max = 0.,var min = 0.
var max_x1 = 0,var min_x1 = 0
var follow_max = 0.,var follow_max_x1 = 0
var follow_min = 0.,var follow_min_x1 = 0
var os = 0,var py1 = 0.,var px1 = 0
ph2 = ta.pivothigh(length2,length2)
pl2 = ta.pivotlow(length2,length2)
max := math.max(high[length2],max)
min := math.min(low[length2],min)
follow_max := math.max(high[length2],follow_max)
follow_min := math.min(low[length2],follow_min)
if max > max[1]
    max_x1 := n-length2
    follow_min := low[length2]
if min < min[1]
    min_x1 := n-length2    
    follow_max := high[length2]
if follow_min < follow_min[1]
    follow_min_x1 := n-length2
if follow_max > follow_max[1]
    follow_max_x1 := n-length2
line.set_x2(ghost_level[1],n)
if ph2
    if show_miss
        if os[1] == 1
            label.new(min_x1,min,'👻',color=miss_pl_css,style=label.style_label_up,size=size.small,
              tooltip=str.tostring(min,'#.####'))
            zigzag := line.new(px1,py1,min_x1,min,color=miss_ph_css,style=line.style_dashed)
            px1 := min_x1,py1 := min
            line.set_x2(ghost_level[1],px1)
            ghost_level := line.new(px1,py1,px1,py1,color=color.new(reg_pl_css,50),width=2)
        else if ph2 < max
            label.new(max_x1,max,'👻',color=miss_ph_css,style=label.style_label_down,size=size.small,
              tooltip=str.tostring(max,'#.####'))
            label.new(follow_min_x1,follow_min,'👻',color=miss_pl_css,style=label.style_label_up,size=size.small,
                  tooltip=str.tostring(min,'#.####'))
            zigzag := line.new(px1,py1,max_x1,max,color=miss_pl_css,style=line.style_dashed)
            px1 := max_x1,py1 := max
            line.set_x2(ghost_level[1],px1)
            ghost_level := line.new(px1,py1,px1,py1,color=color.new(reg_ph_css,50),width=2)
            zigzag := line.new(px1,py1,follow_min_x1,follow_min,color=miss_ph_css,style=line.style_dashed)
            px1 := follow_min_x1,py1 := follow_min
            line.set_x2(ghost_level,px1)
            ghost_level := line.new(px1,py1,px1,py1,color=color.new(reg_pl_css,50),width=2)
    if show_reg
        label.new(n-length2,ph2,'▼',textcolor=label_css,color=reg_ph_css,style=label.style_label_down,size=size.small,
          tooltip=str.tostring(ph2,'#.####'))
        zigzag := line.new(px1,py1,n-length2,ph2,color=miss_pl_css,style=ph2 < max or os[1] == 1 ? line.style_dashed : line.style_solid)
    py1 := ph2,px1 := n-length2,os := 1,max := ph2,min := ph2
if pl2
    if show_miss  
        if os[1] == 0
            label.new(max_x1,max,'👻',color=miss_ph_css,style=label.style_label_down,size=size.small,
              tooltip=str.tostring(max,'#.####'))
            zigzag := line.new(px1,py1,max_x1,max,color=miss_pl_css,style=line.style_dashed)
            px1 := max_x1,py1 := max
            line.set_x2(ghost_level[1],px1)
            ghost_level := line.new(px1,py1,px1,py1,color=color.new(reg_ph_css,50),width=2)
        else if pl2 > min
            label.new(follow_max_x1,follow_max,'👻',color=miss_ph_css,style=label.style_label_down,size=size.small,
              tooltip=str.tostring(max,'#.####'))
            label.new(min_x1,min,'👻',color=miss_pl_css,style=label.style_label_up,size=size.small,
                  tooltip=str.tostring(min,'#.####'))
            zigzag := line.new(px1,py1,min_x1,min,color=miss_ph_css,style=line.style_dashed)
            px1 := min_x1,py1 := min
            line.set_x2(ghost_level[1],px1)
            ghost_level := line.new(px1,py1,px1,py1,color=color.new(reg_pl_css,50),width=2)
            zigzag := line.new(px1,py1,follow_max_x1,follow_max,color=miss_pl_css,style=line.style_dashed)
            px1 := follow_max_x1,py1 := follow_max
            line.set_x2(ghost_level,px1)
            ghost_level := line.new(px1,py1,px1,py1,color=color.new(reg_ph_css,50),width=2)
    if show_reg
        label.new(n-length2,pl2,'▲',textcolor=label_css,color=reg_pl_css,style=label.style_label_up,size=size.small,
          tooltip=str.tostring(pl2,'#.####'))
        zigzag := line.new(px1,py1,n-length2,pl2,color=miss_ph_css,style=pl2 > min or os[1] == 0 ? line.style_dashed : line.style_solid)
    py1 := pl2,px1 := n-length2,os := 0,max := pl2,min := pl2
var label lbl = na
if barstate.islast
    x = 0,y = 0.
    prices = array.new_float(0)
    prices_x = array.new_int(0)
    for i = 0 to n-px1-1
        array.push(prices,os==1?low[i]:high[i])
        array.push(prices_x,n-i)
    label.delete(lbl[1])
    if os == 1
        y := array.min(prices)
        x := array.get(prices_x,array.indexof(prices,y))
        if show_miss
            lbl := label.new(x,y,'👻',color=miss_pl_css,style=label.style_label_up,size=size.small, tooltip=str.tostring(y,'#.####'))
    else
        y := array.max(prices)
        x := array.get(prices_x,array.indexof(prices,y))
        if show_miss
            lbl := label.new(x,y,'👻',color=miss_ph_css,style=label.style_label_down,size=size.small, tooltip=str.tostring(y,'#.####'))
    if show_miss
        line.delete(line.new(px1,py1,x,y,color=os == 1 ? miss_ph_css : miss_pl_css,style=line.style_dashed)[1])
    line.delete(line.new(x,y,n,y,color = color.new(os == 1 ? miss_ph_css : miss_pl_css,50),width=2)[1])



//==========    MEGA TREND LINES    ===========
prd = 2 //min 1 max 50
Factor=3
Pd=10
showlabel = input(defval = true, title="Show Buy/Sell Labels", group = 'MEGA TREND LINES')
showpivot = input(defval = false, title="Show Pivot Points", group = 'MEGA TREND LINES')
showcl = input(defval = false, title="Show PP Center Line", group = 'MEGA TREND LINES')
// get Pivot High/Low
float ph22 = ta.pivothigh(prd, prd)
float pl22 = ta.pivotlow(prd, prd)
// drawl Pivot Points if "showpivot" is enabled
plotshape(ph22 and showpivot, text="H",  style=shape.labeldown, color=na, textcolor=color.red, location=location.abovebar,  offset = -prd)
plotshape(pl22 and showpivot, text="L",  style=shape.labeldown, color=na, textcolor=color.lime, location=location.belowbar,  offset = -prd)
// calculate the Center line using pivot points
var float center = na
float lastpp = ph22 ? ph22 : pl22 ? pl22 : na
if lastpp
    if na(center)
        center := lastpp
    else
        //weighted calculation
        center := (center * 2 + lastpp) / 3
// upper/lower bands calculation
Up = center - (Factor * ta.atr(Pd))
Dn = center + (Factor * ta.atr(Pd))
// get the trend
float TUp = na
float TDown = na
Trend = 0
TUp := close[1] > TUp[1] ? math.max(Up, TUp[1]) : Up
TDown := close[1] < TDown[1] ? math.min(Dn, TDown[1]) : Dn
Trend := close > TDown[1] ? 1: close < TUp[1]? -1: nz(Trend[1], 1)
Trailingsl = Trend == 1 ? TUp : TDown
// plot the trend
linecolor = Trend == 1 and nz(Trend[1]) == 1 ? color.lime : Trend == -1 and nz(Trend[1]) == -1 ? color.red : na
plot(showlabel and Trailingsl ? Trailingsl : na, color = linecolor ,  linewidth = 2, title = "PP SuperTrend")
plot(showcl ? center : na, color = showcl ? center < hl2 ? color.blue : color.red : na)
// check and plot the signals
bsignal = Trend == 1 and Trend[1] == -1
ssignal = Trend == -1 and Trend[1] == 1
plotshape(bsignal and showlabel ? Trailingsl : na, title="Buy", text="Close Short Order\nGo to Long Now", location = location.absolute, style = shape.labelup, size = size.tiny, color = color.lime, textcolor = color.black)
plotshape(ssignal and showlabel ? Trailingsl : na, title="Sell", text="Close Long Order\nGo to Short Now", location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.red, textcolor = color.white)
alerta3 = bsignal
alerta4 = ssignal
Mensaje2 = 'Cierre la posicion y abra una en'
if alerta3
    alert(Mensaje2+" Long.",alert.freq_all)
else if alerta4
    alert(Mensaje2+" Short.",alert.freq_all)



//============ Golden Cross Indicator 50/200 ===============//
showGoldeCross = input(defval = true, title="Show Golden Cross", group = 'GOLDEN CROSS')
short = ta.ema(close, 50)
long = ta.ema(close, 200)
directionc = ta.rising(long, 2) ? +1 : ta.falling(long, 2) ? -1 : 0
tendenup=ta.crossover(short, long)
tendendown=ta.crossunder(short, long)
plotarrow(showGoldeCross and tendenup ? 1 : tendenup ? -1 : na, title="Up Entry Arrow", colorup=showGoldeCross and tendenup ? color.lime : na, colordown=showGoldeCross and tendenup ? color.lime : na, maxheight=1000, minheight=50)
plotarrow(showGoldeCross and tendendown ? -1 : tendendown ? 1 : na, title="Down Entry Arrow", colorup=showGoldeCross and tendendown ? color.red : na, colordown=showGoldeCross and tendendown ? color.red : na, maxheight=1000, minheight=50)
plotshape(showGoldeCross and tendenup, color=color.yellow, textcolor=color.black, text="EMA200\n\nCross\nBuy", style=shape.labelup, location=location.bottom)
plotshape(showGoldeCross and tendendown, color=color.purple, textcolor=color.white, text="EMA200\n\nCross\nSell", style=shape.labelup, location=location.top)



//============ Support/Resistance ===============//
//get S/R levels using Pivot Points
showsr = input(defval = false, title="Show Support/Resistance", group = 'SUPPORT AND RESISTANCE')
float resistance = na
float support = na
support := pl22 ? pl22 : support[1]
resistance := ph22 ? ph22 : resistance[1]
// if enabled then show S/R levels
plot(showsr and support ? support : na, color = showsr and support ? color.lime : na, style = plot.style_circles, linewidth = 1, offset = 0)
plot(showsr and resistance ? resistance : na, color = showsr and resistance ? color.red : na, style = plot.style_circles, linewidth = 1, offset = 0)




//============ Fair Value Gaps ===============//
//-----------------------------------------------------------------------------{
bullCss          = input.color(color.teal, 'FVG Level'               , inline = 'bull', group = 'FAIR VALUE GAPS')
bullAreaCss      = input.color(color.new(color.teal, 50), 'Area'     , inline = 'bull', group = 'FAIR VALUE GAPS')
bullMitigatedCss = input.color(color.new(color.teal, 80), 'Mitigated', inline = 'bull', group = 'FAIR VALUE GAPS')
bearCss          = input.color(color.red, 'FVG Level'                , inline = 'bear', group = 'FAIR VALUE GAPS')
bearAreaCss      = input.color(color.new(color.red, 50), 'Area'      , inline = 'bear', group = 'FAIR VALUE GAPS')
bearMitigatedCss = input.color(color.new(color.red, 80), 'Mitigated' , inline = 'bear', group = 'FAIR VALUE GAPS')
//UDT's
type fvg
    float top
    float btm
    bool  mitigated
    bool  isnew
    bool  isbull
    line  lvl
    box   area
type session_range
    line max
    line min
//Methods
//Method for setting fair value gaps
method set_fvg(fvg id, offset, bg_css, l_css)=>
    avg = math.avg(id.top, id.btm)
    area  = box.new(n - offset, id.top, n, id.btm, na, bgcolor = bg_css)
    avg_l = line.new(n - offset, avg, n, avg, color = l_css, style = line.style_dashed)
    id.lvl := avg_l
    id.area := area
//Method for setting session range maximum/minimum
method set_range(session_range id)=>
    max = math.max(high, id.max.get_y2())
    min = math.min(low, id.min.get_y2())
    id.max.set_xy2(n, max)
    id.max.set_y1(max)
    id.min.set_xy2(n, min)
    id.min.set_y1(min)
//Variables
var chartCss = color.new(chart.fg_color, 50)
var fvg sfvg = fvg.new(na, na, na, true, na)
var session_range sesr = na
var box area = na
var line avg = na
bull_fvg = low > high[2] and close[1] > high[2]
bear_fvg = high < low[2] and close[1] < low[2]
//Alert conditions
bull_isnew      = false
bear_isnew      = false
bull_mitigated  = false
bear_mitigated  = false
within_bull_fvg = false
within_bear_fvg = false
//New session
dtf = timeframe.change('D')
//On new session
if dtf
    //Set delimiter
    line.new(n, high + syminfo.mintick
      , n, low - syminfo.mintick
      , color = chartCss
      , style = line.style_dashed
      , extend = extend.both)
    //Set new range
    sesr := session_range.new(
      line.new(n, high, n, high, color = chartCss)
      , line.new(n, low, n, low, color = chartCss))
    sfvg.isnew := true
    //Set prior session fvg right coordinates
    if not na(sfvg.lvl)
        sfvg.lvl.set_x2(n-2)
        sfvg.area.set_right(n-2)
//Set range
else if not na(sesr)
    sesr.set_range()
    //Set range lines color
    sesr.max.set_color(sfvg.isbull ? bullCss : bearCss)
    sesr.min.set_color(sfvg.isbull ? bullCss : bearCss)
//Set FVG
//New session bullish fvg
if bull_fvg and sfvg.isnew
    sfvg := fvg.new(low, high[2], false, false, true)
    sfvg.set_fvg(2, bullAreaCss, bullCss)
    bull_isnew := true
//New session bearish fvg
else if bear_fvg and sfvg.isnew
    sfvg := fvg.new(low[2], high, false, false, false)
    sfvg.set_fvg(2, bearAreaCss, bearCss)
    bear_isnew := true
//Change object transparencies if mitigated
if not sfvg.mitigated
    //If session fvg is bullish
    if sfvg.isbull and close < sfvg.btm
        sfvg.set_fvg(1, bullMitigatedCss, bullCss)
        sfvg.mitigated := true
        bull_mitigated := true
    //If session fvg is bearish
    else if not sfvg.isbull and close > sfvg.top
        sfvg.set_fvg(1, bearMitigatedCss, bearCss)
        sfvg.mitigated := true
        bear_mitigated := true
//Set fvg right coordinates to current bar
if not sfvg.isnew
    sfvg.lvl.set_x2(n)
    sfvg.area.set_right(n)




//-----------------------------------------------------------------------------}
// áreas de oferta y demanda
//------------------------------------------------------------------------------
per = input.float(10., 'Threshold %', minval = 0, maxval = 100)
div = input.int(50, 'Resolution'    , minval = 2, maxval = 500)
tf  = input.timeframe('', 'Intrabar TF')
//Colors
showSupply = input(true ,'Supply        ', inline = 'supply', group = 'SUPPLY AND DEMAND')
supplyCss  = input(#2157f3, ''         , inline = 'supply', group = 'SUPPLY AND DEMAND')
supplyArea = input(true ,'Area'          , inline = 'supply', group = 'SUPPLY AND DEMAND')
supplyAvg  = input(true ,'Average'       , inline = 'supply', group = 'SUPPLY AND DEMAND')
supplyWavg = input(true ,'Weighted'      , inline = 'supply', group = 'SUPPLY AND DEMAND')
showEqui   = input(true ,'Equilibrium'   , inline = 'equi'  , group = 'SUPPLY AND DEMAND')
equiCss    = input(color.gray, ''      , inline = 'equi'  , group = 'SUPPLY AND DEMAND')
equiAvg    = input(true ,'Average'       , inline = 'equi'  , group = 'SUPPLY AND DEMAND')
equiWavg   = input(true ,'Weighted'      , inline = 'equi'  , group = 'SUPPLY AND DEMAND')
showDemand = input(true ,'Demand    '    , inline = 'demand', group = 'SUPPLY AND DEMAND')
demandCss  = input(#ff5d00, ''         , inline = 'demand', group = 'SUPPLY AND DEMAND')
demandArea = input(true ,'Area'          , inline = 'demand', group = 'SUPPLY AND DEMAND')
demandAvg  = input(true ,'Average'       , inline = 'demand', group = 'SUPPLY AND DEMAND')
demandWavg = input(true ,'Weighted'      , inline = 'demand', group = 'SUPPLY AND DEMAND')
//UDT's
type bin
    float lvl
    float prev
    float sum
    float prev_sum
    float csum
    float avg
    bool isreached
type area
    box  bx
    line avg 
    line wavg 
//Functions
get_hlv()=> [high, low, volume]
method set_area(area id, x1, top, btm, avg, wavg, showArea, showAvg, showWavg)=>
    if showArea
        id.bx.set_lefttop(x1, top)
        id.bx.set_rightbottom(n, btm)    
    if showAvg
        id.avg.set_xy1(x1, avg)
        id.avg.set_xy2(n, avg)
    if showWavg
        id.wavg.set_xy1(x1, wavg)
        id.wavg.set_xy2(n, wavg)
//Main variables
var x1   = 0
var csum = 0.
//Intrabar data
[h, l, v] = request.security_lower_tf(syminfo.tickerid, tf, get_hlv())
//Init on left bar
if time == chart.left_visible_bar_time
    max := high
    min := low
    csum := volume
    x1 := n
else //Accumulate
    max := math.max(high, max)
    min := math.min(low, min)
    csum += volume
//Set zones
var supply_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(supplyCss, 90),text = "::: Supply :::",text_color=color.white)
  , line.new(na, na, na, na, color = supplyCss)
  , line.new(na, na, na, na, color = supplyCss, style = line.style_dashed))
var demand_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(demandCss, 90),text = "::: Demand :::",text_color=color.white)
  , line.new(na, na, na, na, color = demandCss)
  , line.new(na, na, na, na, color = demandCss, style = line.style_dashed))
var equi  = line.new(na, na, na, na, color = equiCss)
var wequi = line.new(na, na, na, na, color = equiCss, style = line.style_dashed)
var float supply_wavg = na
var float demand_wavg = na
if time == chart.right_visible_bar_time
    r = (max - min) / div
    supply = bin.new(max, max, 0, 0, 0, 0, false)
    demand = bin.new(min, min, 0, 0, 0, 0, false)
    //Loop trough intervals
    for i = 0 to div-1
        supply.lvl -= r
        demand.lvl += r
        //Accumulated volume column
        if not supply.isreached and showSupply and supplyArea
            box.new(x1, supply.prev, x1 + int(supply.sum / csum * (n - x1)), supply.lvl, na
              , bgcolor = color.new(supplyCss, 50))
        if not demand.isreached and showDemand and demandArea
            box.new(x1, demand.lvl, x1 + int(demand.sum / csum * (n - x1)), demand.prev, na
              , bgcolor = color.new(demandCss, 50))
        //Loop trough bars
        for j = 0 to (n - x1)-1
            //Loop trough intrabars
            for k = 0 to (v[j]).size()-1
                //Accumulate if within upper internal
                supply.sum      += (h[j]).get(k) > supply.lvl and (h[j]).get(k) < supply.prev ? (v[j]).get(k) : 0
                supply.avg      += supply.lvl * (supply.sum - supply.prev_sum)
                supply.csum     += supply.sum - supply.prev_sum
                supply.prev_sum := supply.sum
                //Accumulate if within lower interval
                demand.sum      += (l[j]).get(k) < demand.lvl and (l[j]).get(k) > demand.prev ? (v[j]).get(k) : 0
                demand.avg      += demand.lvl * (demand.sum - demand.prev_sum)
                demand.csum     += demand.sum - demand.prev_sum
                demand.prev_sum := demand.sum
            //Test if supply accumulated volume exceed threshold and set box
            if supply.sum / csum * 100 > per and not supply.isreached
                avg = math.avg(max, supply.lvl)
                supply_wavg := supply.avg / supply.csum
                //Set Box/Level coordinates
                if showSupply
                    supply_area.set_area(x1, max, supply.lvl, avg, supply_wavg, supplyArea, supplyAvg, supplyWavg)
                supply.isreached := true
            //Test if demand accumulated volume exceed threshold and set box
            if demand.sum / csum * 100 > per and not demand.isreached and showDemand
                avg = math.avg(min, demand.lvl)
                demand_wavg := demand.avg / demand.csum
                //Set Box/Level coordinates
                if showDemand
                    demand_area.set_area(x1, demand.lvl, min, avg, demand_wavg, demandArea, demandAvg, demandWavg)
                demand.isreached := true
            if supply.isreached and demand.isreached
                break
        if supply.isreached and demand.isreached and showEqui
            //Set equilibrium
            if equiAvg
                avg = math.avg(max, min)
                equi.set_xy1(x1, avg)
                equi.set_xy2(n, avg)
            //Set weighted equilibrium
            if equiWavg
                wavg = math.avg(supply_wavg, demand_wavg)
                wequi.set_xy1(x1, wavg)
                wequi.set_xy2(n, wavg)
            break
        supply.prev := supply.lvl
        demand.prev := demand.lvl




//============================= SCALPING PULLBACK TOOL =================================================//
HiLoLen         = 34
fastEMAlength   = 12
mediumEMAlength = 200
slowEMAlength   = 600
ShowFastEMA     = input(true, title="Show FastEMA", group = "SCALPING PULLBACK TOOL")
ShowFractals    = input(true, title="Show Fractals", group = "SCALPING PULLBACK TOOL")
ShowBuySell     = input(true, title="Show Buy/Sell Alert Arrows", group = "SCALPING PULLBACK TOOL")
filterBW        = false
ShowBarColor    = true
Lookback        = 3
DelayArrow      = false
Delay           = DelayArrow ? 1 : 0
ShowTrendBGcolor= true
UseHAcandles    = true
haClose = UseHAcandles ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close) : close
haOpen  = UseHAcandles ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, open) : open
haHigh  = UseHAcandles ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, high) : high
haLow   = UseHAcandles ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, low) : low
isRegularFractal(mode) =>
    ret = mode == 1 ? high[4] < high[3] and high[3] < high[2] and high[2] > high[1] and 
       high[1] > high[0] : mode == -1 ? 
       low[4] > low[3] and low[3] > low[2] and low[2] < low[1] and low[1] < low[0] : 
       false
    ret
isBWFractal(mode) =>
    ret = mode == 1 ? high[4] < high[2] and high[3] <= high[2] and high[2] >= high[1] and 
       high[2] > high[0] : mode == -1 ? 
       low[4] > low[2] and low[3] >= low[2] and low[2] <= low[1] and low[2] < low[0] : 
       false
    ret
fastEMA     = ta.ema(haClose, fastEMAlength)
mediumEMA   = ta.ema(haClose, mediumEMAlength)
slowEMA     = ta.ema(haClose, slowEMAlength)
pacC        = ta.ema(haClose, HiLoLen)
pacL        = ta.ema(haLow, HiLoLen)
pacU        = ta.ema(haHigh, HiLoLen)
TrendDirection = fastEMA > mediumEMA and pacL > mediumEMA ? 1 : fastEMA < mediumEMA and pacU < mediumEMA ? -1 : 0
filteredtopf = filterBW ? isRegularFractal(1) : isBWFractal(1)
filteredbotf = filterBW ? isRegularFractal(-1) : isBWFractal(-1)
valuewhen_H0 = ta.valuewhen(filteredtopf == true, high[2], 0)
valuewhen_H1 = ta.valuewhen(filteredtopf == true, high[2], 1)
valuewhen_H2 = ta.valuewhen(filteredtopf == true, high[2], 2)
higherhigh = filteredtopf == false ? false : 
   valuewhen_H1 < valuewhen_H0 and valuewhen_H2 < valuewhen_H0
lowerhigh = filteredtopf == false ? false : 
   valuewhen_H1 > valuewhen_H0 and valuewhen_H2 > valuewhen_H0
valuewhen_L0 = ta.valuewhen(filteredbotf == true, low[2], 0)
valuewhen_L1 = ta.valuewhen(filteredbotf == true, low[2], 1)
valuewhen_L2 = ta.valuewhen(filteredbotf == true, low[2], 2)
higherlow = filteredbotf == false ? false : 
   valuewhen_L1 < valuewhen_L0 and valuewhen_L2 < valuewhen_L0
lowerlow = filteredbotf == false ? false : 
   valuewhen_L1 > valuewhen_L0 and valuewhen_L2 > valuewhen_L0
TradeDirection = 0
TradeDirection := nz(TradeDirection[1])
pacExitU = haOpen < pacU and haClose > pacU and ta.barssince(haClose<pacC)<=Lookback
pacExitL = haOpen > pacL and haClose < pacL and ta.barssince(haClose>pacC)<=Lookback
Buy = TrendDirection == 1 and pacExitU
Sell = TrendDirection == -1 and pacExitL
TradeDirection := TradeDirection == 1 and haClose<pacC ? 0 : 
   TradeDirection == -1 and haClose>pacC ? 0 : 
   TradeDirection == 0 and Buy ? 1 : 
   TradeDirection == 0 and Sell ? -1 : TradeDirection

// Show buy/sell arrows and Draw the EMA ribbon and fractals
plot(ShowFastEMA ? fastEMA : na, color=color.yellow, linewidth=1, transp=20, title="fastEMA")
plotshape(ShowFractals ? filteredtopf : na, title='Filtered Top Fractals', style=shape.triangledown, location=location.abovebar, color=color.red, offset=-2)
plotshape(ShowFractals ? filteredbotf : na, title='Filtered Bottom Fractals', style=shape.triangleup, location=location.belowbar, color=color.lime, offset=-2)
plotarrow(ShowBuySell and nz(TradeDirection[1+Delay]) == 0 and TradeDirection[Delay] != 0 ? TradeDirection[Delay] : na, offset=-Delay, colorup=color.green, colordown=color.red, transp=20, minheight=20, maxheight=50, title="Buy/Sell Arrow")








//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{

clGR  = 'Liquidation Price Calculator'

lmTT  = 'Presents liquidations on the price chart by measuring the highest leverage value of longs and shorts that have been potentially liquidated on the last chart bar.\n\n' +
         'Liquidations meter allows traders to\n -gauge the momentum of the bar,\n -identify the strength of the bulls and bears, and\n -identify probable reversal/exhaustion points\n\n' +
         'Here with liquidations, we refer to the process of forcibly closing a trader\'s position in the market'
lmSH  = input.bool(true, 'Liquidations Meter', group = 'Liquidations Meter', tooltip = lmTT)
refPS = input.string("open", "Base Price", options = ["open", "close", "oc2", "hl2", "ooc3", "occ3", "hlc3", "ohlc4", "hlcc4"], group = 'Liquidations Meter')

clTT  = 'The liquidation price calculator is useful for leverage trading traders who want to know how much risk they can take for each trade.\n\n' +
         'This tool uses a formula to calculate the liquidation price based on the entry price + leverage ratio.\n\n' +
         'Other factors such as leveraged fees, position size, and other interest payments have been excluded since they are variables that don’t directly affect the level of liquidation of a leveraged position.\n\n' +
         'This calculator also assumes that traders are using an isolated margin for one single position and does not take into consideration the additional margin they might have in their account.'
clSH  = input.bool(true, 'Liquidation Price Calculator', group = clGR, tooltip = clTT)
epTT  = 'Defines the entry price.\nIf the entry price is set to 0, then the selected \'Base Price\' value is assumed as entry price\n\n' +
         'Tip: Before entering a trade, setting base price to \'close\' and entry price to remain at 0 will allow the traders to easily evaluate the risk and reward situation of any given setup'
clEP  = input.float(0., 'Entry Price', group = clGR, tooltip = epTT)
lrTT  = 'Leverage allows traders to borrow funds in order to enter a position larger than their own funds permit\n\n' +
         'the higher the leverage ratio the higher the risk.\n\nIt is important to be aware that when the leverage ratio is increased, the liquidation price moves closer to the entry price, meaning a higher risk trader\'s position will have'
clLR  = input.float(10., 'Leverage', minval = 0, group = clGR, tooltip = lrTT)

lpSH  = input.bool(true, 'Show Calculated Liquidation Prices on the Chart', group = clGR)

dbTT  = 'The bar statistics option enables measuring and presenting trading activity, volatility, and probable liquidations for the last chart bar'
dbSH  = input.bool(true, 'Show Bar Statistics', group = 'Dashboard', tooltip = dbTT)

lcLS  = input.string('Small', 'Liquidations Meter Text Size', options = ['Tiny', 'Small', 'Normal'], group = 'Others')
lcOF  = input.int(3, 'Liquidations Meter Offset', minval = 0, group = 'Others')
clPS  = input.string('Bottom', 'Dashboard/Calculator Placement', options=['Top', 'Middle', 'Bottom'], group = 'Others') 
lcDS  = input.string('Small', 'Dashboard/Calculator Text Size', options = ['Tiny', 'Small', 'Normal'], group = 'Others')

//-----------------------------------------------------------------------------}
// User Defined Types
//-----------------------------------------------------------------------------{

// @type        bar properties with their values 
//
// @field o     (float) open price of the bar
// @field h     (float) high price of the bar
// @field l     (float) low price of the bar
// @field i     (int)   index of the bar

type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int   i = bar_index

//-----------------------------------------------------------------------------}
// Variables 
//-----------------------------------------------------------------------------{

bar b = bar.new()

var label lbL = na, label.delete(lbL[1])
var label lbS = na, label.delete(lbS[1])
var line lnL = na, line.delete(lnL[1])
var line lnS = na, line.delete(lnS[1])

var aLQ = array.new_box()
var aCL = array.new_box()

vST = ''

//-----------------------------------------------------------------------------}
// Functions/methods
//-----------------------------------------------------------------------------{

// @function        converts simple text to formated text  
//                     
// @param  _s       [string] simple string 
//
// @returns         enumarated text size value 

f_gSZ(_s) =>
    switch _s
        'Tiny'  => size.tiny 
        'Small' => size.small 
        => size.normal

// @function        compares the source value with the reference value  
//                     
// @param  _s       [float] source 
// @param  _r       [float] reference  
// @param  _m       [float] multiplier 
//
// @returns         [string] result of the comparison 

f_gST(_s, _r, _m) =>
    if _s
        isS = _s >= 4.669 * _r * _m
        isH = _s >= 1.618 * _r * _m
        isL = _s <= 0.618 * _r * _m

        isS ? 'Very High' : isH ? 'High' : isL ? 'Low' : 'Average'

// @function        converts simple text to source  
//                     
// @param  _s       [string] simple string
//
// @returns         [float] source series 

f_gSRC(_s) =>
    switch _s
        "open"  => open
        "close" => close
        "oc2"   => math.avg(open, close)
        "hl2"   => hl2
        "ooc3"  => math.avg(open, open , close)
        "occ3"  => math.avg(open, close, close)
        "hlc3"  => hlc3
        "ohlc4" => ohlc4
        "hlcc4" => hlcc4

//-----------------------------------------------------------------------------}
// Calculations
//-----------------------------------------------------------------------------{
nzV  = nz(b.v)

vDB  = f_gST(nzV, ta.sma(nzV, 13), 1.1)
vST += '\n\nLast Bar Statistics:\n Trading activity : ' + vDB

aDB  = f_gST(b.h - b.l, ta.atr(13), 0.9)
vST += '\n Volatility : ' + aDB

LQ   = nzV / (b.o / (b.o - b.l)) + nzV / (math.avg(b.o, b.c) / (b.h - math.avg(b.o, b.c)))
lDB  = f_gST(LQ, ta.sma(LQ, 89), 1.9)
vST += '\n Liquidations : ' + lDB

lSZ  = f_gSZ(lcLS)
refP = f_gSRC(refPS)

if lmSH and barstate.islast

    if aLQ.size() > 0
        for i = 1 to aLQ.size()
            box.delete(aLQ.shift())
    
    off = lpSH ? 7 : 0
    
    if (refP - b.l) > 0
        aLQ.push(box.new(b.i + lcOF + off, refP, b.i + lcOF + off + 2, refP * (1 - 1. / 100), border_color = color(na), bgcolor = color.new(color.teal, 89), text = '100x', text_color = chart.fg_color, text_valign = text.align_bottom))
    if (b.h - refP) > 0
        aLQ.push(box.new(b.i + lcOF + off, refP, b.i + lcOF + off + 2, refP * (1 + 1. / 100), border_color = color(na), bgcolor = color.new(color.red,  89), text = '100x', text_color = chart.fg_color, text_valign = text.align_top))

    lev   = array.from(100, 50, 25, 10,  5,  3,  2, 1)
    trans = array.from( 89, 76, 63, 50, 37, 24, 11, 1)

    for i = 1 to 7
        if (refP - b.l) > 0 and refP / (refP - b.l) < lev.get(i - 1)
            aLQ.push(box.new(b.i + lcOF + off, refP * (1 - 1. / lev.get(i - 1)), b.i + lcOF + off + 2, refP * (1 - 1. / lev.get(i)), border_color = color(na), 
             bgcolor = color.new(color.teal, trans.get(i)), text = str.tostring(lev.get(i)) + 'x', text_color = chart.fg_color, text_valign = text.align_bottom))
    
        if (b.h - refP) > 0 and refP / (b.h - refP) < lev.get(i - 1)
            aLQ.push(box.new(b.i + lcOF + off, refP * (1 + 1. / lev.get(i - 1)), b.i + lcOF + off + 2, refP * (1 + 1. / lev.get(i)), border_color = color(na), 
             bgcolor = color.new(color.red, trans.get(i)), text = str.tostring(lev.get(i)) + 'x', text_color = chart.fg_color, text_valign = text.align_top))

    if refP / (refP - b.l) <= 100 and (refP - b.l) > 0
        lbL :=  label.new(b.i + lcOF + off + 1, b.l, '◄ ' + str.tostring(refP / (refP - b.l), '#.#') + 'x Longs Liquidated' ,
                     color = color(na), textcolor = chart.fg_color, size = lSZ, style = label.style_label_left, 
                     tooltip = 'The highest leverage of\n probable liquidated longs : ' + str.tostring(refP / (refP - b.l), '#.##') + 'x\nEstimantion based on\n reference price : '  + str.tostring(refP, format.mintick) + vST)
        lnL := line.new(b.i + lcOF + off, b.l, b.i + lcOF + off + 2, b.l, color = chart.fg_color, style = line.style_dotted)

    if refP / (b.h - refP) <= 100 and (b.h - refP) > 0
        lbS := label.new(b.i + lcOF + off + 1, b.h, '◄ ' + str.tostring(refP / (b.h - refP), '#.#') + 'x Shorts Liquidated', 
                     color = color(na), textcolor = chart.fg_color, size = lSZ, style = label.style_label_left, 
                     tooltip = 'The highest leverage of\n probable liquidated shorts : ' + str.tostring(refP / (b.h - refP), '#.##') + 'x\nEstimantion based on\n reference price : ' + str.tostring(refP, format.mintick) + vST)
        lnS := line.new(b.i + lcOF + off, b.h, b.i + lcOF + off + 2, b.h, color = chart.fg_color, style = line.style_dotted)

tPOS = switch clPS
    'Top'     => position.top_right
    'Middle'  => position.middle_right
    'Bottom'  => position.bottom_right

tSZ = f_gSZ(lcDS)

refP := clEP == 0 ? refP : clEP

var table calc = table.new(tPOS, 3, 18, bgcolor = #1e222d, border_color = #515359, border_width = 1, frame_color = #373a46, frame_width = 1)

if barstate.islast 
    if dbSH    
        table.cell(calc, 0, 0, "BAR STATISTICS\n", text_color = color.white, text_size = tSZ, bgcolor = #2962FF)
        table.merge_cells(calc, 0, 0, 2, 0)

        table.cell(calc, 0, 2, "Volatility", text_color = color.white, text_size = tSZ, text_halign = text.align_left)
        table.merge_cells(calc, 0, 2, 1, 2)
        table.cell(calc, 2, 2, aDB, text_color = color.white, text_size = tSZ)

        if nzV > 0
            table.cell(calc, 0, 1, "Activity", text_color = color.white, text_size = tSZ, text_halign = text.align_left)
            table.merge_cells(calc, 0, 1, 1, 1)
            table.cell(calc, 2, 1, vDB, text_color = color.white, text_size = tSZ)

            table.cell(calc, 0, 3, "Liquidations", text_color = color.white, text_size = tSZ, text_halign = text.align_left)
            table.merge_cells(calc, 0, 3, 1, 3)
            table.cell(calc, 2, 3, lDB + ' !', text_color = color.white, text_size = tSZ, 
             tooltip = 'The highest leverage of\n probable liquidated shorts : ' + (refP / (b.h - refP) > 100 ? '>100' : str.tostring(refP / (b.h - refP), '#.##')) + 
                   'x\n probable liquidated longs  : ' + (refP / (refP - b.l) > 100 ? '>100' : str.tostring(refP / (refP - b.l), '#.##')) + 
                   'x\n\nEstimantion based on\n reference price : '  + str.tostring(refP, format.mintick))

    if clSH
        table.cell(calc, 0, 4, "CALCULATOR\n", text_color = color.white, text_size = tSZ, bgcolor = #2962FF)
        table.merge_cells(calc, 0, 4, 2, 4)

        table.cell(calc, 0, 5, "Entry Price ", text_color = color.white, text_size = tSZ)
        table.merge_cells(calc, 0, 5, 1, 5)
        table.cell(calc, 2, 5, "Leverage", text_color = color.white, text_size = tSZ)

        table.cell(calc, 0, 6, str.tostring(refP, format.mintick), text_color = color.white, text_size = tSZ)
        table.merge_cells(calc, 0, 6, 1, 6)
        table.cell(calc, 2, 6, str.tostring(clLR), text_color = color.white, text_size = tSZ)

        tip = 'Liquidation price is the distance from trader\'s entry price to the price where trader\'s leveraged position gets liquidated due to a loss.\n\n' +
              'If a trader wants to enter a $1.000 trade with ' + str.tostring(clLR) + 'x leverage, then $' + str.tostring(1000/clLR, '#.##') + 
              ' is the initial margin (the amount of money coming from the traders pocket) and the remaining $' + str.tostring(1000 - 1000/clLR, '#.##') + ' are borrowed funds\n\n' +
              'When a trader\'s account falls below the required margin level, exchanges or brokerage platforms cannot allow a trader to lose borrowed funds and therefore the trader\'s positions will be forcibly closed as soon as position losses reach the initial margin.\n\n' +
              'The liquidation prices presented below are approximate values of both long and short liquidation prices. It is important to note that the exchanges will taken into consideration the trader\'s open positions when calculating the liquidation price. Unrealized PNL and maintenance margin of the trader\'s open position will affect the calculation of liquidation price'

        table.cell(calc, 0, 14, 'Liquidation Prices !', text_color = color.white, text_size = tSZ, tooltip = tip)
        table.merge_cells(calc, 0, 14, 2, 14)
        
        table.cell(calc, 0, 15, "█", text_color = color.teal, text_size = tSZ)
        table.cell(calc, 1, 15, "Longs", text_color = color.white, text_size = tSZ, text_halign = text.align_left)
        table.cell(calc, 2, 15, '≅ ' + str.tostring(refP * (1 - 1. / clLR), format.mintick) + ' (↓%' + str.tostring(100. / clLR, '#.##') + ')', 
         text_color = color.white, text_size = tSZ)
        
        table.cell(calc, 0, 16, "█", text_color = color.red, text_size = tSZ)
        table.cell(calc, 1, 16, "Shorts", text_color = color.white, text_size = tSZ, text_halign = text.align_left)
        table.cell(calc, 2, 16, '≅ ' + str.tostring(refP * (1 + 1. / clLR), format.mintick) + ' (↑%' + str.tostring(100. / clLR, '#.##') + ')', 
         text_color = color.white, text_size = tSZ)

    if lpSH
        if aCL.size() > 0
            for i = 1 to aCL.size()
                box.delete(aCL.shift())

        lLP = refP * (1 - 1. / clLR)
        sLP = refP * (1 + 1. / clLR)

        aCL.push(box.new(b.i, lLP, b.i + lcOF + 6, lLP, border_color = color.teal,
             text = 'Long Liquidation Price Level\n'  + (b.l < lLP ? 'trade liquidated' : '%' + str.tostring((math.abs(lLP / b.c - 1) * 100), '#.##') + ' (' + str.tostring(b.c - lLP, format.mintick) + ') to liquidation'), 
             text_size = size.small, text_halign = text.align_right, text_valign = text.align_top, text_color = color.teal))

        aCL.push(box.new(b.i + 2, refP, b.i + lcOF + 4, refP, border_color = color.gray))
    
        aCL.push(box.new(b.i, sLP, b.i + lcOF + 6, sLP, border_color = color.red,
             text = 'Short Liquidation Price Level\n' + (b.h > sLP ? 'trade liquidated' : '%' + str.tostring((math.abs(sLP / b.c - 1) * 100), '#.##') + ' (' + str.tostring(sLP - b.c, format.mintick) + ') to liquidation'), 
             text_size = size.small, text_halign = text.align_right, text_valign = text.align_bottom, text_color = color.red))

//-----------------------------------------------------------------------------}

// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)