// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join us https://t.me/simpleforextools

//@version=5

strategy('HARMONIC V5', overlay=true)
groupUXCOLORS = "======= UX COLOR  ======="
plot(na)

var string ThemeUX = input.string("Cool", "UX THEME", options=["Classic", "Cool"], inline="UX THEME", group=groupUXCOLORS, tooltip="UX THEME / Colors Style")

var color psar_longColor = na
var color psar_longLight = na
var color psar_shortColor = na
var color psar_shortLight = na

// Filter Colors
if ThemeUX == "Classic"
    psar_longColor :=  color.rgb(9, 116, 23,0)
    psar_longLight := color.rgb(9, 116, 23,65)
    psar_shortColor :=  color.rgb(151, 14, 14,0)
    psar_shortLight := color.rgb(151, 14, 14,65)

else if ThemeUX == "Cool"
    psar_longColor := #00DBFF 
    psar_longLight := color.new(#00DBFF , 80)
    psar_shortColor := color.new(#E91E63, 0)
    psar_shortLight := color.new(#E91E63, 80)


color greencolor = psar_longLight
color redcolor = psar_shortLight

// Cambia el color de la vela según si es alcista o bajista
esAlcista = close > open //// Module  by @comgunner

barcolor(esAlcista ? psar_longColor : psar_shortColor)
//////////////////////////////////////////////////////////////////////////////////////////




////
//Main Algo Settings
colors = input.string(title='Color Scheme', defval='DARK', options=['DARK', 'LIGHT'] , group = "Color Scheme")
bullcolor = colors == 'DARK' ? #00DBFF : color.rgb(0, 255, 8) 
bearcolor = colors == 'DARK' ? #E91E63 : color.rgb(255, 0, 0)

Show_Signals   = input.bool(true, title="Show Signal", tooltip="Show Long & Short Signals" , group = "Signal's Settings")
var int length = input(title='Period', defval=1 , group = "Signal's Settings")
var float mult = input.float(title='TBSensitivity', step=0.1, defval=10 , group = "Signal's Settings")
var float SFilter = input.float(title='Signal Filter', step=0.1, defval=1.0 , group = "Signal's Settings")

//////////////////////////////////////////////////////////////////////////////////////////
// Trend Features
LongTrendAverage  = input(true, 'Trend Cloud', group='TREND FEATURES')

var tclength = input(600, title="HULLMA length",group = 'TREND FEATURES', tooltip="Adjust as needed / Ajustar según sea necesario") 
//tclength = 600
hullma = ta.wma(2*ta.wma(close, tclength/2)-ta.wma(close, tclength), math.floor(math.sqrt(tclength)))
plot(LongTrendAverage ? hullma : na, 'Trend Cloud', linewidth=4, color=close[8] > hullma ? color.new(bullcolor, 65) : color.new(bearcolor, 65))






/////
t_type = input.string("Scalping","Strategy",options = ["Default","Scalping","Intraday","Swing"] , group = "Signal's Settings")

if t_type == "Default"
    
    length := length
    mult := mult
    SFilter := SFilter

if t_type == "Scalping"
    length := 10
    mult := 10
    SFilter := 0.5

if t_type == "Intraday"
    length := 2
    mult := 15
    SFilter := 0.5

if t_type == "Swing"
    length := 10
    mult := 5
    SFilter := 1.2



//////////////////////////////////////////////////////////////////////////////////////////
// Color Scheme

//Trend Cloud / Theme
ma2On = input.bool(true, title="Vortex Cloud", group = "Cloud")
TBSENSIII = input.int(2, title="Vortex Cloud Sensitivity",group = "Cloud")



plotRibsw = input(title='Show Trend Ribbon', defval=false , inline = "RIBBON" , group = "Chart Features")
xfixtf = input(title='MTF', defval=false , inline = "RIBBON", group = "Chart Features")
labelSwitch = input(title='Table', defval=false, inline = "RIBBON", group = "Chart Features")
plotRibbonPos = input.string(title='Ribbon Position', options=['Top', 'Bottom'], defval='Bottom', group = "Chart Features")
xtf = input.timeframe(title='Select MTF Ribbon', defval='D', group = "Chart Features")



//SMC
color CLEAR = color.rgb(0,0,0,100)
showSMC = input.bool(true, 'Show Smart Money Concepts', tooltip='Show Market Structure', group='Market Structure')
showSwing = input.bool(false, 'Show Swing Points', tooltip='Show or hide HH, LH, HL, LL' , group="Market Structure")
swingSize = input.int(10, 'Swing Length', tooltip='The number of left and right bars checked when searching for a swing point. Higher value = less swing points plotted and lower value = more swing points plotted.' , group="Market Structure")
bosConfType = input.string('Candle Close', 'BOS/CHoCH Confirmation', ['Candle Close', 'Wicks'], tooltip='Choose whether candle close/wick above previous swing point counts as a BOS/CHoCH.' , group="Market Structure")
choch = true
bosStyle = input.string('Solid', 'Line Style', ['Solid', 'Dashed', 'Dotted'], group="Market Structure")
bosWidth = input.int(1, 'Width', minval=1, group="Market Structure")


Show_PR   = input.bool(true, title="Show Top/Bottom", tooltip="Show's Top/Bottem - 'Don't Buy' = Green/Blue Cross | 'Don't Sell' = Red/Pink Cross " , group = "Top / Bottom")
TBSensi   = input.int(5, title="Top/Bottom Sensitivity", tooltip="The Greater The Value The Stronger The Top/Bottom" , group = "Top / Bottom")


//////////////////////////////////////////////////////////////////////////////////////////




//colorSup   = input(#00DBFF, "Support Color", group="SR")
//colorRes   = input(#E91E63, "Resistance Color", group="SR")
//algo
atr = mult * ta.atr(length)
longStop = hl2 - atr * SFilter
longStopPrev = nz(longStop[1], longStop)
longStop := close[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop

shortStop = hl2 + atr * SFilter
shortStopPrev = nz(shortStop[1], shortStop)
shortStop := close[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop

dir = 1
dir := nz(dir[1], dir)
dir := dir == -1 and close > shortStopPrev ? 1 : dir == 1 and close < longStopPrev ? -1 : dir


longColor = color.blue
shortColor = color.blue


////////////////////////////////////////////////////////////    
// Conditions 1

longCond = bool(na)
shortCond = bool(na)
longCond := ta.crossover(close[1], shortStopPrev)
shortCond := ta.crossunder(close[1], longStopPrev)

// Conditions 2

longCond2 = bool(na)
shortCond2 = bool(na)
longCond2 := ta.crossover(close[1], shortStopPrev)
shortCond2 := ta.crossunder(close[1], longStopPrev)

// Conditions 3

longCond3 = bool(na)
shortCond3 = bool(na)
longCond3 := ta.crossover(close[1], shortStopPrev)
shortCond3 := ta.crossunder(close[1], longStopPrev)

////////////////////////////////////////////////////////////    
// Count your long short conditions for more control with Pyramiding

sectionLongs = 0
sectionLongs := nz(sectionLongs[1])
sectionShorts = 0
sectionShorts := nz(sectionShorts[1])

if longCond
    sectionLongs += 1
    sectionShorts := 0
    sectionShorts

if shortCond
    sectionLongs := 0
    sectionShorts += 1
    sectionShorts

// Count your long short conditions for more control with Pyramiding 2

sectionLongs2 = 0
sectionLongs2 := nz(sectionLongs2[1])
sectionShorts2 = 0
sectionShorts2 := nz(sectionShorts2[1])

if longCond2
    sectionLongs2 += 1
    sectionShorts2 := 0
    sectionShorts2

if shortCond2
    sectionLongs2 := 0
    sectionShorts2 += 1
    sectionShorts2


// Count your long short conditions for more control with Pyramiding 3

sectionLongs3 = 0
sectionLongs3 := nz(sectionLongs3[1])
sectionShorts3 = 0
sectionShorts3 := nz(sectionShorts3[1])

if longCond3
    sectionLongs3 += 1
    sectionShorts3 := 0
    sectionShorts3

if shortCond3 
    sectionLongs3 := 0
    sectionShorts3 += 1
    sectionShorts3

////////////////////////////////////////////////////////////    
// Pyramiding

pyrl = 1


// Pyramiding 2

pyr2 = 1

// Pyramiding 3

pyr3 = 1
////////////////////////////////////////////////////////////    

// These check to see your signal and cross references it against the pyramiding settings above


longCondition = longCond and sectionLongs <= pyrl 

shortCondition = shortCond and sectionShorts <= pyrl 

// These check to see your signal and cross references it against the pyramiding settings above 2


longCondition2 = longCond2 and sectionLongs2 <= pyr2 

shortCondition2 = shortCond2 and sectionShorts2 <= pyr2 

// These check to see your signal and cross references it against the pyramiding settings above 3


longCondition3 = longCond3 and sectionLongs3 <= pyr3 

shortCondition3 = shortCond3 and sectionShorts3 <= pyr3 

////////////////////////////////////////////////////////////    
// Get the price of the last opened long or short

last_open_longCondition = float(na)
last_open_shortCondition = float(na)
last_open_longCondition := longCondition ? open : nz(last_open_longCondition[1])
last_open_shortCondition := shortCondition ? open : nz(last_open_shortCondition[1])

// Get the price of the last opened long or short 2

last_open_longCondition2 = float(na)
last_open_shortCondition2 = float(na)
last_open_longCondition2 := longCondition2 ? open : nz(last_open_longCondition2[1])
last_open_shortCondition2 := shortCondition2 ? open : nz(last_open_shortCondition2[1])

// Get the price of the last opened long or short 3

last_open_longCondition3 = float(na)
last_open_shortCondition3 = float(na)
last_open_longCondition3 := longCondition3 ? open : nz(last_open_longCondition3[1])
last_open_shortCondition3 := shortCondition3 ? open : nz(last_open_shortCondition3[1])


////////////////////////////////////////////////////////////    
// Check if your last postion was a long or a short

last_longCondition = float(na)
last_shortCondition = float(na)
last_longCondition := longCondition ? time : nz(last_longCondition[1])
last_shortCondition := shortCondition ? time : nz(last_shortCondition[1])

in_longCondition = last_longCondition > last_shortCondition
in_shortCondition = last_shortCondition > last_longCondition

// Check if your last postion was a long or a short 2

last_longCondition2 = float(na)
last_shortCondition2 = float(na)
last_longCondition2 := longCondition2 ? time : nz(last_longCondition2[1])
last_shortCondition2 := shortCondition2 ? time : nz(last_shortCondition2[1])

in_longCondition2 = last_longCondition2 > last_shortCondition2
in_shortCondition2 = last_shortCondition2 > last_longCondition2

// Check if your last postion was a long or a short 3

last_longCondition3 = float(na)
last_shortCondition3 = float(na)
last_longCondition3 := longCondition3 ? time : nz(last_longCondition3[1])
last_shortCondition3 := shortCondition3 ? time : nz(last_shortCondition3[1])

in_longCondition3 = last_longCondition3 > last_shortCondition3
in_shortCondition3 = last_shortCondition3 > last_longCondition3


// Strategy Settings




// Define strategy entry and exit logic
strategy.entry("Long", strategy.long, when=longCondition and sectionLongs <= pyrl)
strategy.close("Long", when=shortCondition and sectionShorts <= pyrl)

strategy.entry("Long2", strategy.long, when=longCondition2 and sectionLongs2 <= pyr2)
strategy.close("Long2", when=shortCondition2 and sectionShorts2 <= pyr2)

strategy.entry("Long3", strategy.long, when=longCondition3 and sectionLongs3 <= pyr3)
strategy.close("Long3", when=shortCondition3 and sectionShorts3 <= pyr3)

// Short Strategies
strategy.entry("Short", strategy.short, when=shortCondition and sectionShorts <= pyrl)
strategy.close("Short", when=longCondition and sectionLongs <= pyrl)

strategy.entry("Short2", strategy.short, when=shortCondition2 and sectionShorts2 <= pyr2)
strategy.close("Short2", when=longCondition2 and sectionLongs2 <= pyr2)

strategy.entry("Short3", strategy.short, when=shortCondition3 and sectionShorts3 <= pyr3)
strategy.close("Short3", when=longCondition3 and sectionLongs3 <= pyr3)

//kumo plots
//plot(conversionLine, color=#0496ff, title="Conversion Line")
//plot(baseLine, color=#991515, title="Base Line")
//plot(close, offset = -displacement, color=#459915, title="Lagging Span")
//K1 = plot(leadLine1, offset=displacement, color=color.new(color.green, 0), title='Lead 1')
//K2 = plot(leadLine2, offset=displacement, color=color.new(color.red, 0), title='Lead 2')
//fill(K1, K2, leadLine1 > leadLine2 ? color.green : color.red, transp=90)

/////////////////////////////////////////////////////////////////////////////////////////
//SMC v2
/////////////////////////////////////////////////////////////////////////////////////////

// Functions
lineStyle(x) =>
    switch x
        'Solid' => line.style_solid
        'Dashed' => line.style_dashed
        'Dotted' => line.style_dotted


// Calculations

//Finding high and low pivots
pivHi = ta.pivothigh(high, swingSize, swingSize)
pivLo = ta.pivotlow(low, swingSize, swingSize)


//Tracking the previous swing levels to determine hh lh hl ll
var float prevHigh = na
var float prevLow = na
var int prevHighIndex = na
var int prevLowIndex = na

//Tracking whether previous levels have been breached
var bool highActive = false
var bool lowActive = false

bool hh = false
bool lh = false
bool hl = false
bool ll = false

//Variable to track the previous swing type, used later on to draw 0.5 Retracement Levels (HH = 2, LH = 1, HL = -1, LL = -2)
var int prevSwing = 0

if not na(pivHi)
    if pivHi >= prevHigh
        hh := true
        prevSwing := 2
    else
        lh := true
        prevSwing := 1
    prevHigh := pivHi
    highActive := true
    prevHighIndex := bar_index - swingSize

if not na(pivLo)
    if pivLo >= prevLow
        hl := true
        prevSwing := -1
    else
        ll := true
        prevSwing := -2
    prevLow := pivLo
    lowActive := true
    prevLowIndex := bar_index - swingSize

//Generating the breakout signals
bool highBroken = false
bool lowBroken = false

//Tracking prev breakout
var int prevBreakoutDir = 0

float highSrc = bosConfType == 'Candle Close' ? close : high
float lowSrc = bosConfType == 'Candle Close' ? close : low

if highSrc > prevHigh and highActive
    highBroken := true
    highActive := false
if lowSrc < prevLow and lowActive
    lowBroken := true
    lowActive := false


// Visual Output

//Swing level labels
if hh and showSwing
    label.new(bar_index - swingSize, pivHi, 'HH', color=CLEAR, style=label.style_label_down, textcolor=chart.fg_color)
if lh and showSwing
    label.new(bar_index - swingSize, pivHi, 'LH', color=CLEAR, style=label.style_label_down, textcolor=chart.fg_color)
if hl and showSwing
    label.new(bar_index - swingSize, pivLo, 'HL', color=CLEAR, style=label.style_label_up, textcolor=chart.fg_color)
if ll and showSwing
    label.new(bar_index - swingSize, pivLo, 'LL', color=CLEAR, style=label.style_label_up, textcolor=chart.fg_color)
 

//Generating the BOS/CHoCH Lines
if highBroken and showSMC
    line.new(prevHighIndex, prevHigh, bar_index, prevHigh, color= bullcolor, style=lineStyle(bosStyle), width=bosWidth)
    label.new(math.floor(bar_index - (bar_index - prevHighIndex) / 2), prevHigh, prevBreakoutDir == -1 and choch ? 'CHoCH' : 'BOS', color=CLEAR, textcolor=bullcolor, size=size.tiny)
    prevBreakoutDir := 1

if lowBroken and showSMC
    line.new(prevLowIndex, prevLow, bar_index, prevLow, color=bearcolor, style=lineStyle(bosStyle), width=bosWidth)
    label.new(math.floor(bar_index - (bar_index - prevLowIndex) / 2), prevLow, prevBreakoutDir == 1 and choch ? 'CHoCH' : 'BOS', color=CLEAR, textcolor=bearcolor, style=label.style_label_up, size=size.tiny)
    prevBreakoutDir := -1

////////////////////////////////////////////////////////////////////////////////////////////
//Trend Cloud
///////////////////////////////////////////////////////////////////////////////////////////
length2 = 10*(TBSENSIII / 2)
source2 = close
aboveColor2 = color.rgb(70, 219, 255, 100)
belowColor2 = color.rgb(233, 30, 99, 100)

ma3On = true
length3 = 40*(TBSENSIII / 2)
source3 = close
aboveColor3 = color.rgb(70, 219, 255, 100)
belowColor3 = color.rgb(233, 30, 99, 100)

//Combined Moving Averages Calculations

sma2 = ta.sma(source2, length2)
ema2 = ta.ema(source2, length2)
wma2 = ta.wma(source2, length2)
vwma2 = ta.vwma(source2, length2)
hma2 = ta.hma(source2, length2)
rma2 = ta.rma(source2, length2)

ma2 = (sma2 + ema2 + wma2 + vwma2 + hma2 + rma2) / 6

sma3 = ta.sma(source3, length3)
ema3 = ta.ema(source3, length3)
wma3 = ta.wma(source3, length3)
vwma3 = ta.vwma(source3, length3)
hma3 = ta.hma(source3, length3)
rma3 = ta.rma(source3, length3)

ma3 = (sma3 + ema3 + wma3 + vwma3 + hma3 + rma3) / 6

//Volume Spike Signals
volumeMedian = ta.median(volume, 10)
volumeBuy  = false
highVolumeBuy = false

if volume > volumeMedian and volume < volumeMedian*2
    volumeBuy := true
if volume > volumeMedian*2
    highVolumeBuy := true

//Line & Cloud Colors
redCloud = false
greenCloud = false

if ma2 > ma3
    greenCloud := true
else
    redCloud := true

ma50 = plot(ma2On ? ma2 : na, title="Moving Average #2", color=greenCloud ? aboveColor2 : belowColor2, style=plot.style_line, linewidth=1 , editable = false)
ma100 = plot(ma3On ? ma3 : na, title="Moving Average #3", color=greenCloud ? aboveColor3 : belowColor3, style=plot.style_line, linewidth=1 , editable = false)

fill(ma50, ma100, color=greenCloud and highVolumeBuy ? color.new(bullcolor , 10) : greenCloud and volumeBuy ? color.new(bullcolor , 50) : greenCloud ? color.new(bullcolor , 80) : redCloud and highVolumeBuy ? color.new(bearcolor , 10) : redCloud and volumeBuy ? color.new(bearcolor , 50) : redCloud ? color.new(bearcolor , 80) : na)


/////////////////////////////////////////////////////////
//  Trap Detector
////////////////////////////////////////////////////////
// Functions
wavetrend(src, chlLen, avgLen) =>
    esa = ta.ema(src, chlLen)
    d = ta.ema(math.abs(src - esa), chlLen)
    ci = (src - esa) / (0.015 * d)
    wt1 = ta.ema(ci, avgLen)
    wt2 = ta.sma(wt1, 3)
    [wt1, wt2]
f_top_fractal(src) => src[4] < src[2] and src[3] < src[2] and src[2] > src[1] and src[2] > src[0]
f_bot_fractal(src) => src[4] > src[2] and src[3] > src[2] and src[2] < src[1] and src[2] < src[0]
f_fractalize (src) => f_top_fractal(src) ? 1 : f_bot_fractal(src) ? -1 : 0
f_findDivs(src, topLimit, botLimit) =>
    fractalTop = f_fractalize(src) > 0 and src[2] >= topLimit ? src[2] : na
    fractalBot = f_fractalize(src) < 0 and src[2] <= botLimit ? src[2] : na
    highPrev = ta.valuewhen(fractalTop, src[2], 0)[2]
    highPrice = ta.valuewhen(fractalTop, high[2], 0)[2]
    lowPrev = ta.valuewhen(fractalBot, src[2], 0)[2]
    lowPrice = ta.valuewhen(fractalBot, low[2], 0)[2]
    bearSignal = fractalTop and high[1] > highPrice and src[1] < highPrev
    bullSignal = fractalBot and low[1] < lowPrice and src[1] > lowPrev
    [bearSignal, bullSignal]

// Get components
[wt1, wt2] = wavetrend(close, 5*TBSensi, 10*TBSensi)
[wtDivBear1, wtDivBull1] = f_findDivs(wt2, 15, -40)
[wtDivBear2, wtDivBull2] = f_findDivs(wt2, 45, -65)
wtDivBull = wtDivBull1 or wtDivBull2
wtDivBear = wtDivBear1 or wtDivBear2

plotshape(ta.crossover(wt1, wt2) and Show_PR and wt2 <= -53, "Don't Sell/Bottom" , shape.xcross, location.belowbar, color(bullcolor), size=size.tiny)
plotshape(ta.crossunder(wt1, wt2) and Show_PR and wt2 >= 53, "Don't Buy/Top", shape.xcross, location.abovebar, color(bearcolor), size=size.tiny)



ShowTrailingSl   = input.bool(true, title="Show Trailing Stoploss", tooltip="Show Trailing Stoploss" , group = "Trailing Stoploss")
sl_type = input.string('%', title = "Trailing SL Type" ,options=['%', 'ATR', 'Absolute'], group = "Trailing Stoploss")
sl_perc = input.float(title='Trailing Sl - %', step=0.1, defval=0.4 , group = "Trailing Stoploss")
atr_length = input(14, title='Trailing Sl - Atr Length' , group = "Trailing Stoploss")
atr_mult = input.float(2, title='Trailing Sl - Atr Multiplier' , group = "Trailing Stoploss")
sl_absol = input.float(10, title='Trailing Sl - Absolute  ', group = "Trailing Stoploss" )


//////////////////
// CALCULATIONS //

// Strategy

// SL values
sl_val = sl_type == 'ATR' ? atr_mult * ta.atr(atr_length) : sl_type == 'Absolute' ? sl_absol : close * sl_perc / 100

// Init Variables
pos = 0
trailing_sl = 0.0 

// Trailing Signals Type
bull = dir == 1 and dir[1] == -1 and Show_Signals ? longStop : na
bear = dir == -1 and dir[1] == 1 and Show_Signals ? shortStop : na

long_signal = bull  and ShowTrailingSl 
short_signal = bear and ShowTrailingSl 


sma4        = ta.sma(close, 8)
sma5        = ta.sma(close, 9)
y1 = low - (ta.atr(30) * 2.5)
y2 = high + (ta.atr(30) * 2.5)

buylabel  = long_signal ? label.new(bar_index, y1, sma4 >= sma5 ? "Strong Buy 🚀" : "Buy 🚀", xloc.bar_index, yloc.price, bullcolor, label.style_label_up,  color.rgb(255, 255, 255), size.normal) : na
selllabel = short_signal ? label.new(bar_index, y2, sma4 <= sma5 ? "Strong Sell 🐻️" : "Sell 🐻️", xloc.bar_index, yloc.price,   bearcolor, label.style_label_down, color.rgb(255, 255, 255), size.normal) : na




// Calculate SL
trailing_sl := short_signal ? high + sl_val : long_signal ? low - sl_val : nz(pos[1]) == 1 ? math.max(low - sl_val, nz(trailing_sl[1])) : nz(pos[1]) == -1 ? math.min(high + sl_val, nz(trailing_sl[1])) : nz(trailing_sl[1]) 

// Position var               
pos  := long_signal ? 1 : short_signal ? -1 : nz(pos[1]) 



//////////////
// PLOTINGS //

plot(ShowTrailingSl ? trailing_sl : na , title = "Trailing StopLoss" , linewidth=2, color=pos == 1 ? bullcolor : bearcolor)


changeCond = long_signal or short_signal

//Alerts

//alertcondition(dir == 1 and dir[1] == -1 ? longStop : na, title='BUY', message= 'Pair : {{ticker}} | Type: Long 🟢 | TimeFrame : {{interval}} | Entry Price - {{close}} |||||||||||||||||||| StopLoss - {{plot("SL")}} ||||||||||||||||| TP1 Price - {{plot("TP1")}} |||||||||||||||| TP2 Price - {{plot("TP2")}} ||||||||||||||||  TP3 Price - {{plot("TP3")}} |||||||||||||||| '  )


//alertcondition(dir == -1 and dir[1] == 1 ? shortStop : na, title='SELL', message='"Pair : {{ticker}} | Type: Short 🔴 | TimeFrame : {{interval}} | Entry Price - {{close}} |||||||||||||||||||| StopLoss - {{plot("SL")}} ||||||||||||||||| TP1 Price - {{plot("TP1")}} |||||||||||||||| TP2 Price - {{plot("TP2")}} ||||||||||||||||  TP3 Price - {{plot("TP3")}} |||||||||||||||| ')
//TP1 & TP2 & TP3

//alertcondition(bton(long_tp and last_longCondition > nz(last_long_close[1])), title='TP1 LONG - DYNAMIC')
//alertcondition(bton(short_tp and last_shortCondition > nz(last_short_close[1])), title='TP1 SHORT - DYNAMIC')

//alertcondition(bton(long_sl2 and last_longCondition2 > nz(last_long_close2[1])) or bton(long_sl2 and last_longCondition2 > nz(last_long_close2[1])), title='SL Hit - DYNAMIC')

//alertcondition(bton(short_sl and last_shortCondition > nz(last_short_close[1])) or bton(long_sl and last_longCondition > nz(last_long_close[1])), title='BREAKEVEN - DYNAMIC')

//alertcondition(bton(short_tp and last_shortCondition > nz(last_short_close[1])) or bton(long_tp and last_longCondition > nz(last_long_close[1])), title='Target 1 Hit - DYNAMIC')

//alertcondition(bton(long_tp2 and last_longCondition2 > nz(last_long_close2[1])), title='TP2 LONG - DYNAMIC' )
//alertcondition(bton(short_tp2 and last_shortCondition2 > nz(last_short_close2[1])), title='TP2 SHORT - DYNAMIC')

//alertcondition(bton(short_tp2 and last_shortCondition2 > nz(last_short_close2[1])) or bton(long_tp2 and last_longCondition2 > nz(last_long_close2[1])), title='Target 2 Hit - DYNAMIC')

//alertcondition(bton(long_tp3 and last_longCondition3 > nz(last_long_close3[1])), title='TP3 LONG - DYNAMIC')
//alertcondition(bton(short_tp3 and last_shortCondition3 > nz(last_short_close3[1])), title='TP3 SHORT - DYNAMIC')

//alertcondition(bton(short_tp3 and last_shortCondition3 > nz(last_short_close3[1])) or bton(long_tp3 and last_longCondition3 > nz(last_long_close3[1])) , title='Target 3 Hit - DYNAMIC')

//alertcondition(bton(long_sl and last_longCondition > nz(last_long_close[1])), title='BREAKEVEN LONG - DYNAMIC')
//alertcondition(bton(short_sl and last_shortCondition > nz(last_short_close[1])), title='BREAKEVEN SHORT - DYNAMIC')



//alertcondition(bton(long_sl2 and last_longCondition2 > nz(last_long_close2[1])), title='SL HIT LONG - DYNAMIC')
//alertcondition(bton(short_sl2 and last_shortCondition2 > nz(last_short_close2[1])), title='SL HIT SHORT - DYNAMIC')

////////////
// Alerts //

//alertcondition(long_signal, 'Trailing SL Long', 'SL Long')
//alertcondition(short_signal, 'Trailing SL Short', 'SL Short')

//alertcondition(short_signal or long_signal, 'Trailing SL', 'Trailing SL')


tst(x)=> str.tostring(x)
var int dec = str.length(str.tostring(syminfo.mintick))-2
trc(number) =>
    factor = math.pow(10, dec)
    int(number * factor) / factor
trc_(number) =>
    factor = math.pow(10, 0)
    int(number * factor) / factor




xsrc = close
xprd1 = 12
xsrc2 = close
xprd2 = 26
xsmooth = 1

xPrice = ta.ema(xsrc, xsmooth)
FastMA = xfixtf ? ta.ema(request.security(syminfo.tickerid, xtf, ta.ema(xsrc, xprd1)), xsmooth) : ta.ema(xPrice, xprd1)
xPrice2 = ta.ema(xsrc2, xsmooth)
SlowMA = xfixtf ? ta.ema(request.security(syminfo.tickerid, xtf, ta.ema(xsrc2, xprd2)), xsmooth) : ta.ema(xPrice2, xprd2)
BullTribbon = FastMA > SlowMA
Tribbon = FastMA < SlowMA

//****************************************************************************//
// Define Color Zones

Green = BullTribbon and xPrice > FastMA  // Buy
Blue = Tribbon and xPrice > FastMA and xPrice > SlowMA  //Pre Buy 2 (Strong dip) Consider adding long position
LBlue = Tribbon and xPrice > FastMA and xPrice < SlowMA  //Pre Buy 1 (Weak Dip)

Red = Tribbon and xPrice < FastMA  // Sell
Orange = BullTribbon and xPrice < FastMA and xPrice < SlowMA  // Pre Sell 2 (Strong Rally) Consider adding short position
Yellow = BullTribbon and xPrice < FastMA and xPrice > SlowMA  // Pre Sell 1 (Weak Rally)


//****************************************************************************//
// Define Buy and Sell condition
// This is only for thebasic usage of CDC Actionzone (EMA Crossover) 
// ie. Buy on first green bar and sell on first red bar

buycond = Green and Green[1] == 0
sellcond = Red and Red[1] == 0

bullTribbonish = ta.barssince(buycond) < ta.barssince(sellcond)
Tribbonish = ta.barssince(sellcond) < ta.barssince(buycond)


bColor_BullTribbonTribbon = bullTribbonish ? bullcolor : Tribbonish ? bearcolor : na


plotshape(plotRibsw ? plotRibbonPos == 'Top' ? close : na : na, style=shape.square, title='Buy/Sell Ribbon', location=location.top, color=bColor_BullTribbonTribbon , editable = false)
plotshape(plotRibsw ? plotRibbonPos == 'Bottom' ? close : na : na, style=shape.square, title='Buy/Sell Ribbon', location=location.bottom, color=bColor_BullTribbonTribbon , editable = false)




len2 = 20  //input(20, minval=1, title="Smooth")
src = close
out = ta.vwma(src, len2)


buy = Tribbonish[1] and buycond
sell = bullTribbonish[1] and sellcond


//****************************************************************************//
// Label

//labelstyle = label.style_label_lower_left
labelstyle = close > SlowMA ? label.style_label_down : label.style_label_up
labelyloc = close > SlowMA ? yloc.abovebar : yloc.belowbar
labeltcolor = buy ? color.black : sell ? color.white : close > close[1] ? bullcolor : bearcolor 
labelbgcolor = buy ? bullcolor  : sell ? bearcolor : color.silver
labeltext = buy ? 'Long on next bar\n' : sell ? 'Short on next bar\n' : ' '
trendText = bullTribbonish ? 'Bullish' : Tribbonish ? 'Bearish' : 'Sideways'


l1 = label.new(bar_index, na, text=labeltext + syminfo.ticker + ' ' + str.tostring(close) + ' ' + syminfo.currency + '\n Currently in a ' + trendText + ' Trend \n', color=labelbgcolor, textcolor=labeltcolor, yloc=labelyloc, style=labelstyle)

label.delete(labelSwitch ? l1[1] : l1)







// Module  - Signals - SL - TPS by @comgunner

//-----------------------------------------
//*********************************************************
//*                     Module                            *
//*              Signals - SL - TPSEND                    *
//*********************************************************
//https://t.me/kakupakat_trading_oficial   

// Cálculos

groupEnTpSl = "Module - Signals"
//plot(na)

levels_tip = "Habilita etiquetas compra/venta /SL"
atrLen_tip = "Atr para el Calculo de Stoploss y TakeProfit"
atrRisk_tip = " ATR Risk Multiplier: Recommended 1.5 or 1.9 / Multiplicador de Riesgo ATR: Recomendado 1.5 o 1.9"
tpLen_tip = "Distance in percentage between TakeProfits / Distancia en porcentaje entre TakeProfits"
tpSL_tip = "Distance in percentage for SL / Distancia en porcentaje para SL"

numTP_tip = " Number of Take Profit Levels, min 1 max 10 / Número de niveles de toma de ganancias, mínimo 1 máximo 10 "
numTP = input.int(4, "Number of Take Profit Levels 💪", minval=1, maxval=10,tooltip =numTP_tip ,group=groupEnTpSl)

PercentOrATR_tip="Select the calculation method for TakeProfits / Selecciona el metodo de calculo para los TakeProfits" 

var string PercentOrATR = input.string("PREDICTUM", "Calculation method for TakeProfit (% or ATR)", options=["ATR", "PERCENTAGE","PREDICTUM"], inline="TPS", group=groupEnTpSl,tooltip=PercentOrATR_tip)

levels = input(title='Show Entry Labels/SL/TP /Mostrar Etiquetas de Entrada/SL/TP', defval=true, group=groupEnTpSl, tooltip=levels_tip) 
var bool showtagstrategy = true

atrLen   = input.int(10, "ATR Length TP / SL ", group=groupEnTpSl, tooltip=atrLen_tip)
atrRisk  = input.float(1.0, "ATR Risk TP / SL", group=groupEnTpSl,tooltip=atrRisk_tip )
tpLen = input.float(2.0, "TP [%] 💪", step=0.1, group=groupEnTpSl, tooltip=tpLen_tip)
tpLenpre_tip = "Initial TP for Predictum type calculation / TP inicial para el cálculo del tipo Predictum"
tpLenpre = input.float(1.0, "TP Initial Predictum [%] 💪", minval=0.3, step=0.1, group=groupEnTpSl, tooltip=tpLenpre_tip)
tpSL = input.float(3.5, "SL [%] 💀️", step=0.1, group=groupEnTpSl, tooltip=tpSL_tip)

lvlLines    = input.bool(false, "Show TP/SL lines ? / Mostart Lineas TP/SL? ", inline="levels2",group=groupEnTpSl)
linesStyle  = input.string("SOLID", "", ["SOLID", "DASHED", "DOTTED"], inline="levels2",group=groupEnTpSl)
lvlDistance = input.int(1, "Distance / Distancia", 1, inline="levels2",group=groupEnTpSl)
stylelvl = linesStyle == "SOLID" ? line.style_solid : linesStyle == "DASHED" ? line.style_dashed : line.style_dotted
lvlLinesw = input.int(title=' TP/SL Line Thickness / Grosor de línea TP/SL', defval=2, minval=1,inline="levels2",group=groupEnTpSl)



trigger = long_signal ? 1 : 0
atrBand = ta.atr(atrLen) * atrRisk
atrStop = trigger == 1 ? low - atrBand : high + atrBand






lastTrade(src) => ta.valuewhen(changeCond, src, 0 )

//Nuevo, distancia de TP's

DistanceTp =  close * tpLen / 100 
Distance_CTp = trigger == 1 ? close - DistanceTp : close + DistanceTp


DistanceSL =  close * tpSL / 100 
Distance_CSL = trigger == 1 ? low - DistanceSL : high + DistanceSL

DistanceTppre =  close * tpLenpre / 100 
Distance_CTpre = trigger == 1 ? close - DistanceTppre : close + DistanceTppre



var float atrSL = na

if PercentOrATR == "ATR"
    atrStop := atrStop
    atrSL := atrStop
else
    // Lógica para las opciones "PERCENTAGE" y "PREDICTUM"
    if PercentOrATR == "PERCENTAGE"
        atrStop := Distance_CTp
        atrSL := Distance_CSL
    else if PercentOrATR == "PREDICTUM"
        atrStop := Distance_CTpre  // Ajusta según tu lógica específica para "PREDICTUM"
        atrSL := Distance_CSL
        //numTP := 8

//CONTADOR DE VELAS, APARTIR E LA ULTIMA ENTRADA trigger o changeCondPNL = nz(alertLongPNL, false) != nz(alertShortPNL, false)

var int countOfCandles = 0

if trigger
    countOfCandles := 0
else
    countOfCandles := na(countOfCandles) ? 0 : countOfCandles + 1


//ENTRADA
entry = levels ? label.new(time, close, "ENTRY " + str.tostring(lastTrade(close), "#.#####"), xloc.bar_time, yloc.price, psar_longColor, label.style_label_left,  color.rgb(0, 0, 0), size.normal) : na
label.set_y(entry, lastTrade(close))
label.delete(entry[1])
stop_y = lastTrade(atrSL)

lineEntry = levels and lvlLines ? line.new(bar_index - countOfCandles, lastTrade(close), bar_index + lvlDistance ,lastTrade(close), xloc.bar_index, extend.none, psar_longColor,stylelvl, width=lvlLinesw ) : na
line.delete(lineEntry[1])

//STOPLOSS

stop  = levels ? label.new(time, close, "STOP LOSS💀️" + str.tostring(stop_y, "#.#####"), xloc.bar_time, yloc.price, #92080860, label.style_label_left, color.rgb(255, 252, 252), size.normal) : na
label.set_y(stop, stop_y)
label.delete(stop[1])

linestop = levels and lvlLines ? line.new(bar_index - countOfCandles, lastTrade(atrSL), bar_index  ,lastTrade(atrSL), xloc.bar_index, extend.none, #92080860,stylelvl, width=lvlLinesw ) : na
line.delete(linestop[1])





// Array para almacenar las etiquetas y líneas
var label[] tpLabels = array.new_label(0)
var line[] tpLines = array.new_line(0)

//################################################################

MovingTarget_tip = "Strategy to move StopLoss (BE), when it reaches a TP / Estrategia para mover StopLoss (BE), cuando alcanza un TP "
showLabel_tip = "Show SIGNAL GENERATOR label / Mostrar etiqueta SIGNAL GENERATOR"
MovingTarget = input.int(1, title="Moving Target (BE)", minval=1,group=groupEnTpSl,inline="SignalG",tooltip=MovingTarget_tip)
showLabel = input(false, title="Showlabel Signal Generator",group=groupEnTpSl,inline="SignalG",tooltip=showLabel_tip)

tf = timeframe.period
miSimbolo = ticker.standard(syminfo.tickerid)

//========================================================================

buy_label = ' =====SIGNAL GENERATOR======\n'
buy_label := buy_label + '=========KAKUPAKAT=========\n' 

buy_label := buy_label + ' \n' 

buy_label := buy_label + 'COIN 🪙 : ' + '' + str.tostring(miSimbolo)+ '\n'
buy_label := buy_label + 'TIMEFRAME ⏰ : ' + '' + str.tostring(tf)+ '\n'
buy_label := buy_label + ' \n' 
buy_label := buy_label + 'Dir 🔃: ' + '' + (stop_y < lastTrade(close) ? 'LONG' : 'SHORT') + '\n'
buy_label := buy_label + 'Entry 🚀: ' + '' + str.tostring(lastTrade(close), "#.#####") +'\n'


//*********************************************************
// Función para crear TP y líneas by CoMgUnNeR 
// ¡Codigo mas simplificado da creditos al autor! me costo bastante.
//https://t.me/kakupakat_trading_oficial    
//*********************************************************

// Función para crear TP y líneas
// Función para calcular potencias
pow(base, exponent) =>
    var float result = 1.0
    for i = 1 to exponent
        result := result * base
    result

var float[] tpValues = array.new_float(0)

// Función para crear TP y líneas
createTP(level) =>
    if levels
        var float tp_y = na
        var string emoji = na
        var color textColor = na
        var color lineColor = na
        
        if PercentOrATR == "PREDICTUM"
            if level == 1
                tp_y := (lastTrade(close) - lastTrade(atrStop)) * level + lastTrade(close)
            else
                tp_y := tp_y + (tp_y - lastTrade(close)) * 0.618  
            
            emoji := level == numTP ? "🤲💎" : "💪"
            textColor := color.white
            lineColor := psar_longLight
        else
            tp_y := (lastTrade(close) - lastTrade(atrStop)) * level + lastTrade(close)
            emoji := level == numTP ? "🤲💎" : "💪"
            textColor := color.white
            lineColor := psar_longLight

        tp = label.new(time, tp_y, "TP " + str.tostring(level) + " " + emoji + " " + str.tostring(tp_y, "#.#####"), xloc.bar_time, yloc.price, color=lineColor, style=label.style_label_left, textcolor=textColor, size=size.normal)

        array.push(tpLabels, tp)

        if lvlLines
            tpLine = line.new(bar_index - countOfCandles, tp_y, bar_index + lvlDistance, tp_y, xloc.bar_index, extend.none, lineColor, stylelvl, width=lvlLinesw)
            array.push(tpLines, tpLine)
            if array.size(tpLines) > numTP
                line.delete(array.get(tpLines, 0))
                array.shift(tpLines)

        if array.size(tpLabels) > numTP
            label.delete(array.get(tpLabels, 0))
            array.shift(tpLabels)
        tp_y


// Crear TP y líneas basado en el input del usuario
if (bar_index > 10) // Asegurarse de que hay suficientes barras para calcular
    for i = 1 to numTP
        createTP(i)


        

// Función para crear TP y líneas
createTP2(level_info) =>
    if showLabel
        var float tp_y2 = na
        var string emoji = na

        if PercentOrATR == "PREDICTUM"
            if level_info == 1
                tp_y2 := (lastTrade(close) - lastTrade(atrStop)) * level_info + lastTrade(close)
            else
                tp_y2 := tp_y2 + (tp_y2 - lastTrade(close)) * 0.618  
            
            emoji := level_info == numTP ? "🤲💎" : "💪"
        else
            tp_y2 := (lastTrade(close) - lastTrade(atrStop)) * level_info + lastTrade(close)
            emoji := level_info == numTP ? "🤲💎" : "💪"

        // Agregar el resultado al texto de la etiqueta
        'TP ' + str.tostring(level_info) + ': ' + emoji + str.tostring(tp_y2, "#.#####") + '\n'

if (bar_index > 10)
    for i = 1 to numTP
        // Llamar a la función y agregar el resultado a buy_label
        buy_label := buy_label + createTP2(i)



buy_label := buy_label + 'StopLoss 🛑: ' + '' + str.tostring(stop_y, "#.#####") +'\n'
buy_label := buy_label + ' \n' 

buy_label := buy_label + '=====Strategy======\n'
buy_label := buy_label + ' \n' 
buy_label := buy_label + 'Stop: Moving Target -\n'
buy_label := buy_label + '  Trigger: Target  ' + str.tostring((MovingTarget))+ '\n'

lab_buy = label.new(bar_index - 15, showLabel ? close : na, buy_label, color=color.new(color.gray, 40), textcolor=color.white, style=label.style_label_down, yloc=yloc.abovebar, textalign=text.align_left)

// Mueve la etiqueta fuera del gráfico cuando no se muestra
//label.set_x(lab_buy, bar_index - 500)
if not showLabel
    label.delete(lab_buy)

label.delete(lab_buy[1])


//################################################################
// Define variables for strategy exit
// Define variables for strategy exit
var int qty_percent = na
var int limit_price = na
var bool tp_reached = na

// Variable de script para qtytps
var int qtytps = na

// Calcular qtytps fuera de la función
qtytps := na(qtytps) ? (numTP == 1 ? 100 : 100 / (numTP - 1 + (numTP == 1 ? 1 : 0))) : qtytps

createTP3(level_stg) =>
    // Declarar una variable local
    var bool _tp_reached = na
    if bar_index > 10
        var float tp_y3 = na
        var string emoji = na
        if PercentOrATR == "PREDICTUM"
            if level_stg == 1
                tp_y3 := (lastTrade(close) - lastTrade(atrStop)) * level_stg + lastTrade(close)
            else
                tp_y3 := tp_y3 + (tp_y3 - lastTrade(close)) * 0.618   

            emoji := level_stg == numTP ? "🤲💎" : "💪"
        else
            tp_y3 := (lastTrade(close) - lastTrade(atrStop)) * level_stg + lastTrade(close)
            
            emoji := level_stg == numTP ? "🤲💎" : "💪"

        if  showtagstrategy
            // Modificar el mensaje de la alerta para incluir el nivel de Take Profit
            strategy.exit('TP ' + str.tostring(level_stg), limit=tp_y3, comment='TP ' + str.tostring(level_stg) + ' Close: ' + str.tostring(close), alert_message='🎯 Take Profit ' + str.tostring(level_stg) + ' Reached', qty_percent=qtytps)

            //alert(str.format("🎯 Take Profit Reached: {0}", str.tostring(level_stg)), alert.freq_once_per_bar)
            // Modificar el mensaje de la alerta para incluir el nivel de Take Profit
            //strategy.exit('TP ' + str.tostring(level_stg), limit=tp_y3, comment='TP ' + str.tostring(level_stg) + ' Close: ' + str.tostring(close), alert_message='Take Profit ' + str.tostring(level_stg) + ' Reached', qty_percent=qtytps)

            //if strategy.position_size > 0 and close >= tp_y3
                //alert(str.format("🎯 Take Profit Reached: {0}", str.tostring(level_stg)))
    
        // Actualizar la variable local en lugar de la global
        //Creo que funciona
        _tp_reached := close >= tp_y3
        if _tp_reached == true
            //alert(str.format("🎯 Take Profit Reached:", str.tostring(level_stg), alert.freq_once_per_bar)
            alert(str.format("🎯 Take Profit Reached:  " + str.tostring(level_stg), alert.freq_once_per_bar))

//+ str.tostring(numtp)    
    // Devolver la variable local
    _tp_reached

// Usar la función sin verificar showLabel
for i = 1 to numTP
    // Asignar el valor devuelto por la función a la variable global
    tp_reached := createTP3(i)

//################################################################



// Module -  DASHBOARD
//-----------------------------------------
// Module  by @comgunner
//*********************************************************
//*                     Module                            *
//*                   DASHBOARD                           *
//*********************************************************
//https://t.me/kakupakat_trading_oficial    
// Calculations

groupDASHBOARD_dash = "======= DASHBOARD  ======="
plot(na)

dashOn_dash = input(true, "Dashboard On / Off", group = groupDASHBOARD_dash )
dashDist_dash = input(60, "Dashboard Distance")

// Squeeze
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ————— SqueezeSettings_dash
squeezeConvtip_dash ="Prices being squeezed refer to the action of price being compressed within a tightening area"
squeezeConv_dash   = input(50, 'Convergence Factor', tooltip = squeezeConvtip_dash)
squeezeLengthtip_dash= "The above chart makes use of a convergence factor of 100 and a period of 10."
squeezeLength_dash   = input(20, 'Squeeze Periods', tooltip = squeezeLengthtip_dash)
squeezeSrc_dash = input(close)

//-----------------------------------------------------------------------------}
// ————— Squeeze index_dash
//-----------------------------------------------------------------------------{
var max_dash = 0.
var min_dash = 0.
max_dash := nz(math.max(squeezeSrc_dash, max_dash - (max_dash - squeezeSrc_dash) / squeezeConv_dash), squeezeSrc_dash)
min_dash := nz(math.min(squeezeSrc_dash, min_dash + (squeezeSrc_dash - min_dash) / squeezeConv_dash), squeezeSrc_dash)
diff_dash = math.log(max_dash - min_dash)
squeezePsi_dash = -50 * ta.correlation(diff_dash, bar_index, squeezeLength_dash) + 50
squeezePsiRage_dash = squeezePsi_dash > 80

//Calculates Volatility for Dashboard
atr9_dash = ta.atr(14)
stdAtr_dash = 2 * ta.stdev(atr9_dash, 20)
smaAtr_dash = ta.sma(atr9_dash, 20)
topAtrDev_dash = smaAtr_dash + stdAtr_dash
bottomAtrDev_dash = smaAtr_dash - stdAtr_dash
calcDev_dash = (atr9_dash - bottomAtrDev_dash) / (topAtrDev_dash - bottomAtrDev_dash)
percentVol_dash = 40 * calcDev_dash + 30

//Data for Dashboard
volumeDash_dash = volume
rsiDash_dash = ta.rsi(close, 14)
mfiDash_dash = ta.mfi(hlc3, 14)
momDash_dash = (close / close[10]) * 100

buyingPressure_dash = volumeDash_dash * (close - low) / (high - low)
sellingPressure_dash = volumeDash_dash * (high - close) / (high - low)

percentSellingVol_dash = math.round((sellingPressure_dash / volumeDash_dash) * 100, 0)
percentBuyingVol_dash = 100 - percentSellingVol_dash

//Defines Each Timeframe for Trend Panel
sma_dash = ta.sma(close, 50)
oneM_dash = request.security(syminfo.tickerid, '1', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
fiveM_dash = request.security(syminfo.tickerid, '5', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
fifteenM_dash = request.security(syminfo.tickerid, '15', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
thirtyM_dash = request.security(syminfo.tickerid, '30', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
oneH_dash = request.security(syminfo.tickerid, '60', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
twoH_dash = request.security(syminfo.tickerid, '120', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
fourH_dash = request.security(syminfo.tickerid, '240', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
weekly_dash = request.security(syminfo.tickerid, 'W', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
monthly_dash = request.security(syminfo.tickerid, 'M', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
daily_dash = request.security(syminfo.tickerid, 'D', sma_dash, barmerge.gaps_off, barmerge.lookahead_off)
//Defines An Uptrend for Trend Panel
oneMUp_dash = oneM_dash > oneM_dash[1]
fiveMUp_dash = fiveM_dash > fiveM_dash[1]
fifteenMUp_dash = fifteenM_dash > fifteenM_dash[1]
thirtyMUp_dash = thirtyM_dash > thirtyM_dash[1]
oneHUp_dash = oneH_dash > oneH_dash[1]
twoHUp_dash = twoH_dash > twoH_dash[1]
fourHUp_dash = fourH_dash > fourH_dash[1]
dailyUp_dash = daily_dash > daily_dash[1]
weeklyUp_dash = weekly_dash > weekly_dash[1]
monthlyUp_dash = monthly_dash > monthly_dash[1]
rsiDashUp_dash = rsiDash_dash > rsiDash_dash[1]
mfiDashUp_dash = mfiDash_dash > mfiDash_dash[1]
momDashUp_dash = momDash_dash > momDash_dash[1]

//Checks if the Current State is an Uptrend or Downtrend for the Trend Panel
up_dash = "🟢"
down_dash = "🔴"

oneMTrend_dash = oneMUp_dash ? up_dash : down_dash
fiveMTrend_dash = fiveMUp_dash ? up_dash : down_dash
fifteenMTrend_dash = fifteenMUp_dash ? up_dash : down_dash
thirtyMTrend_dash = thirtyMUp_dash ? up_dash : down_dash

oneHTrend_dash = oneHUp_dash ? up_dash : down_dash
twoHTrend_dash = twoHUp_dash ? up_dash : down_dash
fourHTrend_dash = fourHUp_dash ? up_dash : down_dash
dailyTrend_dash = dailyUp_dash ? up_dash : down_dash
weeklyTrend_dash = weeklyUp_dash ? up_dash : down_dash
monthlyTrend_dash = monthlyUp_dash ? up_dash : down_dash
rsiTrend_dash = rsiDashUp_dash ? up_dash : down_dash
mfiTrend_dash = mfiDashUp_dash ? up_dash : down_dash
momTrend_dash = momDashUp_dash ? up_dash : down_dash

dashColor_dash = input(color.new(#696969, 80), "Dashboard Color", inline="Dash Line")
dashTextColor_dash = input(color.new(#ffffff, 0), "Text Color", inline="Dash Line")
if dashOn_dash
    label Label_dash = label.new(time, close,
     text="      📌     DASHBOARD   📌"
     + "\n━━━━━━━━━━━━━━━━━"
     + "\n              Market Information"
     + "\n━━━━━━━━━━━━━━━━━"
     + "\n  🚀 Volatility              | " + str.tostring(percentVol_dash, "##.##" )     
     + "\n  🚀 Volume                         | " + str.tostring(volumeDash_dash, "##.##" )
     + "\n  🚀 RSI                                        | " + str.tostring(rsiDash_dash, "##.##") + rsiTrend_dash
     + "\n  🚀 MFI                                       | " + str.tostring(mfiDash_dash, "##.##") + mfiTrend_dash
     + "\n  🚀 Momentum          | " + str.tostring(momDash_dash, "##.##") + momTrend_dash
     + "\n━━━━━━━━━━━━━━━━━"
     + "\n  🌊  % Buy Pressure   | " + str.tostring(percentBuyingVol_dash, "##.##" )
     + "\n  🌊  % Sell Pressure   | " + str.tostring(percentSellingVol_dash, "##.##" )
     + "\n━━━━━━━━━━━━━━━━━"
     + "\n  🔃 Squeeze               | " + str.tostring(squeezePsi_dash, "##.##" )
     
     + "\n━━━━━━━━━━━━━━━━━"
     + "\n                   Trend Panel"
     + "\n━━━━━━━━━━━━━━━━━"
     + "\n       1 Minute | " + oneMTrend_dash + "     15 Minute     | " + fifteenMTrend_dash
     + "\n       5 Minute | " + fiveMTrend_dash + "     30 Minute     | " + thirtyMTrend_dash     
     + "\n       1 Hour | " + oneHTrend_dash + "     Daily     | " + dailyTrend_dash
     + "\n       2 Hour | " + twoHTrend_dash + "     Weekly  | " + weeklyTrend_dash
     + "\n       4 Hour | " + fourHTrend_dash + "     Monthly | " + monthlyTrend_dash
     + "\n━━━━━━━━━━━━━━━━━"
     + "\n          💎   KAKUPAKAT TRADING   💎",
     color=dashColor_dash, xloc= xloc.bar_time, style=label.style_label_left, textcolor=dashTextColor_dash, textalign=text.align_left)
    label.set_x(Label_dash, label.get_x(Label_dash) + math.round(ta.change(time)*dashDist_dash))
    label.delete(Label_dash[1])



//@version=5
// © kakupakat_trading 2024
//https://t.me/kakupakat_trading_oficial    
//Disclaimer: This script is free and should not be sold. It’s fine to take ideas to create something new,
//but it’s not okay to claim this work as your own. The goal is to encourage the development of better tools
//that are accessible to everyone, from beginner programmers to more advanced ones. The purpose is to build
//a community based on shared knowledge and collective growth.

//@version=5
//indicator("INFOBOX by comgunner ", overlay = true
//  , max_labels_count = 500
//  , max_lines_count = 500
//  , max_boxes_count = 500
//  , max_bars_back = 500
//  , precision=4
//  , linktoseries=true
//  , max_bars_back=1000
//  , max_lines_count=500
//  , shorttitle             = ' INFOBOX by comgunner ')



color kakupakat =color.rgb(0, 0, 50, 50)

// Module  - Operations
//-----------------------------------------
//*********************************************************
//*                     Module                            *
//*                   Operations                          *
//*********************************************************
// Calculations



// MACDSection
//MACDTitle = splitter + nl
[macd, macdsignal, macdhist] = ta.macd(close, fastlen=12, slowlen=26, siglen=9)
trendMACDUp = macdhist > 0 
trendMACDDn = macdhist < 0 



// RSISection
//RSITitle = splitter + nl
rsibase2 = ta.rsi(close, 7)
rsibase = ta.rsi(close, 14)
rsibase3 = ta.rsi(close, 21)


Trend_RSI_overb = rsibase > 80 and rsibase2 > 80 or  rsibase2 > 80 and rsibase3 > 80  or rsibase > 80 and rsibase3 > 80 
Trend2_RSI_overs = rsibase < 20 and rsibase2 < 20 or rsibase2 < 20 and rsibase3 < 20 or rsibase < 20 and rsibase3 < 20  

//RSI GOLDEN CROSS COMGUNNER INICIO

// Grupo : Opciones del Módulo GOLDEN CROSS 
groupinfboxRsi = "INFOBOX GOLDEN CROSS mRSI"
// Separación visual
plot(na)
// , group=groupinfboxRsi
// 

ma(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "Bollinger Bands" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "SMMA (RMA)" => ta.rma(source, length)
        "WMA" => ta.wma(source, length)
        "VWMA" => ta.vwma(source, length)

rsiLengthInput = 14
rsiSourceInput = input.source(close, group=groupinfboxRsi)

maTypeInput = input.string("SMA", title="mrSI", group="MA Settings", group=groupinfboxRsi)
maLengthInput = 14
bbMultInput = 2.0

uprsi = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)
downrsi = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)
rsi = downrsi == 0 ? 100 : uprsi == 0 ? 0 : 100 - (100 / (1 + uprsi / downrsi))
rsiMA = ma(rsi, maLengthInput, maTypeInput)
isBB = maTypeInput == "Bollinger Bands"

// Agregar una variable para almacenar el valor anterior del RSI
var float prevRSI = na
var float prevRSI2 = na
var float prevRSI3 = na
// Agregar una variable para almacenar el valor anterior del rsiMA
var float prevrsiMA = na
var float prevrsiMA2 = na
var float prevrsiMA3 = na

// Almacenar el valor anterior de RSI
prevRSI := nz(prevRSI[1], rsi[1])
prevRSI2 := nz(prevRSI[2], rsi[2])

// Almacenar el valor anterior de rsiMA
prevrsiMA := nz(prevrsiMA[1], rsiMA[1])
prevrsiMA2 := nz(prevrsiMA[2], rsiMA[2])

//RSIcrossTitle = splitter + nl
goldenrsiUp = ta.crossover(rsi,rsiMA) and rsiMA < prevrsiMA and rsiMA < prevrsiMA2 
goldenrsiDn = ta.crossunder(rsi,rsiMA)  and rsiMA > prevrsiMA and rsiMA > prevrsiMA2 

mRSItrendUp = rsi > rsiMA 
mRSItrendDn = rsi < rsiMA 

//RSI GOLDEN CROSS COMGUNNER INICIO FIN

//INICIA ADX

// Inputs ADX
DMIlength = 14
ATRADX = ta.atr(14)



// +DM and -DM
upMove = high - high[1]
dnMove = low[1] - low
plusDM = upMove > dnMove and upMove > 0 ? upMove : 0
minusDM = dnMove > upMove and dnMove > 0 ? dnMove : 0

// SMMA Wilder; SMMA(x,y) = RMA(x,y) or SMMA(x,y) = EMA(x, (2 * y - 1))
MAcalc(x, y) =>
    ma = ta.rma(x, y)
    ma

// +DI,-DI and ADX
plusDI = 100 * (MAcalc(plusDM, DMIlength) / ATRADX)
minusDI = 100 * (MAcalc(minusDM, DMIlength) / ATRADX)
absDX = 100 * math.abs((plusDI - minusDI) / (plusDI + minusDI))


// Calcular el ADX como se hace en el código original
ADX = MAcalc(absDX, DMIlength)

Trend1ADX = ADX > 25 
Trend2ADX = ADX < 20 
dirADXUp = plusDI > minusDI 
dirADXDn = plusDI < minusDI 
cruceLongADX = ta.crossover(plusDI, minusDI) 
cruceShortADX = ta.crossunder(plusDI, minusDI) 


//TERMINA ADX


//SQUEEZE MOMENTUM COMGUNNER
lengthSqueeze = 20
multSqueeze = 2
lengthKCSqueeze = 20
multKCSqueeze = 1.5
strengthSqueeze = 0.0018
useTrueRangeSqueeze = input.bool(true, title="Use TrueRange (KC)",tooltip = "Parameter for Squeeze M / Parametro para Squeeze M ")

// Calculate BB
sourceSqueeze = close
basisSqueeze = ta.sma(sourceSqueeze, lengthSqueeze)
devSqueeze = multKCSqueeze * ta.stdev(sourceSqueeze, lengthSqueeze)
upperBBSqueeze = basisSqueeze + devSqueeze
lowerBBSqueeze = basisSqueeze - devSqueeze

// Calculate KC
maSqueeze = ta.sma(sourceSqueeze, lengthKCSqueeze)
rangeValSqueeze = useTrueRangeSqueeze ? ta.tr : (high - low)
rangemaSqueeze = ta.sma(rangeValSqueeze, lengthKCSqueeze)
upperKCSqueeze = maSqueeze + rangemaSqueeze * multKCSqueeze
lowerKCSqueeze = maSqueeze - rangemaSqueeze * multKCSqueeze

sqzOnSqueeze  = (lowerBBSqueeze > lowerKCSqueeze) and (upperBBSqueeze < upperKCSqueeze)
sqzOffSqueeze = (lowerBBSqueeze < lowerKCSqueeze) and (upperBBSqueeze > upperKCSqueeze)
noSqzSqueeze  = (sqzOnSqueeze == false) and (sqzOffSqueeze == false)
highestSqueeze = ta.highest(high, lengthKCSqueeze)
lowestSqueeze = ta.lowest(low, lengthKCSqueeze)
lastsmaSqueeze = ta.sma(close,lengthKCSqueeze)
valin = ta.linreg(sourceSqueeze  -  ta.sma((highestSqueeze + lowestSqueeze) / 2, lengthKCSqueeze), lengthKCSqueeze,0)
SqueezeEndLong = valin < (strengthSqueeze*-1) and valin > nz(valin[1])
SqueezeEndShort = valin > strengthSqueeze and valin < nz(valin[1])  

SqueezeCrossUp = ta.crossover(valin, 0) // ?  '🟢' +'[ 0  UP  ]' : na  
SqueezeCrossDn = ta.crossunder(valin,0) // ?  '🔴' + '[ 0  DOWN ]' : na 

//SQUEEZE MOMENTUM COMGUNNER FIN


// Stoch


//CLASICO Estrategia CoMgUnNeR
periodK = 14
periodD = 3
smoothK = 3
//TIPO1

periodK2 = 7
periodD2 = 3
smoothK2 = 3

//TIPO3

periodK3 = 21
periodD3 = 3
smoothK3 = 3

//STD
k = ta.sma(ta.stoch(close, high, low, periodK), smoothK)
d = ta.sma(k, periodD)
//tp2
k2 = ta.sma(ta.stoch(close, high, low, periodK2), smoothK2)
d2 = ta.sma(k2, periodD2)
//tp3
k3 = ta.sma(ta.stoch(close, high, low, periodK3), smoothK3)
d3 = ta.sma(k3, periodD3)



Trend1stoch = k > 80 and k2 > 80 or k2 > 80 and k3 > 80 or k > 80 and k3 > 80 
Trend2stoch = k < 20 and k2 < 20 or k2 < 20 and k3 < 20 or k < 20 and k3 < 20  
//EstochasticSection = i_showEstochastic ? nl + EstochasticTitle + nl +  f_strHelp('STOCH K:', k, 1) + f_strHelp('STOCH D:', d, 1) + nl + Trend1stoch + Trend2stoch + nl : na + nl 

Trend1stochcrossUp = ta.crossover(k, d) 
Trend2stochcrossDn = ta.crossunder(k, d) 





//*********************************************************
//**                 INFORMATION BOX                     **
//**                    HORIZONTAL                       **
//*********************************************************
groupINFOBOXH = "======= INFOBOX HORIZONTAL ======= "
plot(na)

/// BEGING TIPS
showsmasinfoboxh_tip = "This will display Table INFOBOX / Esto mostrará la tabla INFOBOX."
showsmasinfoboxh = input.bool(true, title="Show INFOBOX  Table", tooltip = showsmasinfoboxh_tip, group=groupINFOBOXH)
/// TIPS END
tablePosInput_tipinfoboxh = "Select where you want the table to draw. / Selecciona dónde quieres que se dibuje la tabla"
tableFontSzInput_tipinfoboxh = "Change the font size, default to size.small, for better compatibility with mobile devices / Cambia el tamaño de la fuente, predeterminado en size.small, para mayor compatibilidad con dispositivos moviles"
lineinfoboxh_SLorTP_tip = "Modifies the Take Profit or StopLoss Line Thickness, green and red horizontal lines of each completed trade /Modifica el Grosor de línea Take Profit o StopLoss, lineas horizontal verde y roja de cada trade completado"
tablePosInputinfoboxh = input.string(title="Position", defval="Bottom Center", options=["Bottom Center", "Top Center", "Top Left", "Top Right", "Center Left", "Center Right"], tooltip=tablePosInput_tipinfoboxh)
tableFontSzInputinfoboxh = input.string(title="Font size", defval="size.small", options=["size.normal", "size.tiny","size.small","size.large"], tooltip=tableFontSzInput_tipinfoboxh)
lineinfoboxh_SLorTP = input.int(title=' TP/SL Line Thickness / Grosor de línea TP/SL', defval=1, minval=1,tooltip=lineinfoboxh_SLorTP_tip)
font_size_infob = tableFontSzInputinfoboxh == "size.normal" ? size.normal : tableFontSzInputinfoboxh == "size.tiny" ? size.tiny : tableFontSzInputinfoboxh == "size.small" ? size.small : tableFontSzInputinfoboxh == "size.large" ? size.large : na

var tablePosinfoboxh  = tablePosInputinfoboxh == "Bottom Center" ? position.bottom_center : tablePosInputinfoboxh == "Top Center" ? position.bottom_center : tablePosInputinfoboxh == "Top Left" ? position.top_left : tablePosInputinfoboxh == "Top Right" ? position.top_center : tablePosInputinfoboxh == "Center Left" ? position.middle_left : tablePosInputinfoboxh == "Center Right" ? position.middle_right : na
var infoboxhTable = table.new(position = tablePosinfoboxh, columns = 16, rows = 6, border_color = color.white, border_width = 1)

if showsmasinfoboxh
    // Columnas originales
    table.cell(table_id = infoboxhTable, column = 0, row = 0, bgcolor = kakupakat, text_color = color.orange, text = "RSI", text_size = font_size_infob)
    table.cell(table_id = infoboxhTable, column = 1, row = 0, bgcolor = kakupakat, text_color = color.orange, text = "RSI 🚨", text_size = font_size_infob)
    table.cell(table_id = infoboxhTable, column = 2, row = 0, bgcolor = kakupakat, text_color = color.orange, text = "mRSI T. 🚨", text_size = font_size_infob)
    table.cell(table_id = infoboxhTable, column = 3, row = 0, bgcolor = kakupakat, text_color = color.orange, text = "MACD T. 📊", text_size = font_size_infob)
    table.cell(table_id = infoboxhTable, column = 4, row = 0, bgcolor = kakupakat, text_color = color.orange, text = "DIR SQM 🚨", text_size = font_size_infob)
    
    table.cell(table_id = infoboxhTable, column = 0, row = 2, bgcolor = kakupakat, text_color = color.orange, text = "ADX", text_size = font_size_infob)

    table.cell(table_id = infoboxhTable, column = 1, row = 2, bgcolor = kakupakat, text_color = color.orange, text = "ADX DIR. 🚨", text_size = font_size_infob)
    table.cell(table_id = infoboxhTable, column = 2, row = 2, bgcolor = kakupakat, text_color = color.orange, text = "ADX T.", text_size = font_size_infob)

    table.cell(table_id = infoboxhTable, column = 3, row = 2, bgcolor = kakupakat, text_color = color.orange, text = "STOCH 🚨", text_size = font_size_infob)
    table.cell(table_id = infoboxhTable, column = 4, row = 2, bgcolor = kakupakat, text_color = color.orange, text = "STOCH ❌", text_size = font_size_infob)
 
// ... (Agrega las otras 9 nuevas columnas de manera similar)

    // Contenido de las celdas (ejemplo para la primera fila)
    table.cell(table_id = infoboxhTable, column = 0, row = 1, bgcolor = kakupakat, text_color = color.yellow, text_size = font_size_infob, text = str.tostring(math.round(rsibase, 2)))
    table.cell(table_id = infoboxhTable, column = 1, row = 1, text = Trend_RSI_overb ? "OVERBUY📈" : Trend2_RSI_overs ? "OVERSELL📉" : na, bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)
    table.cell(table_id = infoboxhTable, column = 2, row = 1, text = mRSItrendUp ? "Bullish 📈" : mRSItrendDn ? "Bearish 📉" : na, bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)
    table.cell(table_id = infoboxhTable, column = 3, row = 1, text = trendMACDUp ? "Bullish 📈" : trendMACDDn ? "Bearish 📉" : na, bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)
    table.cell(table_id = infoboxhTable, column = 4, row = 1, text = SqueezeEndLong ? "🔄🟢 DIR END ↗️↘️ " : SqueezeEndShort ? "🔄🔴 DIR END  ↘️↗️" : na, bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)

    table.cell(table_id = infoboxhTable, column = 0, row = 3, text =  str.tostring(math.round(ADX,2)),  bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)

    table.cell(table_id = infoboxhTable, column = 1, row = 3, text = dirADXUp ? "Bullish 📈" : dirADXDn ? "Bearish 📉" : na, bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)
    table.cell(table_id = infoboxhTable, column = 2, row = 3, text = Trend1ADX ? "STRONG 💪" : Trend2ADX ? "WEAK 💔" : na, bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)

    table.cell(table_id = infoboxhTable, column = 3, row = 3, text = Trend1stoch ? " OVERBUY📈" : Trend2stoch ? " OVERSELL📉" : na, bgcolor = kakupakat, text_color = color.yellow, text_size=font_size_infob)
    table.cell(table_id = infoboxhTable, column = 4, row = 3, text = Trend1stochcrossUp ? "🟢🔼 UP" : Trend2stochcrossDn ? "🔴🔽 DOWN" : na,bgcolor=kakupakat,text_color = color.yellow, text_size=font_size_infob)

// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)