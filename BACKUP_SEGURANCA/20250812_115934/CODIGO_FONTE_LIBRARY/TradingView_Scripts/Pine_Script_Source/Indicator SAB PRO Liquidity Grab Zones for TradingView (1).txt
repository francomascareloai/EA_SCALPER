// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join our channel for more free tools: https://t.me/simpleforextools

//@version=5

indicator(title = 'SAB PRO Liquidity Grab Zones', overlay = true, max_boxes_count = 500, max_labels_count = 500, max_lines_count = 500, max_bars_back = 1005)

//#region Constants
const bool   DEBUG             = false
const int    SHOW_LAST_X       = 500
const int    MAX_DISTANCE      = 500 // Affects Running Time
const int    MAX_ZONES         = 100
const int    EXTEND_ZONES_BY   = 15
const int    RETEST_COOLDOWN   = 5
const int    MIN_ZONE_SIZE     = 3
const color  LINE_COLOR        = color.white
const string LINE_STYLE        = "----"
//#endregion

//#region Inputs
pivotLenLiq         = input.int(25, "Pivot Length", group = "General Configuration", display = display.none)
WBR                 = input.float(0.5, "Wick-Body Ratio", step = 0.1, group = "General Configuration", display = display.none)
zoneInvalidation    = input.string("Close", "Zone Invalidation", group = "General Configuration", options = ["Wick", "Close"], display = display.none)
retestsEnabled      = input.bool(true, "Retests", inline = "rb", group = "General Configuration", display = display.none)
breaksEnabled       = input.bool(false, "Breaks", inline = "rb", group = "General Configuration", display = display.none)
inverseZones        = input.bool(true, "Inverse Zones After Broken", group = "General Configuration", display = display.none)


sellsideColor       = input(#08998180, 'Bullish', inline = 'bsColor', group = 'General Configuration', display = display.none)
buysideColor        = input(#f2364680, 'Bearish', inline = 'bsColor', group = 'General Configuration', display = display.none)

combineZones        = DEBUG ? input.bool(true, "[DBG] Combine Zones", group = "Debug", display = display.none) : true
showInvalidated     = DEBUG ? input.bool(true, "[DBG] Show Historic Zones", group = "Debug", display = display.none) : true

bubbleSize          = DEBUG ? input.int(5, "[DBG] Base Bubble Size", group = "Style", display = display.none) : 5
minDist             = DEBUG ? input.int(0, "[DBG] Min Distance", group = "Style", display = display.none) : 0
grabsPerZone        = DEBUG ? input.int(1, "[DBG] Max Grabs Per Zone", group = "Style", display = display.none) : 1
minATRBetweenPivots = DEBUG ? input.float(1, "[DBG] Min ATR Between Pivots", group = "Style", display = display.none) : 1
bubbleOffset        = DEBUG ? input.float(20, "[DBG] Bubble Offset", group = "Style", display = display.none) : 20
textColor           = DEBUG ? input.color(#ffffff80, "[DBG] Text Color", group = "Style", inline = "BBcolors") : #ffffff80
renderLiqZones      = DEBUG ? input.bool(false, "[DBG] Render Liquidity Zones", group = "Style") : false
renderBubbles       = DEBUG ? input.bool(true, "[DBG] Render Bubbles", group = "Style") : false
renderLiqGrabZones  = DEBUG ? input.bool(true, "[DBG] Render Liquidity Grab Zones", group = "Style") : true
//#endregion

//#region UDTs
type liqInfo
    int startTime
    int endTime
    float price
    string liqType
    int grabsFound = 0

type liq
    liqInfo info
    bool isRendered = false
    line liqZone

type liqGrabZone
    int startTime = na
    int endTime = na
    float priceHigh
    float priceLow
    string liqType
    bool disabled = false
    bool ephemeral = false

safeDeleteLiq (liq liqF) =>
    liqF.isRendered := false
    line.delete(liqF.liqZone)
//#endregion

var liq[] allLiqList                = array.new<liq>(0)
var liqGrabZone[] allLiqGrabZones   = array.new<liqGrabZone>(0)

highestTALiq    = ta.pivothigh(pivotLenLiq, pivotLenLiq)
lowestTALiq     = ta.pivotlow(pivotLenLiq, pivotLenLiq)
curATR          = ta.atr(5)

//#region Functions
renderLiq (liq liqF) =>
    if renderLiqZones
        liqF.liqZone := line.new(liqF.info.startTime, liqF.info.price, nz(liqF.info.endTime, time + 1), liqF.info.price, xloc = xloc.bar_time, color = liqF.info.liqType == "Buyside" ? buysideColor : sellsideColor)

handleLiqsFinal () =>
    if DEBUG
        log.info("Liqudities Count " + str.tostring(allLiqList.size()))

    if allLiqList.size() > 0
        for i = 0 to allLiqList.size() - 1
            curLiq = allLiqList.get(i)
            safeDeleteLiq(curLiq)
            if not curLiq.isRendered and not (not showInvalidated and not na(curLiq.info.endTime))
                renderLiq(curLiq)

areaOfZone (liqGrabZone zone) =>
    XA1 = zone.startTime
    XA2 = na(zone.endTime) ? zone.startTime + EXTEND_ZONES_BY : zone.endTime
    YA1 = zone.priceHigh
    YA2 = zone.priceLow
    edge1 = math.sqrt((XA2 - XA1) * (XA2 - XA1) + (YA2 - YA2) * (YA2 - YA2))
    edge2 = math.sqrt((XA2 - XA2) * (XA2 - XA2) + (YA2 - YA1) * (YA2 - YA1))
    totalArea = edge1 * edge2
    totalArea

doZonesTouch (liqGrabZone zone1, liqGrabZone zone2) =>
    XA1 = zone1.startTime
    XA2 = na(zone1.endTime) ? zone1.startTime + EXTEND_ZONES_BY : zone1.endTime
    YA1 = zone1.priceHigh
    YA2 = zone1.priceLow

    XB1 = zone2.startTime
    XB2 = na(zone2.endTime) ? zone2.startTime + EXTEND_ZONES_BY : zone2.endTime
    YB1 = zone2.priceHigh
    YB2 = zone2.priceLow
    intersectionArea = math.max(0, math.min(XA2, XB2) - math.max(XA1, XB1)) * math.max(0, math.min(YA1, YB1) - math.max(YA2, YB2))
    unionArea = areaOfZone(zone1) + areaOfZone(zone2) - intersectionArea
    
    float overlapPercentage = (intersectionArea / unionArea) * 100.0
    if intersectionArea > 0.0
        //log.info(str.tostring(intersectionArea) + " | " + str.tostring(unionArea))
        log.info(str.tostring(overlapPercentage))
    
    if overlapPercentage > 0
        true
    else
        false

combineFunc () =>
    if allLiqGrabZones.size() > 0
        lastCombinations = 999
        while lastCombinations > 0
            lastCombinations := 0
            for i = 0 to allLiqGrabZones.size() - 1
                curZone1 = allLiqGrabZones.get(i)
                for j = 0 to allLiqGrabZones.size() - 1
                    curZone2 = allLiqGrabZones.get(j)
                    if i == j
                        continue
                    if curZone1.liqType != curZone2.liqType
                        continue
                    if curZone1.disabled or curZone2.disabled
                        continue
                    if doZonesTouch(curZone1, curZone2)
                        curZone1.disabled := true
                        curZone2.disabled := true
                        liqGrabZone newZone = liqGrabZone.new(na, na, math.max(curZone1.priceHigh, curZone2.priceHigh), math.min(curZone1.priceLow, curZone2.priceLow), curZone1.liqType)

                        // Combine Zone
                        newZone.startTime := math.min(curZone1.startTime, curZone2.startTime)
                        newZone.endTime := math.max(nz(curZone1.endTime), nz(curZone2.endTime))
                        newZone.endTime := newZone.endTime == 0 ? na : newZone.endTime

                        allLiqGrabZones.unshift(newZone)
                        lastCombinations += 1
//#endregion

if bar_index > last_bar_index - MAX_DISTANCE
    if allLiqList.size() > 0
        for i = 0 to allLiqList.size() - 1
            curLiq = allLiqList.get(i)
            if na(curLiq.info.endTime) and (curLiq.info.liqType == "Buyside" ? close > curLiq.info.price : close < curLiq.info.price)
                curLiq.info.endTime := time
    
    if not na(highestTALiq)
        newLiqInfo = liqInfo.new(time[pivotLenLiq], na, highestTALiq, "Buyside")
        addLiq = true
        if allLiqList.size() > 0
            for i = 0 to allLiqList.size() - 1
                liqInfo curInfo = allLiqList.get(i).info
                if na(curInfo.endTime) and curInfo.liqType == "Buyside"
                    if math.abs(highestTALiq - curInfo.price) < curATR * minATRBetweenPivots
                        addLiq := false
                        break
        if addLiq
            allLiqList.unshift(liq.new(newLiqInfo))
            if allLiqList.size () > SHOW_LAST_X
                safeDeleteLiq(allLiqList.pop())
    
    if not na(lowestTALiq)
        newLiqInfo = liqInfo.new(time[pivotLenLiq], na, lowestTALiq, "Sellside")
        addLiq = true
        if allLiqList.size() > 0
            for i = 0 to allLiqList.size() - 1
                liqInfo curInfo = allLiqList.get(i).info
                if na(curInfo.endTime) and curInfo.liqType == "Sellside"
                    if math.abs(lowestTALiq - curInfo.price) < curATR * minATRBetweenPivots
                        addLiq := false
                        break
        if addLiq
            allLiqList.unshift(liq.new(newLiqInfo))
            if allLiqList.size () > SHOW_LAST_X
                safeDeleteLiq(allLiqList.pop())

var lastHigh = 0
var lastLow = 0

renderHighCircle5 = false
renderHighCircle10 = false
renderHighCircle15 = false
float highCirclePrice = na

renderLowCircle5 = false
renderLowCircle10 = false
renderLowCircle15 = false
float lowCirclePrice = na

if allLiqList.size() > 0
    for i = 0 to allLiqList.size() - 1
        curLiq = allLiqList.get(i)
        if not na(curLiq.info.endTime)
            continue
        if curLiq.info.grabsFound == grabsPerZone
            continue
            
        bodySize = math.abs(close - open)
        wickSize = curLiq.info.liqType == "Buyside" ? (high - math.max(close, open)) : (math.min(close, open) - low)

        curWBR = wickSize / bodySize
        if curLiq.info.liqType == "Buyside"
            if high >= curLiq.info.price and (bar_index - lastHigh > minDist)
                lastHigh := bar_index
                if curWBR >= WBR * 3
                    renderHighCircle15 := true
                else if curWBR >= WBR * 2
                    renderHighCircle10 := true
                else if curWBR >= WBR
                    renderHighCircle5 := true
                highCirclePrice := high + curATR * bubbleOffset / 100.0
                curLiq.info.grabsFound += 1
        else
            if low <= curLiq.info.price and (bar_index - lastLow > minDist)
                lastLow := bar_index
                if curWBR >= WBR * 3
                    renderLowCircle15 := true
                else if curWBR >= WBR * 2
                    renderLowCircle10 := true
                else if curWBR >= WBR
                    renderLowCircle5 := true
                lowCirclePrice := low - curATR * bubbleOffset / 100.0
                curLiq.info.grabsFound += 1

plot(renderHighCircle5 and renderBubbles and barstate.isconfirmed ? highCirclePrice : na, "", buysideColor, bubbleSize, plot.style_circles, false, 0)
plot(renderHighCircle10 and renderBubbles and barstate.isconfirmed ? highCirclePrice : na, "", buysideColor, int(bubbleSize * 1.5), plot.style_circles, false, 0)
plot(renderHighCircle15 and renderBubbles and barstate.isconfirmed ? highCirclePrice : na, "", buysideColor, bubbleSize * 2, plot.style_circles, false, 0)

plot(renderLowCircle5 and renderBubbles and barstate.isconfirmed ? lowCirclePrice : na, "", sellsideColor, bubbleSize, plot.style_circles, false, 0)
plot(renderLowCircle10 and renderBubbles and barstate.isconfirmed ? lowCirclePrice : na, "", sellsideColor, int(bubbleSize * 1.5), plot.style_circles, false, 0)
plot(renderLowCircle15 and renderBubbles and barstate.isconfirmed ? lowCirclePrice : na, "", sellsideColor, bubbleSize * 2, plot.style_circles, false, 0)

if (renderHighCircle5 or renderHighCircle10 or renderHighCircle15) and barstate.isconfirmed
    allLiqGrabZones.unshift(liqGrabZone.new(bar_index, na, high, math.max(close, open), "Buyside"))
    if allLiqGrabZones.size() > MAX_ZONES
        allLiqGrabZones.pop()

else if (renderLowCircle5 or renderLowCircle10 or renderLowCircle15) and barstate.isconfirmed
    allLiqGrabZones.unshift(liqGrabZone.new(bar_index, na, math.min(close, open), low, "Sellside"))
    if allLiqGrabZones.size() > MAX_ZONES
        allLiqGrabZones.pop()


bool renderBreakLabelBuyside = false
bool renderBreakLabelSellside = false

if allLiqGrabZones.size() > 0 and renderLiqGrabZones and barstate.isconfirmed
    for i = 0 to allLiqGrabZones.size() - 1
        curZone = allLiqGrabZones.get(i)
        if na(curZone.endTime) and bar_index > curZone.startTime
            if curZone.liqType == "Buyside"
                if (zoneInvalidation == "Close" ? close : high) > curZone.priceHigh
                    curZone.endTime := bar_index
                    if curZone.endTime - curZone.startTime > MIN_ZONE_SIZE
                        renderBreakLabelBuyside := true
                        if inverseZones and not curZone.ephemeral
                            allLiqGrabZones.unshift(liqGrabZone.new(bar_index, na, curZone.priceHigh, curZone.priceLow, "Sellside", false, true))
            else
                if (zoneInvalidation == "Close" ? close : low) < curZone.priceLow
                    curZone.endTime := bar_index
                    if curZone.endTime - curZone.startTime > MIN_ZONE_SIZE
                        renderBreakLabelSellside := true
                        if inverseZones and not curZone.ephemeral
                            allLiqGrabZones.unshift(liqGrabZone.new(bar_index, na, curZone.priceHigh, curZone.priceLow, "Buyside", false, true))

var lastRetestIndex = 0
float renderRetestLabelBuyside = na
float renderRetestLabelSellside = na

if allLiqGrabZones.size() > 0 and renderLiqGrabZones and bar_index - lastRetestIndex > RETEST_COOLDOWN and barstate.isconfirmed
    for i = 0 to allLiqGrabZones.size() - 1
        curZone = allLiqGrabZones.get(i)
        if bar_index - curZone.startTime < MIN_ZONE_SIZE
            continue
        
        if not na(curZone.endTime)
            continue
        
        middleLine = (curZone.priceLow + curZone.priceHigh) / 2.0
        if curZone.liqType == "Buyside"
            if high > middleLine
                renderRetestLabelBuyside := high
                lastRetestIndex := bar_index
        else
            if low < middleLine
                renderRetestLabelSellside := low
                lastRetestIndex := bar_index

plotshape(not na(renderRetestLabelBuyside) and retestsEnabled, "", shape.labeldown, color = buysideColor, text = "R", location =  location.abovebar, textcolor = color.white, size = size.small)
plotshape(not na(renderRetestLabelSellside) and retestsEnabled, "", shape.labelup, color = sellsideColor, text = "R", location =  location.belowbar, textcolor = color.white, size = size.small)

plotshape(renderBreakLabelBuyside and breaksEnabled, "", shape.labelup, color = color.blue, text = "B", location =  location.belowbar, textcolor = color.white, size = size.small)
plotshape(renderBreakLabelSellside and breaksEnabled, "", shape.labeldown, color = color.blue, text = "B", location =  location.abovebar, textcolor = color.white, size = size.small)

alertcondition((renderHighCircle5 or renderHighCircle10 or renderHighCircle15) and barstate.isconfirmed, "Buyside Liquidity Grab @ {{ticker}}", "Buyside Liquidity Grab @ {{ticker}}")
alertcondition((renderLowCircle5 or renderLowCircle10 or renderLowCircle15) and barstate.isconfirmed, "Sellside Liquidity Grab @ {{ticker}}", "Sellside Liquidity Grab @ {{ticker}}")

alertcondition(not na(renderRetestLabelBuyside) and barstate.isconfirmed, "Buyside Liq Grab Zone Retest @ {{ticker}}", "Buyside Liq Grab Zone Retest @ {{ticker}}")
alertcondition(not na(renderRetestLabelSellside) and barstate.isconfirmed, "Sellside Liq Grab Zone Retest @ {{ticker}}", "Sellside Liq Grab Zone Retest @ {{ticker}}")

alertcondition(renderBreakLabelBuyside and barstate.isconfirmed, "Buyside Liq Grab Zone Break @ {{ticker}}", "Buyside Liq Grab Zone Break @ {{ticker}}")
alertcondition(renderBreakLabelSellside and barstate.isconfirmed, "Sellside Liq Grab Zone Break @ {{ticker}}", "Sellside Liq Grab Zone Break @ {{ticker}}")

if barstate.islast
    handleLiqsFinal()
    for i in box.all
        box.delete(i)
    for i in line.all
        line.delete(i)

    if combineZones
        combineFunc()
    if allLiqGrabZones.size() > 0 and renderLiqGrabZones
        for i = 0 to allLiqGrabZones.size() - 1
            curZone = allLiqGrabZones.get(i)
            if curZone.disabled
                continue
            
            if not na(curZone.endTime)
                if curZone.endTime - curZone.startTime <= MIN_ZONE_SIZE
                    continue
            
            if na(curZone.endTime) or (not na(curZone.endTime) and showInvalidated)
                box.new(curZone.startTime, curZone.priceHigh, nz(curZone.endTime, bar_index + 1) , curZone.priceLow, xloc = xloc.bar_index, extend = na(curZone.endTime) ? extend.right : extend.none, border_width = 0, bgcolor = (curZone.liqType == "Buyside" ? buysideColor : sellsideColor))
                middlePrice = (curZone.priceHigh + curZone.priceLow) / 2
                line.new(curZone.startTime, middlePrice, nz(curZone.endTime, bar_index + 1), middlePrice, color = LINE_COLOR, style = LINE_STYLE == "...." ? line.style_dotted : LINE_STYLE == "____" ? line.style_solid : line.style_dashed, extend = na(curZone.endTime) ? extend.right : extend.none)


typeColoured = input.string(defval='TMA', title='Coloured MA Type: ', options=['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA', 'DEMA', 'TEMA', 'HullMA', 'ZEMA', 'TMA', 'SSMA'])
lenColoured = input.int(defval=18, title='Coloured MA - Length', minval=1)
srcColoured = input(close, title='Coloured MA - Source')
// Fast MA - type, length
typeFast = input.string(defval='EMA', title='Fast MA Type: ', options=['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA', 'DEMA', 'TEMA', 'HullMA', 'ZEMA', 'TMA', 'SSMA'])
lenFast = input.int(defval=21, title='Fast MA - Length', minval=1)
// Medium MA - type, length
typeMedium = input.string(defval='EMA', title='Medium MA Type: ', options=['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA', 'DEMA', 'TEMA', 'HullMA', 'ZEMA', 'TMA', 'SSMA'])
lenMedium = input.int(defval=55, title='Medium MA - Length', minval=1)
// Slow MA - type, length
typeSlow = input.string(defval='EMA', title='Slow MA Type: ', options=['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA', 'DEMA', 'TEMA', 'HullMA', 'ZEMA', 'TMA', 'SSMA'])
lenSlow = input.int(defval=89, title='Slow MA Length', minval=1)
// 3xMA source
ma_src = input(close, title='3xMA and Bollinger Source')

//
filterOption = input.string('SuperTrend+3xMA', title='Signal Filter Option : ', options=['3xMATrend', 'SuperTrend', 'SuperTrend+3xMA', 'ColouredMA', 'No Alerts', 'MACross', 'MACross+ST', 'MACross+3xMA', 'OutsideIn:MACross', 'OutsideIn:MACross+ST', 'OutsideIn:MACross+3xMA'])
//
hideMALines = input(false)
hideSuperTrend = input(true)
hideTrendDirection = input(true)
//
disableFastMAFilter = input(false)
disableMediumMAFilter = input(false)
disableSlowMAFilter = input(false)
//
uKC = false

oiLength = input(8, title='Bollinger Outside In LookBack')
//
SFactor = input.float(3.618, minval=1.0, title='SuperTrend Factor')
SPd = input.int(5, minval=1, title='SuperTrend Length')
//
buyColour_ = input.string('Green', title='BUY Marker Colour: ', options=['Green', 'Lime', 'Aqua', 'DodgerBlue', 'Gray', 'Yellow'])
sellColour_ = input.string('Maroon', title='SELL Marker Colour: ', options=['Maroon', 'Red', 'Fuchsia', 'Blue', 'Black', 'Orange'])

uSuperTrendFilter = filterOption == 'SuperTrend' ? true : false
u3xMATrendFilter = filterOption == '3xMATrend' ? true : false
uBothTrendFilters = filterOption == 'SuperTrend+3xMA' ? true : false
uOIMACrossFilter = filterOption == 'OutsideIn:MACross' ? true : false
uOI3xMAFilter = filterOption == 'OutsideIn:MACross+3xMA' ? true : false
uOISTFilter = filterOption == 'OutsideIn:MACross+ST' ? true : false
uMACrossFilter = filterOption == 'MACross' ? true : false
uMACrossSTFilter = filterOption == 'MACross+ST' ? true : false
uMACross3xMAFilter = filterOption == 'MACross+3xMA' ? true : false
disable3xMAFilter = disableFastMAFilter and disableMediumMAFilter and disableSlowMAFilter
u3xMATrendFilter := disable3xMAFilter ? false : u3xMATrendFilter
disableAllFilters = u3xMATrendFilter or uSuperTrendFilter or uBothTrendFilters or uOI3xMAFilter or uOISTFilter or uOIMACrossFilter or uMACrossFilter or uMACrossSTFilter or uMACross3xMAFilter ? false : true
disableAllFilters := filterOption == 'No Alerts' ? false : disableAllFilters
uSuperTrendFilter := filterOption == 'No Alerts' ? false : uSuperTrendFilter
u3xMATrendFilter := filterOption == 'No Alerts' ? false : u3xMATrendFilter
uBothTrendFilters := filterOption == 'No Alerts' ? false : uBothTrendFilters
uOIMACrossFilter := filterOption == 'No Alerts' ? false : uOIMACrossFilter
uOI3xMAFilter := filterOption == 'No Alerts' ? false : uOI3xMAFilter
uOISTFilter := filterOption == 'No Alerts' ? false : uOISTFilter
uMACrossFilter := filterOption == 'No Alerts' ? false : uMACrossFilter
uMACrossSTFilter := filterOption == 'No Alerts' ? false : uMACrossSTFilter
uMACross3xMAFilter := filterOption == 'No Alerts' ? false : uMACross3xMAFilter
dodgerblue = #1E90FF
lightcoral = #F08080
buyColour = color.green
sellColour = #f44336

buyclr = buyColour_ == 'Lime' ? color.lime : buyColour_ == 'Aqua' ? color.aqua : buyColour_ == 'DodgerBlue' ? dodgerblue : buyColour_ == 'Gray' ? color.gray : buyColour_ == 'Yellow' ? color.yellow : color.green
sellclr = sellColour_ == 'Red' ? color.red : sellColour_ == 'Fuchsia' ? color.fuchsia : sellColour_ == 'Blue' ? color.blue : sellColour_ == 'Black' ? color.black : sellColour_ == 'Orange' ? color.orange : color.maroon

variant(type, src, len) =>
    v1 = ta.sma(src, len)
    v2 = ta.ema(src, len)
    v3 = ta.wma(src, len)
    v4 = ta.vwma(src, len)
    v5 = 0.0
    sma_1 = ta.sma(src, len)
    v5 := na(v5[1]) ? sma_1 : (v5[1] * (len - 1) + src) / len
    v6 = 2 * v2 - ta.ema(v2, len)
    v7 = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len)
    v8 = ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))
    v11 = ta.sma(ta.sma(src, len), len)


    a1 = math.exp(-1.414 * 3.14159 / len)
    b1 = 2 * a1 * math.cos(1.414 * 3.14159 / len)
    c2 = b1
    c3 = -a1 * a1
    c1 = 1 - c2 - c3
    v9 = 0.0
    v9 := c1 * (src + nz(src[1])) / 2 + c2 * nz(v9[1]) + c3 * nz(v9[2])

    e = ta.ema(v1, len)
    v10 = v1 + v1 - e

    type == 'EMA' ? v2 : type == 'WMA' ? v3 : type == 'VWMA' ? v4 : type == 'SMMA' ? v5 : type == 'DEMA' ? v6 : type == 'TEMA' ? v7 : type == 'HullMA' ? v8 : type == 'SSMA' ? v9 : type == 'ZEMA' ? v10 : type == 'TMA' ? v11 : v1


ma_fast = variant(typeFast, ma_src, lenFast)
ma_medium = variant(typeMedium, ma_src, lenMedium)
ma_slow = variant(typeSlow, ma_src, lenSlow)
ma_coloured = variant(typeColoured, srcColoured, lenColoured)

clrdirection = 1
falling_1 = ta.falling(ma_coloured, 2)
clrdirection := ta.rising(ma_coloured, 2) ? 1 : falling_1 ? -1 : nz(clrdirection[1], 1)


madirection = ma_fast > ma_medium and ma_medium > ma_slow ? 1 : ma_fast < ma_medium and ma_medium < ma_slow ? -1 : 0
madirection := disableSlowMAFilter ? ma_fast > ma_medium ? 1 : ma_fast < ma_medium ? -1 : 0 : madirection
madirection := disableMediumMAFilter ? ma_fast > ma_slow ? 1 : ma_fast < ma_slow ? -1 : 0 : madirection
madirection := disableFastMAFilter ? ma_medium > ma_slow ? 1 : ma_medium < ma_slow ? -1 : 0 : madirection
madirection := disableFastMAFilter and disableMediumMAFilter ? ma_coloured > ma_slow ? 1 : -1 : madirection
madirection := disableFastMAFilter and disableSlowMAFilter ? ma_coloured > ma_medium ? 1 : -1 : madirection
madirection := disableSlowMAFilter and disableMediumMAFilter ? ma_coloured > ma_fast ? 1 : -1 : madirection


SUp = hl2 - SFactor * ta.atr(SPd)
SDn = hl2 + SFactor * ta.atr(SPd)

STrendUp = 0.0
STrendDown = 0.0
STrendUp := close[1] > STrendUp[1] ? math.max(SUp, STrendUp[1]) : SUp
STrendDown := close[1] < STrendDown[1] ? math.min(SDn, STrendDown[1]) : SDn
STrend = 0
STrend := close > STrendDown[1] ? 1 : close < STrendUp[1] ? -1 : nz(STrend[1], 1)
Tsl = STrend == 1 ? STrendUp : STrendDown





noiupper = math.abs(ta.highestbars(oiLength))
noilower = math.abs(ta.lowestbars(oiLength))



dcolour = madirection == 1 ? color.green : madirection == -1 ? color.red : color.yellow
plotshape(hideTrendDirection ? na : madirection, title='3xMA Trend Direction', location=location.bottom, style=shape.square, color=dcolour)

_3xmabuy = 0
_3xmasell = 0
_3xmabuy := clrdirection == 1 and close > ma_fast and madirection == 1 ? nz(_3xmabuy[1]) + 1 : clrdirection == 1 and madirection == 1 ? nz(_3xmabuy[1]) > 0 ? nz(_3xmabuy[1]) + 1 : 0 : 0
_3xmasell := clrdirection == -1 and close < ma_fast and madirection == -1 ? nz(_3xmasell[1]) + 1 : clrdirection == -1 and madirection == -1 ? nz(_3xmasell[1]) > 0 ? nz(_3xmasell[1]) + 1 : 0 : 0
//

// SuperTrend Filtering
stbuy = 0
stsell = 0
stbuy := clrdirection == 1 and STrend == 1 ? nz(stbuy[1]) + 1 : 0
stsell := clrdirection == -1 and STrend == -1 ? nz(stsell[1]) + 1 : 0


st3xmabuy = 0
st3xmasell = 0
st3xmabuy := (disable3xMAFilter or _3xmabuy > 0) and stbuy > 0 ? nz(st3xmabuy[1]) + 1 : 0
st3xmasell := (disable3xMAFilter or _3xmasell > 0) and stsell > 0 ? nz(st3xmasell[1]) + 1 : 0


oiMACrossbuy = 0
oiMACrosssell = 0
oi3xmabuy = 0
oi3xmasell = 0
oi3xmabuy := oiMACrossbuy > 0 and (disable3xMAFilter or madirection == 1) ? nz(oi3xmabuy[1]) + 1 : 0
oi3xmasell := oiMACrosssell > 0 and (disable3xMAFilter or madirection == -1) ? nz(oi3xmasell[1]) + 1 : 0


oistbuy = 0
oistsell = 0
oistbuy := oiMACrossbuy > 0 and STrend == 1 ? nz(oistbuy[1]) + 1 : 0
oistsell := oiMACrosssell > 0 and STrend == -1 ? nz(oistsell[1]) + 1 : 0


macrossSTbuy = 0
macrossSTsell = 0
macrossSTbuy := ta.crossover(ma_fast, ma_coloured) and STrend == 1 ? nz(macrossSTbuy[1]) + 1 : 0
macrossSTsell := ta.crossunder(ma_fast, ma_coloured) and STrend == -1 ? nz(macrossSTsell[1]) + 1 : 0


macross3xMAbuy = 0
macross3xMAsell = 0
macross3xMAbuy := ta.crossover(ma_fast, ma_coloured) and (disable3xMAFilter or madirection == 1) ? nz(macross3xMAbuy[1]) + 1 : 0
macross3xMAsell := ta.crossunder(ma_fast, ma_coloured) and (disable3xMAFilter or madirection == -1) ? nz(macross3xMAsell[1]) + 1 : 0


long = u3xMATrendFilter and _3xmabuy == 1 or uSuperTrendFilter and stbuy == 1 or uBothTrendFilters and st3xmabuy == 1 or uOI3xMAFilter and oi3xmabuy == 1 or uOISTFilter and oistbuy == 1 or uOIMACrossFilter and oiMACrossbuy == 1 or uMACrossSTFilter and macrossSTbuy == 1 or uMACross3xMAFilter and macross3xMAbuy == 1
short = u3xMATrendFilter and _3xmasell == 1 or uSuperTrendFilter and stsell == 1 or uBothTrendFilters and st3xmasell == 1 or uOI3xMAFilter and oi3xmasell == 1 or uOISTFilter and oistsell == 1 or uOIMACrossFilter and oiMACrosssell == 1 or uMACrossSTFilter and macrossSTsell == 1 or uMACross3xMAFilter and macross3xMAsell == 1


plotshape(long ? long : na, title='Long Line Marker', location=location.belowbar, style=shape.arrowup, color=buyclr, size=size.auto, text='â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„', textcolor=buyclr, transp=20)
plotshape(short ? short : na, title='Short Line Marker', location=location.abovebar, style=shape.arrowdown, color=#f44336, size=size.auto, text='â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„', textcolor=sellclr, transp=20)


hbuy = 0
hsell = 0
hbuy := clrdirection == 1 ? nz(hbuy[1]) + 1 : 0
hsell := clrdirection == -1 ? nz(hsell[1]) + 1 : 0

macrossbuy = 0
macrosssell = 0
macrossbuy := ta.crossover(ma_fast, ma_coloured) ? nz(macrossbuy[1]) + 1 : 0
macrosssell := ta.crossunder(ma_fast, ma_coloured) ? nz(macrosssell[1]) + 1 : 0
//
along = disableAllFilters and hbuy == 1 or uMACrossFilter and macrossbuy == 1
ashort = disableAllFilters and hsell == 1 or uMACrossFilter and macrosssell == 1
plotarrow(along ? 1 : ashort ? -1 : na, title='ColouredMA or MACross Arrow', colorup=color.new(buyColour, 20), colordown=color.new(sellColour, 20), maxheight=100, minheight=50)

long := long or along
short := short or ashort

alertcondition(long or short, title='Signal Alert', message='Sniper enter')

//EOF


// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)