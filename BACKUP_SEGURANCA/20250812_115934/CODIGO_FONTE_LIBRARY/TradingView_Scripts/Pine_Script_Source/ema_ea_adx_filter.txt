/*
  Enhanced EMA Crossover Momentum EA with ADX Filter
  - Buy: Fast EMA crosses above Slow EMA + ADX above threshold
  - Sell: Fast EMA crosses below Slow EMA + ADX above threshold
  - Multiple orders as price moves IN FAVOR of position
  - Individual trailing stops for each order
  - Momentum-based position scaling
  - ADX filter for trend strength confirmation
*/

extern string ______1 = "=== EMA Settings ===";
extern int FastEMAPeriod  = 50;       // Fast EMA period
extern int SlowEMAPeriod  = 100;      // Slow EMA period

extern string ______2 = "=== ADX Filter Settings ===";
extern bool UseADXFilter  = true;     // Enable ADX filter
extern int ADXPeriod      = 14;       // ADX period
extern double ADXThreshold = 25.0;    // Minimum ADX value to trade
extern bool CloseOnLowADX = true;     // Close all orders when ADX drops below threshold

extern string ______3 = "=== Order Management ===";
extern double LotSize     = 0.1;      // Lot size for each order
extern int MaxOrders      = 5;        // Maximum orders in one direction
extern int OrderDistance  = 200;      // Distance between orders (points)
extern int MagicNumber    = 12345;    // Magic number
extern int Slippage       = 3;        // Slippage

extern string ______4 = "=== Risk Management ===";
extern int StopLoss       = 1000;     // Stop Loss (points)
extern int TakeProfit     = 1500;     // Take Profit (points)
extern bool UseTrailingStop = true;   // Enable trailing stop
extern int TrailingStart  = 200;      // Start trailing after X points profit
extern int TrailingStop   = 150;      // Trailing distance (points)
extern int TrailingStep   = 50;       // Minimum step to move trail (points)

extern string ______5 = "=== Momentum Settings ===";
extern bool UseMomentumTrading = true; // Enable momentum-based entries
extern double MomentumMultiplier = 1.2; // Lot multiplier for momentum orders
extern int MaxMomentumLevels = 3;      // Maximum momentum levels

extern string ______6 = "=== Display Settings ===";
extern bool ShowEMALines = true;      // Show EMA lines on chart
extern bool ShowOrderInfo = true;     // Show order information

// Global variables
int currentDirection = 0;  // 1 = Buy trend, -1 = Sell trend, 0 = No trend
double lastOrderPrice = 0;
bool gridActive = false;
int gridLevel = 0;
bool adxTradingEnabled = true; // Tracks if ADX allows trading

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    Print("Enhanced 2MA Momentum EA with ADX Filter initialized");
    Print("Fast EMA: ", FastEMAPeriod, " | Slow EMA: ", SlowEMAPeriod);
    Print("ADX Filter: ", (UseADXFilter ? "Enabled" : "Disabled"));
    if(UseADXFilter)
    {
        Print("ADX Period: ", ADXPeriod, " | ADX Threshold: ", DoubleToStr(ADXThreshold, 1));
        Print("Close on Low ADX: ", (CloseOnLowADX ? "Yes" : "No"));
    }
    Print("Order Distance: ", OrderDistance, " points");
    Print("Max Orders: ", MaxOrders);
    Print("Momentum Trading: ", (UseMomentumTrading ? "Enabled" : "Disabled"));
    Print("Momentum Multiplier: ", MomentumMultiplier);
    Print("Trailing Stop: ", (UseTrailingStop ? "Enabled" : "Disabled"));
    
    return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert start function                                            |
//+------------------------------------------------------------------+
int start()
{
    // Check ADX condition first
    if(UseADXFilter)
        CheckADXCondition();
    
    // Check for EMA crossover signals only if ADX allows trading
    if(!UseADXFilter || adxTradingEnabled)
        CheckEMACrossover();
    
    // Place momentum orders if conditions are met
    if(currentDirection != 0 && (!UseADXFilter || adxTradingEnabled))
        ManageMomentumOrders();
    
    // Manage trailing stops
    if(UseTrailingStop)
        ManageTrailingStops();
    
    // Display information
    if(ShowOrderInfo)
        DisplayOrderInfo();
    
    // Draw EMA lines if enabled
    if(ShowEMALines)
        DrawEMALines();
    
    return 0;
}

//+------------------------------------------------------------------+
//| Get ADX value                                                    |
//+------------------------------------------------------------------+
double GetADX(int shift = 0)
{
    return iADX(NULL, 0, ADXPeriod, PRICE_CLOSE, MODE_MAIN, shift);
}

//+------------------------------------------------------------------+
//| Check ADX condition for trading                                  |
//+------------------------------------------------------------------+
void CheckADXCondition()
{
    double currentADX = GetADX(0);
    bool previousADXEnabled = adxTradingEnabled;
    
    // Update ADX trading status
    adxTradingEnabled = (currentADX >= ADXThreshold);
    
    // Log ADX status changes
    if(previousADXEnabled != adxTradingEnabled)
    {
        if(adxTradingEnabled)
        {
            Print("ADX Filter: Trading ENABLED - ADX = ", DoubleToStr(currentADX, 2), " (>= ", DoubleToStr(ADXThreshold, 1), ")");
        }
        else
        {
            Print("ADX Filter: Trading DISABLED - ADX = ", DoubleToStr(currentADX, 2), " (< ", DoubleToStr(ADXThreshold, 1), ")");
            
            // Close all orders if ADX drops below threshold and CloseOnLowADX is enabled
            if(CloseOnLowADX)
            {
                Print("Closing all orders due to low ADX");
                CloseAllOrders();
                currentDirection = 0;
                gridActive = false;
                gridLevel = 0;
                lastOrderPrice = 0;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Get EMA value                                                    |
//+------------------------------------------------------------------+
double GetEMA(int period, int shift = 0)
{
    return iMA(NULL, 0, period, 0, MODE_EMA, PRICE_CLOSE, shift);
}

//+------------------------------------------------------------------+
//| Check for EMA crossover                                          |
//+------------------------------------------------------------------+
void CheckEMACrossover()
{
    double fastEMA_0 = GetEMA(FastEMAPeriod, 0);
    double fastEMA_1 = GetEMA(FastEMAPeriod, 1);
    double slowEMA_0 = GetEMA(SlowEMAPeriod, 0);
    double slowEMA_1 = GetEMA(SlowEMAPeriod, 1);
    
    // Additional ADX check for crossover signals
    bool adxAllowsTrading = true;
    if(UseADXFilter)
    {
        double currentADX = GetADX(0);
        adxAllowsTrading = (currentADX >= ADXThreshold);
    }
    
    // Bullish crossover: Fast EMA crosses above Slow EMA + ADX confirmation
    if(fastEMA_1 <= slowEMA_1 && fastEMA_0 > slowEMA_0 && adxAllowsTrading)
    {
        if(currentDirection != 1)
        {
            Print("Bullish EMA crossover detected with ADX confirmation");
            CloseAllOrders();
            currentDirection = 1;
            gridActive = false;
            gridLevel = 0;
            lastOrderPrice = 0;
            
            // Place first buy order
            PlaceOrder(OP_BUY, "EMA Crossover Buy");
        }
    }
    // Bearish crossover: Fast EMA crosses below Slow EMA + ADX confirmation
    else if(fastEMA_1 >= slowEMA_1 && fastEMA_0 < slowEMA_0 && adxAllowsTrading)
    {
        if(currentDirection != -1)
        {
            Print("Bearish EMA crossover detected with ADX confirmation");
            CloseAllOrders();
            currentDirection = -1;
            gridActive = false;
            gridLevel = 0;
            lastOrderPrice = 0;
            
            // Place first sell order
            PlaceOrder(OP_SELL, "EMA Crossover Sell");
        }
    }
}

//+------------------------------------------------------------------+
//| Manage momentum orders                                           |
//+------------------------------------------------------------------+
void ManageMomentumOrders()
{
    int openOrders = CountOrdersByDirection(currentDirection);
    
    if(openOrders >= MaxOrders)
        return;
    
    double currentPrice = (currentDirection == 1) ? Ask : Bid;
    
    // If no orders exist, place the first one
    if(openOrders == 0)
    {
        if(currentDirection == 1)
            PlaceOrder(OP_BUY, "Initial Buy #1");
        else
            PlaceOrder(OP_SELL, "Initial Sell #1");
        return;
    }
    
    // Check if we need to place additional momentum orders
    double lastPrice = GetLastOrderPrice(currentDirection);
    
    if(lastPrice > 0)
    {
        bool placeNewOrder = false;
        string comment = "";
        
        if(currentDirection == 1) // Buy direction - add orders as price moves UP
        {
            // Place new buy order if price moved UP by OrderDistance
            if(currentPrice >= lastPrice + (OrderDistance * Point))
            {
                placeNewOrder = true;
                comment = "Momentum Buy #" + IntegerToString(openOrders + 1);
            }
        }
        else if(currentDirection == -1) // Sell direction - add orders as price moves DOWN
        {
            // Place new sell order if price moved DOWN by OrderDistance
            if(currentPrice <= lastPrice - (OrderDistance * Point))
            {
                placeNewOrder = true;
                comment = "Momentum Sell #" + IntegerToString(openOrders + 1);
            }
        }
        
        if(placeNewOrder)
        {
            double lotSize = LotSize;
            
            // Apply multiplier for momentum scaling
            if(UseMomentumTrading && openOrders > 0)
            {
                lotSize = LotSize * MathPow(MomentumMultiplier, MathMin(openOrders, MaxMomentumLevels));
            }
            
            if(currentDirection == 1)
                PlaceOrder(OP_BUY, comment, lotSize);
            else
                PlaceOrder(OP_SELL, comment, lotSize);
                
            Print("Momentum order placed - Direction: ", (currentDirection == 1 ? "BUY" : "SELL"),
                  " | Order #", openOrders + 1, " | Price: ", DoubleToStr(currentPrice, Digits),
                  " | Lot Size: ", DoubleToStr(lotSize, 2));
        }
    }
}

//+------------------------------------------------------------------+
//| Place an order                                                   |
//+------------------------------------------------------------------+
void PlaceOrder(int orderType, string comment, double lots = 0)
{
    if(lots == 0) lots = LotSize;
    
    double price, sl, tp;
    color clr;
    
    if(orderType == OP_BUY)
    {
        price = Ask;
        sl = (StopLoss > 0) ? price - (StopLoss * Point) : 0;
        tp = (TakeProfit > 0) ? price + (TakeProfit * Point) : 0;
        clr = clrBlue;
    }
    else // OP_SELL
    {
        price = Bid;
        sl = (StopLoss > 0) ? price + (StopLoss * Point) : 0;
        tp = (TakeProfit > 0) ? price - (TakeProfit * Point) : 0;
        clr = clrRed;
    }
    
    // Normalize prices
    price = NormalizeDouble(price, Digits);
    if(sl > 0) sl = NormalizeDouble(sl, Digits);
    if(tp > 0) tp = NormalizeDouble(tp, Digits);
    
    int ticket = OrderSend(Symbol(), orderType, lots, price, Slippage, sl, tp, 
                          comment, MagicNumber, 0, clr);
    
    if(ticket > 0)
    {
        Print("Order placed successfully: ", comment, " | Ticket: ", ticket, 
              " | Price: ", DoubleToStr(price, Digits), " | Lots: ", DoubleToStr(lots, 2));
        lastOrderPrice = price;
    }
    else
    {
        Print("Error placing order: ", GetLastError(), " | Comment: ", comment);
    }
}

//+------------------------------------------------------------------+
//| Count orders by direction                                        |
//+------------------------------------------------------------------+
int CountOrdersByDirection(int direction)
{
    int count = 0;
    
    for(int i = 0; i < OrdersTotal(); i++)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
            {
                if((direction == 1 && OrderType() == OP_BUY) ||
                   (direction == -1 && OrderType() == OP_SELL))
                {
                    count++;
                }
            }
        }
    }
    
    return count;
}

//+------------------------------------------------------------------+
//| Get last order price in direction                               |
//+------------------------------------------------------------------+
double GetLastOrderPrice(int direction)
{
    double lastPrice = 0;
    datetime lastTime = 0;
    
    for(int i = 0; i < OrdersTotal(); i++)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
            {
                if((direction == 1 && OrderType() == OP_BUY) ||
                   (direction == -1 && OrderType() == OP_SELL))
                {
                    if(OrderOpenTime() > lastTime)
                    {
                        lastTime = OrderOpenTime();
                        lastPrice = OrderOpenPrice();
                    }
                }
            }
        }
    }
    
    return lastPrice;
}

//+------------------------------------------------------------------+
//| Manage trailing stops for all positions                         |
//+------------------------------------------------------------------+
void ManageTrailingStops()
{
    for(int i = 0; i < OrdersTotal(); i++)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
            {
                double openPrice = OrderOpenPrice();
                double currentSL = OrderStopLoss();
                int orderType = OrderType();
                int ticket = OrderTicket();
                
                double newSL = 0;
                bool modifyOrder = false;
                double currentProfit = 0;
                
                if(orderType == OP_BUY)
                {
                    currentProfit = Bid - openPrice;
                    
                    // Check if profit is enough to start trailing
                    if(currentProfit >= TrailingStart * Point)
                    {
                        newSL = NormalizeDouble(Bid - (TrailingStop * Point), Digits);
                        
                        // Move SL only if new SL is better than current
                        if(currentSL == 0 || newSL > currentSL + (TrailingStep * Point))
                        {
                            modifyOrder = true;
                        }
                    }
                }
                else if(orderType == OP_SELL)
                {
                    currentProfit = openPrice - Ask;
                    
                    // Check if profit is enough to start trailing
                    if(currentProfit >= TrailingStart * Point)
                    {
                        newSL = NormalizeDouble(Ask + (TrailingStop * Point), Digits);
                        
                        // Move SL only if new SL is better than current
                        if(currentSL == 0 || newSL < currentSL - (TrailingStep * Point))
                        {
                            modifyOrder = true;
                        }
                    }
                }
                
                if(modifyOrder)
                {
                    // Ensure minimum distance from current price
                    double minDistance = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
                    
                    if(orderType == OP_BUY)
                    {
                        if(Bid - newSL < minDistance)
                            newSL = NormalizeDouble(Bid - minDistance, Digits);
                    }
                    else
                    {
                        if(newSL - Ask < minDistance)
                            newSL = NormalizeDouble(Ask + minDistance, Digits);
                    }
                    
                    bool result = OrderModify(ticket, openPrice, newSL, OrderTakeProfit(), 0, clrYellow);
                    
                    if(result)
                    {
                        Print("Trailing stop updated for ticket ", ticket, 
                              " - New SL: ", DoubleToStr(newSL, Digits));
                    }
                    else
                    {
                        Print("Error updating trailing stop for ticket ", ticket, ": ", GetLastError());
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Close all orders                                                 |
//+------------------------------------------------------------------+
void CloseAllOrders()
{
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
            {
                bool result = false;
                
                if(OrderType() == OP_BUY)
                    result = OrderClose(OrderTicket(), OrderLots(), Bid, Slippage, clrRed);
                else if(OrderType() == OP_SELL)
                    result = OrderClose(OrderTicket(), OrderLots(), Ask, Slippage, clrRed);
                
                if(result)
                    Print("Order closed: ", OrderTicket());
                else
                    Print("Error closing order ", OrderTicket(), ": ", GetLastError());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Display order information on chart                              |
//+------------------------------------------------------------------+
void DisplayOrderInfo()
{
    string info = "";
    int buyOrders = CountOrdersByDirection(1);
    int sellOrders = CountOrdersByDirection(-1);
    double totalProfit = 0;
    double currentADX = 0;
    
    if(UseADXFilter)
        currentADX = GetADX(0);
    
    for(int i = 0; i < OrdersTotal(); i++)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
            {
                totalProfit += OrderProfit() + OrderSwap() + OrderCommission();
            }
        }
    }
    
    info += "=== Enhanced 2MA Momentum EA with ADX ===\n";
    info += "Direction: " + (currentDirection == 1 ? "BUY" : (currentDirection == -1 ? "SELL" : "NONE")) + "\n";
    if(UseADXFilter)
    {
        info += "ADX: " + DoubleToStr(currentADX, 1) + " | Status: " + (adxTradingEnabled ? "ENABLED" : "DISABLED") + "\n";
        info += "ADX Threshold: " + DoubleToStr(ADXThreshold, 1) + "\n";
    }
    info += "Buy Orders: " + IntegerToString(buyOrders) + "\n";
    info += "Sell Orders: " + IntegerToString(sellOrders) + "\n";
    info += "Total Profit: " + DoubleToStr(totalProfit, 2) + "\n";
    info += "Fast EMA: " + DoubleToStr(GetEMA(FastEMAPeriod), Digits) + "\n";
    info += "Slow EMA: " + DoubleToStr(GetEMA(SlowEMAPeriod), Digits);
    
    Comment(info);
}

//+------------------------------------------------------------------+
//| Draw EMA lines on chart                                          |
//+------------------------------------------------------------------+
void DrawEMALines()
{
    // Create or update EMA indicators
    static bool indicatorsCreated = false;
    
    if(!indicatorsCreated)
    {
        // This will show the EMAs as separate indicators
        // Note: In a real EA, you might want to use ObjectCreate to draw lines
        indicatorsCreated = true;
    }
    
    // You can add custom line drawing here if needed
    // For now, the EMAs will be visible through the iMA calls
}