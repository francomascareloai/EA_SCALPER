//+------------------------------------------------------------------+
//|                                           BreakoutRobot.mq4      |
//|                                  Copyright 2025, Your Company    |
//|                                             https://www.mql4.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025"
#property link      "https://www.mql4.com"
#property version   "1.00"
#property strict

//--- Input parameters
input string   separator1 = "=== Breakout Settings ===";
input int      InpLookbackCandles = 20;        // Number of candles to check for high/low
input int      InpBreakoutBuffer  = 10;        // Buffer in points for breakout level

input string   separator2 = "=== Risk Management ===";
input double   InpLotSize        = 0.1;        // Lot size
input int      InpStopLoss       = 100;        // Stop Loss in points
input int      InpTakeProfit     = 200;        // Take Profit in points
input bool     InpUseTrailingStop = true;      // Use trailing stop
input int      InpTrailingStart  = 50;         // Trailing stop start in points
input int      InpTrailingStep   = 10;         // Trailing stop step in points

input string   separator3 = "=== News Filter ===";
input bool     InpUseNewsFilter  = true;       // Enable news filter
input int      InpNewsMinutesBefore = 30;      // Minutes before news to avoid trading
input int      InpNewsMinutesAfter  = 30;      // Minutes after news to avoid trading
input string   InpNewsCurrencies = "USD,EUR,GBP,JPY,CAD,AUD,NZD,CHF"; // Currencies to monitor

input string   separator4 = "=== Time Filter ===";
input bool     InpUseTimeFilter  = false;      // Enable time filter
input string   InpStartTime      = "08:00";    // Start trading time
input string   InpEndTime        = "18:00";    // End trading time

input string   separator5 = "=== Other Settings ===";
input int      InpMagicNumber    = 12345;      // Magic number
input string   InpComment        = "BreakoutRobot"; // Order comment
input int      InpSlippage       = 3;          // Slippage in points

//--- Global variables
double         g_upperLevel = 0;
double         g_lowerLevel = 0;
datetime       g_lastNewsCheck = 0;
bool           g_newsFilterActive = false;
datetime       g_lastBarTime = 0;
int            g_buyOrderTicket = 0;
int            g_sellOrderTicket = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Initialize levels
    CalculateBreakoutLevels();
    
    Print("Breakout Robot EA initialized successfully");
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Delete pending orders on EA removal
    if(reason == REASON_REMOVE)
    {
        DeleteAllPendingOrders();
    }
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Check if new bar formed
    if(!IsNewBar()) return;
    
    // Update news filter status
    UpdateNewsFilter();
    
    // Check time filter
    if(InpUseTimeFilter && !IsWithinTradingHours()) return;
    
    // Check if news filter is active
    if(InpUseNewsFilter && g_newsFilterActive)
    {
        DeleteAllPendingOrders();
        return;
    }
    
    // Calculate new breakout levels
    CalculateBreakoutLevels();
    
    // Manage existing positions
    ManagePositions();
    
    // Check if we already have an open position - no stacking
    if(HasOpenPosition()) return;
    
    // Place pending orders if none exist
    if(!HasPendingOrders())
    {
        PlacePendingOrders();
    }
    else
    {
        // Update existing pending orders with new levels
        UpdatePendingOrders();
    }
}

//+------------------------------------------------------------------+
//| Check if new bar formed                                          |
//+------------------------------------------------------------------+
bool IsNewBar()
{
    datetime currentBarTime = Time[0];
    if(currentBarTime != g_lastBarTime)
    {
        g_lastBarTime = currentBarTime;
        return true;
    }
    return false;
}

//+------------------------------------------------------------------+
//| Calculate breakout levels                                        |
//+------------------------------------------------------------------+
void CalculateBreakoutLevels()
{
    double highest = 0;
    double lowest = 999999;
    
    // Find highest high and lowest low of last N candles (excluding current)
    for(int i = 1; i <= InpLookbackCandles; i++)
    {
        double high = High[i];
        double low = Low[i];
        
        if(high > highest) highest = high;
        if(low < lowest) lowest = low;
    }
    
    g_upperLevel = highest + InpBreakoutBuffer * Point;
    g_lowerLevel = lowest - InpBreakoutBuffer * Point;
    
    // Normalize prices
    g_upperLevel = NormalizeDouble(g_upperLevel, Digits);
    g_lowerLevel = NormalizeDouble(g_lowerLevel, Digits);
}

//+------------------------------------------------------------------+
//| Place pending orders                                             |
//+------------------------------------------------------------------+
void PlacePendingOrders()
{
    // Only place orders if levels are away from current price
    if(g_upperLevel > Ask + 10 * Point)
    {
        // Place Buy Stop order
        double sl = g_upperLevel - InpStopLoss * Point;
        double tp = g_upperLevel + InpTakeProfit * Point;
        
        sl = NormalizeDouble(sl, Digits);
        tp = NormalizeDouble(tp, Digits);
        
        int ticket = OrderSend(Symbol(), OP_BUYSTOP, InpLotSize, g_upperLevel, InpSlippage, sl, tp, InpComment, InpMagicNumber, 0, clrBlue);
        
        if(ticket > 0)
        {
            g_buyOrderTicket = ticket;
        }
        else
        {
            Print("Error placing Buy Stop order: ", GetLastError());
        }
    }
    
    if(g_lowerLevel < Bid - 10 * Point)
    {
        // Place Sell Stop order
        double sl = g_lowerLevel + InpStopLoss * Point;
        double tp = g_lowerLevel - InpTakeProfit * Point;
        
        sl = NormalizeDouble(sl, Digits);
        tp = NormalizeDouble(tp, Digits);
        
        int ticket = OrderSend(Symbol(), OP_SELLSTOP, InpLotSize, g_lowerLevel, InpSlippage, sl, tp, InpComment, InpMagicNumber, 0, clrRed);
        
        if(ticket > 0)
        {
            g_sellOrderTicket = ticket;
        }
        else
        {
            Print("Error placing Sell Stop order: ", GetLastError());
        }
    }
}

//+------------------------------------------------------------------+
//| Update existing pending orders                                   |
//+------------------------------------------------------------------+
void UpdatePendingOrders()
{
    // Update Buy Stop order
    if(g_buyOrderTicket > 0 && OrderSelect(g_buyOrderTicket, SELECT_BY_TICKET))
    {
        if(OrderType() == OP_BUYSTOP && MathAbs(OrderOpenPrice() - g_upperLevel) > 5 * Point)
        {
            double sl = NormalizeDouble(g_upperLevel - InpStopLoss * Point, Digits);
            double tp = NormalizeDouble(g_upperLevel + InpTakeProfit * Point, Digits);
            
            if(!OrderModify(g_buyOrderTicket, g_upperLevel, sl, tp, 0, clrBlue))
            {
                Print("Error modifying Buy Stop order: ", GetLastError());
                // If modification fails, delete and recreate
                if(OrderDelete(g_buyOrderTicket))
                    g_buyOrderTicket = 0;
            }
        }
    }
    else
    {
        g_buyOrderTicket = 0; // Order doesn't exist anymore
    }
    
    // Update Sell Stop order
    if(g_sellOrderTicket > 0 && OrderSelect(g_sellOrderTicket, SELECT_BY_TICKET))
    {
        if(OrderType() == OP_SELLSTOP && MathAbs(OrderOpenPrice() - g_lowerLevel) > 5 * Point)
        {
            double sl = NormalizeDouble(g_lowerLevel + InpStopLoss * Point, Digits);
            double tp = NormalizeDouble(g_lowerLevel - InpTakeProfit * Point, Digits);
            
            if(!OrderModify(g_sellOrderTicket, g_lowerLevel, sl, tp, 0, clrRed))
            {
                Print("Error modifying Sell Stop order: ", GetLastError());
                // If modification fails, delete and recreate
                if(OrderDelete(g_sellOrderTicket))
                    g_sellOrderTicket = 0;
            }
        }
    }
    else
    {
        g_sellOrderTicket = 0; // Order doesn't exist anymore
    }
}

//+------------------------------------------------------------------+
//| Check if we have open positions                                  |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == InpMagicNumber)
            {
                if(OrderType() == OP_BUY || OrderType() == OP_SELL)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

//+------------------------------------------------------------------+
//| Check if we have pending orders                                  |
//+------------------------------------------------------------------+
bool HasPendingOrders()
{
    bool hasBuyOrder = false;
    bool hasSellOrder = false;
    
    if(g_buyOrderTicket > 0 && OrderSelect(g_buyOrderTicket, SELECT_BY_TICKET))
    {
        if(OrderType() == OP_BUYSTOP)
            hasBuyOrder = true;
        else
            g_buyOrderTicket = 0;
    }
    
    if(g_sellOrderTicket > 0 && OrderSelect(g_sellOrderTicket, SELECT_BY_TICKET))
    {
        if(OrderType() == OP_SELLSTOP)
            hasSellOrder = true;
        else
            g_sellOrderTicket = 0;
    }
    
    return (hasBuyOrder || hasSellOrder);
}

//+------------------------------------------------------------------+
//| Delete all pending orders                                        |
//+------------------------------------------------------------------+
void DeleteAllPendingOrders()
{
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == InpMagicNumber)
            {
                if(OrderType() == OP_BUYSTOP || OrderType() == OP_SELLSTOP ||
                   OrderType() == OP_BUYLIMIT || OrderType() == OP_SELLLIMIT)
                {
                    int ticket = OrderTicket();
                    if(OrderDelete(ticket))
                    {
                        if(ticket == g_buyOrderTicket)
                            g_buyOrderTicket = 0;
                        if(ticket == g_sellOrderTicket)
                            g_sellOrderTicket = 0;
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Manage existing positions (trailing stop)                       |
//+------------------------------------------------------------------+
void ManagePositions()
{
    if(!InpUseTrailingStop) return;
    
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == InpMagicNumber)
            {
                if(OrderType() == OP_BUY)
                {
                    double currentSL = OrderStopLoss();
                    double openPrice = OrderOpenPrice();
                    
                    // Check if position is in profit by trailing start amount
                    if(Bid > openPrice + InpTrailingStart * Point)
                    {
                        double newSL = NormalizeDouble(Bid - InpTrailingStart * Point, Digits);
                        
                        // Move SL only if it's better than current
                        if(newSL > currentSL + InpTrailingStep * Point || currentSL == 0)
                        {
                            if(!OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrBlue))
                            {
                                Print("Error modifying Buy position trailing stop: ", GetLastError());
                            }
                        }
                    }
                }
                else if(OrderType() == OP_SELL)
                {
                    double currentSL = OrderStopLoss();
                    double openPrice = OrderOpenPrice();
                    
                    // Check if position is in profit by trailing start amount
                    if(Ask < openPrice - InpTrailingStart * Point)
                    {
                        double newSL = NormalizeDouble(Ask + InpTrailingStart * Point, Digits);
                        
                        // Move SL only if it's better than current
                        if(newSL < currentSL - InpTrailingStep * Point || currentSL == 0)
                        {
                            if(!OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0, clrRed))
                            {
                                Print("Error modifying Sell position trailing stop: ", GetLastError());
                            }
                        }
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Update news filter status                                        |
//+------------------------------------------------------------------+
void UpdateNewsFilter()
{
    if(!InpUseNewsFilter) return;
    
    // Check news filter every minute
    if(TimeCurrent() - g_lastNewsCheck < 60) return;
    
    g_lastNewsCheck = TimeCurrent();
    g_newsFilterActive = IsNewsTime();
}

//+------------------------------------------------------------------+
//| Check if it's news time                                          |
//+------------------------------------------------------------------+
bool IsNewsTime()
{
    // This is a simplified news filter
    // In a real implementation, you would connect to a news feed API
    // or use a news calendar service
    
    datetime currentTime = TimeCurrent();
    int hour = TimeHour(currentTime);
    int minute = TimeMinute(currentTime);
    
    // Avoid trading during major news times (simplified example)
    // Major news usually at: 8:30, 10:00, 14:00, 15:30 GMT
    if((hour == 8 && minute >= 25 && minute <= 35) ||
       (hour == 10 && minute >= 0 && minute <= 10) ||
       (hour == 14 && minute >= 0 && minute <= 10) ||
       (hour == 15 && minute >= 25 && minute <= 35))
    {
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Check if within trading hours                                    |
//+------------------------------------------------------------------+
bool IsWithinTradingHours()
{
    if(!InpUseTimeFilter) return true;
    
    datetime currentTime = TimeCurrent();
    int hour = TimeHour(currentTime);
    int minute = TimeMinute(currentTime);
    int currentTimeInt = hour * 100 + minute;
    
    // Parse start and end times (simplified parsing)
    string startHour = StringSubstr(InpStartTime, 0, 2);
    string startMin = StringSubstr(InpStartTime, 3, 2);
    string endHour = StringSubstr(InpEndTime, 0, 2);
    string endMin = StringSubstr(InpEndTime, 3, 2);
    
    int startTime = (int)StringToInteger(startHour) * 100 + (int)StringToInteger(startMin);
    int endTime = (int)StringToInteger(endHour) * 100 + (int)StringToInteger(endMin);
    
    if(startTime <= endTime)
    {
        return (currentTimeInt >= startTime && currentTimeInt <= endTime);
    }
    else
    {
        // Overnight session
        return (currentTimeInt >= startTime || currentTimeInt <= endTime);
    }
}