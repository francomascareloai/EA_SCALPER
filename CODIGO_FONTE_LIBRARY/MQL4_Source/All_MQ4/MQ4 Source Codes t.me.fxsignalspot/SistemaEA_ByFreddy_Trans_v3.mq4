/*
   Generated by EX4-TO-MQ4 decompiler V4.0.224.1 []
   Website: http://purebeam.biz
   E-mail : purebeam@gmail.com
*/
#property copyright "Jose Perez 670405556"
#property link      "http://www.elportatilquebuscabas.com"

#import "user32.dll"
   int PostMessageA(int a0, int a1, int a2, int a3);
#import
#include <stdlib.mqh>

extern string s00 = "** Configuraciуn de la estrategia **"; // Настройки стратегии
extern bool Largos? = TRUE;       //  Разрешение BUY
extern bool Cortos? = TRUE;       //  Разрешение SELL
extern bool Repetir? = TRUE;      //  Повтор, если включен сов каждый тик проверяет возможность открытия позиции
                                  //  если откл, новые позиции после закрытия не открываются до перезапуска советника
extern int TamanoRejilla = 10;    //  используется при Repetir? = TRUE( кратность изменения цены)
extern string s01 = "** Gestiуn de stops **";  // Установка стопов
int gi_108 = 0;
//extern double Start       = 0.1; // Количество ордеров при начальном открытии
extern bool   CloseAll     = true; // Используем режим полного закрытия
extern double    EquitySignal = 1;   // Equity при котором включатся режим закрытия всех ордеров на счете( AccountEquity = Balans + EquitySignal% )
extern double    EquityClose  = 0.9;    // Equity при котором закроются все ордера на счете( AccountEquity = Balans + EquitySignal% )
extern double Plus         = 0.1;  // Коэфф увеличения лота
extern double Minus        = 0.2;  // Коэфф уменьшения лота
extern double StopMin      = 0.1;   // Максимальное количество открываемых лотов
extern double StopMax      = 2;   // Максимальное количество открываемых лотов
extern int TakeProfit = 30;
extern int StopLoss1 = 0;
 int StopLoss2 = 20;
 int StopLoss3 = 30;
extern string s02 = "** Tamaсo de уrdenes. 0 para desactivar **";
extern double OrderLots1 = 0.5;
 double OrderLots2 = 0.1;
 double OrderLots3 = 0.1;
bool gi_160 = FALSE; // TRUE;//                         // Включаем тралл
int gi_164 = 0;              // уровень для включения трала
int gi_168 = 100;            // трал стоп
bool gi_unused_172 = FALSE;
string gs_176 = "JP_GRID";   // Комментарий ордеров
string gs_184 = "v1.0";
extern int Slippage = 1;
extern int SegundosParaReintentarOperar = 20; // количество попыток установить ордер(при неудачном исполнении)
double gd_200 = 0.0;        // Количество лотов используемое поумолчанию, если OrderLots = 0ж
int gi_208 = 1;             // Множитель для пересчета пунктов
int g_magic_212;            // Магик
double stepBuy;              // объем buy ордеров
double stepSell;             // объем sell ордеров
datetime t;                 // время закрытия последнего ордера
int    LastCloseType   = -1;          // Тип последнего закрытого ордера
bool   _close = false;      // режим полного закрытия отключен
double    _equitySignal ;   // Equity при котором включатся режим закрытия всех ордеров на счете( AccountEquity = Balans + EquitySignal% )
double    _equityClose  ;   // Equity при котором закроются все ордера на счете( AccountEquity = Balans + EquitySignal% )


//-----------------------
string gs_unused_216 = "";
string gs_dummy_224;
string gs_dummy_232;
string gs_dummy_240;
string gs_dummy_248;
string gs_dummy_256;
string gs_dummy_264;
string gs_dummy_272;
string gs_dummy_280;
string gs_dummy_288;
string gs_dummy_296;
int gi_unused_304 = 0;
int gi_unused_308 = -1;
string gs_unused_312 = "";
//-----------------------
extern string sh60 = "*** Horarios para la operativa **********";
extern bool OperarSiempre? = TRUE;                                                    // Разрешить советнику действовать все время
extern string sh70 = "*** Configurar Horario de Operaciуn 1 (de 00:00 a 23:59) ***";  // Три варианта расписания работы советника
extern bool OperarHorario1? = TRUE;                                                   
extern string Horario1_Desde = "07:30";
extern string Horario1_Hasta = "14:00";
extern string sh80 = "*** Configurar Horario de Operaciуn 2 (de 00:00 a 23:59) ***";
extern bool OperarHorario2? = FALSE;
extern string Horario2_Desde = "14:00";
extern string Horario2_Hasta = "22:00";
extern string sh90 = "*** Configurar Horario de Operaciуn 3 (de 00:00 a 23:59) ***";
extern bool OperarHorario3? = FALSE;
extern string Horario3_Desde = "22:00";
extern string Horario3_Hasta = "07:30";
extern string sh100 = "*****************************************";
string gs_horario_424 = "Horario";
int gi_unused_432 = 0;
double g_bid_436 = 0.0;    // Текущее значение Bid
int gi_unused_444 = 0;     // Текущее значение Спрэд
int g_time_448 = 0;        // Время начала текущего бара
int    NumberOfTry  = 3;               // Количество торговых попыток
bool   UseSound     = True;            // Использовать звуковой сигнал
color  clCloseSell  = Red;             // Цвет значка закрытия продажи
color  clCloseBuy   = Green;           // Цвет значка закрытия покупки
color  clDelete     = Yellow;          // Цвет значка удаление ордера
string NameFileSound= "expert.wav";    // Наименование звукового файла
//++++++++++++++++++++++++++++++++ Проверка SL на (Минимально допустимый уровень стоп-лосса) 
int comprobarStopLoss(int ai_0) {
   int l_stoplevel_4 = MarketInfo(Symbol(), MODE_STOPLEVEL); // Получили минимально допустимый уровень стоп-лосса по инструменту
   if (ai_0 != 0 && ai_0 < l_stoplevel_4) {                  // Если не равно 0 и меньше допустимого
      Alert("ERROR: El StopLoss mнnimo en ", Symbol(), " es: ", l_stoplevel_4);  // Выдаем сообщение об ошибке
      return (0);
   }
   return (1);                                               // Если проходит возвращаем 1       
}
//++++++++++++++++++++++++++++++++ Проверка TP на (Минимально допустимый уровень тейк-профита в пунктах) 
int comprobarTakeProfit(int ai_0) {
   int l_stoplevel_4 = MarketInfo(Symbol(), MODE_STOPLEVEL); // Получили минимально допустимый уровень 
   if (ai_0 != 0 && ai_0 < l_stoplevel_4) {                  // Если не равно 0 и меньше допустимого
      Alert("ERROR: El TakeProfit mнnimo en ", Symbol(), " es: ", l_stoplevel_4);  // Выдаем сообщение об ошибке
      return (0);
   }
   return (1);                                               // Если проходит возвращаем 1  
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//Возвращает уровень SL
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
double getSL(int ai_0, int ai_4, double a_price_8 = 0.0) {
   if (ai_4 == 0) return (0);
   double ld_ret_16 = 0;
   double ld_24 = MarketInfo(Symbol(), MODE_STOPLEVEL);
   ld_24 *= Point;
   if (ai_0 == 0 || ai_0 == 2 || ai_0 == 4) {
      if (a_price_8 == 0.0) {
         RefreshRates();
         a_price_8 = Ask;
      }
      ld_ret_16 = a_price_8 - ai_4 * Point;
      if (ld_ret_16 > a_price_8 - ld_24) ld_ret_16 = a_price_8 - ld_24;
   }
   if (ai_0 == 1 || ai_0 == 3 || ai_0 == 5) {
      if (a_price_8 == 0.0) {
         RefreshRates();
         a_price_8 = Bid;
      }
      ld_ret_16 = a_price_8 + ai_4 * Point;
      if (ld_ret_16 < a_price_8 + ld_24) ld_ret_16 = a_price_8 + ld_24;
   }
   return (ld_ret_16);
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//Возвращает уровень ТP
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
double getTP(int ai_0, int ai_4, double a_price_8 = 0.0) {
   if (ai_4 == 0) return (0);
   double ld_16 = 0;
   double ld_24 = MarketInfo(Symbol(), MODE_STOPLEVEL);
   ld_24 *= Point;
   if (ai_0 == 0 || ai_0 == 2 || ai_0 == 4) {
      if (a_price_8 == 0.0) {
         RefreshRates();
         a_price_8 = Ask;
      }
      ld_16 = a_price_8 + ai_4 * Point;
      if (ld_16 < a_price_8 + ld_24) ld_16 = a_price_8 + ld_24;
   }
   if (ai_0 == 1 || ai_0 == 3 || ai_0 == 5) {
      if (a_price_8 == 0.0) {
         RefreshRates();
         a_price_8 = Bid;
      }
      ld_16 = a_price_8 - ai_4 * Point;
      if (ld_16 > a_price_8 - ld_24) ld_16 = a_price_8 - ld_24;
   }
   ld_16 = NormalizeDouble(ld_16, Digits);
   return (ld_16);
}
//+++++++++++++++++++++++++++++++++++++++++++++++++
//Функция исполнения приказов (выставление ордеров)
//Параметры:
//         int a_cmd_0        - Торговая операция.
//         double a_price_4   - Цена открытия.
//         double ad_12       - stoploss
//         double ad_20       - takeprofit
//         double a_lots_28   - Количество лотов.
//         string a_comment_36- Текст комментария ордера.
//         int a_datetime_44  - Срок истечения отложенного ордера.
//+++++++++++++++++++++++++++++++++++++++++++++++++
int abrirPosicion(int a_cmd_0, double a_price_4 = 0.0, double ad_12 = 0.0, double ad_20 = 0.0, double a_lots_28 = 0.0, string a_comment_36 = "", int a_datetime_44 = 0) {
   double l_price_48;
   color l_color_56;
   int l_ticket_60;
   int l_error_64;
   double l_price_68;
   double l_price_76;
   if (a_comment_36 == "") a_comment_36 = gs_176 + " " + gs_184 + " " + getPeriodAsString(Period()) + ";";
   double ld_84 = (MarketInfo(Symbol(), MODE_STOPLEVEL) + 1.0) * Point;
   int li_92 = SegundosParaReintentarOperar * 2;
   a_price_4 = NormalizeDouble(a_price_4, Digits);
   while (li_92 > 0) {
      RefreshRates();
      if (a_cmd_0 == OP_BUY || a_cmd_0 == OP_BUYLIMIT || a_cmd_0 == OP_BUYSTOP) {
         l_price_48 = NormalizeDouble(Ask, Digits);
         l_color_56 = Green;
      }
      if (a_cmd_0 == OP_SELL || a_cmd_0 == OP_SELLLIMIT || a_cmd_0 == OP_SELLSTOP) {
         l_price_48 = NormalizeDouble(Bid, Digits);
         l_color_56 = Red;
      }
      if (a_price_4 == 0.0) a_price_4 = l_price_48;
      if (a_lots_28 == 0.0) a_lots_28 = NormalizeLots(gd_200);
      else a_lots_28 = NormalizeLots(a_lots_28);
      if (a_cmd_0 != OP_BUY && a_cmd_0 != OP_SELL) {
         if (a_price_4 < l_price_48 && a_cmd_0 == OP_BUYSTOP) a_cmd_0 = 2;
         if (a_price_4 > l_price_48 && a_cmd_0 == OP_BUYLIMIT) a_cmd_0 = 4;
         if (a_price_4 > l_price_48 && a_cmd_0 == OP_SELLSTOP) a_cmd_0 = 3;
         if (a_price_4 < l_price_48 && a_cmd_0 == OP_SELLLIMIT) a_cmd_0 = 5;
         if (a_cmd_0 == OP_BUYLIMIT || a_cmd_0 == OP_BUYSTOP || a_cmd_0 == OP_SELLLIMIT || a_cmd_0 == OP_SELLSTOP) {
            if (MathAbs(l_price_48 - a_price_4) > ld_84) l_price_48 = a_price_4;
            else {
               if (a_cmd_0 == OP_BUYLIMIT || a_cmd_0 == OP_BUYSTOP) {
                  a_cmd_0 = 0;
                  a_datetime_44 = 0;
               }
               if (a_cmd_0 == OP_SELLLIMIT || a_cmd_0 == OP_SELLSTOP) {
                  a_cmd_0 = 1;
                  a_datetime_44 = 0;
               }
            }
         }
      }
      if (ad_12 != 0.0) l_price_68 = ad_12;
      else l_price_68 = getSL(a_cmd_0, gi_108, l_price_48);
      if (ad_20 != 0.0) l_price_76 = ad_20;
      else l_price_76 = getTP(a_cmd_0, TakeProfit, l_price_48);
      if (a_cmd_0 == OP_BUY || a_cmd_0 == OP_BUYLIMIT || a_cmd_0 == OP_BUYSTOP) {
         if (l_price_68 != 0.0 && l_price_48 - l_price_68 < ld_84) {
            if (l_price_48 - l_price_68 > 0.0) {
               l_price_68 = NormalizeDouble(l_price_48 - ld_84, Digits);
               Print("Cambiando el StopLoss al mнnimo de la plataforma");
            } else {
               l_price_68 = 0;
               Print("Eliminando StopLoss incorrecto");
            }
         }
         if (l_price_76 != 0.0 && l_price_76 - l_price_48 < ld_84) {
            if (l_price_76 - l_price_48 > 0.0) {
               l_price_76 = NormalizeDouble(l_price_48 + ld_84, Digits);
               Print("Cambiando el TakeProfit al mнnimo de la plataforma");
            } else {
               l_price_76 = 0;
               Print("Eliminando TakeProfit incorrecto");
            }
         }
      }
      if (a_cmd_0 == OP_SELL || a_cmd_0 == OP_SELLLIMIT || a_cmd_0 == OP_SELLSTOP) {
         if (l_price_68 != 0.0 && l_price_68 - l_price_48 < ld_84) {
            if (l_price_68 - l_price_48 > 0.0) {
               l_price_68 = NormalizeDouble(l_price_48 + ld_84, Digits);
               Print("Cambiando el StopLoss al mнnimo de la plataforma");
            } else {
               l_price_68 = 0;
               Print("Eliminando StopLoss incorrecto");
            }
         }
         if (l_price_76 != 0.0 && l_price_48 - l_price_76 < ld_84) {
            if (l_price_48 - l_price_76 > 0.0) {
               l_price_76 = NormalizeDouble(l_price_48 - ld_84, Digits);
               Print("Cambiando el TakeProfit al mнnimo de la plataforma");
            } else {
               l_price_76 = 0;
               Print("Eliminando TakeProfit incorrecto");
            }
         }
      }
      while (!IsTradeAllowed() || IsTradeContextBusy()) Sleep(1000);
      l_ticket_60 = OrderSend(Symbol(), a_cmd_0, a_lots_28, l_price_48, Slippage, l_price_68, l_price_76, a_comment_36, g_magic_212, a_datetime_44, l_color_56);
      if (l_ticket_60 < 0) {
         l_error_64 = GetLastError();
         Print("OrderSend fallу con error #", l_error_64);
         Print("Orden: ", a_cmd_0, " L=", a_lots_28, " pa=", l_price_48, " precio=" + a_price_4 + " sp=", Slippage, " sl=", l_price_68, " tp=", l_price_76, " c=", a_comment_36, " stoplevel=", ld_84, " Bid=", Bid);
         li_92--;
         Sleep(500);
      } else return (l_ticket_60);
   }
   Alert("Se intentу operar durante " + SegundosParaReintentarOperar + " segundos. Error #" + l_error_64);
   return (-1);
}
//++++++++++++++++++++++++++++++++++++
// Возвращет значение Магик которое будет использовать советник
//++++++++++++++++++++++++++++++++++++
int getMagicNumber(bool ai_0 = FALSE) {
   int li_ret_4;                                            // возвращаемое значение
   if (!IsTesting()) li_ret_4 = WindowHandle(Symbol(), 0);  // если не тестер присваиваем системный дескриптор окна (window handle), содержащего указанный график
   else
      if (!IsVisualMode()) li_ret_4 = 23;                   // иначе если не в режиме визуала присваиваем 23
   if (ai_0) {                                              // если функция вызвана с параметром true
      for (int l_pos_8 = OrdersTotal() - 1; l_pos_8 >= 0; l_pos_8--) { // перебираем все ордера
         OrderSelect(l_pos_8, SELECT_BY_POS);
         if (OrderSymbol() == Symbol()) {
            if (StringSubstr(OrderComment(), 0, StringLen(gs_176)) == gs_176 && StringFind(OrderComment(), " ", StringLen(gs_176) + 1) == -1 || StringSubstr(OrderComment(), StringFind(OrderComment(), " ", StringLen(gs_176) +
               1) + 1, StringLen(getPeriodAsString(Period()))) == getPeriodAsString(Period())) {
               Print("Retomando orden " + OrderTicket());
               li_ret_4 = OrderMagicNumber();   // если находим ордер нашего иструмента и его комментарий содержит "JP_GRID" ....
               break;                           // присваиваем магик этого ордера
            }
         }
      }
   }
   return (li_ret_4);
}
//+++++++++++++++++++++++++++
//Перебор всех ордеров, применяем трал только к своим
// Параметры:  
//           ai_0 - уровень для включения трала
//           ai_4 - тралстоп
//           ai_8 - тралстеп 
//+++++++++++++++++++++++++++
void ajustarTrailingStopTodas(int ai_0, int ai_4, int ai_8 = 0) {
   for (int l_pos_12 = 0; l_pos_12 < OrdersTotal(); l_pos_12++)
      if ((OrderSelect(l_pos_12, SELECT_BY_POS) && OrderMagicNumber() == g_magic_212)) ajustarTrailingStop(OrderTicket(), ai_0, ai_4, ai_8);
}
//+++++++++++++++++++++++++++
//Трал ордера с определенным тикетом
//           a_ticket_0 -  номер тикета 
//           ai_4       - уровень для включения трала
//           ai_8       - тралстоп
//           ai_12      - тралстеп
//+++++++++++++++++++++++++++

int ajustarTrailingStop(int a_ticket_0, int ai_4, int ai_8, int ai_12 = 0) {
   int li_20;
   double l_price_24;
   double ld_32;
   int li_40;
   if (!OrderSelect(a_ticket_0, SELECT_BY_TICKET)) return (0);
   if (ai_8 < MarketInfo(OrderSymbol(), MODE_STOPLEVEL)) {
      Print("No se puede modificar el SL, la distancia mнnima requerida es " + DoubleToStr(MarketInfo(OrderSymbol(), MODE_STOPLEVEL), 0) + " y se ha calculado " + DoubleToStr(ai_8, 0));
      return (0);
   }
   if (OrderType() == OP_BUY || OrderType() == OP_BUYLIMIT || OrderType() == OP_BUYSTOP) li_20 = (OrderClosePrice() - OrderOpenPrice()) / MarketInfo(OrderSymbol(), MODE_POINT);
   else
      if (OrderType() == OP_SELL || OrderType() == OP_SELLLIMIT || OrderType() == OP_SELLSTOP) li_20 = (OrderOpenPrice() - OrderClosePrice()) / MarketInfo(OrderSymbol(), MODE_POINT);
   if (li_20 <= 0) return (0);
   if (li_20 > ai_4) {
      if (OrderType() == OP_BUY || OrderType() == OP_BUYLIMIT || OrderType() == OP_BUYSTOP) {
         l_price_24 = OrderOpenPrice() + (li_20 - ai_8) * Point;
         l_price_24 = NormalizeDouble(l_price_24, Digits);
         ld_32 = l_price_24 - ai_12 * Point;
         if (NormalizeDouble(OrderStopLoss(), Digits) < NormalizeDouble(ld_32, Digits) || OrderStopLoss() == 0.0) {
            li_40 = SegundosParaReintentarOperar * 2;
            while (li_40 > 0) {
               while (!IsTradeAllowed() || IsTradeContextBusy()) Sleep(1000);
               if (OrderModify(OrderTicket(), OrderOpenPrice(), l_price_24, OrderTakeProfit(), 0, Black)) return (1);
               Print("Error " + GetLastError() + " al ajustar TrailingStop, nuevoStop=" + l_price_24 + ", viejoStop=" + OrderStopLoss());
               li_40--;
               Sleep(500);
            }
         }
      }
      if (OrderType() == OP_SELL || OrderType() == OP_SELLLIMIT || OrderType() == OP_SELLSTOP) {
         l_price_24 = OrderOpenPrice() - (li_20 - ai_8) * Point;
         l_price_24 = NormalizeDouble(l_price_24, Digits);
         ld_32 = l_price_24 + ai_12 * Point;
         if (NormalizeDouble(OrderStopLoss(), Digits) > NormalizeDouble(ld_32, Digits) || OrderStopLoss() == 0.0) {
            li_40 = SegundosParaReintentarOperar * 2;
            while (li_40 > 0) {
               while (!IsTradeAllowed() || IsTradeContextBusy()) Sleep(1000);
               if (OrderModify(OrderTicket(), OrderOpenPrice(), l_price_24, OrderTakeProfit(), 0, Black)) return (1);
               Print("Error " + GetLastError() + " al ajustar TrailingStop, nuevoStop=" + l_price_24 + ", viejoStop=" + OrderStopLoss());
               li_40--;
               Sleep(500);
            }
         }
      }
   }
   return (0);
}
//++++++++++++++++++++++++++++++++++
//Получение  названия Периода
//++++++++++++++++++++++++++++++++++
string getPeriodAsString(int a_timeframe_0 = 0) {
   if (a_timeframe_0 == 0) a_timeframe_0 = Period();
   switch (a_timeframe_0) {
   case PERIOD_M1:
      return ("M1");
   case PERIOD_M5:
      return ("M5");
   case PERIOD_M15:
      return ("M15");
   case PERIOD_M30:
      return ("M30");
   case PERIOD_H1:
      return ("H1");
   case PERIOD_H4:
      return ("H4");
   case PERIOD_D1:
      return ("D1");
   case PERIOD_W1:
      return ("W1");
   case PERIOD_MN1:
      return ("MN1");
   }
   return ("");
}
//++++++++++++++++++++++++++++++++
// Нормализация лота
//++++++++++++++++++++++++++++++++
double NormalizeLots(double ad_0) {
   double ld_8 = ad_0;
   double l_minlot_16 = MarketInfo(Symbol(), MODE_MINLOT);
   if (ld_8 < l_minlot_16) return (0);
   double l_maxlot_24 = MarketInfo(Symbol(), MODE_MAXLOT);
   if (ld_8 > l_maxlot_24) return (l_maxlot_24);
   double l_lotstep_32 = MarketInfo(Symbol(), MODE_LOTSTEP);
   int li_40 = MathRound(ld_8 / l_lotstep_32);
   ld_8 = l_lotstep_32 * li_40;
   return (NormalizeDouble(ld_8, 2));
}
//++++++++++++++++++++++++++++++++++++++
// Проверяем какое расписание работы установлено в параметрах
// в случае если на данный момент попадаем в промежуток времени возвращаем 1
//++++++++++++++++++++++++++++++++++++++
int enHorario?() {
   if (OperarSiempre?) return (1);
   string l_time2str_0 = TimeToStr(TimeCurrent(), TIME_SECONDS);
   int l_str2time_8 = StrToTime(l_time2str_0);
   int l_str2time_12 = StrToTime(Horario1_Desde);
   int l_str2time_16 = StrToTime(Horario1_Hasta);
   int l_str2time_20 = StrToTime(Horario2_Desde);
   int l_str2time_24 = StrToTime(Horario2_Hasta);
   int l_str2time_28 = StrToTime(Horario3_Desde);
   int l_str2time_32 = StrToTime(Horario3_Hasta);
   if (OperarHorario1?) {
      if (l_str2time_12 < l_str2time_16) {
         if (l_str2time_8 >= l_str2time_12 && l_str2time_8 < l_str2time_16) return (1);
      } else
         if ((l_str2time_8 >= l_str2time_12 && l_str2time_8 <= StrToTime("23:59:59")) || l_str2time_8 < l_str2time_16) return (1);
   }
   if (OperarHorario2?) {
      if (l_str2time_20 < l_str2time_24) {
         if (l_str2time_8 >= l_str2time_20 && l_str2time_8 < l_str2time_24) return (1);
      } else
         if ((l_str2time_8 >= l_str2time_20 && l_str2time_8 <= StrToTime("23:59:59")) || l_str2time_8 < l_str2time_24) return (1);
   }
   if (OperarHorario3?) {
      if (l_str2time_28 < l_str2time_32) {
         if (l_str2time_8 >= l_str2time_28 && l_str2time_8 < l_str2time_32) return (1);
      } else
         if ((l_str2time_8 >= l_str2time_28 && l_str2time_8 <= StrToTime("23:59:59")) || l_str2time_8 < l_str2time_32) return (1);
   }
   return (0);
}
//++++++++++++++++++++++++++++++++++++++
// Выводим информацию на экран - текущее время, разрешена ли работа
//++++++++++++++++++++++++++++++++++++++
void mostrarGraficoHorario(bool ai_0) {
   string l_text_4;
   int l_datetime_12;
   int l_hour_16;
   int l_minute_20;
   if (IsTesting() && !IsVisualMode()) return;
   if (OperarSiempre? == 0) {
      l_text_4 = "Cargando datos...";
      if (ObjectFind(gs_horario_424) == -1) {
         ObjectCreate(gs_horario_424, OBJ_LABEL, 0, 0, 0);
         ObjectSet(gs_horario_424, OBJPROP_CORNER, 2);
         ObjectSet(gs_horario_424, OBJPROP_XDISTANCE, 20);
         ObjectSet(gs_horario_424, OBJPROP_YDISTANCE, 10);
         ObjectSetText(gs_horario_424, l_text_4, 14, "Times New Roman", Lime);
      }
      l_datetime_12 = TimeCurrent();
      l_text_4 = "[";
      l_hour_16 = TimeHour(l_datetime_12);
      if (l_hour_16 < 10) l_text_4 = l_text_4 + "0";
      l_text_4 = l_text_4 + l_hour_16 + ":";
      l_minute_20 = TimeMinute(l_datetime_12);
      if (l_minute_20 < 10) l_text_4 = l_text_4 + "0";
      l_text_4 = l_text_4 + l_minute_20 + "]";
      if (ai_0) ObjectSetText(gs_horario_424, l_text_4 + " Dentro de horario.", 14, "Times New Roman", Lime);
      else ObjectSetText(gs_horario_424, l_text_4 + " Fuera de horario.", 14, "Times New Roman", Red);
   }
}
//+++++++++++++++++++++++++++++++++++++++++++++++++
// ИНИЦИАЛИЗАЦИЯ
//+++++++++++++++++++++++++++++++++++++++++++++++++
int init() {
   if (Digits == 3 || Digits == 5) gi_208 = 10; // Проверка цифр после десятичной точки в цене текущего инструмента
   else gi_208 = 1;                             // Устанавливаем множитель 10 для (3 и 5)
 //--------------------------------------------- Умножаем параметры в пунктах на множитель  
   gi_108 *= gi_208;                           
   StopLoss1 *= gi_208;    
   StopLoss2 *= gi_208;
   StopLoss3 *= gi_208;
   TakeProfit *= gi_208;
   TamanoRejilla *= gi_208;
   Slippage *= gi_208;
   gi_168 *= gi_208;
   
   stepBuy      = OrderLots1;
   stepSell     = OrderLots1;
   _equitySignal = ND(AccountBalance() + AccountBalance()*EquitySignal/100);
   _equityClose  = ND(AccountBalance() + AccountBalance()*EquityClose/100);
   
  //--------------------------------------------- Проверка введенных параметров стопов на минимально допустимые значения
  //                                              если не соответствует выдаем Alert с информ о мин допустимом значении и присваиваем переменной 0
   if (!comprobarStopLoss(StopLoss1)) {
      Alert("Se elimina el StopLoss1 al ser menor que el mнnimo para " + Symbol() + ": " + DoubleToStr(MarketInfo(Symbol(), MODE_STOPLEVEL), 0));
      StopLoss1 = 0;
   }
   if (!comprobarStopLoss(StopLoss2)) {
      Alert("Se elimina el StopLoss2 al ser menor que el mнnimo para " + Symbol() + ": " + DoubleToStr(MarketInfo(Symbol(), MODE_STOPLEVEL), 0));
      StopLoss2 = 0;
   }
   if (!comprobarStopLoss(StopLoss3)) {
      Alert("Se elimina el StopLoss3 al ser menor que el mнnimo para " + Symbol() + ": " + DoubleToStr(MarketInfo(Symbol(), MODE_STOPLEVEL), 0));
      StopLoss3 = 0;
   }
   if (!comprobarStopLoss(gi_168)) {
      Alert("Se elimina el TrailingStopDistancia al ser menor que el mнnimo para " + Symbol() + ": " + DoubleToStr(MarketInfo(Symbol(), MODE_STOPLEVEL), 0));
      gi_168 = 0;
   }
   if (!comprobarTakeProfit(TakeProfit)) {
      Alert("Se elimina el TakeProfit al ser menor que el mнnimo para " + Symbol() + ": " + DoubleToStr(MarketInfo(Symbol(), MODE_STOPLEVEL), 0));
      TakeProfit = 0;
   }
//---------------------------------------------  Получаем магик который будет использоваться в советнике
//                                               если ордер уже существует используем его магик, если нет то используем 
//                                               (если не тестер) системный дескриптор окна (window handle) , на котором работает сов
   
   g_magic_212 = getMagicNumber(1);
  // Print(" g_magic_212 = ", g_magic_212);
//---------------------------------------------  
   return (0);
}
//---------------------------------------------  Start()
int start() {
   Comment(Text());
//------------------------ Закрываем по Equity   
   if(CloseAll && !_close){
     if(AccountEquity()>= _equitySignal) _close = true;
   }
   if( _close && (AccountEquity() <= _equityClose)){
       ClosePosBySortLots();
       stepBuy      = OrderLots1;
       stepSell     = OrderLots1;
       _equitySignal = ND( AccountBalance() + AccountBalance()*EquitySignal/100);
       _equityClose  = ND( AccountBalance() + AccountBalance()*EquityClose/100);
       _close        = false;
   }
 /*  double _tempequitySignal=ND( AccountBalance() + 2*AccountBalance()*EquitySignal/100);
   if( _close && (AccountEquity() > _tempequitySignal)){
      _equitySignal = ND( AccountBalance() + 2*AccountBalance()*EquitySignal/100);
      _equityClose  = ND( AccountBalance() + 2*AccountBalance()*EquityClose/100);
   } 
 */  
// ------- Выводим информацию в случае если выбран режим работы по расписанию
//         Отображается текущее время и состояние ( в расписании или нет )
//         enHorario?() - проверяет какое расписание  разрешено, возвращает true если находимся в расписании
   mostrarGraficoHorario(enHorario?());
//-------- Проверяем включен ли режим трала
//         ajustarTrailingStopTodas - перебор всех ордеров, применяем  трал только к нашим
   if (gi_160) ajustarTrailingStopTodas(gi_164, gi_168);
//-------- Проверка появления нового бара или если включен Повтор
//         выполняем проверку возможности открытия позиции
   if (g_time_448 == 0 || Repetir?) {
      abrirPosiciones();
      g_time_448 = Time[0];  
   }
   return (0);
}
//---------------------------------------------  
int deinit() {
   ObjectDelete(gs_horario_424);
   Comment("");
   return (0);
}
//++++++++++++++++++++++++++++++++++++++++++++++++++
//Проверка условий открытия позиций
//При первом запуске (или перезапуске)торговля разрешена в оба направления
//Если включен Повтор в настройках, после открытия первых ордеров, каждый тик проверяется возможность установки ордеров по направлениям.
//Ордера открываются тройками.
//++++++++++++++++++++++++++++++++++++++++++++++++++
void abrirPosiciones() {
   int li_4;
   int li_8;
   int li_16;
   int li_20;
   int li_24;
   bool li_0 = FALSE; 
   
   if (g_bid_436 == 0.0) {
      li_0 = TRUE;
      g_bid_436 = Bid;
      gi_unused_444 = (Ask - Bid) / Point;
   } else {
      if (Repetir?) {
         li_4 = g_bid_436 / Point / gi_208;
         li_8 = Bid / Point / gi_208; 
         if (li_8 == li_4) li_0 = TRUE;
         else {
            if (li_8 > li_4) {                      // если цена увеличилась относительно цены на момент запуска советника
               while (li_8 > li_4) {
                  li_8 -= TamanoRejilla / gi_208;   
                  if (li_8 == li_4) {              // и изменение произошло кратно параметру TamanoRejilla( если = 10,то на 10,20 и т.д
                     li_0 = TRUE;                  // разрешаем торговлю
                     break;
                  }
               }
            } else {
               if (li_8 < li_4) {                  // если цена уменьшилась относительно цены на момент запуска советника
                  while (li_8 < li_4) {
                     li_8 += TamanoRejilla / gi_208;  // и изменение произошло кратно параметру TamanoRejilla( если = 10,то на 10,20 и т.д
                     if (li_8 == li_4) {
                        li_0 = TRUE;               // разрешаем торговлю
                        break;
                     }
                  }
               }
            }
         }
         if (li_0) {                                                         // если торговля разрешена
            for (int l_pos_12 = 0; l_pos_12 < OrdersTotal(); l_pos_12++) {   // проверяем наши ордера
               if ((OrderSelect(l_pos_12, SELECT_BY_POS) && OrderMagicNumber() == g_magic_212)) {
                  li_16 = Bid / Point / gi_208;
                  li_20 = Ask / Point / gi_208;
                  li_24 = OrderOpenPrice() / Point / gi_208;
                  if ((OrderType() == OP_SELL && MathAbs(li_24 - li_16) < 2.0) || (OrderType() == OP_BUY && MathAbs(li_24 - li_20) < 2.0)) {
                     li_0 = FALSE;       // если цена от ордера меньше 2 пунктов торговля запрещена
                     break;
                  }
               }
            }
         }
      }
   }
   if (li_0) {
     int _type = GetTypeLastClosePos();
     Print(" _type = ",_type);
      if(_type==0){
        stepBuy  += Plus; 
        stepSell -= Minus;
        if(stepBuy>StopMax)     stepBuy =NormalizeLots1(StopMax);
        if(stepSell<StopMin)    stepSell=NormalizeLots1(StopMin); 
      }  
      if(_type==1){
         stepSell +=  Plus;
         stepBuy  -=  Minus;
        if(stepSell>StopMax)   stepSell= NormalizeLots1(StopMax);
        if(stepBuy<StopMin)    stepBuy =NormalizeLots1(StopMin); 
      }
     
      if (Largos?) {   // если разрешено BUY - открываем stepBuy ордера
             
             abrirPosicion(OP_BUY, 0, getSL(0, StopLoss1), getTP(0, TakeProfit), stepBuy);
        
        // abrirPosicion(OP_BUY, 0, getSL(0, StopLoss2), getTP(0, TakeProfit), OrderLots2);
        // abrirPosicion(OP_BUY, 0, getSL(0, StopLoss3), getTP(0, TakeProfit), OrderLots3);
      }
      if (Cortos?) {   // если разрешено SELL - открываем stepSell ордера
           
            abrirPosicion(OP_SELL, 0, getSL(1, StopLoss1), getTP(1, TakeProfit), stepSell);
         
        // abrirPosicion(OP_SELL, 0, getSL(1, StopLoss2), getTP(1, TakeProfit), OrderLots2);
        // abrirPosicion(OP_SELL, 0, getSL(1, StopLoss3), getTP(1, TakeProfit), OrderLots3);
      }
   }
}

//-------------------
string Text()
{
 // GetTypeLastClosePos();
  string msg;
  if(CloseAll ) msg = "\n    Включен режим закрытия";
  if(_close && CloseAll)    msg = StringConcatenate(msg,"\n    Сигнал на закрытие получен на Equity = ", _equitySignal);
  if(!_close && CloseAll)   msg = StringConcatenate(msg,"\n    Сигнал на закрытие  БУДЕТ получен на Equity = ", _equitySignal);
   if( CloseAll)            msg = StringConcatenate(msg,"\n    Закрытие произойдет на Equity = ", _equityClose);
   if( CloseAll)            msg = StringConcatenate(msg,"\n    Текущее Equity = ", AccountEquity());
         msg= StringConcatenate(msg,
                                "\n    Step Buy  = ",stepBuy,
                                "\n    Step Sell   = ",stepSell,
                                "\n    Start        = ",OrderLots1,
                                "\n    StopMin   = ",StopMin,
                                "\n    StopMax   = ",StopMax);
         if( t != 0)                msg= StringConcatenate(msg,"\n   Time Last Close  = ", TimeToStr(t));                       
         if( LastCloseType == 0)    msg= StringConcatenate(msg,"\n   Type Last Close  = BUY");
         if( LastCloseType == 1)    msg= StringConcatenate(msg,"\n   Type Last Close  = SELL");
                                    msg= StringConcatenate(msg,"\n   Ордеров на счете  = ", OrdersTotal());
  
  return(msg);   
}
//------------------
int  GetTypeLastClosePos() {
  
  int      i, k=OrdersHistoryTotal();
  
  int _lastCloseType = -1;
//  Print ("period = ",TimeToStr(_period)); 
  double LastCloseProfit = EMPTY;       // Профит последнего закрытого ордера
  
  for (i=0; i<k; i++) {
    if (OrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) {
      if (OrderSymbol()==Symbol() &&  OrderMagicNumber()==g_magic_212 ) {
        if (OrderType()==OP_BUY || OrderType()==OP_SELL) {
          LastCloseProfit   =OrderProfit()+OrderSwap()+OrderCommission();
          if (t<OrderCloseTime() && LastCloseProfit>0) {
            t=OrderCloseTime();
            _lastCloseType    =OrderType();
            LastCloseType = _lastCloseType;
          }
        }
      }
    }
  }
  return ( _lastCloseType );
}
//+------------------------------------------------------------------+
//| Нормализация лота                                                |
//+------------------------------------------------------------------+

double NormalizeLots1(double lot)
{
   double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
   double lots = NormalizeDouble(lot / lotStep, 0) * lotStep;   
   lots = MathMax(lots, MarketInfo(Symbol(), MODE_MINLOT));
   lots = MathMin(lots, MarketInfo(Symbol(), MODE_MAXLOT));   
   return (lots);
}

//+----------------------------------------------------------------------------+
//|  Версия   : 11.12.2008                                                     |
//|  Описание : Закрытие позиций в порядке сортировки по размерам лотов.       |
//+----------------------------------------------------------------------------+
//|  Параметры:                                                                |
//|    sy - наименование инструмента        (    ""       - любой символ,      |
//|                                             NULL      - текущий символ)    |
//|    op - операция                        (    -1       - любая позиция)     |
//|    mn - MagicNumber                     (    -1       - любой магик)       |
//|    sd - Направление сортировки лотов    (MODE_ASCEND  - возрастание,       |
//|                                          MODE_DESCEND - убывание)          |
//+----------------------------------------------------------------------------+
void ClosePosBySortLots(string sy="", int op=-1, int mn=-1, int sd=MODE_DESCEND) {
  double a[][2];                  // Массив лотов и тикетов
  int    i, k=OrdersTotal();      // Счётчик и количество ордеров
  int    p=0;                     // Количество позиций

  if (sy=="0") sy=Symbol();
  for (i=0; i<k; i++) {
    if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
      if ((OrderSymbol()==sy || sy=="") && (op<0 || OrderType()==op)) {
        if (OrderType()==OP_BUY || OrderType()==OP_SELL) {
          if (mn<0 || OrderMagicNumber()==mn) {
            p++;
            ArrayResize(a, p);
            a[p-1][0]=OrderLots();
            a[p-1][1]=OrderTicket();
          }
        }
      }
    }
  }

  // вдруг позиций нету, тогда и закрывать нечего
  if (p>0) {
    ArraySort(a, WHOLE_ARRAY, 0, sd);
    for (i=0; i<p; i++) {
      if (OrderSelect(a[i][1], SELECT_BY_TICKET)) {
        // проверим незакрытость на всякий случай,
        // может какая-то позиция уже закрылась по стопу/тейку
        if (OrderCloseTime()==0) ClosePosBySelect();
      }
    }
  }
}
//+----------------------------------------------------------------------------+
//|  Версия  : 19.02.2008                                                      |
//|  Описание: Закрытие одной предварительно выбранной позиции                 |
//+----------------------------------------------------------------------------+
void ClosePosBySelect() {
  bool   fc;
  color  clClose;
  double ll, pa, pb, pp;
  int    err, it;

  if (OrderType()==OP_BUY || OrderType()==OP_SELL) {
    for (it=1; it<=NumberOfTry; it++) {
      if (!IsTesting() && (!IsExpertEnabled() || IsStopped())) break;
      while (!IsTradeAllowed()) Sleep(5000);
      RefreshRates();
      pa=MarketInfo(OrderSymbol(), MODE_ASK);
      pb=MarketInfo(OrderSymbol(), MODE_BID);
      if (OrderType()==OP_BUY) {
        pp=pb; clClose=clCloseBuy;
      } else {
        pp=pa; clClose=clCloseSell;
      }
      ll=OrderLots();
      fc=OrderClose(OrderTicket(), ll, pp, Slippage, clClose);
      if (fc) {
        if (UseSound) PlaySound(NameFileSound); break;
      } else {
        err=GetLastError();
        if (err==146) while (IsTradeContextBusy()) Sleep(1000*11);
        Print("Error(",err,") Close ",GetNameOP(OrderType())," ",
              ErrorDescription(err),", try ",it);
        Print(OrderTicket(),"  Ask=",pa,"  Bid=",pb,"  pp=",pp);
        Print("sy=",OrderSymbol(),"  ll=",ll,"  sl=",OrderStopLoss(),
              "  tp=",OrderTakeProfit(),"  mn=",OrderMagicNumber());
        Sleep(1000*5);
      }
    }
  } else Print("Некорректная торговая операция. Close ",GetNameOP(OrderType()));
}
//+----------------------------------------------------------------------------+
//|  Описание : Возвращает наименование торговой операции                      |
//+----------------------------------------------------------------------------+
//|  Параметры:                                                                |
//|    op - идентификатор торговой операции                                    |
//+----------------------------------------------------------------------------+
string GetNameOP(int op) {
  switch (op) {
    case OP_BUY      : return("Buy");
    case OP_SELL     : return("Sell");
    case OP_BUYLIMIT : return("BuyLimit");
    case OP_SELLLIMIT: return("SellLimit");
    case OP_BUYSTOP  : return("BuyStop");
    case OP_SELLSTOP : return("SellStop");
    default          : return("Unknown Operation");
  }
}
//+----------------------------------------------------------------------------+
//+  Описание : Нормализация double                                            |
//+----------------------------------------------------------------------------+
//|  Параметры:                                                                |
//|    v - double                                                              |
//+----------------------------------------------------------------------------+
double ND(double v){return(NormalizeDouble(v,Digits));}

