/*******************************************************************************
 *                                                                AnyCandle.mq4 
 *                                                                         v1.1  
 *                                                             © 2011 sunbrella 
 *
 * 
 * Overview 
 * ========
 * This is a simple indicator that displays one (or more) candle(s) of higher 
 * timeframes on the right side of your current chart E.g. If your chart is set 
 * to M15, you can add e.g. H1, H4 and D1 candles to your M15 chart side by side 
 * according to your AnyCandle settings. Note that each candle needs a separate 
 * AnyCandle instance.
 *
 * If you enable the Alarm feature, candle will start to change its colour  
 * when the candle is going to close within a few minutes (or seconds for lower 
 * timeframes) (you can set this level) plus gives you an easy to understand 
 * human voice speech alert as well. This will help to identify what candle
 * is going to be closed exactly. This way you will be notyfied in advance to be 
 * there when the candle closes. This is useful if you take into account closed 
 * candles' price spread and the accompanying volume in your decisions. This is 
 * where Anycandle can help especially when used together with SonicR volume 
 * indicators from TAH (see links below).
 * 
 * Note that volume always means activity of the BBs, worth considering. On the 
 * other hand, the volume you see in the spot forex market is limited to the 
 * volume of order-flow generated by the accounts (and account sizes) your 
 * broker has (worst case: you have an account at a "dealing desk MM broker", 
 * non dealing desk STP/ECN brokers are much reliable). 
 * 
 * So it is not the whole market at all and can be manipulated as well but still 
 * can be informative to some extent (for more reliable volume one has to trade 
 * futures).
 
 * Recommended links
 * =================
 * For an in depth discussion of the candle price spread and volume interrela-
 * tionship check the VSA thread along with a comprehensive guide in PDF 
 * (Master the Market)here: 
 * 
 *     Link: http://www.forexfactory.com/showthread.php?t=157629
 *
 * For an easy to follow trading system check the SonicR thread here:
 *
 *     Link: http://www.forexfactory.com/showthread.php?t=114792
 *
 * And finally a big thank you from here to the founder Sonic, TraderAtHome 
 * for his endless energy and efforts continuously enhancing the SonicR system 
 * with his high quality indicators and his clean templates, and you all being 
 * there for couple of years and sharing your valuable time and your set-ups.
 *
 * How to install
 * ===============
 * 1. Extract the attached ZIP file to your temporary folder.
 * 2. Copy the mq4 and ex4 files to the following folder:
 *
 *    c:\Program Files\YourBroker MetaTrader\experts\indicators\
 *
 * 3. Copy the WAV files to the following folder:
 *
 *    c:\Program Files\YourBroker MetaTrader\sounds\
 *
 *
 * How to use                      
 * ==========
 * First, check the AnyCandle_Settings.gif pic in the ZIP file as a quick 
 * reference guide, it has all the necessary info on how to set-up this 
 * indicator and shows a general view how it looks like on the chart. 
 * 
 * Setting-up: 
 * 1. add an AnyCandle instance to your chart
 * 2. set the TimeFrame property; AnyCandle will display the candle for that TF
 *    (1440 means daily candle, this is the default setting)
 * 3. set the TimeShift property if you want to see a different OHLC candle 
 *    from those on your chart (shifts the starting bar of the candle)
 * 4. set the DisplayOffset property (only if you use more than one AnyCandle 
 *    indicator on the same chart, otherwise you can leave it as is)
 * 5. set the Alarm settings (ON by default, 10% of candletime left until 
 *    candle closes)
 * 
 * Note: if you want to display more than one AnyCandle, you have to add a new
 * AnyCandle indicator for each new candle to your chart and set it for that 
 * new TF. Don't forget to change the DisplayOffset porperty (e.g. 10 for the 
 * second candle, 13 for the third), otherwise your new candle will be 
 * displayed over the previous candle.
 * 
 *
 * Legal notes 
 * ============
 * This code is free for any personal use (except commercial use). Feel free 
 * to enhance/modify the mq4 code and distribute it until you:
 * - do it free of charge
 * - leave the reference unchanged to the author of the original version
 * - leave the reference unchanged to this legal note
 * - your modifications are added to the version history
 * 
 * If you find any bug, feel free to contact me or repair it yourself ;-) 
 * Any optimization is welcome, pls send me a copy of the modified version.
 *
 * Hope you find it useful. 
 * 
 * Sunbrella, 05-17-2011 
 *
 *
 * Version history:
 * ----------------
 * 1.1: TimeShift and voice alerts added
 * 1.0: initial release
 *
 ********************************************************************************/
#property copyright "© 2011 - sunbrella"
#property link      "sunbrella@rocketmail.com"

#property indicator_chart_window
#property indicator_buffers 4

extern bool   Indicator_On    = TRUE;
extern string Comment0        = "--- Timeframe and Shift Settings ---";
extern string Comment1        = "1 = M1; 5 = M5; 15 = M15; 30 = M30";
extern string Comment2        = "60 = H1; 240 = H4; 1440 = D1";
extern int    TimeFrame       = 60;
extern string Comment3        = "bars added to your broker time";
extern int    TimeShift       = 0;
extern string Comment4        = "--- Display Settings ---------------";
extern string Comment5        = "when multiple AnyCandle indicators";
extern string Comment6        = "are used on the same chart, add +3";
extern string Comment7        = "to the offset for each new AnyCandle";
extern string Comment8        = "instances (10, 13, etc.)";
extern int    DisplayOffset   = 7;
extern string Comment9        = "--- Alarm Settings -----------------";
extern string Comment10       = "if you want to see that the candle";
extern string Comment11       = "is going to close within a given";
extern string Comment12       = "period of time, set this to TRUE;";
extern string Comment13       = "10 means that colour will change";
extern string Comment14       = "when 10% of time left until close";
extern bool   Alarm_On        = TRUE;
extern int    AlarmStartLevel = 10;

// Candle OHLC buffers
double gdaLow[];     // 0 = Low
double gdaHigh[];    // 1 = High
double gdaClose[];   // 2 = Close
double gdaOpen[];    // 3 = Open

string gsCandleLabel;
string gsSoundFileName;
bool   gbFirstAlert = true;

int init() 
{
   if (Indicator_On)
   {
      // just ensuring that user has set a valid timeframe
      TimeFrame     = ValidateTimeFrame(TimeFrame, "Candle");
      if ((Alarm_On) && ((AlarmStartLevel < 0) || (AlarmStartLevel > 100)))
      {
         Alert("AnyCandle: " + AlarmStartLevel  + " is an invalid alarm level, 10% will be used instead.");
         AlarmStartLevel = 10;
      }

      if ((TimeShift < 0) || (TimeShift > 24))
      {
         Alert("AnyCandle: " + TimeShift  + " is an invalid timeshift value, 0 will be used instead.");
         TimeShift = 0;
      }

      // default = bull candle
      SetIndexBuffer(0, gdaLow);   SetIndexStyle(0, DRAW_HISTOGRAM, STYLE_SOLID, 1, clrGreen);     SetIndexShift(0, DisplayOffset); SetIndexLabel(0, gsCandleLabel);
      SetIndexBuffer(1, gdaHigh);  SetIndexStyle(1, DRAW_HISTOGRAM, STYLE_SOLID, 1, clrFireBrick); SetIndexShift(1, DisplayOffset); SetIndexLabel(1, gsCandleLabel);
      SetIndexBuffer(2, gdaClose); SetIndexStyle(2, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrLime);      SetIndexShift(2, DisplayOffset); SetIndexLabel(2, gsCandleLabel);
      SetIndexBuffer(3, gdaOpen);  SetIndexStyle(3, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrRed);       SetIndexShift(3, DisplayOffset); SetIndexLabel(3, gsCandleLabel);
   }
   return (0);
} // init
int deinit() 
{
   int liObjectsTotal = ObjectsTotal();
   for (int i = liObjectsTotal; i >= 0; i--) 
   {
      if (ObjectName(i) == gsCandleLabel) 
         ObjectDelete(gsCandleLabel);
   }
   return (0);
} // deinit
int start() 
{
   if (Indicator_On == FALSE) 
   {
      deinit();
      return (0);
   }
   // Draw candle for selected timeframe
   if (Alarm_On)
      AnyCandleWithAlarm();
   else
      AnyCandleWithoutAlarm();
      
   return (0);
} // start
int ValidateTimeFrame(int piTimeFrame, string psCandleLabel)
{
   // just ensuring that user set a valid timeframe
   switch(piTimeFrame)
   {
      case PERIOD_M1:
         int ldResult    = 1;
         gsCandleLabel   = "M1_" + psCandleLabel;
         gsSoundFileName = "M1.wav";
         break;
      case PERIOD_M5:
         ldResult        = 5;
         gsCandleLabel   = "M5_" + psCandleLabel;
         gsSoundFileName = "M5.wav";
         break;
      case PERIOD_M15:
         ldResult        = 15;
         gsCandleLabel   = "M15_" + psCandleLabel;
         gsSoundFileName = "M15.wav";
         break;
      case PERIOD_M30:
         ldResult        = 30;
         gsCandleLabel   = "M30_" + psCandleLabel;
         gsSoundFileName = "M30.wav";
         break;
      case PERIOD_H1:
         ldResult        = 60;
         gsCandleLabel   = "H1_" + psCandleLabel;
         gsSoundFileName = "H1.wav";
         break;
      case PERIOD_H4:
         ldResult        = 240;
         gsCandleLabel   = "H4_" + psCandleLabel;
         gsSoundFileName = "H4.wav";
         break;
      case PERIOD_D1:
         ldResult        = 1440;
         gsCandleLabel   = "D_" + psCandleLabel;
         gsSoundFileName = "Daily.wav";
         break;
      case PERIOD_W1:
         ldResult        = 10080;
         gsCandleLabel   = "W_" + psCandleLabel;
         gsSoundFileName = "";
         break;
      case PERIOD_MN1:
         ldResult        = 43200;
         gsCandleLabel   = "Month_" + psCandleLabel;
         gsSoundFileName = "";
         break;
      default:
         ldResult        = 1440;  // daily
         gsCandleLabel   = "D_" + psCandleLabel;
         gsSoundFileName = "Daily.wav";
         Alert("AnyCandle: " + piTimeFrame + " is an invalid timeframe, D1 will be used instead.");
         break;
  }
  return(ldResult);
} // ValidateTimeFrame
void AnyCandleWithoutAlarm() 
{
   // Setting OHLC values
   double ldOpen  = iOpen(NULL, TimeFrame, TimeShift);
   double ldHigh  = iHigh(NULL, TimeFrame, TimeShift);
   double ldLow   = iLow(NULL, TimeFrame, TimeShift);
   double ldClose = iClose(NULL, TimeFrame, TimeShift);
   
   if (ldClose - ldOpen < 0.0) 
   {
      // we have a bear candle
      gdaLow[0]   = ldLow;
      gdaHigh[0]  = ldHigh;
      gdaOpen[0]  = ldOpen;
      gdaClose[0] = ldClose;
   } 
   else 
   {
      // we have a bull candle
      gdaOpen[0]  = ldOpen;
      gdaHigh[0]  = ldLow;
      gdaLow[0]   = ldHigh;
      gdaClose[0] = ldClose;
   }
   // erasing previous candles when a new bar starts on the chart
   gdaOpen[1]  = 0;
   gdaHigh[1]  = 0;
   gdaLow[1]   = 0;
   gdaClose[1] = 0;
   
   return(0);
} // AnyCandleWithoutAlarm
void AnyCandleWithAlarm() 
{
   // Get candle time until close
   int liTimeLeftSecs    = TimeCurrent() - iTime(NULL, TimeFrame, TimeShift);
   int liTimeLeftPercent = 100 - (100.0 * liTimeLeftSecs / (TimeFrame * 60));
   
   // Setting OHLC values
   double ldOpen  = iOpen(NULL, TimeFrame, TimeShift);
   double ldHigh  = iHigh(NULL, TimeFrame, TimeShift);
   double ldLow   = iLow(NULL, TimeFrame, TimeShift);
   double ldClose = iClose(NULL, TimeFrame, TimeShift);
   
   if (ldClose - ldOpen < 0.0) 
   {
      // we have a bear candle
      gdaLow[0]   = ldLow;
      gdaHigh[0]  = ldHigh;
      gdaOpen[0]  = ldOpen;
      gdaClose[0] = ldClose;
      
      if (liTimeLeftPercent <= AlarmStartLevel)
      {
         SetIndexStyle(0, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrRed);   // 0 = Low
         SetIndexStyle(1, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrBlue);   // 1 = High 
         SetIndexStyle(2, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrRed);     // 2 = Close 
         SetIndexStyle(3, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrBlue);     // 3 = Open 
         if (gbFirstAlert)
         {
            PlaySound(gsSoundFileName);
            gbFirstAlert = false;
         }
      }
      else
      {
         SetIndexStyle(0, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrRed);   // 0 = Low
         SetIndexStyle(1, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrBlue);   // 1 = High 
         SetIndexStyle(2, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrRed);     // 2 = Close 
         SetIndexStyle(3, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrBlue);     // 3 = Open 

         gbFirstAlert = true;
      }
   }
   else 
   {
      // we have a bull candle
      gdaOpen[0]  = ldOpen;
      gdaHigh[0]  = ldLow;
      gdaLow[0]   = ldHigh;
      gdaClose[0] = ldClose;

      if (liTimeLeftPercent <= AlarmStartLevel)
      {
         SetIndexStyle(0, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrRed);   // 0 = Low
         SetIndexStyle(1, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrBlue);   // 1 = High 
         SetIndexStyle(2, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrRed);     // 2 = Close 
         SetIndexStyle(3, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrBlue);     // 3 = Open 
         {
            PlaySound(gsSoundFileName);
            gbFirstAlert = false;
         }
      }
      else
      {
        SetIndexStyle(0, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrRed);   // 0 = Low
        SetIndexStyle(1, DRAW_HISTOGRAM, STYLE_SOLID, 2, clrBlue);   // 1 = High 
        SetIndexStyle(2, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrRed);     // 2 = Close 
        SetIndexStyle(3, DRAW_HISTOGRAM, STYLE_SOLID, 4, clrBlue);     // 3 = Open 

         gbFirstAlert = true;
      }
   } 
   // erasing previous candles when a new bar starts on the chart
   gdaOpen[1]  = 0;
   gdaHigh[1]  = 0;
   gdaLow[1]   = 0;
   gdaClose[1] = 0;
   
   return(0);
} // AnyCandleWithAlarm

