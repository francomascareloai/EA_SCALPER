/*
   Generated by EX4-TO-MQ4 decompiler V4.0.438.3 [-]
   Website: https://purebeam.biz
   E-mail : purebeam@gmail.com
*/

#property indicator_chart_window
#property indicator_buffers 8

#property indicator_color1 White
#property indicator_color2 RoyalBlue
#property indicator_color3 Lavender //Lime
#property indicator_color4 Purple
#property indicator_color5 Lime
#property indicator_color6 Red
#property indicator_color7 Lime
#property indicator_color8 Red
#property indicator_width1  4
#property indicator_width2  2
#property indicator_width5  2
#property indicator_width6  2

extern int     TMAPeriod  =  3;
extern int HalfTMAPeriod  =  21;
extern int      TMAPrice  =  0;
extern bool   ShowZigZag  =  true;
extern int         Depth  =  12;
extern int     Deviation  =  20;
extern int      Backstep  =  3;


double KREST[];
double ZIGZAG[];
double CenterTMA[];
double HalfTMA[];
double ArrowUP[];
double ArrowDN[];
double ZoneBUY[];
double ZoneSELL[];
int gia_136[6] = {0, 0, 0, 0, 0, 0};
int gia_140[5] = {0, 0, 0, 0, 0};
int gi_144;
int gi_148;
int gi_152;
int gi_156;
int gi_160;
bool gi_164 = TRUE;
int g_bars_168 = 0;

void f0_6(int i) {
   if (Bars - i > TMAPeriod + 1) f0_5(i);
   else CenterTMA[i] = 0;
   if (Bars - i > HalfTMAPeriod + TMAPeriod + 2) {
      CalcTMAlines(i);
      return;
   }
   HalfTMA[i] = 0;
}

void f0_5(int i) {
   int li_4;
   int count_8;
   int counted_bars;
   int limit;
   double ld_20;
   switch (TMAPrice) {
   case 0:
      CenterTMA[i] = iMA(NULL, 0, TMAPeriod + 1, 0, MODE_LWMA, PRICE_CLOSE, i);
      break;
   case 1:
      CenterTMA[i] = iMA(NULL, 0, TMAPeriod + 1, 0, MODE_LWMA, PRICE_OPEN, i);
      break;
   case 4:
      CenterTMA[i] = iMA(NULL, 0, TMAPeriod + 1, 0, MODE_LWMA, PRICE_MEDIAN, i);
      break;
   case 5:
      CenterTMA[i] = iMA(NULL, 0, TMAPeriod + 1, 0, MODE_LWMA, PRICE_TYPICAL, i);
      break;
   case 6:
      CenterTMA[i] = iMA(NULL, 0, TMAPeriod + 1, 0, MODE_LWMA, PRICE_WEIGHTED, i);
      break;
   default:
      CenterTMA[i] = iMA(NULL, 0, TMAPeriod + 1, 0, MODE_LWMA, PRICE_OPEN, i);
   }
   for (int x = i + TMAPeriod + 2; x > i; x--) {
      ld_20 = 0.0;
      li_4 = 0;
      count_8 = 0;
      counted_bars = x + TMAPeriod;
      limit = x - TMAPeriod;
      if (limit < i) limit = i;
      while (counted_bars >= x) {
         count_8++;
         ld_20 += count_8 * f0_2(counted_bars);
         li_4 += count_8;
         counted_bars--;
      }
      while (counted_bars >= limit) {
         count_8--;
         ld_20 += count_8 * f0_2(counted_bars);
         li_4 += count_8;
         counted_bars--;
      }
      CenterTMA[x] = ld_20 / li_4;
   }
}

double f0_2(int i) {
   switch (TMAPrice) {
   case 0:
      return (Close[i]);
   case 1:
      return (Open[i]);
   case 4:
      return ((High[i] + Low[i]) / 2.0);
   case 5:
      return ((Close[i] + High[i] + Low[i]) / 3.0);
   case 6:
      return ((2.0 * Close[i] + High[i] + Low[i]) / 4.0);
   }
   return (Open[i]);
}

void CalcTMAlines(int i) {
   double ld_4;
   double ld_12;
   for (int k = i + TMAPeriod + 2; k >= i; k--) {
      ld_4 = CenterTMA[ArrayMaximum(CenterTMA, HalfTMAPeriod, k)];
      ld_12 = CenterTMA[ArrayMinimum(CenterTMA, HalfTMAPeriod, k)];
      HalfTMA[k] = ((Backstep + 2) * 2 * CenterTMA[k] - (ld_4 + ld_12)) / 2.0 / (Backstep + 1);
   }
}

void ManageZigZag(int i) {
   int li_4;
   int j;
   int counted_bars;
   int index_16;
   int k = i - 1;
   int li_24 = 0;
   int li_28 = 0;
   while (k < gi_144 && counted_bars == 0) {
      k++;
      ZIGZAG[k] = 0;
      li_4 = k - Deviation;
      if (li_4 < i) li_4 = i;
      j = k + Deviation;
      if (k == ArrayMinimum(HalfTMA, j - li_4 + 1, li_4)) {
         counted_bars = -1;
         li_24 = k;
      }
      if (k == ArrayMaximum(HalfTMA, j - li_4 + 1, li_4)) {
         counted_bars = 1;
         li_28 = k;
      }
   }
   if (counted_bars != 0) {
      index_16 = 0;
      if (k > i) {
         if (HalfTMA[k] > HalfTMA[i]) {
            if (counted_bars == 1) {
               if (k >= i + Deviation && index_16 < 5) {
                  index_16++;
                  gia_136[index_16] = k;
               }
               li_28 = k;
               ZIGZAG[k] = HalfTMA[k];
            }
         } else {
            if (counted_bars == -1) {
               if (k >= i + Deviation && index_16 < 5) {
                  index_16++;
                  gia_136[index_16] = k;
               }
               li_24 = k;
               ZIGZAG[k] = HalfTMA[k];
            }
         }
      }
      while (k < gi_160 || index_16 < 5) {
         ZIGZAG[k] = 0;
         li_4 = k - Deviation;
         if (li_4 < i) li_4 = i;
         j = k + Deviation;
         if (k == ArrayMinimum(HalfTMA, j - li_4 + 1, li_4)) {
            if (counted_bars == -1 && HalfTMA[k] < HalfTMA[li_24]) {
               if (k >= i + Deviation && index_16 < 5) gia_136[index_16] = k;
               ZIGZAG[li_24] = 0;
               ZIGZAG[k] = HalfTMA[k];
               li_24 = k;
            }
            if (counted_bars == 1) {
               if (k >= i + Deviation && index_16 < 5) {
                  index_16++;
                  gia_136[index_16] = k;
               }
               ZIGZAG[k] = HalfTMA[k];
               counted_bars = -1;
               li_24 = k;
            }
         }
         if (k == ArrayMaximum(HalfTMA, j - li_4 + 1, li_4)) {
            if (counted_bars == 1 && HalfTMA[k] > HalfTMA[li_28]) {
               if (k >= i + Deviation && index_16 < 5) gia_136[index_16] = k;
               ZIGZAG[li_28] = 0;
               ZIGZAG[k] = HalfTMA[k];
               li_28 = k;
            }
            if (counted_bars == -1) {
               if (k >= i + Deviation && index_16 < 5) {
                  index_16++;
                  gia_136[index_16] = k;
               }
               ZIGZAG[k] = HalfTMA[k];
               counted_bars = 1;
               li_28 = k;
            }
         }
         k++;
         if (k > gi_144) return;
      }
      gi_152 = Bars - gia_136[5];
      ZIGZAG[i] = HalfTMA[i];
      return;
   }
}

void ManageArrowsZones(int i) {
   int li_4;
   int j;
   int counted_bars;
   int index_16;
   int k = i - 1;
   int li_24 = 0;
   int li_28 = 0;
   while (k <= gi_160 && counted_bars == 0) {
      k++;
      ZoneSELL[k] = 0;
      ZoneBUY[k] = 0;
      ArrowDN[k] = 0;
      ArrowUP[k] = 0;
      KREST[k] = 0;
      li_4 = k - Depth;
      if (li_4 < i) li_4 = i;
      j = k + Depth;
      if (k == ArrayMinimum(HalfTMA, j - li_4 + 1, li_4)) {
         counted_bars = -1;
         li_24 = k;
      }
      if (k == ArrayMaximum(HalfTMA, j - li_4 + 1, li_4)) {
         counted_bars = 1;
         li_28 = k;
      }
   }
   if (counted_bars != 0) {
      index_16 = 0;
      if (k > i) {
         if (HalfTMA[k] > HalfTMA[i]) {
            if (counted_bars == 1) {
               if (k >= i + Depth && index_16 < 4) {
                  index_16++;
                  gia_140[index_16] = k;
               }
               li_28 = k;
               ArrowDN[k - 1] = Open[k - 1];
            }
         } else {
            if (counted_bars == -1) {
               if (k >= i + Depth && index_16 < 4) {
                  index_16++;
                  gia_140[index_16] = k;
               }
               li_24 = k;
               ArrowUP[k - 1] = Open[k - 1];
            }
         }
      }
      while (k <= gi_160 || index_16 < 4) {
         ZoneSELL[k] = 0;
         ZoneBUY[k] = 0;
         ArrowDN[k] = 0;
         ArrowUP[k] = 0;
         KREST[k] = 0;
         li_4 = k - Depth;
         if (li_4 < i) li_4 = i;
         j = k + Depth;
         if (k == ArrayMinimum(HalfTMA, j - li_4 + 1, li_4)) {
            if (counted_bars == -1 && HalfTMA[k] < HalfTMA[li_24]) {
               if (k >= i + Depth && index_16 < 4) gia_140[index_16] = k;
               ArrowUP[li_24 - 1] = 0;
               ArrowUP[k - 1] = Open[k - 1];
               li_24 = k;
            }
            if (counted_bars == 1) {
               if (k >= i + Depth && index_16 < 4) {
                  index_16++;
                  gia_140[index_16] = k;
               }
               ArrowUP[k - 1] = Open[k - 1];
               counted_bars = -1;
               li_24 = k;
            }
         }
         if (k == ArrayMaximum(HalfTMA, j - li_4 + 1, li_4)) {
            if (counted_bars == 1 && HalfTMA[k] > HalfTMA[li_28]) {
               if (k >= i + Depth && index_16 < 4) gia_140[index_16] = k;
               ArrowDN[li_28 - 1] = 0;
               ArrowDN[k - 1] = Open[k - 1];
               li_28 = k;
            }
            if (counted_bars == -1) {
               if (k >= i + Depth && index_16 < 4) {
                  index_16++;
                  gia_140[index_16] = k;
               }
               ArrowDN[k - 1] = Open[k - 1];
               counted_bars = 1;
               li_28 = k;
            }
         }
         k++;
         if (k > gi_160) return;
      }
      gi_148 = Bars - gia_140[4];
      return;
   }
}

void DrawKREST() {
   int li_0;
   int li_4 = 0;
   for (int j = gi_160; ZIGZAG[j] == 0.0; j--) {
   }
   int counted_bars = j;
   double ld_16 = ZIGZAG[j];
   for (j--; ZIGZAG[j] == 0.0; j--) {
   }
   if (ZIGZAG[j] > ld_16) li_4 = 1;
   if (ZIGZAG[j] > 0.0 && ZIGZAG[j] < ld_16) li_4 = -1;
   ld_16 = ZIGZAG[counted_bars];
   for (j = counted_bars - 1; j > 0; j--) {
      if (ZIGZAG[j] > ld_16) {
         li_4 = -1;
         ld_16 = ZIGZAG[j];
      }
      if (ZIGZAG[j] > 0.0 && ZIGZAG[j] < ld_16) {
         li_4 = 1;
         ld_16 = ZIGZAG[j];
      }
      if (li_4 > 0 && ArrowDN[j] > 0.0) {
         KREST[j] = Open[j];
         ArrowDN[j] = 0;
      }
      if (li_4 < 0 && ArrowUP[j] > 0.0) {
         KREST[j] = Open[j];
         ArrowUP[j] = 0;
      }
      if (li_4 > 0 && ArrowUP[j] > 0.0) {
         if (j > 1) {
            counted_bars = j - 1;
            li_0 = counted_bars - Depth + 1;
            if (li_0 < 0) li_0 = 0;
            for (int li_24 = counted_bars; li_24 >= li_0 && ArrowDN[li_24] == 0.0; li_24--) {
               ZoneBUY[li_24] = ArrowUP[j];
               ZoneSELL[li_24] = 0;
            }
         }
         if (j == 1) ZoneBUY[0] = ArrowUP[j];
      }
      if (li_4 < 0 && ArrowDN[j] > 0.0) {
         if (j > 1) {
            counted_bars = j - 1;
            li_0 = counted_bars - Depth + 1;
            if (li_0 < 0) li_0 = 0;
            for (li_24 = counted_bars; li_24 >= li_0 && ArrowUP[li_24] == 0.0; li_24--) {
               ZoneSELL[li_24] = ArrowDN[j];
               ZoneBUY[li_24] = 0;
            }
         }
         if (j == 1) ZoneSELL[0] = ArrowDN[j];
      }
   }
}

void deinit() {
}

int init() {
   //string lsa_unused_0[256];
   IndicatorBuffers(8);
   SetIndexBuffer(0, KREST);
   SetIndexStyle(0, DRAW_ARROW);
   SetIndexArrow(0, SYMBOL_STOPSIGN);
   SetIndexEmptyValue(0, 0.0);
   
   SetIndexBuffer(1, ZIGZAG);
   if (ShowZigZag) { SetIndexStyle(1, DRAW_SECTION);   SetIndexEmptyValue(1, 0.0); }    else SetIndexStyle(1, DRAW_NONE);
   
   SetIndexBuffer(2, CenterTMA);
   SetIndexStyle(2, DRAW_LINE);
   
   SetIndexBuffer(3, HalfTMA);
   SetIndexStyle(3, DRAW_LINE);
   
   SetIndexBuffer(4, ArrowUP);
   SetIndexStyle(4, DRAW_ARROW);
   SetIndexArrow(4, 233);
   SetIndexEmptyValue(4, 0.0);
   
   SetIndexBuffer(5, ArrowDN);
   SetIndexStyle(5, DRAW_ARROW);
   SetIndexArrow(5, 234);
   SetIndexEmptyValue(5, 0.0);
   
   SetIndexBuffer(6, ZoneBUY);
   SetIndexStyle(6, DRAW_ARROW, STYLE_SOLID);
   SetIndexArrow(6, 116);
   SetIndexEmptyValue(6, 0.0);
   
   SetIndexBuffer(7, ZoneSELL);
   SetIndexStyle(7, DRAW_ARROW, STYLE_SOLID);
   SetIndexArrow(7, 116);
   SetIndexEmptyValue(7, 0.0);
   
   
   return (0);
}


int start() {
   ////string ls_0 = "2333.01.30";
   ////int str2time_8 = StrToTime(ls_0);
   ////if (TimeCurrent() >= str2time_8) {
   ////   Alert("Maaf simple-v3 Sudah Expired...! Sumarjan Toguna diFB");
   ////   return (0);
   ////}
   int counted_bars = IndicatorCounted();
   if (counted_bars < 0) return (-1);
   if (counted_bars > 0) counted_bars--;
   if (gi_164 == TRUE) {
      if (TMAPeriod < 2) TMAPeriod = 2;
      if (Bars <= (Deviation + HalfTMAPeriod + TMAPeriod + 2) * 2) return (-1);
      if (Depth <= TMAPeriod) Depth = TMAPeriod + 1;
      gi_144 = Bars - (Deviation + HalfTMAPeriod + TMAPeriod + 2);
      gi_160 = gi_144;
      gi_156 = gi_160;
      g_bars_168 = Bars;
      gi_164 = FALSE;
   }
   int limit = Bars - counted_bars;
   for (int k = limit; k >= 0; k--) f0_6(k);
   if (g_bars_168 != Bars) {
      gi_156 = Bars - gi_148;
      gi_160 = Bars - gi_152;
      g_bars_168 = Bars;
   }
   ManageArrowsZones(0);
   ManageZigZag(0);
   DrawKREST();
   return (0);
}
