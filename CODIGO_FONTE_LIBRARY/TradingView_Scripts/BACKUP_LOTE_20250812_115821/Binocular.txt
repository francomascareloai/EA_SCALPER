// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Jib1979

//@version=5
indicator("Binocular", overlay=true, max_bars_back = 5000)

//Binocular
//Settlement

// === INPUTS
useDaily = input(true, title='Use Daily Data to Calculate HV (default), otherwise chart TF')
LookBack = input.int(21, minval=1)
annual = input.int(252, minval=1)
DaystoExpire_ = input.int(defval=0, minval=0, title='Calender Days to Expiry (0=Auto, default)')
src_111 = input(close, title='Settlement Source (close=default)')
sLength_ = input.int(1, minval=1, title='Settlement Volume Weighted Average Length (1=Use end of day)')
//
showset  = input(title="Settlement", defval=true, group='Settlement')
stddev1 = input(true, title='Display 1x Standard Deviation Levels', group='Settlement')
stddev2 = input(false, title='Display 2x Standard Deviation Levels',group='Settlement')
stddev3 = input(false, title='Display 3x Standard Deviation Levels',group='Settlement')
pivotNow = input(false, title='Display Only Todays Deviation Levels',group='Settlement')
showstd1 = input(title="Dev1 Labels", defval=true, group='Settlement')
showstd2 = input(title="Dev2 Labels", defval=false,group='Settlement')
showstd3 = input(title="Dev3 Labels", defval=false, group='Settlement')


// 
// === /INPUTs
dodgerblue = #1E90FF
//
// Test for new Daily Session or start of new month for Daily.
sLength = timeframe.isintraday ? sLength_ : 1
nstart = request.security(syminfo.tickerid, 'D', bar_index, barmerge.gaps_off, barmerge.lookahead_on)
start1 = request.security(syminfo.tickerid, 'D', time, barmerge.gaps_off, barmerge.lookahead_on)
first = request.security(syminfo.tickerid, 'D', ta.valuewhen(barstate.islast, time, 0), barmerge.gaps_off, barmerge.lookahead_on)

nohist = nstart <= math.max(sLength, LookBack) + 1

change_1 = ta.change(start1)
newDay = nohist ? false : timeframe.isintraday ? change_1 : dayofmonth(time) < dayofmonth(time[1])


// Calculate Annualised Volatility
hv = 0.0
stdev_1 = ta.stdev(math.log(src_111 / src_111[1]), LookBack)
security_1 = request.security(syminfo.tickerid, 'D', stdev_1 * math.sqrt(annual), barmerge.gaps_off, barmerge.lookahead_on)
stdev_2 = ta.stdev(math.log(src_111 / src_111[1]), LookBack)
hv_ = useDaily ? security_1 : stdev_2 * math.sqrt(annual)
hv := newDay ? hv_ : nz(hv[1], hv_)
hinow = high
hinow := newDay ? high : high > hinow[1] ? high : hinow[1]
lonow = low
lonow := newDay ? low : low < lonow[1] ? low : lonow[1]

prevhi = ta.valuewhen(newDay, hinow[1], 0)
prevlo = ta.valuewhen(newDay, lonow[1], 0)

// get the Daily Settlement 
valuewhen_1 = ta.valuewhen(start1[1] <= time, src_111, 0)
vwma_1 = ta.vwma(src_111[1], sLength)
settlement = sLength == 1 ? valuewhen_1 : vwma_1
settlement := newDay ? settlement : nz(settlement[1], open[1])



firstDay = dayofmonth(start1) == dayofmonth(first) and month(start1) == month(first) and year(start1) == year(first)
stdhv = 0.0
DaystoExpire = DaystoExpire_ == 0 ? timeframe.isintraday ? useDaily ? 1 : math.min(annual, 1440 / timeframe.multiplier) : LookBack : DaystoExpire_
stdhv := newDay ? settlement * hv * math.sqrt(DaystoExpire / annual) : nz(stdhv[1])

// calculate StdDev lines ratios.
stdhv05 = stdhv * 0.5
stdhv07 = stdhv * 0.7
stdhv1 = stdhv
Stdhv05u = settlement + stdhv05
Stdhv05d = settlement - stdhv05
Stdhv07u = settlement + stdhv07
Stdhv07d = settlement - stdhv07
Stdhv1u  = settlement + stdhv1
Stdhv1d  = settlement - stdhv1


// Plot the StdDev Levels for all Days.

SettleM = plot(not nohist and showset and (not pivotNow or firstDay) and not newDay ? settlement : na, color=color.new(#ec186d, 0), title='Settlement', linewidth=2, style=plot.style_linebr)
stdhv05u = plot(not nohist and stddev1 and (not pivotNow or firstDay) and not newDay ? settlement + stdhv05 : na, color=color.new(color.orange, 20), title='+0.5 SD', linewidth=1, style=plot.style_linebr)
stdhv05d = plot(not nohist and stddev1 and (not pivotNow or firstDay) and not newDay ? settlement - stdhv05 : na, color=color.new(color.orange, 20), title='-0.5 SD', linewidth=1, style=plot.style_linebr)
stdhv07u = plot(not nohist and stddev1 and (not pivotNow or firstDay) and not newDay ? settlement + stdhv07 : na, color=color.new(color.red, 20), title='+0.7 SD', linewidth=1, style=plot.style_linebr)
stdhv07d = plot(not nohist and stddev1 and (not pivotNow or firstDay) and not newDay ? settlement - stdhv07 : na, color=color.new(color.red, 20), title='-0.7 SD', linewidth=1, style=plot.style_linebr)
stdhv1u = plot(not nohist and stddev1 and (not pivotNow or firstDay) and not newDay ? settlement + stdhv1 : na, color=color.new(color.lime, 20), title='+1 SD', linewidth=3, style=plot.style_linebr)
stdhv1d = plot(not nohist and stddev1 and (not pivotNow or firstDay) and not newDay ? settlement - stdhv1 : na, color=color.new(color.lime, 20), title='-1 SD', linewidth=3, style=plot.style_linebr)

//Show Settlement

if showset
    settlement = label.new(start1, settlement, text='Settlement', xloc=xloc.bar_time, textcolor=color.new(#ec186d,0), style=label.style_none)
    label.delete(settlement[1])

if stddev1
    if Stdhv05u
        Stdhv05u = label.new(start1, Stdhv05u, text='+0.5', xloc=xloc.bar_time, textcolor=color.new(color.orange,0), style=label.style_none)
        label.delete(Stdhv05u[1])
    if Stdhv05d
        Stdhv05d = label.new(start1, Stdhv05d, text='-0.5', xloc=xloc.bar_time, textcolor=color.new(color.orange,0), style=label.style_none)
        label.delete(Stdhv05d[1])
    if Stdhv07u
        Stdhv07u = label.new(start1, Stdhv07u, text='+0.7', xloc=xloc.bar_time, textcolor=color.new(color.red,0), style=label.style_none)
        label.delete(Stdhv07u[1])
    if Stdhv07d
        Stdhv07d = label.new(start1, Stdhv07d, text='-0.7', xloc=xloc.bar_time, textcolor=color.new(color.red,0), style=label.style_none)
        label.delete(Stdhv07d[1])
    if Stdhv1u
        Stdhv1u = label.new(start1, Stdhv1u, text='+1.0', xloc=xloc.bar_time, textcolor=color.new(color.lime,10), style=label.style_none)
        label.delete(Stdhv1u[1])
    if Stdhv1d
        Stdhv1d = label.new(start1, Stdhv1d, text='-1.0', xloc=xloc.bar_time, textcolor=color.new(color.lime,10), style=label.style_none)
        label.delete(Stdhv1d[1])


//
//

//Buy Sell

// ======================================================================
//                               INPUTS 
// ======================================================================

tgrp = "???????????????? TRADE SETUP ????????????????"
bfr = input.float(0.02,title = "Entry Buffer",inline = "1",group = tgrp)
tm = input.session("Last Trade", title = "", options = ["Last Trade","All Trade"],inline = "1",group = tgrp)
eb = input.bool(true,title = "Entry",inline = "2",group = tgrp)
tb1 = input.bool(true,title = "Target 1",inline = "2",group = tgrp)
tb2 = input.bool(true,title = "Target 2",inline = "2",group = tgrp)
tb3 = input.bool(true,title = "Target 3",inline = "2",group = tgrp)
slb = input.bool(true,title = "Stop Loss",inline = "2",group = tgrp)

// ============================== VWAP ==================================

gr1 = "???????????????? VWAP ????????????????"
vwapd = input.bool(true,"",inline="1",group=gr1)
vwapw = input.bool(false,"",inline="1",group=gr1)
vwapm = input.bool(false,"",inline="1",group=gr1)
src = input.source(hlc3,title="Source",inline="1",group=gr1)
dvc = ta.vwap(close) > close ? color.new(color.fuchsia,0) : color.new(color.blue,0)
wvc = color.new(#44f513,0)
mvc = color.new(color.yellow,0)

// =============================== MA ===================================
gr2 = "???????????????? MA ????????????????"
mab1 = input.bool(false,"",inline="1",group=gr2)
mat1 = input.string(title = "", defval = "SMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"],inline="1", group=gr2)
mas1 = input.source(hlc3,title="",inline="1",group=gr2)
mal1 = input.int(21,title="",inline="1",group=gr2)
c1 =   color.new(color.lime,0)

mab2 = input.bool(false,"",inline="2",group=gr2)
mat2 = input.string(title = "", defval = "SMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"],inline="2", group=gr2)
mas2 = input.source(hlc3,title="",inline="2",group=gr2)
mal2 = input.int(44,title="",inline="2",group=gr2)
c2 = color.new(color.red,0)
mab3 = input.bool(false,"",inline="3",group=gr2)
mat3 = input.string(title = "", defval = "SMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"],inline="3", group=gr2)
mas3 = input.source(hlc3,title="",inline="3",group=gr2)
mal3 = input.int(100,title="",inline="3",group=gr2)
c3 = color.new(color.blue,0)

// ============================= TABLE ==================================

tab = "???????????????? TABLE ????????????????"
plt = input.bool(true,title="P/L Table",inline="1",group=tab)
TablePos = input.string(title="Table Location", defval="Bottom Right", options=["Top Right",  "Middle Right",  "Bottom Right", 
              "Top Center", "Middle Center", "Bottom Center", "Top Left",   "Middle Left",   "Bottom Left"], inline="1", group=tab)

size = input.string(title="Table Size", defval="Auto", options=["Auto",  "Huge",  "Large", "Normal", "Small", "Tiny"], inline="1", group=tab)

tbgc = color.new(color.black,0)
brc = color.new(color.white,0)
tw = input.int(2,"",inline="1",group=tab)




// =============== EXPORT FUNCTION =========================================================================================

tablelocation(string TablePos,string size) =>
    _TablePos= TablePos== "Top Right"    ? position.top_right: 
           TablePos== "Middle Right" ? position.middle_right:  
           TablePos== "Bottom Right" ? position.bottom_right: 
           TablePos== "Top Center"   ? position.top_center: 
           TablePos== "Middle Center"? position.middle_center:
           TablePos== "Bottom Center"? position.bottom_center:
           TablePos== "Top Left"     ? position.top_left: 
           TablePos== "Middle Left"  ? position.middle_left:position.bottom_left
    _size= size == "Auto" ? size.auto:  size == "Huge"  ? size.huge: 
       size == "Large"? size.large: size == "Normal"? size.normal: 
       size == "Small"? size.small: size.tiny
    [_TablePos,_size]

DefineLabel(bool but,int pos,int index,float Price,color color_,string text_)=>
    var label _offsetLabel=na
    line li = na
    label msg = na
    if barstate.islast and index > 0 and pos != 0 and but
        li := line.new(index, Price, bar_index+5, Price, extend=extend.right,color=color_)
        _offsetLabel := label.new(bar_index + 10, Price,text = text_+" : "+ str.tostring(int(math.round(Price,2))),color=color_,textcolor=color_,style=label.style_none)

    label.delete(_offsetLabel[1])
    line.delete(li[1])

entry(bool plt,table testTable,string _size,int bs,int pos,int index,float Price,float sl) =>
    label le = na
    line li = na
    if barstate.islast and pos == 0
        if bs == 1
            txt = "BUY ABOVE : " + str.tostring(int(math.round(Price,2)))
            li := line.new(index, Price, bar_index+5, Price, extend=extend.right,color=color.new(color.lime,0),style=line.style_dashed)
            le := label.new(bar_index + 10, Price, text= txt, style=label.style_none,textcolor=color.new(color.lime,0),textalign=text.align_left)

        if bs == -1
            txt = "SELL BELLOW : " + str.tostring(int(math.round(Price,2)))
            li := line.new(index, Price, bar_index+5, Price, extend=extend.right,color=color.new(color.red,0),style=line.style_dashed)
            le := label.new(bar_index + 10, Price, text= txt, style=label.style_none,textcolor=color.new(color.red,0),textalign=text.align_left)
    label.delete(le[1])
    line.delete(li[1])    

    pl = 0.0
    pl := pos == 1 ? math.max((high - Price),nz(pl[1])) : pos == -1 ? math.max((Price - low),nz(pl[1])) : 0
    plp = math.round(math.abs(pl*100/Price),2)
    
    htc = color.new(color.white,0)
    btc = color.new(color.white,0)
    bg = bs == 1 ? color.new(#025d06,0) : color.new(#b60000,0)
    if barstate.islast and plt
        table.cell(table_id = testTable, column = 0, row = 0, text = "Entry",text_color=htc,text_size=_size)
        table.cell(table_id = testTable, column = 1, row = 0, text = "SL",text_color=htc,text_size=_size)
        table.cell(table_id = testTable, column = 0, row = 1, text = str.tostring(int(math.round(Price,2))), bgcolor = bg,text_color=btc,text_size=_size)
        table.cell(table_id = testTable, column = 1, row = 1, text = str.tostring(int(math.round(sl,2))), bgcolor = bg,text_color=btc,text_size=_size)
     
//
//
//EMA
showema = input(title='Show EMA', defval=true)
len1 = input.int(30, minval=1, title='MA1')
len2 = input.int(35, minval=1, title='MA2')
len3 = input.int(40, minval=1, title='MA3')
len4 = input.int(45, minval=1, title='MA4')
len5 = input.int(50, minval=1, title='MA5')
len6 = input.int(60, minval=1, title='MA6')


ma1 = ta.ema(close, len1)
ma2 = ta.ema(close, len2)
ma3 = ta.ema(close, len3)
ma4 = ta.ema(close, len4)
ma5 = ta.ema(close, len5)
ma6 = ta.ema(close, len6)

plot(showema ? ma1 : na, title='MA1', color=close > ma1 ? color.new(color.green, 0) : color.new(color.red,0))
plot(showema ? ma2 : na, title='MA2', color=close > ma2 ? color.new(color.green,0) : color.new(color.red, 0))
plot(showema ? ma3 : na, title='MA3', color=close > ma3 ? color.new(color.green,0) : color.new(color.red, 0))
plot(showema ? ma4 : na, title='MA4', color=close > ma4 ? color.new(color.green, 0) : color.new(color.red,0))
plot(showema ? ma5 : na, title='MA5', color=close > ma5 ? color.new(#44f513, 0) : color.new(#ff0000,0), linewidth=3, style=plot.style_line)
plot(showema ? ma6 : na, title='MA6', color=close > ma6 ? color.new(color.green, 0) : color.new(color.red,0))


longCond = bool(na)
shortCond = bool(na)
longCond := ma1 > ma6 and ma2 > ma6 and ma3 > ma6 and ma4 > ma6 and ma5 > ma6
shortCond :=  ma1 < ma6 and ma2 < ma6 and ma3 < ma6 and ma4 < ma6 and ma5 < ma6

CondIni = 0
CondIni := longCond ? 1 : shortCond ? -1 : CondIni[1]
longCondition = longCond and CondIni[1] == -1
shortCondition = shortCond and CondIni[1] == 1
//
//Price Volume Trend
signalType = input.string(title='Signal Smoothing Type', defval='SMA', options=['EMA', 'SMA'])
signalLength = input(title='Signal Smoothing Length', defval=21)
src420 = input(title='Source', defval=close)
highlightCrossovers = input(title='Highlight Crossovers ?', defval=false)
applyFilling = input(title='Apply Ribbon Filling ?', defval=true)

signal_1 = signalType == 'EMA' ? ta.ema(ta.pvt, signalLength) : ta.sma(ta.pvt, signalLength)

//

calculation(float bfr) =>
    time_limit = timestamp(2222, 1, 31, 23, 00)
    display = timenow < time_limit
    rsi1 = ta.rsi(close,25)
    rsi2 = ta.rsi(close,55)
    
    length = 10
    mult = 2.2
    useClose = true
    
    atr = mult * ta.atr(length)
    
    longStop = (useClose ? ta.highest(close, length) : ta.highest(length)) - atr
    longStopPrev = nz(longStop[1], longStop)
    longStop := close[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop
    
    shortStop = (useClose ? ta.lowest(close, length) : ta.lowest(length)) + atr
    shortStopPrev = nz(shortStop[1], shortStop)
    shortStop := close[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop
    
    var int dir = 1
    dir := close > shortStopPrev ? 1 : close < longStopPrev ? -1 : dir
    
    BUY = dir == 1 and ta.pvt > signal_1 and rsi1 > rsi2
    SELL = dir == -1 and ta.pvt < signal_1 and rsi1 < rsi2    

    var bool buy=false
    var bool sell = false
    var bool buy1=false
    var bool sell1 = false
    
    var float HighVal=na
    var float LowVal = na
    
    var float Stoploss=na
    var float Target1 = na
    var float Target2 = na
    var float Target3 = na
    var float Target4 = na
    var index = 0
    var pos = 0
    var bs = 0
    var en = 0.0
    if  display
        if BUY and BUY[1]==false and buy==false
            bs := 1
            label.new(bar_index,close,text='',size=size.normal,color=color.new(color.green,100),yloc=yloc.belowbar,style=label.style_label_up,textcolor=color.new(color.white,100))
            pos := 0
            index := bar_index
            buy:=true
            sell:=false
            sell1:=false
            en := high*(1+bfr/100)
            HighVal:=high*(1+bfr/100)
            Stoploss:=math.min(low[1],low)            
            diff = (high-low[1])*2
            Target1:=high+diff
            Target2:=Target1+diff
            Target3:=Target2+diff
            Target4:=Target3+diff
        
        
        if SELL and SELL[1]==false and sell==false
            bs := -1
            label.new(bar_index,close,text='',size=size.normal,color=color.new(color.red,100),yloc=yloc.abovebar,style=label.style_label_down,textcolor=color.new(color.white,100))
            pos := 0
            index := bar_index
            sell:=true
            buy:=false
            buy1:=false
            en := low*(1-bfr/100)
            LowVal:=low*(1-bfr/100)
            Stoploss:=math.max(high[1],high)
            diff = (high[1]-low)*2
            Target1:=low-diff
            Target2:=Target1-diff
            Target3:=Target2-diff
            Target4:=Target3-diff
        
        
        if buy and high>HighVal and buy1==false
            label.new(bar_index,close,text='',size=size.tiny,color=color.new(color.green,100),yloc=yloc.belowbar,style=label.style_triangleup,textcolor=color.new(color.white,0))
            pos := 1
            buy1:=true
            sell1:=false
            
        if sell and low<LowVal and sell1==false
            label.new(bar_index,close,text='',size=size.tiny,color=color.new(color.red,100),yloc=yloc.abovebar,style=label.style_triangledown,textcolor=color.new(color.white,0))
            pos := -1
            buy1:=false
            sell1:=true
        


    [bs,pos,index,en,Stoploss,Target1,Target2,Target3]

// ============== VWAP + MA Calculation ===================================================================================

vwapc(float src,string tf1,string tf2,string tf3) =>
    time_limit = timestamp(2222, 1, 31, 23, 00)
    display = timenow < time_limit
    
    v1 = display ? ta.vwap(src, timeframe.change(tf1)) : na
    v2 = display ? ta.vwap(src, timeframe.change(tf2)) : na
    v3 = display ? ta.vwap(src, timeframe.change(tf3)) : na
    
    [v1,v2,v3]

ma(float source,simple int length,string type) =>
    time_limit = timestamp(2222, 1, 31, 23, 00)
    display = timenow < time_limit
    if display
        switch type
            "SMA" => ta.sma(source, length)
            "EMA" => ta.ema(source, length)
            "SMMA (RMA)" => ta.rma(source, length)
            "WMA" => ta.wma(source, length)
            "VWMA" => ta.vwma(source, length)
    else
        na

// ============== IMPORT FUNCTIONS ====================================================================================

[bs,pos,index,e,sl,t1,t2,t3] = calculation(bfr)

plot(tm == "All Trade" and eb and pos != 0 ? e : na, title = "Entry", color=color.new(#019a66,0), style = plot.style_linebr)
plot(tm == "All Trade" and tb1 and pos != 0 ? t1 : na, title = "TG 1",color=color.new(color.lime,0), style = plot.style_linebr)
plot(tm == "All Trade" and tb2 and pos != 0 ? t2 : na, title = "TG 2",color=color.new(color.lime,0), style = plot.style_linebr)
plot(tm == "All Trade" and tb3 and pos != 0 ? t3 : na, title = "TG 3",color=color.new(color.lime,0), style = plot.style_linebr)
plot(tm == "All Trade" and slb and pos != 0 ? sl : na, title = "SL",color=color.new(color.red,0), style = plot.style_linebr)

DefineLabel(eb,pos,index,e,color.new(#019a66,0),'EN')
DefineLabel(slb,pos,index,sl,color.new(color.red,0),'SL')
DefineLabel(tb1,pos,index,t1,color.new(color.green,0),'TG1')
DefineLabel(tb2,pos,index,t2,color.new(color.green,0),'TG2')
DefineLabel(tb3,pos,index,t3,color.new(color.green,0),'TG3')

[_TablePos,_size] = tablelocation(TablePos,size)
var testTable = table.new(_TablePos, 3, 2, bgcolor = tbgc, frame_color = brc, frame_width = tw, border_color = brc, border_width = tw)

entry(plt,testTable,_size,bs,pos,index,e,sl)

// ========================================================================================================================

[v1,v2,v3] = vwapc(src,"D","W","M")

plot(vwapd?v1:na, title = "Daily VWAP", color=dvc, linewidth=2)
plot(vwapw?v2:na, title = "Weekly VWAP", color=wvc, linewidth=2)
plot(vwapm?v3:na, title = "Monthly VWAP", color=mvc, linewidth=2)

plot(mab1 ? ma(mas1,mal1,mat1) : na, title = "MA 1", color=c1)
plot(mab2 ? ma(mas2,mal2,mat2) : na, title = "MA 2", color=c2)
plot(mab3 ? ma(mas3,mal3,mat3) : na, title = "MA 3", color=c3)




// ========================================================================================================================

signal() =>
    rsi1 = ta.rsi(close,25)
    rsi2 = ta.rsi(close,55)
    
    length = 10
    mult = 2.2
    useClose = true
    
    atr = mult * ta.atr(length)
    
    longStop = (useClose ? ta.highest(close, length) : ta.highest(length)) - atr
    longStopPrev = nz(longStop[1], longStop)
    longStop := close[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop
    
    shortStop = (useClose ? ta.lowest(close, length) : ta.lowest(length)) + atr
    shortStopPrev = nz(shortStop[1], shortStop)
    shortStop := close[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop
    
    var int dir = 1
    dir := close > shortStopPrev ? 1 : close < longStopPrev ? -1 : dir
    
    BUY = dir == 1 and ta.pvt > signal_1
    SELL = dir == -1 and ta.pvt < signal_1
    [BUY,SELL]



mtf_t = input.bool(true,title="P/L Table",inline="1", group = "MTF SIGNAL")
mtf_p = input.string(title="Table Location", defval="Top Right", options=["Top Right",  "Middle Right",  "Bottom Right", 
              "Top Center", "Middle Center", "Bottom Center", "Top Left",   "Middle Left",   "Bottom Left"], inline="1", group = "MTF SIGNAL")

mtf_s = input.string(title="Table Size", defval="Auto", options=["Auto",  "Huge",  "Large", "Normal", "Small", "Tiny"], inline="1", group = "MTF SIGNAL")

tf_1 = input.timeframe('3', title = "Time Frame", inline = "1", group = "MTF SIGNAL")
tf_2 = input.timeframe('5', title = "Time Frame", inline = "1", group = "MTF SIGNAL")
tf_3 = input.timeframe('15', title = "Time Frame", inline = "1", group = "MTF SIGNAL")
tf_4 = input.timeframe('30', title = "Time Frame", inline = "1", group = "MTF SIGNAL")



[_mtf_p,_mtf_s] = tablelocation(mtf_p,mtf_s)
var mtf_Table = table.new(_mtf_p, 2, 20, border_color = color.new(color.white,0), border_width = 1)


plotrow1(n, tf) =>
    [buy,sell] = request.security_lower_tf(syminfo.tickerid, tf, signal())
    b = array.get(buy,array.size(buy)-1)
    s = array.get(sell,array.size(sell)-1)

    table.cell(table_id = mtf_Table, column = 0, row = n, text = str.tostring(tf), text_color = color.new(color.white,0), text_size = _mtf_s, bgcolor = b ? color.new(color.lime,0) : s ? color.new(color.red,0) : color.new(color.gray,0))

plotrow(n, tf) =>
    [b,s] = request.security(syminfo.tickerid, tf, signal())
    table.cell(table_id = mtf_Table, column = 0, row = n, text = str.tostring(tf), text_color = color.new(color.white,0), text_size = _mtf_s, bgcolor = b ? color.new(color.lime,0) : s ? color.new(color.red,0) : color.new(color.gray,0))

if barstate.islast and mtf_t
    table.cell(table_id = mtf_Table, column = 0, row = 0, text = str.tostring(syminfo.ticker), text_color = color.new(color.white,0), text_size = _mtf_s, bgcolor = color.new(#60040c,0))
    
    plotrow1(1, tf_1),plotrow(2, tf_2),plotrow(3, tf_3),plotrow(4, tf_4)
//

//Supertrend
showst = input(title='Supertrend', defval=false)

Mult_11 = input.float(2.2, minval=0, maxval=10)
Period_11 = input.int(10, minval=1, maxval=100)


[Trailings, Trend] = ta.supertrend(Mult_11, Period_11)


linecolor = Trend == 1 ? color.red : color.lime
plot(showst ? Trailings : na, color=linecolor, linewidth=1, title='SuperTrend')

//
//EMA200

showema200 = input(title='EMA 200', defval=true)
len200 = input.int(200, minval=1, title='MA6')

ma200 = ta.ema(close, len200)

plot(showema200 ? ma200 : na, title='EMA200', color=close > ma200 ? color.new(#AAFF00, 0) : color.new(#EE4B2B,0), linewidth=2)
//

//one day moving average
showema_ = input(title='Daily EMA', defval=true)
showemalb = input(title="Daily EMA Labels", defval=true)

Ema_Len = input(50)
Ema_Len2 = input(200)
EMA50 = request.security(syminfo.tickerid, "D", ta.ema(close[1],Ema_Len), barmerge.gaps_off, barmerge.lookahead_on)
EMA200 = request.security(syminfo.tickerid, "D", ta.ema(close[1],Ema_Len2), barmerge.gaps_off, barmerge.lookahead_on)
EMA200_15 = request.security(syminfo.tickerid, "15", ta.ema(close[1],Ema_Len2), barmerge.gaps_off, barmerge.lookahead_on)

plot(showema_ ?  EMA50 : na, title='Daily EMA50', color=color.new(#ff8103,0),style=plot.style_line, linewidth=2)
plot(showema_ ? EMA200 : na, title='Daily EMA200', color=color.new(#ff8103,0),style=plot.style_line, linewidth=2)
plot(showema_ ? EMA200_15 : na, title='15Min EMA200', color=color.new(#ff8103,0),style=plot.style_line, linewidth=2)


if showemalb
    var EMA50Label = label.new(x = bar_index, y = EMA50, style = label.style_label_left, color = color.new(color.blue,0), textcolor = color.white, text = "Daily 50")
    label.set_xy(EMA50Label, x = bar_index, y = EMA50)
    var EMA200_15Label = label.new(x = bar_index, y = EMA200_15, style = label.style_label_left, color = color.new(color.blue,0), textcolor = color.white, text = "15Min 200")
    label.set_xy(EMA200_15Label, x = bar_index, y = EMA200_15)
    var EMA200Label = label.new(x = bar_index, y = EMA200, style = label.style_label_left, color = color.new(color.blue,0), textcolor = color.white, text = "Daily 200")
    label.set_xy(EMA200Label, x = bar_index, y = EMA200)
//
//BarColor

n1 = input(10, 'Channel Length')
n2 = input(21, 'Average Length')

ap = hlc3
esa = ta.ema(ap, n1)
d1 = ta.ema(math.abs(ap - esa), n1)
ci = (ap - esa) / (0.015 * d1)
tci = ta.ema(ci, n2)

wt1 = tci
wt2 = ta.sma(wt1, 4)

plot(0, color=color.new(color.gray, 0))

barcolor(ta.cross(wt1, wt2) ? wt2 - wt1 > 0 ? color.new(color.aqua,0) : color.new(#00FF00, 0) : na)
//
//RSI Table
//TABLE INPUTS

PosTable = input.string(title="Position", defval="Bottom Right", options=["Top Right", "Middle Right", "Bottom Right", "Top Center", "Middle Center", "Bottom Center", "Top Left", "Middle Left", "Bottom Left"], group="Position & Size", inline="01")
SizTable = input.string(title="Size", defval="Small", options=["Auto", "Huge", "Large", "Normal", "Small", "Tiny"], group="Position & Size", inline="01")

Pos1Table=PosTable == "Bottom Left" ? position.top_right : PosTable == "Middle Right" ? position.middle_right : PosTable == "Bottom Right" ? position.bottom_right : PosTable == "Top Center" ? position.top_center : PosTable == "Middle Center" ? position.middle_center : PosTable == "Bottom Center" ? position.bottom_center : PosTable == "Top Left" ? position.top_left : PosTable == "Middle Left" ? position.middle_left : position.bottom_left
Siz1Table = SizTable == "Auto" ? size.auto : SizTable == "Huge" ? size.huge : SizTable == "Large" ? size.large : SizTable == "Normal" ? size.normal : SizTable == "Small" ? size.small : size.tiny
RSITable = table.new(Pos1Table, 7, 2, bgcolor=#000000, frame_color=#4F4F4F, frame_width=4, border_color=#696969, border_width=1)

//RSI INPUTS
len = input.int(14, minval=1, title="Length ? ?", inline="001", group="rsi inputs")
src_101 = input.source(close, "Source ? ?", inline="002", group="rsi inputs")

//VALUE OVERSOLD AND OVERBOUGHT RSI
limitH = input.int(50, "O.B", 0, 100, inline="001", group="rsi inputs")
limitL = input.int(50, "O.S", 0, 100, inline="002", group="rsi inputs")

//SELECTION OF TIMEFRAMES IN THE TABLES#
rsitf1 = input.timeframe("1",  "TF 1", inline="1", group="select timeframe")
rsitf2 = input.timeframe("5",  "TF 2", inline="3", group="select timeframe")
rsitf3 = input.timeframe("15", "TF 3", inline="5", group="select timeframe")
rsitf4 = input.timeframe("60", "TF 4", inline="1", group="select timeframe")
rsitf5 = input.timeframe("240","TF 5", inline="3", group="select timeframe")
rsitf6 = input.timeframe("1D", "TF 6", inline="5", group="select timeframe")


RSITF1  = request.security(syminfo.tickerid, rsitf1, ta.rsi(close, len))
RSITF5  = request.security(syminfo.tickerid, rsitf2, ta.rsi(close, len))
RSITF15 = request.security(syminfo.tickerid, rsitf3, ta.rsi(close, len))
RSITF60 = request.security(syminfo.tickerid, rsitf4, ta.rsi(close, len))
RSITF4H = request.security(syminfo.tickerid, rsitf5, ta.rsi(close, len))
RSITF1D = request.security(syminfo.tickerid, rsitf6, ta.rsi(close, len))
//PLOT RSI VALUES ABOUT THE CELLS

tfTxt(x)=>
    //adds abbreviation next to timeframe value
    out = x
    if not str.contains(x, "S") and not str.contains(x, "M") and 
       not str.contains(x, "W") and not str.contains(x, "D")
        if str.tonumber(x)%60 == 0
            out := str.tostring(str.tonumber(x)/60)+"H"
        else
            out := x + "m"
    out

f_fillCellText(_table, _column, _row, _value, _timeframe) =>

    //Default colors in table
    cell_color = #000000
    cell_txt   = #00000000
        
    //function to change cell and text colors based on O.B/O.S values
    if _value <= limitL
        cell_color := #8B0000
        cell_txt := #FF8C00
    else if _value >= limitH
        cell_color := #006400
        cell_txt := #00FF00

    else
        cell_color := #1C1C1C
        cell_txt := #DCDCDC
    //

    _cellText = str.tostring(_value, '#.##') + '\n' + _timeframe
                                                                                                                                                               
    table.cell(RSITable, _column, _row, _cellText, bgcolor=color.new(cell_color, 40), text_color=cell_txt, text_size = Siz1Table)
    table.cell(RSITable, 0, 0, "Time", text_color=#FFD700, bgcolor=#000000, text_size=size.small)
    table.cell(RSITable, 0, 1, "RSI ("+str.tostring(len)+")", text_color=#FFD700, bgcolor=#000000, text_size=Siz1Table)

    table.cell(RSITable, 1, 0, tfTxt(rsitf1), text_color=#FFFFFF, text_size =Siz1Table)
    table.cell(RSITable, 2, 0, tfTxt(rsitf2), text_color=#FFFFFF, text_size =Siz1Table)
    table.cell(RSITable, 3, 0, tfTxt(rsitf3), text_color=#FFFFFF, text_size =Siz1Table)
    table.cell(RSITable, 4, 0, tfTxt(rsitf4), text_color=#FFFFFF, text_size =Siz1Table)
    table.cell(RSITable, 5, 0, tfTxt(rsitf5), text_color=#FFFFFF, text_size =Siz1Table)
    table.cell(RSITable, 6, 0, tfTxt(rsitf6), text_color=#FFFFFF, text_size =Siz1Table)

if barstate.islast
    f_fillCellText(RSITable, 1, 1, RSITF1,  "")
    f_fillCellText(RSITable, 2, 1, RSITF5,  "")
    f_fillCellText(RSITable, 3, 1, RSITF15, "")
    f_fillCellText(RSITable, 4, 1, RSITF60, "")
    f_fillCellText(RSITable, 5, 1, RSITF4H, "")
    f_fillCellText(RSITable, 6, 1, RSITF1D, "")
//
//Demand and Supply
//SETTINGS
//

//      INDICATOR SETTINGS
swing_length = input.int(10, title = 'Swing High/Low Length', group = 'Settings', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20, title = 'History To Keep', minval = 5, maxval = 50)
box_width = input.float(2.5, title = 'Supply/Demand Box Width', group = 'Settings', minval = 1, maxval = 10, step = 0.5)

//      INDICATOR VISUAL SETTINGS
show_zigzag = input.bool(false, title = 'Show Zig Zag', group = 'Visual Settings', inline = '1')
show_price_action_labels = input.bool(false, title = 'Show Price Action Labels', group = 'Visual Settings', inline = '2')

supply_color = input.color(color.new(#741313, 0), title = 'Supply', group = 'Visual Settings', inline = '3')
supply_outline_color = input.color(color.new(color.white,75), title = 'Outline', group = 'Visual Settings', inline = '3')

demand_color = input.color(color.new(#0e462b, 0), title = 'Demand', group = 'Visual Settings', inline = '4')
demand_outline_color = input.color(color.new(color.white,75), title = 'Outline', group = 'Visual Settings', inline = '4')

bos_label_color = input.color(color.white, title = 'BOS Label', group = 'Visual Settings', inline = '5')
poi_label_color = input.color(color.white, title = 'POI Label', group = 'Visual Settings', inline = '7')

swing_type_color = input.color(color.black, title = 'Price Action Label', group = 'Visual Settings', inline = '8')
zigzag_color = input.color(color.new(#000000,0), title = 'Zig Zag', group = 'Visual Settings', inline = '9')

//
//END SETTINGS
//


//
//FUNCTIONS
//

//      FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

//      FUNCTION SWING H & L LABELS
f_sh_sl_labels(array, swing_type) =>

    var string label_text = na
    if swing_type == 1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HH'
        else
            label_text := 'LH'
        label.new(bar_index - swing_length, array.get(array,0), text = label_text, style=label.style_label_down, textcolor = swing_type_color, color = color.new(swing_type_color, 100), size = size.tiny)
    
    else if swing_type == -1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HL'
        else
            label_text := 'LL'
        label.new(bar_index - swing_length, array.get(array,0), text = label_text, style=label.style_label_up, textcolor = swing_type_color, color = color.new(swing_type_color, 100), size = size.tiny)

//      FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
f_check_overlapping(new_poi, box_array, atr) =>

    atr_threshold = atr * 2
    okay_to_draw = true

    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2

        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold

        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw


//      FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atr) =>

    atr_buffer = atr * (box_width / 10)
    box_left = array.get(bn_array, 0)
    box_right = bar_index

    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00


    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2

    okay_to_draw = f_check_overlapping(poi, box_array, atr)
    // okay_to_draw = true

    //delete oldest box, and then create a new box and add it to the array
    if box_type == 1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = supply_outline_color,
             bgcolor = supply_color, extend = extend.right, text = 'SUPPLY', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))
        
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(poi_label_color,90),
             bgcolor = color.new(poi_label_color,90), extend = extend.right, text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))

    else if box_type == -1 and okay_to_draw
        box.delete( array.get(box_array, array.size(box_array) - 1) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = demand_outline_color,
             bgcolor = demand_color, extend = extend.right,  text = 'DEMAND', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))
        
        box.delete( array.get(label_array, array.size(label_array) - 1) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(poi_label_color,90),
             bgcolor = color.new(poi_label_color,90), extend = extend.right,  text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))


//      FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>

    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            // if ta.crossover(close, level_to_break)
            if close >= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))


    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            // if ta.crossunder(close, level_to_break)
            if close <= level_to_break
                copied_box = box.copy(array.get(box_array,i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                box.set_top(array.get(bos_array,0), mid)
                box.set_bottom(array.get(bos_array,0), mid)
                box.set_extend( array.get(bos_array,0), extend.none)
                box.set_right( array.get(bos_array,0), bar_index)
                box.set_text( array.get(bos_array,0), 'BOS' )
                box.set_text_color( array.get(bos_array,0), bos_label_color)
                box.set_text_size( array.get(bos_array,0), size.small)
                box.set_text_halign( array.get(bos_array,0), text.align_center)
                box.set_text_valign( array.get(bos_array,0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))



//      FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
f_extend_box_endpoint(box_array) =>

    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 100)


//
//END FUNCTIONS
//  


//
//CALCULATIONS
//

//      CALCULATE ATR 
atr = ta.atr(50)

//      CALCULATE SWING HIGHS & SWING LOWS
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)

//      ARRAYS FOR SWING H/L & BN 
var swing_high_values = array.new_float(5,0.00)
var swing_low_values = array.new_float(5,0.00)

var swing_high_bns = array.new_int(5,0)
var swing_low_bns = array.new_int(5,0)

//      ARRAYS FOR SUPPLY / DEMAND
var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var current_demand_box = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR SUPPLY / DEMAND POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

//      ARRAYS FOR BOS
var supply_bos = array.new_box(5, na)
var demand_bos = array.new_box(5, na)
//
//END CALCULATIONS
//

//      NEW SWING HIGH
if not na(swing_high)

    //MANAGE SWING HIGH VALUES
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_high_values, 1)

    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atr)

//      NEW SWING LOW
else if not na(swing_low)

    //MANAGE SWING LOW VALUES
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_low_values, -1)
    
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atr)


f_sd_to_bos(current_supply_box, supply_bos, current_supply_poi, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_poi, -1)

f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

//ZIG ZAG
h = ta.highest(high, swing_length * 2 + 1)
l = ta.lowest(low, swing_length * 2 + 1)
f_isMin(len) =>
    l == low[len]
f_isMax(len) =>
    h == high[len]

var dirUp = false
var lastLow = high * 100
var lastHigh = 0.0
var timeLow = bar_index
var timeHigh = bar_index
var line li = na

f_drawLine() =>
    _li_color = show_zigzag ? zigzag_color : color.new(#ffffff,100)
    line.new(timeHigh - swing_length, lastHigh, timeLow - swing_length, lastLow, xloc.bar_index, color=_li_color, width=2)

if dirUp
    if f_isMin(swing_length) and low[swing_length] < lastLow
        lastLow := low[swing_length]
        timeLow := bar_index
        line.delete(li)
        li := f_drawLine()
        li

    if f_isMax(swing_length) and high[swing_length] > lastLow
        lastHigh := high[swing_length]
        timeHigh := bar_index
        dirUp := false
        li := f_drawLine()
        li

if not dirUp
    if f_isMax(swing_length) and high[swing_length] > lastHigh
        lastHigh := high[swing_length]
        timeHigh := bar_index
        line.delete(li)
        li := f_drawLine()
        li
    if f_isMin(swing_length) and low[swing_length] < lastHigh
        lastLow := low[swing_length]
        timeLow := bar_index
        dirUp := true
        li := f_drawLine()
        if f_isMax(swing_length) and high[swing_length] > lastLow
            lastHigh := high[swing_length]
            timeHigh := bar_index
            dirUp := false
            li := f_drawLine()
            li
// if barstate.islast
    // label.new(x = bar_index + 10, y = close[1], text = str.tostring( array.size(current_supply_poi) ))
//     label.new(x = bar_index + 20, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 0))))
//     label.new(x = bar_index + 30, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 1))))
//     label.new(x = bar_index + 40, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 2))))
//     label.new(x = bar_index + 50, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 3))))
//     label.new(x = bar_index + 60, y = close[1], text = str.tostring( box.get_bottom( array.get(current_supply_box, 4))))
//
//Trend Bar
ShowTrendIndi = input(true, title='Show Trend Indicator')
PACLen = input.int(50, minval=2, title='EMA ')
src_YGS = input(close, title='Source for Wave centre EMA')

// --- CONSTANTS ---
DodgerBlue = #1E90FF

// === /INPUTS ===
// Constants colours that include fully non-transparent option.
lime100 = #00FF00FF
blue100 = #0000FFFF
aqua100 = #00FFFFFF
darkred100 = #8B0000FF

// === SERIES SETUP ===

// Price action channel (Wave)

pacLo = ta.ema(low, PACLen)
pacHi = ta.ema(high, PACLen)

// === PLOTTING ===

// Show trend direction indication on the bottom
wcolor = high > pacHi and low > pacHi ? color.lime : low < pacLo and high < pacLo ? color.red : color.gray
plotshape(ShowTrendIndi ? src_YGS : na, color=wcolor, location=location.bottom, style=shape.square, size=size.normal, title='Trend Direction', transp=20)

////

