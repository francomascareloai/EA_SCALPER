
//@version=5
indicator("EDITED Trend Hunter 2.1", overlay = true)

f_angle(_src, _lookback, _atrPeriod) =>
    rad2degree = 180  
    ang = rad2degree * math.atan((_src[0] - _src[_lookback]) / ta.atr(_atrPeriod)/_lookback)
    ang


lengthx = input.int(200, minval=1, title="MA Length")
x = input.int(3, minval=1, title="Trend Angle")
srcx = input(close, title="Source")
matype = input.string(title='', defval='EMA', options=['EMA', 'SMA'])
lookback = input.int(4, 'Angle Lookback', minval=1)
atrPeriodx = input.int(10, 'ATR Period', minval=1)
Trend_detector=input.int(15,'Trend detector sensitivity',minval=1)
Positiontbl = input.string(position.top_right, 'Trend Detector Table', options=[position.top_right, position.middle_left , position.middle_right, position.top_left, position.bottom_right,position.bottom_left], inline='s')

simplema = ta.ema(srcx,lengthx)

if(matype == "SMA")
    simplema := ta.sma(srcx,lengthx)

_angle = f_angle(simplema, lookback, atrPeriodx)

negative_x = x * -1
Pcolor = _angle > x ? color.lime : _angle < negative_x ? color.red : color.rgb(172, 175, 180)

buyTrend = false
sellTrend = false
trendChangeP = false
trendChangeN = false

if(_angle > x)
    buyTrend := true
if(_angle < negative_x )
    sellTrend := true
    
if(buyTrend and buyTrend[1] == false) 
    trendChangeP := true
    
if(sellTrend and sellTrend[1] == false) 
    trendChangeN := true 
    
plot(simplema ,title='Color MA', color=Pcolor, linewidth=2)





// Nueva función para calcular la media del ángulo de las últimas 20 velas
calculateAngleAvg() =>
    sum = 0.0
    for i = 0 to 19
        sum := sum + f_angle(simplema, lookback, atrPeriodx)[i]
    sum / Trend_detector

// Llama a la nueva función para obtener la media del ángulo
angleAvg = calculateAngleAvg()

// Modifica la lógica de color en printTable
printTable(txt, angleAvg) =>
    var table t = table.new(Positiontbl,1,1 )
    // Define el color del fondo basado en la media del ángulo
    bgcolor = angleAvg > 8 ? color.green : angleAvg < -8 ? color.red : color.gray
   // Define el texto de acuerdo con el color del fondo
    displayText = txt
    if bgcolor == color.gray
        displayText := "RANGE\n" + txt
    else if bgcolor == color.red or bgcolor == color.green
        displayText := "STRONG TREND\n" + txt

    table.cell(t, 0, 0, displayText, bgcolor = bgcolor)

// Llama a printTable con el ángulo y el promedio del ángulo
printTable("•EMA Angle•\n" + str.tostring(_angle), angleAvg)


// ALERTS

alertcondition(trendChangeP, title='Colored MA Bullish alert', message='Colored MA - Bullish Signal')
alertcondition(trendChangeN, title='Colored MA Bearish Alert', message='Colored MA - Bearish Signal')
alertcondition(trendChangeP or trendChangeN, title='Colored MA Trend Change', message='Colored MA - Signal')


bgcolor = angleAvg > 8 ? color.green : angleAvg < -8 ? color.red : color.gray


// Guarda el color de fondo de la barra anterior usando var y el operador de historia [1]
var color prevBgColor = na
prevBgColor := bgcolor[1]  

// Define una condición para cuando el color de fondo cambie de gris a verde o rojo
colorChangeAlert = prevBgColor == color.gray and (bgcolor == color.green or bgcolor == color.red)






// Condiciones específicas para los cambios de color
colorChangeToRed = prevBgColor == color.gray and bgcolor == color.red
colorChangeToGreen = prevBgColor == color.gray and bgcolor == color.green

// Alerta existente para cualquier cambio fuerte de tendencia
alertcondition(colorChangeAlert, title="START TREND STRONG", message="START TREND STRONG")

// Nueva alerta para cambio de color de gris a rojo
alertcondition(colorChangeToRed, title="BEARISH STRONG TREND", message="Trend has changed to strong bearish")

// Nueva alerta para cambio de color de gris a verde
alertcondition(colorChangeToGreen, title="BULLISH STRONG TREND", message="Trend has changed to strong bullish")


//////////////////////////////////////////////

//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{
length = input.int(5, minval = 3)

//Colors
showBull = input(true, 'Bullish Structures', inline = 'bull', group = 'Style')
bullCss = input.color(#089981, '', inline = 'bull', group = 'Style')

showBear = input(true, 'Bearish Structures', inline = 'bear', group = 'Style')
bearCss = input.color(#f23645, '', inline = 'bear', group = 'Style')

showSupport = input(true, 'Support', inline = 's', group = 'Style')
supCss = input.color(#089981, '', inline = 's', group = 'Style')

showResistance = input(true, 'Resistance', inline = 'r', group = 'Style')
resCss = input.color(#f23645, '', inline = 'r', group = 'Style')


//-----------------------------------------------------------------------------}
//Types
//-----------------------------------------------------------------------------{
type fractal
    float value
    int loc
    bool iscrossed

////////////////////
//-----------------------------------------------------------------------------}
//Fractal Detection
//-----------------------------------------------------------------------------{
var p = int(length/2)
n = bar_index

dh = math.sum(math.sign(high - high[1]), p)
dl = math.sum(math.sign(low - low[1]), p)

bullf = dh == -p and dh[p] == p and high[p] == ta.highest(length)
bearf = dl == p and dl[p] == -p and low[p] == ta.lowest(length)

bullf_count = ta.cum(bullf ? 1 : 0)
bearf_count = ta.cum(bearf ? 1 : 0)

//-----------------------------------------------------------------------------}
//Bullish market structure
//-----------------------------------------------------------------------------{
var upper = fractal.new()
var line lower_lvl = na
var label ms_lbl = na
var bull_ms_count = 0
var broken_sup = false
var os = 0

if bullf
    upper.value := high[p]
    upper.loc := n-p
    upper.iscrossed := false

if ta.crossover(close, upper.value) and not upper.iscrossed
    line.new(upper.loc, upper.value, n, upper.value, color = showBull ? bullCss : na)

    ms_lbl := label.new(int(math.avg(n, upper.loc)), upper.value, os == -1 ? 'ChoCH' : 'BOS'
      , color = color(na)
      , textcolor = showBull ? bullCss : na
      , style = label.style_label_down
      , size = size.tiny)

    //Set support
    k = 2
    min = low[1]
    for i = 2 to (n - upper.loc)-1
        min := math.min(low[i], min)
        k := low[i] == min ? i : k

    if showSupport
        lower_lvl := line.new(n-k, min, n, min, color = bullCss, style = line.style_dashed)
        broken_sup := false

    upper.iscrossed := true
    bull_ms_count += 1
    os := 1
  
else if showSupport and not broken_sup
    lower_lvl.set_x2(n)

    if close < lower_lvl.get_y2()
        broken_sup := true

//-----------------------------------------------------------------------------}
//Bearish market structure
//-----------------------------------------------------------------------------{
var lower = fractal.new()
var line upper_lvl = na
var broken_res = false
var bear_ms_count = 0

if bearf
    lower.value := low[p]
    lower.loc := n-p
    lower.iscrossed := false

if ta.crossunder(close, lower.value) and not lower.iscrossed
    line.new(lower.loc, lower.value, n, lower.value, color = showBear ? bearCss : na)
    
    label.new(int(math.avg(n, lower.loc)), lower.value, os == 1 ? 'ChoCH' : 'BOS'
      , color = color(na)
      , textcolor = showBear ? bearCss : na
      , style = label.style_label_up
      , size = size.tiny)

    //Set resistance
    k = 2
    max = high[1]
    for i = 2 to (n - lower.loc)-1
        max := math.max(high[i], max)
        k := high[i] == max ? i : k

    if showResistance
        upper_lvl := line.new(n-k, max, n, max, color = bearCss, style = line.style_dashed)
        broken_res := false
    
    lower.iscrossed := true
    bear_ms_count += 1
    os := -1
   
else if showResistance and not broken_res
    upper_lvl.set_x2(n)

    if close > upper_lvl.get_y2()
        broken_res := true


//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
plot(broken_res and not broken_res[1] ? low : na, 'Resistance Breakout', #089981, 2, plot.style_circles)
plot(broken_sup and not broken_sup[1] ? high : na, 'Support Breakout', #f23645, 2, plot.style_circles)



// Condición para BOS Alcista
bullBosCondition = ta.crossover(close, upper.value) and not upper.iscrossed
alertcondition(bullBosCondition, title="Bullish BOS", message="Bullish BOSS")

// Condición para BOS Bajista
bearBosCondition = ta.crossunder(close, lower.value) and not lower.iscrossed
alertcondition(bearBosCondition, title="Bearish BOS", message="Bearish BOSS")


// Condición para CHoCH Alcista
chochBullCondition = ta.crossover(close, upper.value) and os == 1
alertcondition(chochBullCondition, title="CHoCH Bullish", message="Bullish ChoCH")

// Condición para CHoCH Bajista
chochBearCondition = ta.crossunder(close, lower.value) and os == -1
alertcondition(chochBearCondition, title="CHoCH Bearish", message="Bearish ChoCH")


alertcondition(bearBosCondition or chochBullCondition or bullBosCondition or chochBearCondition,title = "Internal structure alert",message = "Internal structure alert")
alertcondition(chochBullCondition or bullBosCondition,title = "Internal bullish structure alert",message ="Internal structure alert")
alertcondition(chochBearCondition or bearBosCondition,title = "Internal bearish structure alert",message ="Internal bearish structure alert")


/////////////////////////////////////////////////////////////////////////////

//Titles
inputGroupTitle     = "=== Pivots ==="
plotGroupTitle      = "=== Plots ==="

//Inputs
source              = input.string("Wicks", options=['Wicks','Bodys', 'Full Candle'], title="Source", group=inputGroupTitle)

leftLenH            = input.int(title="Pivot High", defval=80, minval=1, inline="Pivot High", group=inputGroupTitle)
rightLenH           = input.int(title="/", defval=80, minval=1, inline="Pivot High", group=inputGroupTitle)

leftLenL            = input.int(title="Pivot Low", defval=80, minval=1, inline="Pivot Low", group=inputGroupTitle)
rightLenL           = input.int(title="/", defval=80, minval=1, inline="Pivot Low", group=inputGroupTitle)

bullBoxColor        = input.color(color.new(#00b8e6, 80), title="Bullish Color", group=plotGroupTitle, inline="1")
bearBoxColor        = input.color(color.new(#f700ff, 80), title="Bearish Color", group=plotGroupTitle, inline="1")
closedBoxColor      = input.color(color.new(color.gray,90), title="Closed", group=plotGroupTitle, inline="1")

extendBox           = input.bool(true, title="Extend Boxes", group=plotGroupTitle, tooltip="Extend boxes until price hits them")
boxLength           = input.int(100, title="Box Size", tooltip="if Extend boxes is off, boxes will be drawn this long", group=plotGroupTitle)

//Wick / Body option
phOption            = switch source
    "Wicks" => high
    "Bodys" => close
    "Full Candle" => high

plOption            = switch source
    "Wicks" => low
    "Bodys" => close
    "Full Candle" => low


ph                  = ta.pivothigh(phOption,leftLenH, rightLenH)
pl                  = ta.pivotlow(plOption,leftLenL, rightLenL)

//Variables
var leftBull        = bar_index
var rightBull       = bar_index
var topBull         = close
var bottomBull      = close

var leftBear        = bar_index
var rightBear       = bar_index
var topBear         = close
var bottomBear      = close

var box[] _bearBoxes = array.new_box()
var box[] _bullBoxes = array.new_box()


//Bear Box Calc
if ph
    leftBear        := bar_index-leftLenH
    rightBear       := bar_index-(leftLenH-boxLength)
    topBear         := switch source
        "Bodys" => close[leftLenH]>open[leftLenH] ? close[leftLenH] : open[leftLenH]
        "Wicks" => high[leftLenH]
        "Full Candle" => high[leftLenH]
    bottomBear      := switch source
        "Bodys" => close[leftLenH]>open[leftLenH] ? open[leftLenH] : close[leftLenH]
        "Wicks" => close[leftLenH] > open[leftLenH] ? close[leftLenH] : open[leftLenH]
        "Full Candle" => low[leftLenH]

//Bull Box Calc
if pl
    leftBull        := bar_index-leftLenL
    rightBull       := bar_index-(leftLenL-boxLength)
    topBull         := switch source
        "Bodys" => close[leftLenL]>open[leftLenL] ? close[leftLenL] : open[leftLenL]
        "Wicks" => close[leftLenL] > open[leftLenL] ? open[leftLenL] : close[leftLenL]
        "Full Candle" => high[leftLenL]
    bottomBull      := switch source
        "Bodys" => close[leftLenL]>open[leftLenL] ? open[leftLenL] : close[leftLenL]
        "Wicks" => low[leftLenL]
        "Full Candle" => low[leftLenL]

if pl
    array.push(_bullBoxes, box.new(left=leftBull, right=rightBull, top=topBull, bottom=bottomBull, bgcolor=color.new(bullBoxColor,80), border_color=bullBoxColor))

if ph
    array.push(_bearBoxes, box.new(left=leftBear, right=rightBear, top=topBear, bottom=bottomBear, bgcolor=color.new(bearBoxColor,80), border_color=bearBoxColor))

extend_boxes(_array, _type)=>
    if array.size(_array)>0
        for i = 0 to array.size(_array)-1
            _box = array.get(_array,i)
            _boxLow = box.get_bottom(_box)
            _boxHigh = box.get_top(_box)
            _boxLeft = box.get_left(_box)
            _boxRight = box.get_right(_box)
            
            if _type=="bull" and _boxRight == bar_index
                if low >  _boxHigh
                    box.set_right(_box,bar_index+1)
                else
                    box.set_bgcolor(_box, closedBoxColor)
                    box.set_border_color(_box, closedBoxColor)
                    box.set_text_color(_box, closedBoxColor)
                    box.set_right(_box,bar_index)

            if _type=="bear" and _boxRight == bar_index
                if high <  _boxLow
                    box.set_right(_box,bar_index+1)
                else
                    box.set_bgcolor(_box, closedBoxColor)
                    box.set_border_color(_box, closedBoxColor)
                    box.set_text_color(_box, closedBoxColor)
                    box.set_right(_box,bar_index)

if extendBox
    extend_boxes(_bullBoxes,"bull")
    extend_boxes(_bearBoxes,"bear")







var int TYPE_UP = 1
var int TYPE_DOWN = -1
var string LINE_WIDTH1_STR = "Width 1"
var string LINE_WIDTH2_STR = "Width 2"
_get_width(string str_input) =>
    switch str_input // {string:int}
        LINE_WIDTH1_STR => 1
        LINE_WIDTH2_STR => 2

////-----------------------------------------------------------------
////                                SR
////-----------------------------------------------------------------





// Get user input
enableSR   = input(true, "SR On/Off", group="SR")
colorSup   = input(color.green, "Support Color", group="SR")
colorRes   = input(color.red, "Resistance Color", group="SR")
strengthSR = input.int(5, "S/R Strength", 1, group="SR")
lineStyle  = input.string("Dotted", "Line Style", ["Solid", "Dotted", "Dashed"], group="SR")
lineWidth  = input.int(1, "S/R Line Width", 1, group="SR")
useZones   = input(true, "Zones On/Off", group="SR")
useHLZones = input(true, "High Low Zones On/Off", group="SR")
zoneWidth  = input.int(1, "Zone Width %", 0, tooltip="it's calculated using % of the distance between highest/lowest in last 300 bars", group="SR")
expandSR   = input(true, "Expand SR")
// Functions
percWidth(len, perc) => (ta.highest(len) - ta.lowest(len)) * perc / 100
// Get components
rb            = 10
prd           = 284
ChannelW      = 10
label_loc     = 55
style         = lineStyle == "Solid" ? line.style_solid : lineStyle == "Dotted" ? line.style_dotted : line.style_dashed
PH            = ta.pivothigh(rb, rb)
PL            = ta.pivotlow (rb, rb)
sr_levels     = array.new_float(21, na)
prdhighest    = ta.highest(prd)
prdlowest     = ta.lowest(prd)
cwidth        = percWidth(prd, ChannelW)
zonePerc      = percWidth(300, zoneWidth)
aas           = array.new_bool(41, true)
u1            = 0.0, u1 := nz(u1[1])
d1            = 0.0, d1 := nz(d1[1])
highestPH     = 0.0, highestPH := highestPH[1]
lowestPL      = 0.0, lowestPL := lowestPL[1]
var sr_levs   = array.new_float(21, na)
label hlabel  = na, label.delete(hlabel[1])
label llabel  = na, label.delete(llabel[1])
var sr_lines  = array.new_line(21, na)
var sr_linesH = array.new_line(21, na)
var sr_linesL = array.new_line(21, na)
var sr_linesF = array.new_linefill(21, na)
var sr_labels = array.new_label(21, na)
if PH or PL
    for x = 0 to array.size(sr_levels) - 1
        array.set(sr_levels, x, na)
    highestPH := prdlowest
    lowestPL := prdhighest
    countpp = 0
    for x = 0 to prd
        if na(close[x])
            break
        if not na(PH[x]) or not na(PL[x])
            highestPH := math.max(highestPH, nz(PH[x], prdlowest), nz(PL[x], prdlowest))
            lowestPL := math.min(lowestPL, nz(PH[x], prdhighest), nz(PL[x], prdhighest))
            countpp += 1
            if countpp > 40
                break
            if array.get(aas, countpp)
                uPL = (PH[x] ? high[x + rb] : low[x + rb]) + cwidth
                dnl = (PH[x] ? high[x + rb] : low[x + rb]) - cwidth
                u1 := countpp == 1 ? uPL : u1
                d1 := countpp == 1 ? dnl : d1
                tmp = array.new_bool(41, true)
                cnt = 0
                tpoint = 0
                for xx = 0 to prd
                    if na(close[xx])
                        break
                    if not na(PH[xx]) or not na(PL[xx])
                        chg = false
                        cnt += 1
                        if cnt > 40
                            break
                        if array.get(aas, cnt)
                            if not na(PH[xx])
                                if high[xx + rb] <= uPL and high[xx + rb] >= dnl
                                    tpoint += 1
                                    chg := true
                            if not na(PL[xx])
                                if low[xx + rb] <= uPL and low[xx + rb] >= dnl
                                    tpoint += 1
                                    chg := true
                        if chg and cnt < 41
                            array.set(tmp, cnt, false)
                if tpoint >= strengthSR
                    for g = 0 to 40 by 1
                        if not array.get(tmp, g)
                            array.set(aas, g, false)
                    if PH[x] and countpp < 21
                        array.set(sr_levels, countpp, high[x + rb])
                    if PL[x] and countpp < 21
                        array.set(sr_levels, countpp, low[x + rb])
// PLot
var line highest_ = na, line.delete(highest_)
var line lowest_  = na, line.delete(lowest_)
var line highest_fill1 = na, line.delete(highest_fill1)
var line highest_fill2 = na, line.delete(highest_fill2)
var line lowest_fill1  = na, line.delete(lowest_fill1)
var line lowest_fill2  = na, line.delete(lowest_fill2)
hi_col = close >= highestPH ? colorSup : colorRes
lo_col = close >= lowestPL  ? colorSup : colorRes
if enableSR
    highest_ := line.new(bar_index - 311, highestPH, bar_index, highestPH, xloc.bar_index, expandSR ? extend.both : extend.right, hi_col, style, lineWidth)
    lowest_  := line.new(bar_index - 311, lowestPL , bar_index, lowestPL , xloc.bar_index, expandSR ? extend.both : extend.right, lo_col, style, lineWidth)
    if useHLZones
        highest_fill1 := line.new(bar_index - 311, highestPH + zonePerc, bar_index, highestPH + zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na)
        highest_fill2 := line.new(bar_index - 311, highestPH - zonePerc, bar_index, highestPH - zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na)
        lowest_fill1  := line.new(bar_index - 311, lowestPL + zonePerc , bar_index, lowestPL + zonePerc , xloc.bar_index, expandSR ? extend.both : extend.right, na)
        lowest_fill2  := line.new(bar_index - 311, lowestPL - zonePerc , bar_index, lowestPL - zonePerc , xloc.bar_index, expandSR ? extend.both : extend.right, na)
        linefill.new(highest_fill1, highest_fill2, color.new(hi_col, 80))
        linefill.new(lowest_fill1 , lowest_fill2 , color.new(lo_col, 80))
if PH or PL
    for x = 0 to array.size(sr_lines) - 1
        array.set(sr_levs, x, array.get(sr_levels, x))
for x = 0 to array.size(sr_lines) - 1
    line.delete(array.get(sr_lines, x))
    line.delete(array.get(sr_linesH, x))
    line.delete(array.get(sr_linesL, x))
    linefill.delete(array.get(sr_linesF, x))
    if array.get(sr_levs, x) and enableSR
        line_col = close >= array.get(sr_levs, x) ? colorSup : colorRes
        array.set(sr_lines, x, line.new(bar_index - 355, array.get(sr_levs, x), bar_index, array.get(sr_levs, x), xloc.bar_index, expandSR ? extend.both : extend.right, line_col, style, lineWidth))
        if useZones
            array.set(sr_linesH, x, line.new(bar_index - 355, array.get(sr_levs, x) + zonePerc, bar_index, array.get(sr_levs, x) + zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na))
            array.set(sr_linesL, x, line.new(bar_index - 355, array.get(sr_levs, x) - zonePerc, bar_index, array.get(sr_levs, x) - zonePerc, xloc.bar_index, expandSR ? extend.both : extend.right, na))
            array.set(sr_linesF, x, linefill.new(array.get(sr_linesH, x), array.get(sr_linesL, x), color.new(line_col, 80)))
for x = 0 to array.size(sr_labels) - 1
    label.delete(array.get(sr_labels, x))
    if array.get(sr_levs, x) and enableSR
        lab_loc = close >= array.get(sr_levs, x) ? label.style_label_up : label.style_label_down
        lab_col = close >= array.get(sr_levs, x) ? colorSup             : colorRes
        array.set(sr_labels, x, label.new(bar_index + label_loc, array.get(sr_levs, x), str.tostring(math.round_to_mintick(array.get(sr_levs, x))), color=lab_col , textcolor=#000000, style=lab_loc))
hlabel := enableSR ? label.new(bar_index + label_loc + math.round(math.sign(label_loc)) * 20, highestPH, "High Level : " + str.tostring(highestPH), color=hi_col, textcolor=#000000, style=label.style_label_down) : na
llabel := enableSR ? label.new(bar_index + label_loc + math.round(math.sign(label_loc)) * 20, lowestPL , "Low  Level : " + str.tostring(lowestPL) , color=lo_col, textcolor=#000000, style=label.style_label_up  ) : na



////-----------------------------------------------------------------
////                                SMA Input for MTF
////-----------------------------------------------------------------


emain = input(21,"21 SMA Input for MTF",group = "MTF Table")
emain2 = input(200,"200 SMA Input for MTF",group = "MTF Table")

emag = ta.sma(close,emain)
emag2 = ta.sma(close,emain2)

treng = close > emag ? color.green : color.red
treng1 = close > emag2 ? color.green : color.red


trend1 = request.security(syminfo.tickerid, "1", treng)
trend5 = request.security(syminfo.tickerid, "5", treng)
trend7 = request.security(syminfo.tickerid, "7", treng)
trend15 = request.security(syminfo.tickerid, "15", treng)
trend1h = request.security(syminfo.tickerid, "60", treng)
trend4h = request.security(syminfo.tickerid, "240", treng)
trend1d = request.security(syminfo.tickerid, "1D", treng)

t2rend1 = request.security(syminfo.tickerid, "1", treng1)
t2rend5 = request.security(syminfo.tickerid, "5", treng1)
t2rend7 = request.security(syminfo.tickerid, "7", treng1)
t2rend15 = request.security(syminfo.tickerid, "15", treng1)
t2rend1h = request.security(syminfo.tickerid, "60", treng1)
t2rend4h = request.security(syminfo.tickerid, "240", treng1)
t2rend1d = request.security(syminfo.tickerid, "1D", treng1)


trendcur = request.security(syminfo.tickerid, timeframe.period, close > emag ? color.green : color.red)
trendcur2 = request.security(syminfo.tickerid, timeframe.period, close > emag2 ? color.green : color.red)

//MTF Table
showStats = input.bool(true, 'Show MTF Table', group='MTF Table', inline='s')
tblPosition = input.string(position.bottom_right, '', group='MTF Table', options=[position.top_right, position.middle_left , position.middle_right, position.top_left, position.bottom_right,position.bottom_left], inline='s')
textSize = input.string(size.tiny, '', group='MTF Table', options=[size.tiny, size.small, size.normal, size.large, size.huge], inline='s', tooltip='Option to display pivot details in stats table')

var table tbltoprigt = table.new(tblPosition, 20, 20, border_width=1)

table.cell(tbltoprigt, 3, 2, text='T.F', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 2, text="21", text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 2, text="200", text_size=textSize, bgcolor=color.black, text_color=color.white)

table.cell(tbltoprigt, 3, 3, text='F.Trend', text_size=textSize, bgcolor=color.rgb(54, 58, 69), text_color=color.white)
table.cell(tbltoprigt, 4, 3, text=trendcur == color.green ? "UP" : "DOWN", text_size=textSize, bgcolor=trendcur, text_color=color.white)
table.cell(tbltoprigt, 5, 3, text=trendcur2 == color.green ? "UP" : "DOWN", text_size=textSize, bgcolor=trendcur2, text_color=color.white)

table.cell(tbltoprigt, 3, 4, text='1', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 4, text=trend1 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=trend1, text_color= color.white)
table.cell(tbltoprigt, 3, 4, text='1', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 4, text=t2rend1 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=t2rend1, text_color= color.white)
//
table.cell(tbltoprigt, 3, 5, text='5', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 5, text=trend5 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=trend5, text_color= color.white)
table.cell(tbltoprigt, 3, 5, text='5', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 5, text=t2rend5 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=t2rend5, text_color= color.white)
//
table.cell(tbltoprigt, 3, 6, text='7', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 6, text=trend7 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=trend7, text_color= color.white)
table.cell(tbltoprigt, 3, 6, text='7', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 6, text=t2rend7 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=t2rend7, text_color= color.white)
//
table.cell(tbltoprigt, 3, 7, text='15', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 7, text=trend15 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=trend15, text_color= color.white)
table.cell(tbltoprigt, 3, 7, text='15', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 7, text=t2rend15 == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=t2rend15, text_color= color.white)
//
table.cell(tbltoprigt, 3, 8, text='1H', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 8, text=trend1h == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=trend1h, text_color= color.white)
table.cell(tbltoprigt, 3, 8, text='1H', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 8, text=t2rend1h == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=t2rend1h, text_color= color.white)
//
table.cell(tbltoprigt, 3, 9, text='4H', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 9, text=trend4h == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=trend4h, text_color= color.white)
table.cell(tbltoprigt, 3, 9, text='4H', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 9, text=t2rend4h == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=t2rend4h, text_color= color.white)
//
table.cell(tbltoprigt, 3, 11, text='1D', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 4, 11, text=trend1d == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=trend1d, text_color= color.white)
table.cell(tbltoprigt, 3, 11, text='1D', text_size=textSize, bgcolor=color.black, text_color=color.white)
table.cell(tbltoprigt, 5, 11, text=t2rend1d == color.green ? "🟢" : "🔴", text_size=textSize, bgcolor=t2rend1d, text_color= color.white)

////-----------------------------------------------------------------
////                                DMI Cross Color Bars
////-----------------------------------------------------------------

lensig = input.int(21, title="ADX Smoothing", minval=1, maxval=50,group = 'DMI')
len = input.int(21, minval=1, title="DI Length",group = 'DMI')
up = ta.change(high)
down = -ta.change(low)
plusDM = na(up) ? na : (up > down and up > 0 ? up : 0)
minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)
trur = ta.rma(ta.tr, len)
plus = fixnan(100 * ta.rma(plusDM, len) / trur)
minus = fixnan(100 * ta.rma(minusDM, len) / trur)
sum = plus + minus
adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), lensig)

// Determine if +DI crosses above -DI
crossAbove = ta.crossover(plus, minus)

// Determine if +DI crosses below -DI
crossBelow = ta.crossunder(plus, minus)

// Define bar colors
colorUp = color.rgb(0, 255, 255)
colorDown = color.rgb(255, 0, 234)

// Color the bars based on DMI crosses
barcolor(crossAbove ? colorUp : crossBelow ? colorDown : na)
alertcondition(crossAbove, title='Alert: +DM', message='+DM !\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')
alertcondition(crossBelow, title='Alert: -DM', message='-DM !\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')
