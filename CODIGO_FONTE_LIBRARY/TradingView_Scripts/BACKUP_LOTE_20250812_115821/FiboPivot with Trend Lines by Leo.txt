// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Leandrolopezf
//
//@version=5
indicator('FiboPivot with Trend Lines by Leo', overlay=true,max_bars_back=1000,max_lines_count=500,max_labels_count=500)
lb = input.int(30, title='Left Bars', minval=1)
rb = input.int(30, title='Right Bars', minval=1)
showpivot = input(true, title='Show Pivot Points')
chdashed = input(true, title='Show Old Line as Dashed')
ucolor = input(defval=color.lime, title='Uptrend line color')
dcolor = input(defval=color.red, title='Downtrend line color')

mb = lb + rb + 1

float top = na
float bot = na
highestbars_1 = ta.highestbars(high, mb)  // Pivot High
iff_1 = highestbars_1 == -rb ? high[rb] : na
top := not na(high[mb]) ? iff_1 : na
lowestbars_1 = ta.lowestbars(low, mb)  // Pivot Low
iff_2 = lowestbars_1 == -rb ? low[rb] : na
bot := not na(low[mb]) ? iff_2 : na

plotshape(top and showpivot, text='H', style=shape.labeldown, color=color.new(color.white, 100), textcolor=color.new(color.red, 0), location=location.abovebar, offset=-rb)
plotshape(bot and showpivot, text='L', style=shape.labelup, color=color.new(color.white, 100), textcolor=color.new(color.lime, 0), location=location.belowbar, offset=-rb)

ltop = ta.valuewhen(top, top, 1)
bst = 0
bst := top ? 1 : nz(bst[1]) + 1
float t_angle = 0.0
t_angle := t_angle[1]
if not na(ltop) and not na(top)
    line tline = na
    if ltop > top
        tline := line.new(bar_index - bst[1] - rb, high[bst[1] + rb], bar_index - rb, high[rb], color=dcolor, extend=extend.right)
        t_angle := (high[bst[1] + rb] - high[rb]) / bst[1]
        if t_angle < t_angle[1] and t_angle[1] != 0
            line.set_extend(tline[1], extend=extend.none)
        if t_angle > t_angle[1] and t_angle[1] != 0
            line.set_extend(tline, extend=extend.none)
    if ltop <= top
        t_angle := 0.0
        t_angle
    if chdashed
        line.set_style(tline[1], style=line.style_dashed)

lbot = ta.valuewhen(bot, bot, 1)
bsb = 0
bsb := bot ? 1 : nz(bsb[1]) + 1
float b_angle = 0.0
b_angle := b_angle[1]
if not na(lbot) and not na(bot)
    line bline = na
    if lbot < bot
        bline := line.new(bar_index - bsb[1] - rb, low[bsb[1] + rb], bar_index - rb, low[rb], color=ucolor, extend=extend.right)
        b_angle := (low[bsb[1] + rb] - low[rb]) / bsb[1]
        if b_angle > b_angle[1] and b_angle[1] != 0
            line.set_extend(bline[1], extend=extend.none)
        if b_angle < b_angle[1] and b_angle[1] != 0
            line.set_extend(bline, extend=extend.none)
    if lbot >= bot
        b_angle := 0.0
        b_angle
    if chdashed
        line.set_style(bline[1], style=line.style_dashed)



//indicator("Nadaraya-Watson Envelope: Modified by Yosiet",overlay=true,max_bars_back=1000,max_lines_count=500,max_labels_count=500)

length = input.float(500,'Window Size',maxval=500,minval=0)
h      = input.float(10.,'Bandwidth')
mult   = input.float(3.) 
srcUpperBand = input.source(low,'Source Upper Band')
src    = input.source(high,'Source Lower Band')


up_col = input.color(#ff1100,'Colors',inline='col')
dn_col = input.color(#39ff14,'',inline='col')
show_bands = input(false, 'Show Bands')
show_sma_7_low_1 = input(false, 'Show SMA 7 LOW +1')
show_sma_7_low_7 = input(false, 'Show SMA 7 LOW -7')
show_sma_30_high = input(false, 'Show SMA 30 HIGH')
//----
n = bar_index
var k = 2
var upper = array.new_line(0) 
var lower = array.new_line(0) 

sma7_low = ta.sma(low, 7)
sma30_high = ta.sma(high, 30)

strDownArrows = "↓▼↓"
strUpArrows = "↑▲↑"

RoundUp(number, decimals) =>
    factor = math.pow(10, decimals)
    math.ceil(number * factor) / factor

plot(show_sma_7_low_1?sma7_low:na, color=color.rgb(255, 235, 59, 81), title="SMA 7 LOW +1", offset=+1, linewidth=1)
plot(show_sma_7_low_7?sma7_low:na, color=color.rgb(255, 235, 59, 81), title="7 sma", offset=-7, linewidth=1)
plot(show_sma_30_high ? sma30_high:na, color=color.purple, title="SMA 30 High", linewidth=1)
lset(l,x1,y1,x2,y2,col)=>
    line.set_xy1(l,x1,y1)
    line.set_xy2(l,x2,y2)
    line.set_color(l,col)
    line.set_width(l,2)

if barstate.isfirst
    for i = 0 to length/k-1
        array.push(upper,line.new(na,na,na,na))
        array.push(lower,line.new(na,na,na,na))
//----
line up = na
line dn = na
//----
cross_up = 0.
cross_dn = 0.
if barstate.islast
    y = array.new_float(0)
    yUpper = array.new_float(0)
    
    sum_upper_e = 0.
    sum_e = 0.
    for i = 0 to length-1
        sum_upper = 0.
        sumw_upper = 0.
        sum = 0.
        sumw = 0.
        
        for j = 0 to length-1
            w = math.exp(-(math.pow(i-j,2)/(h*h*2)))
            sum_upper += srcUpperBand[j]*w
            sum += src[j]*w
            sumw += w
        
        y_upper_2 = sum_upper/sumw
        sum_upper_e += math.abs(srcUpperBand[i] - y_upper_2)
        array.push(yUpper,y_upper_2)

        y2 = sum/sumw
        sum_e += math.abs(src[i] - y2)
        array.push(y,y2)

    mae_upper = sum_upper_e/length*mult
    mae = sum_e/length*mult
    
    for i = 1 to length-1
        upper_y2 = array.get(yUpper,i)
        upper_y1 = array.get(yUpper,i-1)

        y2 = array.get(y,i)
        y1 = array.get(y,i-1)
        
        up := array.get(upper,i/k) 
        dn := array.get(lower,i/k)

        //draw borders bands
        if show_bands
            lset(up,n-i+1,upper_y1 + mae_upper,n-i,upper_y2 + mae_upper,up_col)
            lset(dn,n-i+1,y1 - mae,n-i,y2 - mae,dn_col)
        
        //draw fractals
        //if src[i] > y1 + mae and src[i+1] < y1 + mae
        //    label.new(n-i,src[i],strDownArrows,color=#00000000,style=label.style_label_down,textcolor=dn_col,textalign=text.align_center)
        //if src[i] < y1 - mae and src[i+1] > y1 - mae
        //    label.new(n-i,src[i],strUpArrows,color=#00000000,style=label.style_label_up,textcolor=up_col,textalign=text.align_center)
        
        //draw sma 30 high signals
        if sma30_high[i] > upper_y1 + mae_upper and sma30_high[i+1] < upper_y2 + mae_upper
            label.new(n-i,srcUpperBand[i]+mae_upper,strDownArrows,color=#00000000,style=label.style_label_center,textcolor=#ec0505,textalign=text.align_center)
        //if sma30_high[i] < y1 - mae and sma30_high[i+1] > y2 - mae
        //    label.new(n-i,src[i+1],strUpArrows,color=#00000000,style=label.style_label_down,textcolor=#ec05af,textalign=text.align_center)

        //draw sma 7 low signals
        if sma7_low[i] > upper_y1 + mae_upper and sma7_low[i+1] < upper_y2 + mae_upper
            label.new(n-i,src[i],strDownArrows,color=#00000000,style=label.style_label_down,textcolor=color.orange,textalign=text.align_center)
        if sma7_low[i] < y1 - mae and sma7_low[i+1] > y2 - mae
            label.new(n-i,src[i]-mae,strUpArrows,color=#00000000,style=label.style_label_center,textcolor=color.rgb(16, 177, 4),textalign=text.align_center)
		
    cross_up := array.get(yUpper,0) + mae_upper
    cross_dn := array.get(y,0) - mae	

sma7_crossover = ta.crossover(sma7_low,cross_up)
sma7_crossunder = ta.crossunder(sma7_low,cross_dn)

sma30_crossover = ta.crossover(sma30_high,cross_up)
sma30_crossunder = ta.crossunder(sma30_high,cross_dn)

alertcondition(sma30_crossunder or sma7_crossunder,title="LONG", message='LONG: {{ticker}}/{{interval}} at price {{close}} on {{exchange}}' )
alertcondition(sma7_crossover or sma30_crossover,title="SHORT", message='SHORT: {{ticker}}/{{interval}} at price {{close}} on {{exchange}}' )

//indicator("QM Signal [TradingFinder] Quasimodo Pattern - Head and Shoulders", overlay = true , max_bars_back = 5000 , max_lines_count = 500 , max_labels_count = 500)


PP = input.int(5 , 'Pivot Period')
ATR = ta.atr(21)
var ArrayType = array.new_string()
var ArrayValue = array.new_float()
var ArrayIndex =  array.new_int()
var Line = array.new_line()

HighPivot = ta.pivothigh(PP,PP)
LowPivot = ta.pivotlow(PP,PP)

HighValue = ta.valuewhen(HighPivot ,high[PP], 0)
LowValue = ta.valuewhen(LowPivot ,low[PP], 0)

HighIndex = ta.valuewhen(HighPivot ,bar_index[PP], 0)
LowIndex = ta.valuewhen(LowPivot ,bar_index[PP], 0)

Correct_HighPivot = 0.0
Correct_LowPivot =  0.0

PASS = 0

if HighPivot  and  LowPivot
    if ArrayType.size() == 0
        PASS := 1
    else if ArrayType.size() >= 1
        if ((ArrayType.get(ArrayType.size() - 1)) == "L" or
             (ArrayType.get(ArrayType.size() - 1)) == "LL")
            if LowPivot < ArrayValue.get(ArrayType.size() - 1)
                array.remove(ArrayType,ArrayType.size() - 1)
                array.remove(ArrayValue,ArrayValue.size() - 1)
                array.remove(ArrayIndex,ArrayIndex.size() - 1) 
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                array.push(ArrayValue, LowValue)
                array.push(ArrayIndex, LowIndex)
                Correct_LowPivot :=  LowValue
            else 
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H" ) ///////////////////////////////Here
                array.push(ArrayValue, HighValue)
                array.push(ArrayIndex, HighIndex)
            Correct_HighPivot := HighValue  
        else if (ArrayType.get(ArrayType.size() - 1)) == "H" or 
             (ArrayType.get(ArrayType.size() - 1)) == "HH"
            if HighPivot > ArrayValue.get(ArrayType.size() - 1)
                array.remove(ArrayType,ArrayType.size() - 1)
                array.remove(ArrayValue,ArrayValue.size() - 1)
                array.remove(ArrayIndex,ArrayIndex.size() - 1)
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H")///////////////////////////////Here
                array.push(ArrayValue, HighValue)
                array.push(ArrayIndex, HighIndex)
                Correct_HighPivot := HighValue  
            else 
                array.push(ArrayType,ArrayType.size()>2?  ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                array.push(ArrayValue, LowValue)
                array.push(ArrayIndex, LowIndex)
            Correct_LowPivot :=  LowValue    
        else if (ArrayType.get(ArrayType.size() - 1)) == "LH"
            if HighPivot < ArrayValue.get(ArrayType.size() - 1)
                array.push(ArrayType,ArrayType.size()>2?  ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                array.push(ArrayValue, LowValue)
                array.push(ArrayIndex, LowIndex)
                Correct_LowPivot :=  LowValue 
            else if HighPivot > ArrayValue.get(ArrayType.size() - 1)
                if close < ArrayValue.get(ArrayType.size() - 1)
                    array.remove(ArrayType,ArrayType.size() - 1)
                    array.remove(ArrayValue,ArrayValue.size() - 1)
                    array.remove(ArrayIndex,ArrayIndex.size() - 1)
                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H")///////////////////////////////Here
                    array.push(ArrayValue, HighValue)
                    array.push(ArrayIndex, HighIndex)
                    Correct_HighPivot := HighValue  
                else if close > ArrayValue.get(ArrayType.size() - 1)
                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                    array.push(ArrayValue, LowValue)
                    array.push(ArrayIndex, LowIndex)
                    Correct_LowPivot :=  LowValue
        else if (ArrayType.get(ArrayType.size() - 1)) == "HL"
            if LowPivot > ArrayValue.get(ArrayType.size() - 1)
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H" ) ///////////////////////////////Here
                array.push(ArrayValue, HighValue)
                array.push(ArrayIndex, HighIndex)
                Correct_HighPivot := HighValue                       
            else if LowPivot < ArrayValue.get(ArrayType.size() - 1)
                if close > ArrayValue.get(ArrayType.size() - 1)
                    array.remove(ArrayType,ArrayType.size() - 1)
                    array.remove(ArrayValue,ArrayValue.size() - 1)
                    array.remove(ArrayIndex,ArrayIndex.size() - 1) 
                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                    array.push(ArrayValue, LowValue)
                    array.push(ArrayIndex, LowIndex)
                    Correct_LowPivot :=  LowValue
                else if close < ArrayValue.get(ArrayType.size() - 1)
                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H")///////////////////////////////Here
                    array.push(ArrayValue, HighValue)
                    array.push(ArrayIndex, HighIndex)
                    Correct_HighPivot := HighValue                         
else if  HighPivot 
    if ArrayType.size() == 0
        array.insert(ArrayType, 0, "H")
        array.insert(ArrayValue, 0, HighValue)
        array.insert(ArrayIndex, 0, HighIndex)
        Correct_HighPivot := HighValue
    else if ArrayType.size() >= 1
        if ((ArrayType.get(ArrayType.size() - 1)) == "L" or
             (ArrayType.get(ArrayType.size() - 1)) == "HL" or
             (ArrayType.get(ArrayType.size() - 1)) == "LL")
            if HighPivot > ArrayValue.get(ArrayType.size() - 1)
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H" ) ///////////////////////////////Here
                array.push(ArrayValue, HighValue)
                array.push(ArrayIndex, HighIndex)
                Correct_HighPivot := HighValue
            else if  HighPivot < ArrayValue.get(ArrayType.size() - 1)
                array.remove(ArrayType,ArrayType.size() - 1)
                array.remove(ArrayValue,ArrayValue.size() - 1)
                array.remove(ArrayIndex,ArrayIndex.size() - 1) 
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                array.push(ArrayValue, LowValue)
                array.push(ArrayIndex, LowIndex)
                Correct_LowPivot :=  LowValue                         
        else if (ArrayType.get(ArrayType.size() - 1)) == "H" or 
             (ArrayType.get(ArrayType.size() - 1)) == "HH" or 
             (ArrayType.get(ArrayType.size() - 1)) == "LH"
            if (ArrayValue.get(ArrayValue.size() - 1)) < HighValue
                array.remove(ArrayType,ArrayType.size() - 1)
                array.remove(ArrayValue,ArrayValue.size() - 1)
                array.remove(ArrayIndex,ArrayIndex.size() - 1)
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H")///////////////////////////////Here
                array.push(ArrayValue, HighValue)
                array.push(ArrayIndex, HighIndex)
                Correct_HighPivot := HighValue               
else if LowPivot 
    if ArrayType.size() == 0
        array.insert(ArrayType, 0, "L")
        array.insert(ArrayValue, 0, LowValue)
        array.insert(ArrayIndex, 0, LowIndex)
        Correct_LowPivot :=  LowValue
    else if ArrayType.size() >= 1
        if (ArrayType.get(ArrayType.size() - 1)) == "H" or 
             (ArrayType.get(ArrayType.size() - 1)) == "HH" or 
             (ArrayType.get(ArrayType.size() - 1)) == "LH"
            if LowPivot < ArrayValue.get(ArrayType.size() - 1)
                array.push(ArrayType,ArrayType.size()>2?  ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                array.push(ArrayValue, LowValue)
                array.push(ArrayIndex, LowIndex)
                Correct_LowPivot :=  LowValue
            else if LowPivot > ArrayValue.get(ArrayType.size() - 1)
                array.remove(ArrayType,ArrayType.size() - 1)
                array.remove(ArrayValue,ArrayValue.size() - 1)
                array.remove(ArrayIndex,ArrayIndex.size() - 1)
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? "HH" : "LH" : "H")///////////////////////////////Here
                array.push(ArrayValue, HighValue)
                array.push(ArrayIndex, HighIndex)
                Correct_HighPivot := HighValue                        
        else if (ArrayType.get(ArrayType.size() - 1)) == "L" or 
             (ArrayType.get(ArrayType.size() - 1)) == "HL" or 
             (ArrayType.get(ArrayType.size() - 1)) == "LL"
            if (ArrayValue.get(ArrayValue.size() - 1)) > LowValue
                array.remove(ArrayType,ArrayType.size() - 1)
                array.remove(ArrayValue,ArrayValue.size() - 1)
                array.remove(ArrayIndex,ArrayIndex.size() - 1) 
                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? "HL" : "LL" : "L")///////////////////////////////Here
                array.push(ArrayValue, LowValue)
                array.push(ArrayIndex, LowIndex)
                Correct_LowPivot :=  LowValue

QMDetector()=>
    //Bearish QM

    var string TH1 = ""
    var string TH2 = ""
    var string TH3 = ""
    var string TH4 = ""
    var string TH5 = ""

    var int IH = 0
    var int IH1 = 0
    var int IH2 = 0
    var int IH3 = 0
    var int IH4 = 0
    var int IH5 = 0

    var float VH1 = 0.0
    var float VH2 = 0.0
    var float VH3 = 0.0
    var float VH4 = 0.0
    var float VH5 = 0.0

    var bool BearQM = false

    //Bullish QM

    var string TL1 = ""
    var string TL2 = ""
    var string TL3 = ""
    var string TL4 = ""
    var string TL5 = ""

    var int IL = 0
    var int IL1 = 0
    var int IL2 = 0
    var int IL3 = 0
    var int IL4 = 0
    var int IL5 = 0

    var float VL1 = 0.0
    var float VL2 = 0.0
    var float VL3 = 0.0
    var float VL4 = 0.0
    var float VL5 = 0.0

    var bool BullQM = false

    if ArrayType.size() > 5 
        TH1 := ArrayType.get(ArrayType.size() - 1)
        TH2 :=  ArrayType.get(ArrayType.size() - 2)
        TH3 :=  ArrayType.get(ArrayType.size() - 3)
        TH4 :=  ArrayType.get(ArrayType.size() - 4)
        TH5 :=  ArrayType.get(ArrayType.size() - 5)
        IH  := ArrayIndex.get(ArrayType.size() - 1)

        IH1 := ArrayIndex.get(ArrayType.size() - 1)
        IH2 := ArrayIndex.get(ArrayType.size() - 2)
        IH3 := ArrayIndex.get(ArrayType.size() - 3)
        IH4 := ArrayIndex.get(ArrayType.size() - 4)
        IH5 := ArrayIndex.get(ArrayType.size() - 5)

        VH1 := ArrayValue.get(ArrayType.size() - 1)
        VH2 := ArrayValue.get(ArrayType.size() - 2)
        VH3 := ArrayValue.get(ArrayType.size() - 3)
        VH4 := ArrayValue.get(ArrayType.size() - 4)
        VH5 := ArrayValue.get(ArrayType.size() - 5)

    if ArrayType.size() > 5 
        TL1 := ArrayType.get(ArrayType.size() - 1)
        TL2 := ArrayType.get(ArrayType.size() - 2)
        TL3 := ArrayType.get(ArrayType.size() - 3)
        TL4 := ArrayType.get(ArrayType.size() - 4)
        TL5 := ArrayType.get(ArrayType.size() - 5)

        IL  := ArrayIndex.get(ArrayType.size() - 1)
        IL1 := ArrayIndex.get(ArrayType.size() - 1)
        IL2 := ArrayIndex.get(ArrayType.size() - 2)
        IL3 := ArrayIndex.get(ArrayType.size() - 3)
        IL4 := ArrayIndex.get(ArrayType.size() - 4)
        IL5 := ArrayIndex.get(ArrayType.size() - 5)

        VL1 := ArrayValue.get(ArrayType.size() - 1)
        VL2 := ArrayValue.get(ArrayType.size() - 2)
        VL3 := ArrayValue.get(ArrayType.size() - 3)
        VL4 := ArrayValue.get(ArrayType.size() - 4)
        VL5 := ArrayValue.get(ArrayType.size() - 5)

    //Bearish QM
    var BearQM_Start = 0.0
    var BearQM_End = 0.0
    var BearQM_Index = 0.0
    var CheckBe = 0
    if TH1 == "LL" and  TH2 == "HH" and TH3 == "HL" and TH4 == "HH"  and VH5 < VH1 and IH == (bar_index - PP) and CheckBe == 0
        BearQM := true
        BearQM_Start := VH2
        BearQM_End := VH1
        BearQM_Index := IH
        CheckBe := 1 
    else
        BearQM := false
    if BearQM_Start != VH2
        CheckBe := 0


    //Bullish QM
    var BullQM_Start = 0.0
    var BullQM_End = 0.0
    var BullQM_Index = 0
    var CheckBu = 0
    if  TL1 == "HH" and TL2 == "LL" and TL3 == "LH" and TL4 == "LL" and VL5 > VL1 and  IL == bar_index - PP and CheckBu == 0 
        BullQM := true
        BullQM_Start := VL2
        BullQM_End := VL1
        BullQM_Index := IL
        CheckBu := 1
    else
        BullQM := false

    if BullQM_Start != VL2
        CheckBu := 0

    var line BuLeg1 = na
    var line BuLeg2 = na
    var line BuLeg3 = na
    var line BuLeg4 = na
    var line BuLeg5 = na
    var line BuEntryLine= na    
    var line BuSLLine   = na
    var line BuTP1Line  = na
    var line BuTP2Line  = na
    var label BuEntryLabel= na    
    var label BuSLLabel   = na
    var label BuTP1Label  = na
    var label BuTP2Label  = na 
    BuMove  = (IL2 - IL4) /2

    var line BeLeg1 = na
    var line BeLeg2 = na
    var line BeLeg3 = na
    var line BeLeg4 = na
    var line BeLeg5 = na
    var line BeEntryLine= na
    var line BeSLLine   = na
    var line BeTP1Line  = na
    var line BeTP2Line  = na
    var label BeEntryLabel= na
    var label BeSLLabel   = na
    var label BeTP1Label  = na
    var label BeTP2Label  = na
    BeMove  = (IH2 - IH4) /2
    
    if BullQM
        // BuMove := (IL2 - IL5) * 2 + 6
        BuLeg1 := line.new(IL5 , VL5 , IL4 , VL4, color = color.rgb(38, 150, 41) , width = 2)
        BuLeg2 := line.new(IL4 , VL4 , IL3 , VL3, color = color.rgb(38, 150, 41) , width = 2)
        BuLeg3 := line.new(IL3 , VL3 , IL2 , VL2, color = color.rgb(38, 150, 41) , width = 2)
        BuLeg4 := line.new(IL2 , VL2 , IL1 , VL1, color = color.rgb(38, 150, 41) , width = 2)
        BuLeg5 := line.new(IL1 , VL1 , IL1 + BuMove-2 , VL4, color = color.rgb(4, 215, 252) , width = 2 , style = line.style_arrow_right)
        BuEntryLine:= line.new(IL4 , VL4 , IL1 + BuMove , VL4, color = color.rgb(0, 0, 0) , width = 1 , style = line.style_dotted)
        BuSLLine   := line.new(IL2  , VL2- (ATR/2) , IL1 + BuMove , VL2 - (ATR/2), color = color.rgb(170, 29, 29), width = 1, style = line.style_dotted)
        BuTP1Line  := line.new(IL3 , VL3 , IL1 + BuMove , VL3, color = color.rgb(91, 172, 74) , width = 1, style = line.style_dotted)
        BuTP2Line  := line.new(IL1 , VL1 , IL1 + BuMove , VL1, color = color.rgb(91, 172, 74) , width = 1, style = line.style_dotted) 
        BuEntryLabel:= label.new(IL1 + BuMove+1 , VL4 , 'Entry' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )
        BuSLLabel   := label.new(IL1 + BuMove+1 , VL2- (ATR/2) , 'SL' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )
        BuTP1Label  := label.new(IL1 + BuMove+1 , VL3 , 'TP1' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )
        BuTP2Label  := label.new(IL1 + BuMove+1 , VL1 , 'TP2' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )

    if BearQM
        BeLeg1 := line.new(IH5 , VH5 , IH4 , VH4, color = color.rgb(170, 29, 29) , width = 2)
        BeLeg2 := line.new(IH4 , VH4 , IH3 , VH3, color = color.rgb(170, 29, 29) , width = 2)
        BeLeg3 := line.new(IH3 , VH3 , IH2 , VH2, color = color.rgb(170, 29, 29) , width = 2)
        BeLeg4 := line.new(IH2 , VH2 , IH1 , VH1, color = color.rgb(170, 29, 29) , width = 2)
        BeLeg5 := line.new(IH1 , VH1 , IH1 + BeMove-2 , VH4, color = color.rgb(252, 173, 4) , width = 2 , style = line.style_arrow_right)
        BeEntryLine:= line.new(IH4 , VH4 , IH1 + BeMove , VH4, color = color.rgb(0, 0, 0) , width = 1 , style = line.style_dotted)
        BeSLLine   := line.new(IH2  , VH2+ (ATR/2) , IH1 + BeMove , VH2 + (ATR/2), color = color.rgb(170, 29, 29), width = 1, style = line.style_dotted)
        BeTP1Line  := line.new(IH3 , VH3 , IH1 + BeMove , VH3, color = color.rgb(91, 172, 74) , width = 1, style = line.style_dotted)
        BeTP2Line  := line.new(IH1 , VH1 , IH1 + BeMove , VH1, color = color.rgb(91, 172, 74) , width = 1, style = line.style_dotted) 
        BeEntryLabel:= label.new(IH1 + BeMove+1 , VH4 , 'Entry' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )
        BeSLLabel   := label.new(IH1 + BeMove+1 , VH2+ (ATR/2) , 'SL' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )
        BeTP1Label  := label.new(IH1 + BeMove+1 , VH3 , 'TP1' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )
        BeTP2Label  := label.new(IH1 + BeMove+1 , VH1 , 'TP2' , color = color.rgb(255, 255, 255, 100) , style = label.style_text_outline )

QMDetector()


h1 = input.float(80., 'Bandwidth') 
src1 = input.source(close, 'Source') 
 
// Function to calculate Nadaraya-Watson estimate 
nadaraya_watson(src1, h1, n) => 
    sum = 0.0 
    sumw = 0.0 
    for i = 0 to math.min(499, n) 
        w = math.exp(-(math.pow(i, 2) / (h1 * h1 * 2))) 
        sum += src1[i] * w 
        sumw += w 
    sum / sumw 
 
var estimates = array.new_float(500, 0.0) 
var signals = array.new_string(500, "none") 
 
update_index = n % 500 
 
current_estimate = nadaraya_watson(src1, h1, n) 
array.set(estimates, update_index, current_estimate) 
 
prev_estimate = n > 0 ? array.get(estimates, (update_index - 1 + 500) % 500) : current_estimate 
prev_prev_estimate = n > 1 ? array.get(estimates, (update_index - 2 + 500) % 500) : prev_estimate 
 
d = current_estimate - prev_estimate 
prev_d = prev_estimate - prev_prev_estimate 
 
if d > 0 and prev_d <= 0 
    array.set(signals, update_index, "buy") 
else if d < 0 and prev_d >= 0 
    array.set(signals, update_index, "sell") 
else 
    array.set(signals, update_index, n > 0 ? array.get(signals, (update_index - 1 + 500) % 500) : "none") 
 
var line[] lines = array.new_line(500) 
if barstate.isfirst 
    for i = 0 to 499 
        array.push(lines, line.new(na, na, na, na)) 
 
if barstate.islast 
    for i = 0 to math.min(499, n) 
        l = array.get(lines, i) 
        y2 = array.get(estimates, (update_index - i + 500) % 500) 
        y1 = i == math.min(499, n) ? y2 : array.get(estimates, (update_index - i - 1 + 500) % 500) 
         
        line.set_xy1(l, n - i, y1) 
        line.set_xy2(l, n - i + 1, y2) 
        line.set_color(l, y2 > y1 ? color.new(#880e4f, 50) : color.new(#089981, 50)) 
        line.set_width(l, 6) 
 
        signal = array.get(signals, (update_index - i + 500) % 500) 
        prev_signal = i < n ? array.get(signals, (update_index - i - 1 + 500) % 500) : "none" 
        if signal == "buy" and prev_signal != "buy" 
            label.new(n - i, low[i], "↟", color=#00000000, style=label.style_label_up, textcolor=color.green, textalign=text.align_center, size=size.huge) 
        else if signal == "sell" and prev_signal != "sell" 
            label.new(n - i, high[i], "↡", color=#00000000, style=label.style_label_down, textcolor=color.red, textalign=text.align_center, size=size.huge) 
 
alertcondition(array.get(signals, update_index) == "buy" and (n == 0 or array.get(signals, (update_index - 1 + 500) % 500) != "buy"), "Buy Signal", "Nadaraya-Watson Estimator: Buy Signal") 
alertcondition(array.get(signals, update_index) == "sell" and (n == 0 or array.get(signals, (update_index - 1 + 500) % 500) != "sell"), "Sell Signal", "Nadaraya-Watson Estimator: Sell Signal") 


//indicator("FiboPivot By Leo", overlay=true,max_bars_back=1000,max_lines_count=500,max_labels_count=500)

// Colores
color Color_R3 = color.blue
color Color_R2 = color.blue
color Color_R1 = color.blue
color Color_P  = color.purple
color Color_S1 = color.orange
color Color_S2 = color.orange
color Color_S3 = color.orange

// Anchuras de línea
int Width_R3 = 1
int Width_R2 = 3
int Width_R1 = 1
int Width_P  = 1
int Width_S1 = 1
int Width_S2 = 3
int Width_S3 = 1

// Tamaño del texto
var TextSize = size.small

// Variables estáticas para cálculos de niveles pivot
var float yesterday_high = na
var float yesterday_low = na
var float yesterday_close = na
var float current_day_close = na
var float current_day_high = na
var float current_day_low = na
var float P = na
var float R3 = na
var float R2 = na 
var float R1 = na 
var float S1 = na
var float S2 = na
var float S3 = na

// Si es una nueva barra diaria
if (dayofweek(time) != dayofweek(time[1]))  
    // Asignar los valores del día anterior al inicio de un nuevo día
    yesterday_close := current_day_close
    yesterday_high := current_day_high
    yesterday_low := current_day_low

    // Reiniciar los valores del día actual
    current_day_close := close
    current_day_high := high
    current_day_low := low
else
    // Actualizar los valores del día actual
    current_day_close := close
    current_day_high := math.max(current_day_high, high)
    current_day_low := math.min(current_day_low, low)

// Calcular los niveles de pivote solo una vez al día
    float R = yesterday_high - yesterday_low
    P := (yesterday_high + yesterday_low + yesterday_close) / 3
    R3 := P + (R * 1.000)
    R2 := P + (R * 0.618)
    R1 := P + (R * 0.382)
    S1 := P - (R * 0.382)
    S2 := P - (R * 0.618)
    S3 := P - (R * 1.000)

// Dibujar y actualizar líneas horizontales de niveles de soporte y resistencia
var line line_R3 = na
var line line_R2 = na
var line line_R1 = na
var line line_P = na
var line line_S1 = na
var line line_S2 = na
var line line_S3 = na

// Dibujar líneas horizontales de niveles de soporte y resistencia
if not na(R3)
    line_R3 := line.new(bar_index[1], R3, bar_index, R3, color=Color_R3, width=Width_R3, style=line.style_dashed, extend = extend.both)

if not na(R2)
    line_R2 := line.new(bar_index[1], R2, bar_index, R2, color=Color_R2, width=Width_R2, style=line.style_solid, extend = extend.both)

if not na(R1)
    line_R1 := line.new(bar_index[1], R1, bar_index, R1, color=Color_R1, width=Width_R1, style=line.style_solid, extend = extend.both)

if not na(P)
    line_P := line.new(bar_index[1], P, bar_index, P, color=Color_P, width=Width_P, style=line.style_dotted, extend = extend.both)

if not na(S1)
    line_S1 := line.new(bar_index[1], S1, bar_index, S1, color=Color_S1, width=Width_S1, style=line.style_solid, extend = extend.both)

if not na(S2)
    line_S2 := line.new(bar_index[1], S2, bar_index, S2, color=Color_S2, width=Width_S2, style=line.style_solid, extend = extend.both)

if not na(S3)
    line_S3 := line.new(bar_index[1], S3, bar_index, S3, color=Color_S3, width=Width_S3, style=line.style_dashed, extend = extend.both)

// Actualizar las líneas solo cuando los niveles de pivote están disponibles
if not na(P)
    line.set_xy1(line_R3, bar_index[1], R3)
    line.set_xy2(line_R3, bar_index, R3)
    line.set_width(line_R3, Width_R3)
    line.set_color(line_R3, Color_R3)
    line.set_style(line_R3, line.style_dashed)

    line.set_xy1(line_R2, bar_index[1], R2)
    line.set_xy2(line_R2, bar_index, R2)
    line.set_width(line_R2, Width_R2)
    line.set_color(line_R2, Color_R2)
    line.set_style(line_R2, line.style_solid)

    line.set_xy1(line_R1, bar_index[1], R1)
    line.set_xy2(line_R1, bar_index, R1)
    line.set_width(line_R1, Width_R1)
    line.set_color(line_R1, Color_R1)
    line.set_style(line_R1, line.style_solid)

    line.set_xy1(line_P, bar_index[1], P)
    line.set_xy2(line_P, bar_index, P)
    line.set_width(line_P, Width_P)
    line.set_color(line_P, Color_P)
    line.set_style(line_P, line.style_dashed)

    line.set_xy1(line_S1, bar_index[1], S1)
    line.set_xy2(line_S1, bar_index, S1)
    line.set_width(line_S1, Width_S1)
    line.set_color(line_S1, Color_S1)
    line.set_style(line_S1, line.style_solid)

    line.set_xy1(line_S2, bar_index[1], S2)
    line.set_xy2(line_S2, bar_index, S2)
    line.set_width(line_S2, Width_S2)
    line.set_color(line_S2, Color_S2)
    line.set_style(line_S2, line.style_solid)

    line.set_xy1(line_S3, bar_index[1], S3)
    line.set_xy2(line_S3, bar_index, S3)
    line.set_width(line_S3, Width_S3)
    line.set_color(line_S3, Color_S3)
    line.set_style(line_S3, line.style_dashed)

// Mostrar y actualizar etiquetas solo cuando los niveles están disponibles
var label lbl_R3 = na
var label lbl_R2 = na
var label lbl_R1 = na
var label lbl_P = na
var label lbl_S1 = na
var label lbl_S2 = na
var label lbl_S3 = na

if not na(P)
    lbl_R3 := label.new(bar_index, R3, text="Resistance 3 - "+ str.tostring(R3,'#.##'), style=label.style_label_down, color=#00bbd400, textcolor=color.blue, size=TextSize)
    lbl_R2 := label.new(bar_index, R2, text="Resistance 2 - "+ str.tostring(R2,'#.##'), style=label.style_label_down, color=#00bbd400, textcolor=color.blue, size=TextSize)
    lbl_R1 := label.new(bar_index, R1, text="Resistance 1 - "+ str.tostring(R1,'#.##'), style=label.style_label_down, color=#00bbd400, textcolor=color.blue, size=TextSize)
    lbl_P := label.new(bar_index, P, text="Pivot - "+ str.tostring(P,'#.##'), style=label.style_label_down, color=#00bbd400, textcolor=color.purple, size=TextSize)
    lbl_S1 := label.new(bar_index, S1, text="Support 1 - "+ str.tostring(S1,'#.##'), style=label.style_label_up, color=#00bbd400, textcolor=color.orange, size=TextSize)
    lbl_S2 := label.new(bar_index, S2, text="Support 2 - "+ str.tostring(S2,'#.##'), style=label.style_label_up, color=#00bbd400, textcolor=color.orange, size=TextSize)
    lbl_S3 := label.new(bar_index, S3, text="Support 3 - "+ str.tostring(S3,'#.##'), style=label.style_label_up, color=#00bbd400, textcolor=color.orange, size=TextSize)

// Limpiar las etiquetas para evitar la acumulación en cada nueva barra
label.delete(lbl_R3[1])
label.delete(lbl_R2[1])
label.delete(lbl_R1[1])
label.delete(lbl_P[1])
label.delete(lbl_S1[1])
label.delete(lbl_S2[1])
label.delete(lbl_S3[1])

// Limpiar las etiquetas para evitar la acumulación en cada nueva barra
line.delete(line_R3[1])
line.delete(line_R2[1])
line.delete(line_R1[1])
line.delete(line_P[1])
line.delete(line_S1[1])
line.delete(line_S2[1])
line.delete(line_S3[1])


// Mostrar los valores de yesterday_close, yesterday_high y yesterday_low
//if (dayofweek(time) != dayofweek(time[1]))  // Solo mostrar en la nueva barra
//    label.new(bar_index, yesterday_close, str.tostring(yesterday_close), color=color.white, style=label.style_label_down, textcolor=color.black, size=size.small)
//    label.new(bar_index, yesterday_high, str.tostring(yesterday_high), color=color.white, style=label.style_label_down, textcolor=color.green, size=size.small)
//    label.new(bar_index, yesterday_low, str.tostring(yesterday_low), color=color.white, style=label.style_label_down, textcolor=color.red, size=size.small)

len = input.int(54, minval=1, title="Length")
src11 = input(close, title="Source")
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window)
out = ta.sma(src1, len)
plot(out, color=color.orange, title="SMA 54 FiboPivot", offset=offset)


//Liquidity Levels/Voids (VP) 

//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{

mdTT = 'The mode option controls the number of visual objects presented, where\n\n- Historical, takes into account all data available to the user\n- Present, takes into account only the last X bars specified in the \'# Bars\' option\n\nPossible \'# Bars\' values [100-5000]'
mode = input.string('Present', title = 'Mode', options =['Present', 'Historical'], inline = 'MOD')
back = input.int   (360, ' # Bars', minval = 100, maxval = 5000, step = 10, inline = 'MOD', tooltip = mdTT)

grpLQ = 'Liquidity Levels / Voids'
liqUC = input.color( #50c4ee36,'Liquidity Levels/Voids', inline = 'UFL', group = grpLQ, tooltip = 'Color customization option for Unfilled Liquidity Levels/Voids')
ppLen = input.int(47, "Detection Length", minval = 1, group = grpLQ, tooltip = 'Lookback period used for the calculation of Swing Levels\n\nMinimum value [1]')
liqT  = input.int(21, 'Threshold %', minval = 1, maxval = 51, group = grpLQ, tooltip = 'Threshold used for the calculation of the Liquidity Levels & Voids\n\nPossible values [1-51]') / 100
vpLev = input.int(27, 'Sensitivity' , minval = 10, maxval = 100, step = 1, group = grpLQ, tooltip = 'Adjusts the number of levels between two swing points, as a result, the height of a level is determined and then based on the above-given threshold the level is checked if it matches the liquidity level/void conditions\n\nPossible values [10-100]')
liqFD = input.bool(false, 'Filled Liquidity Levels/Voids', inline = 'FL', group = grpLQ, tooltip = 'Toggles the visibility of the Filled Liquidity Levels/Voids and color customization option for Filled Liquidity Levels/Voids')
liqFC = input.color(color.new(#1848cc, 79), '', inline = 'FL', group = grpLQ)

othGR = 'Other Features'
ppLev = input.bool(false, 'Swing Highs/Lows', inline = 'ppLS', group = othGR, tooltip = 'Toggles the visibility of the Swing Levels, where tooltips present statistical information, such as price, price change, and cumulative volume between the two swing levels detected based on the detection length specified above\n\nColoring options to customize swing low and swing high label colors and Size option to adjust the size of the labels')
ppLCB = input.color(color.new(#f23645, 0), '', inline = 'ppLS', group = othGR)
ppLCS = input.color(color.new(#089981, 0), '', inline = 'ppLS', group = othGR)
ppLS  = input.string('Small', "", options=['Tiny', 'Small', 'Normal'], inline = 'ppLS', group = othGR)

//-----------------------------------------------------------------------------}
// User Defined Types
//-----------------------------------------------------------------------------{

// @type        bar properties with their values 
//
// @field h     (float) high price of the bar
// @field l     (float) low price of the bar
// @field v     (float) volume of the bar
// @field i     (int)   index of the bar

type bar
    float h = high
    float l = low
    float v = volume
    int   i = bar_index

// @type        store pivot high/low and index data 
//
// @field x     (int)    last pivot bar index
// @field x1    (int)    previous pivot bar index
// @field h     (float)  last pivot high
// @field h1    (float)  previous pivot high
// @field l     (float)  last pivot low
// @field l1    (float)  previous pivot low

type pivotPoint
    int    x
    int    x1
    float  h
    float  h1
    float  l
    float  l1

// @type        maintain liquidity data 
//
// @field b     (array<bool>) array maintains price levels where liquidity exists
// @field bx    (array<box>)  array maintains visual object of price levels where liquidity exists

type liquidity
    bool [] b
    box  [] bx

// @type        maintain volume profile data 
//
// @field vs    (array<float>) array maintains tolal traded volume
// @field vp    (array<box>)   array maintains visual object of each price level

type volumeProfile
    float [] vs
    box   [] vp

//-----------------------------------------------------------------------------}
// Variables
//-----------------------------------------------------------------------------{

bar b = bar.new()

var pivotPoint pp = pivotPoint.new()

var liquidity[] aLIQ = array.new<liquidity> (1, liquidity.new(array.new <bool> (vpLev, false), array.new <box> (na)))
var liquidity[] dLIQ = array.new<liquidity> (1, liquidity.new(array.new <bool> (na)          , array.new <box> (na)))

volumeProfile aVP  = volumeProfile.new(array.new <float> (vpLev + 1, 0.), array.new <box> (na))

qBXs = 0

//-----------------------------------------------------------------------------}
// Functions/methods
//-----------------------------------------------------------------------------{

// @function        calcuates highest price, lowest price and cumulative volume of the given range
//                     
// @param _l        (int)  length of the range
// @param _c        (bool) check
// @param _o        (int)  offset 
//
// @returns         (float, float, float) highest, lowest and cumulative volume

f_calcHLV(_l, _c, _o) =>
    if _c
        l = low [_o]
        h = high[_o]
        v  = 0.
        
        for x = 0 to _l - 1
            l := math.min(low [_o + x], l)
            h := math.max(high[_o + x], h)
            v += volume[_o + x]

        l := math.min(low [_o + _l], l)
        h := math.max(high[_o + _l], h)
        
        [h, l, v]

//-----------------------------------------------------------------------------}
// Calculations
//-----------------------------------------------------------------------------{

per  = mode == 'Present' ? last_bar_index - b.i <= back : true
nzV  = nz(b.v)

ppS = switch ppLS
    'Tiny'   => size.tiny
    'Small'  => size.small
    'Normal' => size.normal

pp_h = ta.pivothigh(ppLen, ppLen)
pp_l = ta.pivotlow (ppLen, ppLen)

if not na(pp_h)
    pp.h1 := pp.h
    pp.h  := pp_h

if not na(pp_l)
    pp.l1 := pp.l
    pp.l  := pp_l

go = not na(pp_h) or not na(pp_l) 

if go 
    pp.x1 := pp.x
    pp.x  := b.i

vpLen = pp.x - pp.x1

[pHst, pLst, tV] = f_calcHLV(vpLen, go, ppLen)
pStp = (pHst - pLst) / vpLev

if go and nzV and pStp > 0 and b.i > vpLen and vpLen > 0 and per

    for bIt = vpLen to 1
        l = 0
        bI = bIt + ppLen
        
        for pLev = pLst to pHst by pStp
            if b.h[bI] >= pLev and b.l[bI] < pLev + pStp
                aVP.vs.set(l, aVP.vs.get(l) + nzV[bI] * ((b.h[bI] - b.l[bI]) == 0 ? 1 : pStp / (b.h[bI] - b.l[bI])))
            l += 1

    aLIQ.unshift(liquidity.new(array.new <bool> (vpLev, false), array.new <box> (na)))
    cLIQ = aLIQ.get(0)

    for l = vpLev - 1 to 0
        if aVP.vs.get(l) / aVP.vs.max() < liqT
            cLIQ.b.set(l, true)
            cLIQ.bx.unshift(box.new(b.i[ppLen], pLst + (l + 0.00) * pStp, b.i[ppLen], pLst + (l + 1.00) * pStp, border_color = color(na), bgcolor = liqUC ))
        else
            cLIQ.bx.unshift(box.new(na, na, na, na))
            cLIQ.b.set(l, false)

    for bIt = 0 to vpLen
        bI = bIt + ppLen
        int qBX = cLIQ.bx.size()

        for bx = 0 to (qBX > 0 ? qBX - 1 : na)
            if bx < cLIQ.bx.size()
                if cLIQ.b.get(bx) 
                    cBX = cLIQ.bx.get(bx)
                    mBX = math.avg(cBX.get_bottom(), cBX.get_top())
                    
                    if math.sign(close[bI + 1] - mBX) != math.sign(low[bI] - mBX) or math.sign(close[bI + 1] - mBX) != math.sign(high[bI] - mBX) or math.sign(close[bI + 1] - mBX) != math.sign(close[bI]  - mBX)
                        cBX.set_left(b.i[bI])
                        cLIQ.b.set(bx, false)

    for bI = ppLen to 0
        int qBX = cLIQ.bx.size()

        for bx = (qBX > 0 ? qBX - 1 : na) to 0
            if bx < cLIQ.bx.size()
                cBX = cLIQ.bx.get(bx)
                mBX = math.avg(box.get_bottom(cBX), box.get_top(cBX))
                
                if math.sign(close[bI + 1] - mBX) != math.sign(low[bI] - mBX) or math.sign(close[bI + 1] - mBX) != math.sign(high[bI] - mBX) 
                    if liqFD
                        cBX.set_bgcolor(liqFC)
                    else
                        cBX.delete()

                    cLIQ.bx.remove(bx)
                else
                    cBX.set_right(b.i[bI])

for i = aLIQ.size() - 1 to 0
    x = aLIQ.get(i)
    int qBX = x.bx.size()

    qBXs := qBXs + qBX
    if qBXs > 500
        aLIQ.pop()
        
    for bx = (qBX > 0 ? qBX - 1 : na) to 0
        if bx < x.bx.size()
            cBX = x.bx.get(bx)
            mBX = math.avg(box.get_bottom(cBX), box.get_top(cBX))

            if math.sign(close[1] - mBX) != math.sign(low - mBX) or math.sign(close[1] - mBX) != math.sign(high - mBX) 
                //cBX.delete()
                if liqFD
                    cBX.set_bgcolor(liqFC)
                else
                    cBX.delete()
                x.bx.remove(bx)
            else
                cBX.set_right(b.i)


if ppLev and (mode == 'Present' ? last_bar_index - b.i <= back * 1.318 : true)
    statTip = '\n -Traded Volume : ' + str.tostring(tV, format.volume) + ' (' + str.tostring(vpLen - 1) + ' bars)\n  *Average Volume/Bar : ' + str.tostring(tV / (vpLen - 1), format.volume)

    if not na(pp_h)
        swH = pp.h > pp.h1 ? "HH" : pp.h < pp.h1 ? "LH" : na
        label.new(b.i[ppLen], pp.h, swH, xloc.bar_index, yloc.price, color(na), label.style_label_down, ppLCS, ppS, text.align_center, 'Swing High : ' + str.tostring(pp.h, format.mintick) + '\n -Price Change : %' + str.tostring((pp.h - pp.l) * 100 / pp.l, '#.##') + statTip)
    if not na(pp_l)
        swL = pp.l < pp.l1 ? "LL" : pp.l > pp.l1 ? "HL" : na
        label.new(b.i[ppLen], pp.l ,swL, xloc.bar_index, yloc.price, color(na), label.style_label_up  , ppLCB, ppS, text.align_center, 'Swing Low : '  + str.tostring(pp.l, format.mintick) + '\n -Price Change : %' + str.tostring((pp.h - pp.l) * 100 / pp.h, '#.##') + statTip)

vpLen := barstate.islast ? last_bar_index - pp.x + ppLen  : 1
pHst  := ta.highest(b.h, vpLen > 0 ? vpLen + 1 : 1)
pLst  := ta.lowest (b.l, vpLen > 0 ? vpLen + 1 : 1)
pStp  := (pHst - pLst) / vpLev

if barstate.islast and nzV and vpLen > 0 and pStp > 0

    tLIQ = dLIQ.shift()
    if tLIQ.bx.size() > 0
        for i = 0 to tLIQ.bx.size() - 1
            tLIQ.bx.shift().delete()
        tLIQ.b.shift()

    for bI = vpLen to 1 //1 to vpLen
        l = 0
        for pLev = pLst to pHst by pStp
            if b.h[bI] >= pLev and b.l[bI] < pLev + pStp
                aVP.vs.set(l, aVP.vs.get(l) + nzV[bI] * ((b.h[bI] - b.l[bI]) == 0 ? 1 : pStp / (b.h[bI] - b.l[bI])))
            l += 1
    
    dLIQ.unshift(liquidity.new(array.new <bool> (na), array.new <box> (na)))
    cLIQ = dLIQ.get(0)

    for l = 0 to vpLev - 1
        if aVP.vs.get(l) / aVP.vs.max() < liqT
            cLIQ.b.unshift(true)
            cLIQ.bx.unshift(box.new(b.i, pLst + (l + 0.00) * pStp, b.i, pLst + (l + 1.00) * pStp, border_color = color(na), bgcolor = liqUC))
        else
            cLIQ.bx.unshift(box.new(na, na, na, na))
            cLIQ.b.unshift(false)

    for bI = 0 to vpLen
        int qBX = cLIQ.bx.size()

        for bx = 0 to (qBX > 0 ? qBX - 1 : na)
            if bx < cLIQ.bx.size()
                if cLIQ.b.get(bx) 
                    cBX = cLIQ.bx.get(bx)
                    mBX = math.avg(cBX.get_bottom(), cBX.get_top())
                
                    if math.sign(close[bI + 1] - mBX) != math.sign(low[bI] - mBX) or math.sign(close[bI + 1] - mBX) != math.sign(high[bI] - mBX) or math.sign(close[bI + 1] - mBX) != math.sign(close[bI]  - mBX)
                        cBX.set_left(b.i[bI])
                        cLIQ.b.set(bx, false)

 //-----------------------------------------------------------------------------}