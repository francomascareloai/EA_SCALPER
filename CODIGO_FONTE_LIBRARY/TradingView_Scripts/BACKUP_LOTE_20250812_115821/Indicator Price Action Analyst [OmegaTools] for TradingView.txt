// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join our channel for more free tools: https://t.me/simpleforextools

//@version=6
indicator('Price Action Analyst [OmegaTools]', 'PAA', overlay = true, max_boxes_count = 500, max_lines_count = 500)

// Functions

orderblock(lnt) =>
    ispivotlow = not na(ta.pivotlow(lnt, lnt))
    ispivothigh = not na(ta.pivothigh(lnt, lnt))
    isengulfinglong = ispivotlow and (close[lnt - 1] > high[lnt] or close[lnt - 2] > high[lnt - 1]) and close[lnt + 1] < open[lnt + 1]
    isengulfingshort = ispivothigh and (close[lnt - 1] < low[lnt] or close[lnt - 2] < low[lnt - 1]) and close[lnt + 1] > open[lnt + 1]
    int lnttouse = ispivotlow ? close[lnt] < open[lnt] ? lnt : lnt + 1 : ispivothigh ? close[lnt] > open[lnt] ? lnt : lnt + 1 : lnt

    mom = math.abs(ta.mom(hlc3, lnt))
    vol = volume
    isvolconfirmed = vol[lnt] > vol[lnt + 1] and vol[lnt] > ta.sma(vol[lnt], 20) * 1
    ismomconfirmed = mom > ta.percentile_linear_interpolation(mom, 300, 75)
    isfvgconfirmed = isengulfinglong ? low[lnt - 2] > high[lnt] or low[lnt - 3] > high[lnt - 1] : ispivothigh ? high[lnt - 2] < low[lnt] or high[lnt - 3] < low[lnt - 1] : false
    ifliqconfirmed = not na(ta.pivothigh(lnt * 7, lnt)) or not na(ta.pivotlow(lnt * 7, lnt))

    int strength = 1
    if ismomconfirmed
        strength := strength + 1
        strength
    if isfvgconfirmed
        strength := strength + 1
        strength
    if isvolconfirmed
        strength := strength + 1
        strength
    if ifliqconfirmed
        strength := strength + 1
        strength
    rangeconfirmed = high[lnttouse] - low[lnttouse] < ta.sma(high[lnttouse] - low[lnttouse], 100) * 1.5
    bool oblong = isengulfinglong and close > low[lnttouse] and rangeconfirmed
    bool obshort = isengulfingshort and close < high[lnttouse] and rangeconfirmed

    [oblong, obshort, strength, lnttouse]

marketstructure(left, right) =>
    pvh = ta.pivothigh(close, left, right)
    pvl = ta.pivotlow(close, left, right)
    var float ph = na
    var float pl = na
    ph := pvh != 0 ? pvh : ph[1]
    pl := pvl != 0 ? pvl : pl[1]
    currenth = ta.valuewhen(pvh != 0, high[right], 0)
    lasth = ta.valuewhen(pvh != 0, high[right], 1)
    currentl = ta.valuewhen(pvl != 0, low[right], 0)
    lastl = ta.valuewhen(pvl != 0, low[right], 1)

    var int ms = na
    ms := if currenth > lasth and close > ph
        ms := 2
        ms
    else if close > ph
        ms := 1
        ms
    else if currentl < lastl and close < pl
        ms := -2
        ms
    else if close < pl
        ms := -1
        ms
    else
        ms[1]
    ms

backtest(prev, cond, lnt, size) =>
    var int win = 0
    var int loss = 0
    var total = array.new_int()
    if prev[lnt]
        if cond
            total.push(1)
        else
            total.push(0)
    if array.size(total) > size
        array.remove(total, 0)
    winrate = array.sum(total) / array.size(total) * 100
    winrate

ictbias(tf) =>
    h = request.security(syminfo.tickerid, tf, high)
    l = request.security(syminfo.tickerid, tf, low)
    c = request.security(syminfo.tickerid, tf, close)
    longc = request.security(syminfo.tickerid, tf, c > h[1])
    shortc = request.security(syminfo.tickerid, tf, c < l[1])
    longr = request.security(syminfo.tickerid, tf, l < l[1] and c > c[1])
    shortr = request.security(syminfo.tickerid, tf, h > h[1] and c < c[1])
    bias = longc ? 2 : shortc ? -2 : longr ? 1 : shortr ? -1 : 0
    bias

// Inputs

lnt = input.int(10, 'Длина')
hideold = input.bool(false, 'Удалить старые зоны', inline = 'del')
dynamic = input.bool(false, 'Динамическая корректировка', inline = 'del')
minval = input.int(1, 'Фильтр силы', minval = 1, maxval = 5)
maxzones = input.int(5, 'Макс. Orderblocks', group = 'Инструменты')
maxFvgs = input.int(3, 'Макс. FVGs', group = 'Инструменты')
msinp = input.string('Градиент', 'Структура рынка', ['Нет', 'Двойной градиент', 'Градиент', 'Оба', 'Внутренняя', 'Периферийная', 'P.I.Z.'], group = 'Инструменты')
maxlines = input.int(1, 'Макс. линии тренда', group = 'Инструменты')
ext = 10 // input.int(10, "Продлить линии тренда", group = "Инструменты")
upc = input.color(#2962ff, 'Первый цвет', group = 'Визуал')
dnc = input.color(#e91e63, 'Второй цвет', group = 'Визуал')
midc = input.color(color.gray, 'Третий цвет', group = 'Визуал')
tablewhere = input.string('Нижний правый', 'Расположение таблицы', ['Нижний правый', 'Верхний правый', 'Нижний левый', 'Верхний левый'], group = 'Визуал')

// Signals

h = ta.highest(high[1], 20)
l = ta.lowest(low[1], 20)
m = math.avg(h, l)

vol = volume > ta.sma(volume, 9)
sgrab = high > h and close < h and vol
bgrab = low < l and close > l and vol
rng = math.avg(high - low, math.abs(close - open))
enb = rng > rng[1] and close > open
ens = rng > rng[1] and close < open

buy = true
sell = true
lbr = close > h and h >= h[1]
sbr = close < l and l <= l[1]
lastbs = 0
lastbs := lbr ? nz(lastbs[1]) + 1 : sbr ? 0 : nz(lastbs[1])
lastss = 0
lastss := sbr ? nz(lastss[1]) + 1 : lbr ? 0 : nz(lastss[1])
if lastbs[1] > 0
    buy := false
    buy
if lastss[1] > 0
    sell := false
    sell

filt = math.abs(close - open) * 1.34 > high - low

plotshape(bgrab, 'Ликвидность покупка', shape.diamond, location.belowbar, enb ? upc : midc, display = display.pane)
plotshape(sgrab, 'Ликвидность продажа', shape.diamond, location.abovebar, ens ? dnc : midc, display = display.pane)
plotshape(lbr and buy and vol, 'Пробой покупка', shape.triangleup, location.belowbar, filt ? upc : midc, display = display.pane)
plotshape(sbr and sell and vol, 'Пробой продажа', shape.triangledown, location.abovebar, filt ? dnc : midc, display = display.pane)

// Orderblocks

[demand, supply, strength, lntx] = orderblock(lnt)

var array<box> supplyZones = array.new_box()
var array<box> demandZones = array.new_box()
var array<bool> supplyBroken = array.new_bool()
var array<bool> demandBroken = array.new_bool()
lefttime = chart.left_visible_bar_time

demandcol = color.from_gradient(strength, 1, 5, color.new(upc, 85), color.new(upc, 40))
supplycol = color.from_gradient(strength, 1, 5, color.new(dnc, 85), color.new(dnc, 40))

if supply and maxzones > 0 and strength >= minval
    supplyBox = box.new(left = bar_index - lntx, top = high[lntx], right = bar_index, bottom = low[lntx], bgcolor = supplycol, border_color = supplycol, border_style = line.style_dotted, text = str.tostring(strength), text_color = color.new(chart.fg_color, 50), text_size = size.tiny, text_halign = text.align_right)
    if array.size(supplyZones) >= maxzones
        box.delete(array.shift(supplyZones))
        array.shift(supplyBroken)
    array.push(supplyZones, supplyBox)
    array.push(supplyBroken, false)

if demand and maxzones > 0 and strength >= minval
    demandBox = box.new(left = bar_index - lntx, top = high[lntx], right = bar_index, bottom = low[lntx], bgcolor = demandcol, border_color = demandcol, border_style = line.style_dotted, text = str.tostring(strength), text_color = color.new(chart.fg_color, 50), text_size = size.tiny, text_halign = text.align_right)
    if array.size(demandZones) >= maxzones
        box.delete(array.shift(demandZones))
        array.shift(demandBroken)
    array.push(demandZones, demandBox)
    array.push(demandBroken, false)

if array.size(supplyZones) > 0 and maxzones > 0
    for i = 0 to array.size(supplyZones) - 1 by 1
        b = array.get(supplyZones, i)
        isBroken = array.get(supplyBroken, i)
        if not isBroken
            if close > box.get_top(b) or (dynamic ? lefttime > time(timeframe.period, bar_index - box.get_left(b)) : box.get_left(b) + 500 < bar_index)
                array.set(supplyBroken, i, true)
                if hideold
                    box.delete(b)
            else
                box.set_right(b, bar_index)

if array.size(demandZones) > 0 and maxzones > 0
    for i = 0 to array.size(demandZones) - 1 by 1
        b = array.get(demandZones, i)
        isBroken = array.get(demandBroken, i)
        if not isBroken
            if close < box.get_bottom(b) or (dynamic ? lefttime > time(timeframe.period, bar_index - box.get_left(b)) : box.get_left(b) + 500 < bar_index)
                array.set(demandBroken, i, true)
                if hideold
                    box.delete(b)
            else
                box.set_right(b, bar_index)

bool priceInSupply = false
bool priceInDemand = false
bool closeInSupply = false
bool closeInDemand = false
if array.size(supplyZones) > 0
    for i = 0 to array.size(supplyZones) - 1 by 1
        b = array.get(supplyZones, i)
        if not array.get(supplyBroken, i) and close <= box.get_top(b) and high >= box.get_bottom(b)
            priceInSupply := true
            priceInSupply
        if not array.get(supplyBroken, i) and close <= box.get_top(b) and close >= box.get_bottom(b)
            closeInSupply := true
            break

if array.size(demandZones) > 0
    for i = 0 to array.size(demandZones) - 1 by 1
        b = array.get(demandZones, i)
        if not array.get(demandBroken, i) and low <= box.get_top(b) and close >= box.get_bottom(b)
            priceInDemand := true
            priceInDemand
        if not array.get(demandBroken, i) and close <= box.get_top(b) and close >= box.get_bottom(b)
            closeInDemand := true
            break

pid = priceInDemand //and not closeInDemand
pis = priceInSupply //and not closeInSupply

btval = pid ? 1 : pis ? -1 : 0
wr1 = backtest(pid, close > close[7], 7, 500)
wr2 = backtest(pis, close < close[7], 7, 500)
tablepos = tablewhere == 'Нижний правый' ? position.bottom_right : tablewhere == 'Верхний правый' ? position.top_right : tablewhere == 'Нижний левый' ? position.bottom_left : position.top_left
tab = table.new(tablepos, 1, 3)
tab.cell(0, 0, str.tostring(math.round(wr1, 1)) + '% Длинная', text_color = chart.fg_color)
tab.cell(0, 1, str.tostring(math.round(wr2, 1)) + '% Короткая', text_color = chart.fg_color)

// ICT Bias

string autotf = na
if timeframe.isintraday
    autotf := timeframe.multiplier <= 5 ? '60' : timeframe.multiplier <= 60 ? 'D' : 'W'
    autotf
else if timeframe.isdaily
    autotf := 'W'
    autotf
else if timeframe.isweekly or timeframe.ismonthly
    autotf := '12M'
    autotf
string autotf2 = na
if timeframe.isintraday
    autotf2 := timeframe.multiplier <= 5 ? 'Часовой' : timeframe.multiplier <= 60 ? 'Дневной' : 'Недельный'
    autotf2
else if timeframe.isdaily
    autotf2 := 'Недельный'
    autotf2
else if timeframe.isweekly or timeframe.ismonthly
    autotf2 := 'Годовой'
    autotf2
bias = ictbias(autotf)
tab.cell(0, 2, autotf2 + ' Смещение' + ': ' + (bias > 0 ? 'Длинная' : bias < 0 ? 'Короткая' : 'Нейтральная'), text_color = bias > 0 ? upc : bias < 0 ? dnc : color.gray)

// Market Structure

internalms = marketstructure(5, 5)
externalms = marketstructure(20, 20)
bigms = marketstructure(100, 100)
smallms = marketstructure(3, 3)
mediumms = marketstructure(10, 10)

ms = msinp == 'Градиент' or msinp == 'Двойной градиент' ? internalms + externalms + smallms + mediumms + bigms : msinp == 'Оба' ? internalms > 0 and externalms > 0 ? 2 : internalms < 0 and externalms < 0 ? -2 : 0 : msinp == 'Внутренняя' ? internalms : msinp == 'Периферийная' ? externalms : na
barc = msinp != 'Нет' and msinp != 'Градиент' and msinp != 'Двойной градиент' and msinp != 'P.I.Z.' ? ms == 2 ? upc : ms == -2 ? dnc : ms == 1 ? color.new(upc, 30) : ms == -1 ? color.new(dnc, 30) : ms == 0 ? midc : na : msinp == 'Градиент' ? color.from_gradient(ms, -6, 6, dnc, upc) : msinp == 'Двойной градиент' ? ms >= 0 ? color.from_gradient(ms, 0, 6, midc, upc) : color.from_gradient(ms, -6, 0, dnc, midc) : msinp == 'P.I.Z.' ? pid ? upc : pis ? dnc : na : na
barcolor(barc)
plotcandle(open, high, low, close, 'Ценовые бары', barc, barc, bordercolor = barc)

// FVGs

fvgup = low > high[2]
fvgdn = high < low[2]

var array<box> upFvgBoxes = array.new_box(0)
var array<bool> upFvgBroken = array.new_bool(0)
var array<box> dnFvgBoxes = array.new_box(0)
var array<bool> dnFvgBroken = array.new_bool(0)

var arrup = array.new_float()
if fvgup
    array.push(arrup, math.abs(low - high[2]))
thresup = array.percentile_linear_interpolation(arrup, 75)

var arrdn = array.new_float()
if fvgdn
    array.push(arrdn, math.abs(high - low[2]))
thresdn = array.percentile_linear_interpolation(arrdn, 75)

longfvg = fvgup and low - high[2] > thresup
shortfvg = fvgdn and math.abs(high - low[2]) > thresdn

if longfvg
    upBox = box.new(left = bar_index[2], top = low, right = bar_index, bottom = high[2], border_color = color.new(upc, 100), bgcolor = lbr[1] ? color.new(midc, 70) : color.new(midc, 85), text = lbr[1] ? 'FVG+' : 'FVG', text_size = size.tiny, text_halign = text.align_right, text_valign = text.align_center, text_color = color.new(chart.fg_color, 50))
    array.unshift(upFvgBoxes, upBox)
    array.unshift(upFvgBroken, false)
    if array.size(upFvgBoxes) > maxFvgs
        box.delete(array.pop(upFvgBoxes))
        array.pop(upFvgBroken)

if shortfvg
    dnBox = box.new(left = bar_index[2], top = low[2], right = bar_index, bottom = high, border_color = color.new(dnc, 100), bgcolor = sbr[1] ? color.new(midc, 70) : color.new(midc, 85), text = sbr[1] ? 'FVG+' : 'FVG', text_size = size.tiny, text_halign = text.align_right, text_valign = text.align_center, text_color = color.new(chart.fg_color, 50))
    array.unshift(dnFvgBoxes, dnBox)
    array.unshift(dnFvgBroken, false)
    if array.size(dnFvgBoxes) > maxFvgs
        box.delete(array.pop(dnFvgBoxes))
        array.pop(dnFvgBroken)

if array.size(upFvgBoxes) > 0
    for i = 0 to array.size(upFvgBoxes) - 1 by 1
        upBox = array.get(upFvgBoxes, i)
        isBroken = array.get(upFvgBroken, i)
        if not isBroken
            if low < math.avg(box.get_top(upBox), box.get_bottom(upBox)) or box.get_left(upBox) + 50 < bar_index
                array.set(upFvgBroken, i, true)
                if hideold
                    box.delete(upBox)
            else
                box.set_right(upBox, bar_index + 1)

if array.size(dnFvgBoxes) > 0
    for i = 0 to array.size(dnFvgBoxes) - 1 by 1
        dnBox = array.get(dnFvgBoxes, i)
        isBroken = array.get(dnFvgBroken, i)
        if not isBroken
            if high > math.avg(box.get_bottom(dnBox), box.get_top(dnBox)) or box.get_left(dnBox) + 50 < bar_index
                array.set(dnFvgBroken, i, true)
                if hideold
                    box.delete(dnBox)
            else
                box.set_right(dnBox, bar_index + 1)

// Trend Lines

newpvh = not na(ta.pivothigh(lnt, lnt))
newpvl = not na(ta.pivotlow(lnt, lnt))

dnx1 = ta.valuewhen(newpvh, bar_index[lnt], 1)
dny1 = ta.valuewhen(newpvh, high[lnt], 1)
dnx2 = ta.valuewhen(newpvh, bar_index[lnt], 0)
dny2 = ta.valuewhen(newpvh, high[lnt], 0)
changedn = (dny2 - dny1) / (dnx2 - dnx1)
newdnx2 = ta.valuewhen(newpvh, dnx2 + ext, 0)
newdny2 = ta.valuewhen(newpvh, dny2 + changedn * ext, 0)

upx1 = ta.valuewhen(newpvl, bar_index[lnt], 1)
upy1 = ta.valuewhen(newpvl, low[lnt], 1)
upx2 = ta.valuewhen(newpvl, bar_index[lnt], 0)
upy2 = ta.valuewhen(newpvl, low[lnt], 0)
changeup = (upy2 - upy1) / (upx2 - upx1)
newupx2 = ta.valuewhen(newpvl, upx2 + ext, 0)
newupy2 = ta.valuewhen(newpvl, upy2 + changeup * ext, 0)

var array<line> tlsArray = array.new_line(0)
var array<line> tllArray = array.new_line(0)

if newpvh and dny2 < dny1 and maxlines > 0
    tls = line.new(dnx1, dny1, newdnx2, newdny2, color = color.new(dnc, 50), width = 2)
    array.unshift(tlsArray, tls)
    if array.size(tlsArray) > maxlines
        line.delete(array.pop(tlsArray))

if newpvl and upy2 > upy1 and maxlines > 0
    tll = line.new(upx1, upy1, newupx2, newupy2, color = color.new(upc, 50), width = 2)
    array.unshift(tllArray, tll)
    if array.size(tllArray) > maxlines
        line.delete(array.pop(tllArray))

// Last High and Low

lookback = 100

var float hh = na
var float ll = na
var int hh_bar_index = na
var int ll_bar_index = na

if ta.highest(high, lookback) == high
    hh := high
    hh_bar_index := bar_index
    hh_bar_index

if ta.lowest(low, lookback) == low
    ll := low
    ll_bar_index := bar_index
    ll_bar_index

hh_candles_ago = bar_index - hh_bar_index
ll_candles_ago = bar_index - ll_bar_index

if not na(hh) and hh_candles_ago > 0
    line_style = hh_candles_ago < math.round(int(int(lookback / 3))) ? line.style_dotted : line.style_solid
    hh_line = dynamic and lefttime < time(timeframe.period, bar_index - hh_bar_index) ? line.new(x1 = hh_bar_index, y1 = hh, x2 = bar_index, y2 = hh, color = dnc, width = 1, style = line_style) : na
    line.delete(hh_line[1])

if not na(ll) and ll_candles_ago > 0
    line_style = ll_candles_ago < math.round(int(int(lookback / 3))) ? line.style_dotted : line.style_solid
    ll_line = dynamic and lefttime < time(timeframe.period, bar_index - ll_bar_index) ? line.new(x1 = ll_bar_index, y1 = ll, x2 = bar_index, y2 = ll, color = upc, width = 1, style = line_style) : na
    line.delete(ll_line[1])

// Percentile Price

pplnt = 200

avgpp = ta.sma(close * volume, pplnt) / ta.sma(volume, pplnt)
hpp = ta.percentile_linear_interpolation(hl2, pplnt, 75)
lpp = ta.percentile_linear_interpolation(hl2, pplnt, 25)

plot(barstate.islast ? avgpp : na, 'Справедливая цена', midc, 2, show_last = 1, offset = 3, style = plot.style_circles)
plot(barstate.islast ? hpp : na, 'Премиальная цена', dnc, 2, show_last = 1, offset = 3, style = plot.style_circles)
plot(barstate.islast ? lpp : na, 'Скидочная цена', upc, 2, show_last = 1, offset = 3, style = plot.style_circles)

if barstate.islast
    label.new(x = barstate.islast ? bar_index + 3 : na, y = avgpp, text = 'Справедливая', color = color.new(midc, 85), textcolor = chart.fg_color, textalign = text.align_center, style = label.style_label_left)
    label.new(x = barstate.islast ? bar_index + 3 : na, y = hpp, text = 'Премиальная', color = color.new(dnc, 85), textcolor = chart.fg_color, textalign = text.align_center, style = label.style_label_left)
    label.new(x = barstate.islast ? bar_index + 3 : na, y = lpp, text = 'Скидочная', color = color.new(upc, 85), textcolor = chart.fg_color, textalign = text.align_center, style = label.style_label_left)

plot(btval, 'Цена в зоне BT', color.new(color.gray, 100), display = display.none, editable = false)

// End of Script


// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)