//@version=5

strategy(title='RR Dangov v3.3', overlay=true, pyramiding = 99, max_boxes_count = 500)

src = close
gold = #FFD700
maxProfit = input(defval = 10, title = "maximumProfitPerDay", group = "maximumProfit")
rev = input(false, "Reverse Entry")
first_entry = input.string('None', 'first_entry', options=["Guppy", "VWAP", "ORB","Supertrend","CPR", "None"])    // "Supertrend Closed Alert" ,"Supertrend Crossed Alert",
second_entry = input.string('None', 'secondary_entry', options=["Guppy", "VWAP", "ORB", "Supertrend", "CPR","None"])    // "Supertrend Closed Alert" ,"Supertrend Crossed Alert", 
check_guppy = input(false, "Guppy EMA", group="Checkbox Entry")
check_vwap = input(false, "VWAP", group="Checkbox Entry")
check_orb = input(false, "ORB", group="Checkbox Entry")
check_st = input(false, "Supertrend", group="Checkbox Entry")
check_cpr = input(false, "CPR", group="Checkbox Entry")
check_wa = input(false, "WaveTrend", group="Checkbox Entry")
co6 = input(false, 'weekly open line', group="Checkbox Entry")
co7 = input(false, 'monthly open line', group="Checkbox Entry")
co8 = input(false, 'weekly Pivot', group="Checkbox Entry")
co9 = input(false, 'Monthly pivot', group="Checkbox Entry")
co24 = input(false,"Small Candles", group="Additional Entries")
co25 = input(false, 'Stochastic', group="Additional Entries")
co26 = input(false,"C-125-Range Filter", group="Additional Entries")

////
// Use alternate Anchor TF for MAs
anchor = input.int(0, minval=0, maxval=1440, title='Use alternate Anchor TimeFrame (0=none, max=1440 (mins,D,W)', group="Guppy Multiple Moving Average")
emaFilter = input(false, title='EMA 200 Filter', group="Guppy Multiple Moving Average")


// Binary options
// ShowBreak = input(true, title='Show Trend Break Arrow Alerts', group="Guppy Multiple Moving Average")
// ShowSwing = input(true, title='Show Swing Arrow Alerts', group="Guppy Multiple Moving Average")
ShowCon = input(false, title='Give Only Fast+Slow Confluence Alerts', group="Guppy Multiple Moving Average")
uOCCswing = input(false, title='Add Bar Colour Changes to Swing Alerts', group="Guppy Multiple Moving Average")
Lookback = input(6, title='Alert Lookback Length', group="Guppy Multiple Moving Average")
// ShowAvgs  = input(false,title="Show Average Fast and Slow Guppy Curves")
// show200   = input(false,title="Show 200 EMA Curve")


VWAPSource = input(title='VWAP Source', defval=close, group= "VWAP")
VWAPrice = ta.vwap(VWAPSource)


inputMax = input(15, title= "ORB total time (minutes)", group = "ORB")

sess = input.session("0000-0015", title="Session Time", group = "ORB") 


InputFactor = input.float(2.0, minval=0, maxval=100, title='Factor', group='supertrend')
InputLength = input.int(10, minval=1, maxval=100, title='Lenght', group='supertrend')



grprf = "C-125-Range Filter"


srcrf = input(defval=close, title='Source', group=grprf)
 
// Sampling Period
// Settings for 5min chart, BTCUSDC. For Other coin, change the paremeters
 
per = input.int(defval=100, minval=1, title='Sampling Period')
 
// Range Multiplier
 
mult_ = input.float(defval=2.0, minval=0.1, title='Range Multiplier 1')
 
mult2 = input.float(defval=4.0, minval=0.1, title='Range Multiplier 2')
 
mult3 = input.float(defval=6.0, minval=0.1, title='Range Multiplier 3')
 
open_cond= input.int(defval=2, minval=1, title='Trade Filters (Open)')
 
close_cond= input.int(defval=2, minval=1, title='Trade Filters (Close)')
 
// Smooth Average Range
 
smoothrng1(x, t, m) =>
    wper = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    smoothrng = ta.ema(avrng, wper) * m
    smoothrng
 
smrng1 = smoothrng1(srcrf, per, mult_)
smrng2 = smoothrng1(srcrf, per, mult2)
smrng3 = smoothrng1(srcrf, per, mult3)
 
// Range Filter
 
rngfilt1(x, r) =>
    rngfilt = x
    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r
    rngfilt
filt1 = rngfilt1(srcrf, smrng1)
filt2 = rngfilt1(srcrf, smrng2)
filt3 = rngfilt1(srcrf, smrng3)
 
// Filter Direction
 
upward1 = 0.0
upward1 := filt1 > filt1[1] ? nz(upward1[1]) + 1 : filt1 < filt1[1] ? 0 : nz(upward1[1])
downward1 = 0.0
downward1 := filt1 < filt1[1] ? nz(downward1[1]) + 1 : filt1 > filt1[1] ? 0 : nz(downward1[1])
 
upward2 = 0.0
upward2 := filt2 > filt2[1] ? nz(upward2[1]) + 1 : filt2 < filt2[1] ? 0 : nz(upward2[1])
downward2 = 0.0
downward2 := filt2 < filt2[1] ? nz(downward2[1]) + 1 : filt2 > filt2[1] ? 0 : nz(downward2[1])
 
upward3 = 0.0
upward3 := filt3 > filt3[1] ? nz(upward3[1]) + 1 : filt3 < filt3[1] ? 0 : nz(upward3[1])
downward3 = 0.0
downward3 := filt3 < filt3[1] ? nz(downward3[1]) + 1 : filt3 > filt3[1] ? 0 : nz(downward3[1])
 
// Target Bands
 
hband1 = filt1 + smrng1
lband1 = filt1 - smrng1
 
hband2 = filt2 + smrng2
lband2 = filt2 - smrng2
 
hband3 = filt3 + smrng3
lband3 = filt3 - smrng3
 
// Colors
 
filtcolor1 = upward1 > 0 ? color.lime : downward1 > 0 ? color.red : color.orange
barcolor1 = srcrf > filt1 and srcrf > srcrf[1] and upward1 > 0 ? color.lime : srcrf > filt1 and srcrf < srcrf[1] and upward1 > 0 ? color.green : srcrf < filt1 and srcrf < srcrf[1] and downward1 > 0 ? color.red : srcrf < filt1 and srcrf > srcrf[1] and downward1 > 0 ? color.maroon : color.orange
 
filtcolor2 = upward2 > 0 ? color.lime : downward2 > 0 ? color.red : color.orange
barcolor2 = srcrf > filt2 and srcrf > srcrf[1] and upward2 > 0 ? color.lime : srcrf > filt2 and srcrf < srcrf[1] and upward2 > 0 ? color.green : srcrf < filt2 and srcrf < srcrf[1] and downward2 > 0 ? color.red : srcrf < filt2 and srcrf > srcrf[1] and downward2 > 0 ? color.maroon : color.orange
 
filtcolor3 = upward3 > 0 ? color.lime : downward3 > 0 ? color.red : color.orange
barcolor3 = srcrf > filt3 and srcrf > srcrf[1] and upward3 > 0 ? color.lime : srcrf > filt3 and srcrf < srcrf[1] and upward3 > 0 ? color.green : srcrf < filt3 and srcrf < srcrf[1] and downward3 > 0 ? color.red : srcrf < filt3 and srcrf > srcrf[1] and downward3 > 0 ? color.maroon : color.orange
 
// filtplot = plot(filt1, color=filtcolor, linewidth=3, title='Range Filter')
// filtplot2 = plot(filt2, color=filtcolor2, linewidth=3, title='Range Filter 2')
// filtplot3 = plot(filt3, color=filtcolor3, linewidth=3, title='Range Filter 3')
 
// // Target
 
// hbandplot = plot(hband, color=color.new(color.aqua, 100), title='High Target')
// lbandplot = plot(lband, color=color.new(color.fuchsia, 100), title='Low Target')
 
// hbandplot2 = plot(hband2, color=color.new(color.aqua, 100), title='High Target 2')
// lbandplot2 = plot(lband2, color=color.new(color.fuchsia, 100), title='Low Target 2')
 
// hbandplot3 = plot(hband3, color=color.new(color.aqua, 100), title='High Target 3')
// lbandplot3 = plot(lband3, color=color.new(color.fuchsia, 100), title='Low Target 3')
 
// // Fills
 
// fill(hbandplot, filtplot, color=color.new(color.aqua, 90), title='High Target Range')
// fill(lbandplot, filtplot, color=color.new(color.fuchsia, 90), title='Low Target Range')
 
// // Bar Color
 
// barcolor(barcolor)
 
// Break Outs
 
longCond = bool(na)
shortCond = bool(na)
 
 
longCond := srcrf > filt1 and srcrf > srcrf[1] and upward1 > 0 or srcrf > filt1 and srcrf < srcrf[1] and upward1 > 0
shortCond := srcrf < filt1 and srcrf < srcrf[1] and downward1 > 0 or srcrf < filt1 and srcrf > srcrf[1] and downward1 > 0
 
longCond2 = bool(na)
shortCond2 = bool(na)
 
 
longCond2 := srcrf > filt2 and srcrf > srcrf[1] and upward2 > 0 or srcrf > filt2 and srcrf < srcrf[1] and upward2 > 0
shortCond2 := srcrf < filt2 and srcrf < srcrf[1] and downward2 > 0 or srcrf < filt2 and srcrf > srcrf[1] and downward2 > 0
 
longCond3 = bool(na)
shortCond3 = bool(na)
 
 
longCond3 := srcrf > filt3 and srcrf > srcrf[1] and upward3 > 0 or srcrf > filt3 and srcrf < srcrf[1] and upward3 > 0
shortCond3 := srcrf < filt3 and srcrf < srcrf[1] and downward3 > 0 or srcrf < filt3 and srcrf > srcrf[1] and downward3 > 0
 
final_long_Condition= open_cond==2? (longCond and longCond2) or (longCond2 and longCond3) or (longCond and longCond3) ? true : false : open_cond==3 ? longCond and longCond2 and longCond3 ? true : false : false
 
final_short_Condition= open_cond==2? (shortCond and shortCond2) or (shortCond2 and shortCond3) or (shortCond and shortCond3) ? true : false : open_cond==3 ? shortCond and shortCond2 and shortCond3 ? true : false : false
 
final_long_exit_Condition = close_cond==2? (shortCond and shortCond2) or (shortCond2 and shortCond3) or (shortCond and shortCond3) ? true : false : close_cond==3 ? shortCond and shortCond2 and shortCond3 ? true : false : close_cond==1 ? shortCond or shortCond2 or shortCond3 ? true : false : false
 
final_short_exit_Condition = close_cond==2? (longCond and longCond2) or (longCond2 and longCond3) or (longCond and longCond3) ? true : false : close_cond==3 ? longCond and longCond2 and longCond3 ? true : false : close_cond==1 ? longCond or longCond2 or longCond3 ? true : false : false
 
CondIni1 = 0
CondIni1 := final_long_Condition ? 1 : final_short_Condition ? -1 : CondIni1[1]

longConditionrf = final_long_Condition and CondIni1[1] == -1
shortConditionrf = final_short_Condition and CondIni1[1] == 1

periodK = input.int(8, title="%K Length", minval=1, group="Stochastic")
smoothK = input.int(3, title="%K Smoothing", minval=1, group="Stochastic")
periodD = input.int(5, title="%D Smoothing", minval=1, group="Stochastic")
stoch_ul = input(70.0, "Sell Above",  group="Stochastic")
stoch_ll = input(30.0, "Buy Below",  group="Stochastic")
sto_k = ta.sma(ta.stoch(close, high, low, periodK), smoothK)
sto_d = ta.sma(sto_k, periodD) 

stoch_buy = ta.crossover(sto_k,sto_d) and sto_d<stoch_ll
stoch_sell = ta.crossunder(sto_k,sto_d) and sto_d>stoch_ul
barHeight = input.int(34, group='Small Candles')
 
bigUp() =>
    close > open and high - low < barHeight
bigDown() =>
    close < open and high - low < barHeight 

buy25 = co25 and stoch_buy     
sell25 = co25 and stoch_sell    
buy24 = co24 and bigUp()     
sell24 = co24 and bigDown()    
buy26 = co26 and longConditionrf     
sell26 = co26 and shortConditionrf    

add_sell = sell25 or sell24 or sell26 
add_buy = buy25 or buy24 or buy26
//buy27 = co27?   newwt_buy     : false
//sell27 = co27 ?  newwt_sell    : false

emaFilter_ = input(false, title='EMA 200 Filter', group="EMA 200 Filter")
ema_200 = ta.ema(input(close,"Source",group="EMA 200 Filter"),input(200,"Length",group="EMA 200 Filter"))

ema_b = emaFilter_ ? close>ema_200 : true
ema_s= emaFilter_ ? close<ema_200 : true

emaFilter_20 = input(false, title='EMA 20 Filter', group="EMA 20 Filter")
ema_20 = ta.ema(input(close,"Source",group="EMA 20 Filter"),input(20,"Length",group="EMA 20 Filter"))

ema20_b = emaFilter_20 ? close>ema_20 : true
ema20_s= emaFilter_20 ? close<ema_20 : true

use_vol = input(false, "Use Volume Filter", group="Volume Filter")
vol =use_vol ?  ta.highest(volume ,  input(20, "Volume Higher than past n candles", group="Volume Filter") + 1 ) ==volume : true

filter1 =input(false, "Use Filter", group="Candle Size Filter") ?  (math.abs(high-low)/low)>= (input(0.5, "Candle Size % (from Low to high)", group="Candle Size Filter")/100) : true

sl = input(0.1, "% buffer for Stop Loss", group="SL/TP")/100
rr = input(15, "Risk Reward ratio", group="SL/TP")
max_prof = input(3.6, "Maximum Profit %", group="SL/TP")/100



dir = input.string("Both", "Trade Direction", options=["Long", "Short", "Both"], group="Strategy Properties")
maxe = input(5000.0, "max allowed position size in USDT", group="Strategy Properties")
use_qty = input.string("USD", "quantity Calculation", group= "Strategy Properties", options=["USD", "SL Based"]) =="USD"
usd = input(100.0, "USD for Quantity", group="Strategy Properties")
risk = input(100.0, "Risk Value(For SL Based)", group="Strategy Properties")
round = input(3, "Round Quantity Decimal", group="Strategy Properties")
max_day = input(50, "Max trades Per day", group="Strategy Properties")

grp = "Alert Management" 
typ = input.string("ISOLATED","Type",["ISOLATED","CROSS"],group = grp) 
lev = input.string("","Leverage",group = grp)
tp  = input.string("","TP",group = grp)
sl_  = input.string("","SL",group = grp)

tr_meth = input.string("With TP and SL","Type",["With TP and SL","Only TP","Only SL","Auto TP","Auto SL","Auto TP&SL","Strategy","stg-nolev",'Stg-TP-SL','Stg-TP','Stg-SL','Stg-AutoTP-SL','Stg-AutoTP','Stg-AutoSL'],group = grp) 

testPeriodSwitch = input(true, "Use Backtesting Range", group="Date Range Settings" )
i_startTime = input.time(defval = timestamp("01 Nov 2023 00:01 +0000"), title = "Backtesting Start Time",group = "Date Range Settings")
i_endTime = input.time(defval = timestamp("31 Dec 2033 23:59 +0000"), title = "Backtesting End Time",group = "Date Range Settings")

sess_al = input.bool(true,  title="Use Session Filter",group = "Session Filter") 
InSession(sess) => not na(time(timeframe.period, sess)) and sess_al
Session1 = InSession(input.session(title='Trading Hours', defval='0945-0945',group="Session Filter"))


cl_arr = math.round_to_mintick(close)

timeinrange(res, sess) =>
    time(res, sess) != 0


grpbg = "Bitcoin Kill Zones v2"
// **** Checkboxes and custom Session
iKZNY = input(true, title='New York Kill Zone',group = grpbg)
iOpenKZLondon = input(true, title='London Open Kill Zone',group = grpbg)
iCloseKZLondon = input(true, title='London Close Kill Zone',group = grpbg)
iAsiaKZ = input(true, title='Asia Kill Zone',group = grpbg)
KZNY = input.session('1230-1430', title='New York Kill Zone',group = grpbg)
LondonOpenKZ = input.session('0600-0800', title='London Open Kill Zone',group = grpbg)
LondonCloseKZ = input.session('1500-1700', title='London Close Kill Zone',group = grpbg)
AsiaKZ = input.session('2300-0300', title='Asia Kill Zone',group = grpbg)

// iRealOpenSessionAlertBar = input(true, title='Real Open Session Alert Bar',group = grpbg )
// NYOpenAlertBar = input.session('1330-1345', title='New York Open Session',group = grpbg )
// LondonOpenAlertBar = input.session('0700-0715', title='London Open Session',group = grpbg )
// LondonCloseAlertBar = input.session('1545-1600', title='London Close Session',group = grpbg )
// AsiaOpenAlertBar = input.session('0000-0015', title='Asia Open Session',group = grpbg )

// **** Logic
sessToUse = iKZNY == 1 ? KZNY : '0000-0000'
// sessToUse2 = iRealOpenSessionAlertBar == 1 ? NYOpenAlertBar : '0000-0000'
sessToUse3 = iOpenKZLondon == 1 ? LondonOpenKZ : '0000-0000'
// sessToUse4 = iRealOpenSessionAlertBar == 1 ? LondonOpenAlertBar : '0000-0000'
sessToUse5 = iCloseKZLondon == 1 ? LondonCloseKZ : '0000-0000'
// sessToUse6 = iRealOpenSessionAlertBar == 1 ? LondonCloseAlertBar : '0000-0000'
sessToUse7 = iAsiaKZ == 1 ? AsiaKZ : '0000-0000'
// sessToUse8 = iRealOpenSessionAlertBar == 1 ? AsiaOpenAlertBar : '0000-0000'

// *** Apply custom rules
bgPlot = iKZNY == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse)
// bgPlot2 = iRealOpenSessionAlertBar == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse2)
bgPlot3 = iOpenKZLondon == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse3)
// bgPlot4 = iRealOpenSessionAlertBar == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse4)
bgPlot5 = iCloseKZLondon == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse5)
// bgPlot6 = iRealOpenSessionAlertBar == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse6)
bgPlot7 = iAsiaKZ == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse7)
// bgPlot8 = iRealOpenSessionAlertBar == 0 ? time(timeframe.period) : time(timeframe.period, sessToUse8)

//**** Plot as background
bgcolor(iKZNY and bgPlot > 0 ? color.new(color.red , transp=90): na)
// bgcolor(iKZNY and iRealOpenSessionAlertBar ? color.new(color.red , transp=70): na)
bgcolor(iOpenKZLondon and bgPlot3 > 0 ? color.new(color.green , transp=90): na)
// bgcolor(iOpenKZLondon and iRealOpenSessionAlertBar ? color.new(color.green , transp=70): na)
bgcolor(iCloseKZLondon and bgPlot5 > 0 ? color.new(color.olive , transp=90): na)
// bgcolor(iCloseKZLondon and iRealOpenSessionAlertBar ? color.new(color.olive , transp=70): na)
bgcolor(iAsiaKZ and bgPlot7 > 0 ? color.new(color.orange , transp=90): na)
// bgcolor(iAsiaKZ and iRealOpenSessionAlertBar ? color.new(color.orange , transp=70): na)

allow = (iKZNY and bgPlot > 0)  or (iOpenKZLondon and bgPlot3 > 0)  or (iCloseKZLondon and bgPlot5 > 0)  or (iAsiaKZ and bgPlot7 > 0)



// Supertrend
BasicUpperBand = hl2 - InputFactor * ta.atr(InputLength)
BasicLowerBand = hl2 + InputFactor * ta.atr(InputLength)
FinalUpperBand = 0.0
FinalLowerBand = 0.0
FinalUpperBand := close[1] > FinalUpperBand[1] ? math.max(BasicUpperBand, FinalUpperBand[1]) : BasicUpperBand
FinalLowerBand := close[1] < FinalLowerBand[1] ? math.min(BasicLowerBand, FinalLowerBand[1]) : BasicLowerBand
IsTrend = 0.0
IsTrend := close > FinalLowerBand[1] ? 1 : close < FinalUpperBand[1] ? -1 : nz(IsTrend[1], 1)
STrendline = IsTrend == 1 ? FinalUpperBand : FinalLowerBand
linecolor = IsTrend == 1 ? color.green : color.red
// Plotline = PlotSTrend ? STrendline : na
// plot(Plotline, color=linecolor, style=plot.style_line, linewidth=1, title='SuperTrend')
 
PlotShapeUp_trend = ta.cross(close, STrendline) and close > STrendline
PlotShapeDown_trend = ta.cross(STrendline, close) and close < STrendline


pivot = (high + low + close) / 3  //Central Povit
BC_ = (high + low) / 2  //Below Central povit
TC_ = (pivot - BC_) + pivot  //Top Central povot

tick = ticker.new(syminfo.prefix,syminfo.ticker)

[DayPivot,BC,TC] = request.security(tick, 'D', [pivot[1],BC_[1],TC_[1]], lookahead=barmerge.lookahead_on)

buy_cpr = ta.crossover(close,math.max(TC, BC))
sell_cpr = ta.crossunder(close,math.min(TC, BC))

// Define Trader and Investor groups
// T1 = .int(3, minval=1, title='Trader EMA 1 length', group="Guppy Multiple Moving Average")
// T2 = input.int(5, minval=1, title='Trader EMA 2 length', group="Guppy Multiple Moving Average")
// T3 = input.int(8, minval=1, title='Trader EMA 3 length', group="Guppy Multiple Moving Average")
// T4 = input.int(10, minval=1, title='Trader EMA 4 length', group="Guppy Multiple Moving Average")
// T5 = input.int(12, minval=1, title='Trader EMA 5 length', group="Guppy Multiple Moving Average")
// T6 = input.int(15, minval=1, title='Trader EMA 6 length', group="Guppy Multiple Moving Average")

// I1 = input.int(30, minval=1, title='Investor EMA 1 length', group="Guppy Multiple Moving Average")
// I2 = input.int(35, minval=1, title='Investor EMA 2 length', group="Guppy Multiple Moving Average")
// I3 = input.int(40, minval=1, title='Investor EMA 3 length', group="Guppy Multiple Moving Average")
// I4 = input.int(45, minval=1, title='Investor EMA 4 length', group="Guppy Multiple Moving Average")
// I5 = input.int(50, minval=1, title='Investor EMA 5 length', group="Guppy Multiple Moving Average")
// I6 = input.int(60, minval=1, title='Investor EMA 6 length', group="Guppy Multiple Moving Average")

// Calculate Trader and Investor groups
// TEMA1 = ta.ema(src, T1)
// TEMA2 = ta.ema(src, T2)
// TEMA3 = ta.ema(src, T3)
// TEMA4 = ta.ema(src, T4)
// TEMA5 = ta.ema(src, T5)
// TEMA6 = ta.ema(src, T6)

// IEMA1 = ta.ema(src, I1)
// IEMA2 = ta.ema(src, I2)
// IEMA3 = ta.ema(src, I3)
// IEMA4 = ta.ema(src, I4)
// IEMA5 = ta.ema(src, I5)
// IEMA6 = ta.ema(src, I6)

// Plot Trader and Investor groups
// transp1 = 15
// transp2 = 12
// transp3 = 9
// transp4 = 6
// transp5 = 3
// transp6 = 0

// plot(TEMA1, title='Trader EMA 1', color=color.aqua, style=plot.style_line, transp=transp1)
// plot(TEMA2, title='Trader EMA 2', color=color.aqua, style=plot.style_line, transp=transp2)
// plot(TEMA3, title='Trader EMA 3', color=color.aqua, style=plot.style_line, transp=transp3)
// plot(TEMA4, title='Trader EMA 4', color=color.aqua, style=plot.style_line, transp=transp4)
// plot(TEMA5, title='Trader EMA 5', color=color.aqua, style=plot.style_line, transp=transp5)
// plot(TEMA6, title='Trader EMA 6', color=color.aqua, style=plot.style_line, transp=transp6)

// plot(IEMA1, title='Investor EMA 1', color=color.red, style=plot.style_line, transp=transp1)
// plot(IEMA2, title='Investor EMA 2', color=color.red, style=plot.style_line, transp=transp2)
// plot(IEMA3, title='Investor EMA 3', color=color.red, style=plot.style_line, transp=transp3)
// plot(IEMA4, title='Investor EMA 4', color=color.red, style=plot.style_line, transp=transp4)
// plot(IEMA5, title='Investor EMA 5', color=color.red, style=plot.style_line, transp=transp5)
// plot(IEMA6, title='Investor EMA 6', color=color.red, style=plot.style_line, transp=transp6)



// Super Guppy

//Fast EMAs
lenF1 = 3
lenF2 = 5
lenF3 = 7
lenF4 = 9
lenF5 = 11
lenF6 = 13
lenF7 = 15
lenF8 = 17
lenF9 = 19
lenF10 = 21
lenF11 = 23

//Slow EMAs
lenS1 = 25
lenS2 = 28
lenS3 = 31
lenS4 = 34
lenS5 = 37
lenS6 = 40
lenS7 = 43
lenS8 = 46
lenS9 = 49
lenS10 = 52
lenS11 = 55
lenS12 = 58
lenS13 = 61
lenS14 = 64
lenS15 = 67
lenS16 = 70

len = 200

// Calculate the Multiplier for Anchor MAs.
mult = timeframe.isintraday ? anchor == 0 or timeframe.multiplier <= 0 or timeframe.multiplier >= anchor or anchor > 1440 ? 1 : math.round(anchor / timeframe.multiplier) > 1 ? math.round(anchor / timeframe.multiplier) : 1 : 1
mult := not timeframe.isintraday ? anchor == 0 or timeframe.multiplier <= 0 or timeframe.multiplier >= anchor or anchor > 52 ? mult : math.round(anchor / timeframe.multiplier) > 1 ? math.round(anchor / timeframe.multiplier) : 1 : mult

//Fast EMA
emaF1 = ta.ema(src, lenF1 * mult)
emaF2 = ta.ema(src, lenF2 * mult)
emaF3 = ta.ema(src, lenF3 * mult)
emaF4 = ta.ema(src, lenF4 * mult)
emaF5 = ta.ema(src, lenF5 * mult)
emaF6 = ta.ema(src, lenF6 * mult)
emaF7 = ta.ema(src, lenF7 * mult)
emaF8 = ta.ema(src, lenF8 * mult)
emaF9 = ta.ema(src, lenF9 * mult)
emaF10 = ta.ema(src, lenF10 * mult)
emaF11 = ta.ema(src, lenF11 * mult)
//average
emafast = (emaF1 + emaF2 + emaF3 + emaF4 + emaF5 + emaF6 + emaF7 + emaF8 + emaF9 + emaF10 + emaF11) / 11
//
//Slow EMA
emaS1 = ta.ema(src, lenS1 * mult)
emaS2 = ta.ema(src, lenS2 * mult)
emaS3 = ta.ema(src, lenS3 * mult)
emaS4 = ta.ema(src, lenS4 * mult)
emaS5 = ta.ema(src, lenS5 * mult)
emaS6 = ta.ema(src, lenS6 * mult)
emaS7 = ta.ema(src, lenS7 * mult)
emaS8 = ta.ema(src, lenS8 * mult)
emaS9 = ta.ema(src, lenS9 * mult)
emaS10 = ta.ema(src, lenS10 * mult)
emaS11 = ta.ema(src, lenS11 * mult)
emaS12 = ta.ema(src, lenS12 * mult)
emaS13 = ta.ema(src, lenS13 * mult)
emaS14 = ta.ema(src, lenS14 * mult)
emaS15 = ta.ema(src, lenS15 * mult)
emaS16 = ta.ema(src, lenS16 * mult)
// average
emaslow = (emaS1 + emaS2 + emaS3 + emaS4 + emaS5 + emaS6 + emaS7 + emaS8 + emaS9 + emaS10 + emaS11 + emaS12 + emaS13 + emaS14 + emaS15 + emaS16) / 16
//
//EMA 200
ema200 = ta.ema(src, len * mult)

//Fast EMA Color Rules
colfastL = emaF1 > emaF2 and emaF2 > emaF3 and emaF3 > emaF4 and emaF4 > emaF5 and emaF5 > emaF6 and emaF6 > emaF7 and emaF7 > emaF8 and emaF8 > emaF9 and emaF9 > emaF10 and emaF10 > emaF11
colfastS = emaF1 < emaF2 and emaF2 < emaF3 and emaF3 < emaF4 and emaF4 < emaF5 and emaF5 < emaF6 and emaF6 < emaF7 and emaF7 < emaF8 and emaF8 < emaF9 and emaF9 < emaF10 and emaF10 < emaF11
//Slow EMA Color Rules
colslowL = emaS1 > emaS2 and emaS2 > emaS3 and emaS3 > emaS4 and emaS4 > emaS5 and emaS5 > emaS6 and emaS6 > emaS7 and emaS7 > emaS8 and emaS8 > emaS9 and emaS9 > emaS10 and emaS10 > emaS11 and emaS11 > emaS12 and emaS12 > emaS13 and emaS13 > emaS14 and emaS14 > emaS15 and emaS15 > emaS16
colslowS = emaS1 < emaS2 and emaS2 < emaS3 and emaS3 < emaS4 and emaS4 < emaS5 and emaS5 < emaS6 and emaS6 < emaS7 and emaS7 < emaS8 and emaS8 < emaS9 and emaS9 < emaS10 and emaS10 < emaS11 and emaS11 < emaS12 and emaS12 < emaS13 and emaS13 < emaS14 and emaS14 < emaS15 and emaS15 < emaS16

//Fast EMA Final Color Rules
colFinal = colfastL and emaS1 > emaS16 ? color.aqua : colfastS and emaS1 < emaS16 ? color.blue : color.gray
//Slow EMA Final Color Rules
colFinal2 = colslowL ? color.lime : colslowS ? color.red : color.gray

// Generate Alert Arrows
buy = 0
sell = 0
buybreak = 0
sellbreak = 0
//
buy := emafast > emaslow and (not colslowS) and colfastL and (not ShowCon or colslowL) and ((not emaFilter) or emafast > ema200) ? nz(buy[1]) > 0 ? buy[1] + 1 : 1 : 0
sell := emafast < emaslow and (not colslowL) and colfastS and (not ShowCon or colslowS) and ((not emaFilter) or emafast < ema200) ? nz(sell[1]) > 0 ? sell[1] + 1 : 1 : 0
buy := buy > 1 and colfastL and uOCCswing and close[1] < open[1] and close > open ? 1 : buy
sell := sell > 1 and colfastS and uOCCswing and close[1] > open[1] and close < open ? 1 : sell
//
buybreak := emafast > emaslow and (not colslowS) and ((not emaFilter) or emafast > ema200) ? nz(buybreak[1]) > 0 ? buybreak[1] + 1 : 1 : 0
sellbreak := emafast < emaslow and (not colslowL) and ((not emaFilter) or emafast < ema200) ? nz(sellbreak[1]) > 0 ? sellbreak[1] + 1 : 1 : 0
//
// plotarrow(ShowSwing and buy == 1 and ta.barssince(nz(buy[1], 1) == 1) > Lookback ? 1 : na, title='BUY Swing Arrow', colorup=color.new(color.lime, 20), maxheight=60, minheight=50)
// plotarrow(ShowSwing and sell == 1 and ta.barssince(nz(sell[1], 1) == 1) > Lookback ? -1 : na, title='SELL Swing Arrow', colordown=color.new(color.red, 20), maxheight=60, minheight=50)

// plotarrow(ShowBreak and buybreak == 1 and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback ? 1 : na, title='BUY Break Arrow', colorup=color.new(color.aqua, 20), maxheight=60, minheight=50)
// plotarrow(ShowBreak and sellbreak == 1 and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback ? -1 : na, title='SELL Break Arrow', colordown=color.new(color.blue, 20), maxheight=60, minheight=50)



long1 = (buy == 1 and ta.barssince(nz(buy[1], 1) == 1) > Lookback) or (buybreak == 1 and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback)
short1 = (sell == 1 and ta.barssince(nz(sell[1], 1) == 1) > Lookback) or (sellbreak == 1 and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback)




var lsl = 0.0
var ssl = 0.0
var ltp = 0.0
var stp = 0.0


timeCond = (time > i_startTime) and (time < i_endTime)
isPeriod = testPeriodSwitch == true ? timeCond : true


var latp = ""
var satp = ""
var lasl = ""
var sasl = ""

msg(q)=>
    var le=""
    var lx=""
    var se=""
    var sx=""
    sym = syminfo.ticker
    if tr_meth == "With TP and SL"
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+tp+'","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+tp+'","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'

    if tr_meth == "Only TP"
        
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+tp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+tp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'

    if tr_meth == "Only SL"
        
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'

    if tr_meth == "Auto TP"
        
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+latp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+satp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'

    if tr_meth == "Auto SL"
        
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","SL":"'+lasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","SL":"'+sasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'


    if tr_meth == "Auto TP&SL"
        
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+latp+'","SL":"'+lasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+satp+'","SL":"'+sasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'

    if tr_meth == "Strategy" 
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]' 
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]' 
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'

    if tr_meth == "stg-nolev"
        le := '[{"C":"CURRENCY","MODE":"HEDGE","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"BUY","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        se := '[{"C":"CURRENCY","MODE":"HEDGE","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := '[{"C":"CURRENCY","MODE":"HEDGE","CLOSE":"CLOSE","TT":"SELL","TS":"'+sym+'","Q":"'+q+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'

    if tr_meth == 'Stg-TP-SL'
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+tp+'","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := " "
        se := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+tp+'","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := " "


    if tr_meth == 'Stg-TP'
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+tp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := " "
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+tp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := " "

    if tr_meth == 'Stg-SL'
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := " "
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","SL":"'+sl_+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := " "


    if tr_meth == 'Stg-AutoTP-SL'
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+latp+'","SL":"'+lasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := " "
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+satp+'","SL":"'+sasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := " "


    if tr_meth == 'Stg-AutoTP'
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","TP":"'+latp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := " "
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","TP":"'+satp+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := " "


    if tr_meth == 'Stg-AutoSL'
        le := '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"BUY","SL":"'+lasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        lx := " "
        se :=  '[{"C":"CURRENCY","MODE":"HEDGE","LEV":"'+lev+'","TYPE":"'+typ+'","TS":"'+sym+'","Q":"'+q+'","TT":"SELL","SL":"'+sasl+'","OT":"MARKET","AT":"BINANCE_PERPETUAL"}]'
        sx := " "

    [le,lx,se,sx]


send(x, q )=>
    pass = ''
    qs = (math.ceil((q*close)/10)+1) * 10
    [le,lx,se,sx] = msg(str.tostring(qs))
    if x=='le' 
        pass:=le
    if x=='lx' 
        pass:=lx
    if x=='se' 
        pass:=se
    if x=='sx' 
        pass:=sx
    pass



long = false
short = false

plot(VWAPrice , color=color.new(color.teal, 0), title='VWAP', display=display.none)


t = time(timeframe.period, sess + ":1234567")
hide = timeframe.isintraday and timeframe.multiplier <= inputMax

is_newbar(res) => ta.change(time(res)) != 0
in_session = not na(t)
is_first = in_session and not in_session[1]

orb_high = float(na)
orb_low = float(na)

if is_first
    orb_high := high
    orb_low := low
else
    orb_high := orb_high[1]
    orb_low := orb_low[1]
if high > orb_high and in_session
    orb_high := high
if low < orb_low and in_session
    orb_low := low

//plot(hide ? orb_high : na , style=plot.style_line, color=orb_high[1] != orb_high ? na : color.green, title="ORB High", linewidth=2)
//plot(hide ? orb_low : na , style=plot.style_line, color=orb_low[1] != orb_low ? na : color.red, title="ORB Low", linewidth=2)


if first_entry == 'VWAP'
    if strategy.position_size<=0
        long := ta.cross(close, VWAPrice) and close > VWAPrice
    if strategy.position_size>=0
        short := ta.cross(VWAPrice, close) and close < VWAPrice
if first_entry == 'Guppy'
    if strategy.position_size<=0
        long := long1
    if strategy.position_size>=0
        short := short1
if first_entry == 'ORB'
    if strategy.position_size<=0
        long := ta.crossover(close, orb_high)
    if strategy.position_size>=0
        short := ta.crossunder(close, orb_low)
if first_entry == 'Supertrend'
    if strategy.position_size<=0
        long := PlotShapeUp_trend
    if strategy.position_size>=0
        short := PlotShapeDown_trend
if first_entry == 'CPR'
    if strategy.position_size<=0
        long := buy_cpr
    if strategy.position_size>=0
        short := sell_cpr
// if first_entry == "Supertrend Closed Alert"
//     if strategy.position_size<=0
//         long := ta.crossunder(sup_value, cl_arr)
//     if strategy.position_size>=0
//         short := ta.crossover(sup_value, cl_arr)
// if first_entry == "Supertrend Crossed Alert"
//     if strategy.position_size<=0
//         long := ta.crossunder(sup_value1, cl_arr)
//     if strategy.position_size>=0
//         short := ta.crossover(sup_value1, cl_arr)
        
      
    

if second_entry == 'VWAP'
    if strategy.position_size>0
        long := ta.cross(close, VWAPrice) and close > VWAPrice
    if strategy.position_size<0
        short := ta.cross(VWAPrice, close) and close < VWAPrice
if second_entry == 'Guppy'
    if strategy.position_size>0
        long := long1
    if strategy.position_size<0
        short := short1 
if second_entry == 'ORB'
    if strategy.position_size>0
        long := ta.crossover(close, orb_high)
    if strategy.position_size<0
        short := ta.crossunder(close, orb_low)
if second_entry == 'Supertrend'
    if strategy.position_size>0
        long := PlotShapeUp_trend
    if strategy.position_size<0
        short := PlotShapeDown_trend
if second_entry == 'CPR'
    if strategy.position_size>0
        long := buy_cpr
    if strategy.position_size<0
        short := sell_cpr
// if second_entry == "Supertrend Closed Alert"
//     if strategy.position_size<=0
//         long := ta.crossunder(sup_value, cl_arr)
//     if strategy.position_size>=0
//         short := ta.crossover(sup_value, cl_arr)
// if second_entry == "Supertrend Crossed Alert"
//     if strategy.position_size<=0
//         long := ta.crossunder(sup_value1, cl_arr)
//     if strategy.position_size>=0
//         short := ta.crossover(sup_value1, cl_arr)




//@version=5
// indicator(title='WaveTrend Oscillator [Krypt]', shorttitle='WT_Krypt', precision=3)

PI = 3.14159265359

dropn(src_wt, n) =>
    na(src_wt[n]) ? na : src_wt

EhlersSuperSmoother(src_wt, lower) =>
    a1 = math.exp(-PI * math.sqrt(2) / lower)
    coeff2 = 2 * a1 * math.cos(math.sqrt(2) * PI / lower)
    coeff3 = -math.pow(a1, 2)
    coeff1 = (1 - coeff2 - coeff3) / 2
    filt = 0.0
    filt := nz(coeff1 * (src_wt + nz(src_wt[1], src_wt)) + coeff2 * filt[1] + coeff3 * nz(filt[2], filt[1]), src_wt)
    filt

// Replaces built-in EMA function for better sensitivity in the beginning
xema(src_wt, len) =>
    mult = 2.0 / (len + 1.0)
    res = float(na)
    res := mult * src_wt + (1.0 - mult) * nz(res[1], src_wt)
    res

EhlersEmaSmoother(sig, smoothK, smoothP) =>
    EhlersSuperSmoother(xema(sig, smoothK), smoothP)

// step function (assigns values if series evaluates to True 
// and keeps them until a new True result is seen)
step(xs, vals) =>
    res = float(na)
    res := nz(xs ? vals : res[1], vals)
    res

// try to detect monotonous increase in step function
casc_1(xs, start, while_1) =>
    res = float(na)
    res := math.abs(nz(start and xs > xs[1] and not res[1] and while_1 ? xs - xs[1] : xs >= xs[1] and while_1 ? res[1] + xs - xs[1] : 0.0))
    res
casc_2(xs, start, while_2) =>
    res = float(na)
    res := math.abs(nz(start and xs > xs[1] and not res[1] and while_2 ? xs - xs[1] : xs >= xs[1] and while_2 ? res[1] + xs - xs[1] : 0.0))
    res

// try to detect monotonous decrease in step function
cdesc_1(xs, start, while_3) =>
    res = float(na)
    res := math.abs(nz(start and xs < xs[1] and not res[1] and while_3 ? xs[1] - xs : xs <= xs[1] and while_3 ? res[1] + xs[1] - xs : 0.0))
    res
cdesc_2(xs, start, while_4) =>
    res = float(na)
    res := math.abs(nz(start and xs < xs[1] and not res[1] and while_4 ? xs[1] - xs : xs <= xs[1] and while_4 ? res[1] + xs[1] - xs : 0.0))
    res

findhidden(price, allbottoms, alltops, bottomsteps, topsteps, backtrack) =>
    pricebottoms = step(allbottoms, ta.lowest(price, backtrack))
    pricetops = step(alltops, ta.highest(price, backtrack))
    hbull = math.sqrt(cdesc_1(bottomsteps, true, true) * casc_1(pricebottoms, true, true))
    hbear = math.sqrt(casc_1(topsteps, true, true) * cdesc_1(pricetops, true, true))
    [hbull / (1.0 + hbear), hbear / (1.0 + hbull)]

n1 = input.int(10, title='Channel Length', minval=1,group = "WaveTrend Oscillator [Krypt]")
n2 = input.int(21, title='Average Length', minval=1,group = "WaveTrend Oscillator [Krypt]")
smoothing = input.int(4, title='Signal Smoothing', minval=0,group = "WaveTrend Oscillator [Krypt]")
maperiod = input.int(4, title='MA Period', minval=1,group = "WaveTrend Oscillator [Krypt]")
ob = input.float(0.75, title='Overbought Level', minval=0.0,group = "WaveTrend Oscillator [Krypt]")
os = input.float(-0.75, title='Oversold Level', maxval=-0.0,group = "WaveTrend Oscillator [Krypt]")
showhist = input(true, title='Histogram',group = "WaveTrend Oscillator [Krypt]")
showsignals = input(true, title='Buy/Sell Signals',group = "WaveTrend Oscillator [Krypt]")
src_wt = input(close, title='Source',group = "WaveTrend Oscillator [Krypt]")

price = math.log(dropn(src_wt, 1))

delta = price - xema(price, n1)
d = xema(math.abs(delta), n1)
ci = d == 0 ? 0 : delta / d
sig = EhlersEmaSmoother(ci, n2, smoothing)
ma = ta.sma(sig, maperiod)

// create plots
// plot(sig, color=color.new(#0094ff, 0), style=plot.style_line, title='Signal')
// plot(ma, color=color.new(#ff6a00, 0), style=plot.style_line, title='SMA')

// lineBuyBottom = plot(os, color=color.new(color.orange, 0), title='Oversold Level')
// lineSellTop = plot(ob, color=color.new(#00bb00, 0), title='Overbought Level')

// lineBuy = plot(series=sig < os ? sig : os, title='n/a', editable=false, transp=100)
// lineSell = plot(series=sig > ob ? sig : ob, title='n/a', editable=false, transp=100)

// fill(plot1=lineBuy, plot2=lineBuyBottom, color=color.new(color.orange, 50), title='Oversold area')
// fill(plot1=lineSellTop, plot2=lineSell, color=color.new(#00bb00, 50), title='Overbought area')

// plot(showhist ? sig - ma : na, color=sig > ma ? #5fc8ff : #ff9900, style=plot.style_area, title='Histogram', transp=80)

// buy/sell signals

midpoint = (ob + os) / 2
exoff = (ob - midpoint) / 7
ploff = (ob - midpoint) / 8
hiddenupper = midpoint + 0.61803398875
hiddenlower = midpoint - 0.61803398875

// filter out false positives by adding sum of signal and MA at last 5 pips
reqpips = 5
sumsig = math.sum(sig, reqpips)
summa = math.sum(ma, reqpips)
allbottoms = showsignals and ma < ob and ta.crossover(sig, ma) and sumsig[1] < summa[1]
alltops = showsignals and ma > os and ta.crossunder(sig, ma) and sumsig[1] > summa[1]

// bullish and bearish conditions
bottomsteps = step(allbottoms, ma)
topsteps = step(alltops, ma)

[hiddenbull, hiddenbear] = findhidden(price, allbottoms, alltops, bottomsteps, topsteps, reqpips)

possiblebull = casc_2(bottomsteps, bottomsteps[1] < os or hiddenbull[1] > hiddenbear[1], sig < ob)
possiblebear = cdesc_2(topsteps, topsteps[1] > ob or hiddenbear[1] > hiddenbull[1], sig > os)
bullishtrend = possiblebull / (1.0 + possiblebear)
bearishtrend = possiblebear / (1.0 + possiblebull)


obs = input(false,"Oversold / Bought filter",group = "WaveTrend Oscillator [Krypt]")

buysignals = allbottoms and (ma < midpoint and (sig[1] < os - exoff or bullishtrend > hiddenbear) or ma < hiddenupper and hiddenbull > bearishtrend) and (obs?((sig[1]-ploff)<os):true) 
sellsignals = alltops and (ma > midpoint and (sig[1] > ob + exoff or bearishtrend > hiddenbull) or ma > hiddenlower and hiddenbear > bullishtrend) and (obs?((sig[1]+ploff)>ob):true) 

//plotshape(buysignals, title="Buy", text="Buy", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.green, textcolor=color.white)
//plotshape(sellsignals, title="Sell", text="Sell", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.red, textcolor=color.white)

// plot(buysignals ? sig[1] - ploff : na, style=plot.style_circles, color=color.new(#008fff, 0), linewidth=3, title='Buy Signal')
// plot(sellsignals ? sig[1] + ploff : na, style=plot.style_circles, color=color.new(#ff0000, 0), linewidth=3, title='Sell Signal')

diff_new = input.float(0.1, 'New Levels nearer %',group="Open/Pivot Based Entries") / 100.0


diff_new_buy(lvl)=>
    close > lvl and math.abs(lvl - close) <= diff_new * close
diff_new_sell(lvl)=>
    lvl > close and math.abs(lvl - close) <= diff_new * close   



// pivot = (high + low + close) / 3  //Central Povit
// BC = (high + low) / 2  //Below Central povit
// TC = pivot - BC + pivot  //Top Central povot

S1 = (pivot * 2) - high
S2 = pivot - (high - low)
S3 = low - 2 * (high - pivot)

//----------------------------3  resistance levels

R1 = (pivot * 2) - low
R2 = pivot + (high - low)
R3 = high + 2 * (pivot-low)


ranger = high - low
H5_ = (high / low) * close
H4_ = close + ranger * 1.1/2
H3_ = close + ranger * 1.1/4
H2_ = close + ranger * 1.1/6
H1_ = close + ranger * 1.1/12
H6_ = H5_ + 1.168 * (H5_ - H4_) 

L1_ = close - ranger * 1.1/12
L2_ = close - ranger * 1.1/6
L3_ = close - ranger * 1.1/4
L4_ = close - ranger * 1.1/2
L5_ = close - (H5_ - close)
L6_ = close - (H6_ - close)

[wopen,weekPivot,weekBC,weekTC, wR1,wS1, wR2, wS2,wR3, wS3] = request.security(tick, 'W', [open,pivot[1],BC[1],TC[1], R1[1], S1[1], R2[1], S2[1], R3[1], S3[1]]   , lookahead=barmerge.lookahead_on)
[mopen,monthPivot,monthBC,monthTC, mR1,mS1, mR2, mS2,mR3, mS3] = request.security(tick, 'M', [open,pivot[1],BC[1],TC[1], R1[1], S1[1], R2[1], S2[1], R3[1], S3[1]]   , lookahead=barmerge.lookahead_on)

buy6 = co6 ? diff_new_buy(wopen) : false
sell6 = co6 ? diff_new_sell(wopen): false
 
buy7 = co7 ? diff_new_buy(mopen) : false
sell7 = co7 ? diff_new_sell(mopen) : false
 
buy8 = co8 ? diff_new_buy(weekPivot) : false
sell8 = co8 ? diff_new_sell(weekPivot) : false
 
buy9 = co9 ? diff_new_buy(monthPivot) : false
sell9 = co9 ?  diff_new_sell(monthPivot) : false

x_long = (check_vwap ? ta.cross(close, VWAPrice) and close > VWAPrice : false) or (check_guppy ? long1 : false) or (check_orb ? ta.crossover(close, orb_high) : false) or (check_st and PlotShapeUp_trend ) or (buy_cpr and check_cpr) or (check_wa and buysignals) or buy6 or buy7 or buy8 or buy9
x_short = (check_vwap ? ta.cross(VWAPrice, close) and close < VWAPrice : false) or (check_guppy ? short1 : false) or (check_orb ? ta.crossunder(close, orb_low) : false) or (check_st and PlotShapeDown_trend ) or (sell_cpr and check_cpr) or (check_wa and sellsignals) or sell6 or sell7 or sell8 or sell9

clong = short1
cshort = long1

if clong
    strategy.close(  "Long" ,alert_message = send('lx', math.abs(strategy.position_size)))
if cshort
    strategy.close(  "Short" ,alert_message = send('sx', math.abs(strategy.position_size)))


var count = 0
if dayofmonth!=dayofmonth[1]
    count:=0


//maximumEntry = input(defval=100, title='Maximum entries per day')
// maxLoss = input(defval = 1, title = "maximumLossPerDay") * (-1)
maxProfitOrLossNotReached = true
profit = 0.0

// plot(profit, color=color.fuchsia)
for tradeNo = 0 to strategy.closedtrades - 1
    if strategy.closedtrades.entry_time(tradeNo) > time - 86400000
        profit += strategy.closedtrades.profit(tradeNo)

if (profit >= maxProfit) //or (profit <= maxLoss)
    maxProfitOrLossNotReached := false

if (long or x_long or add_buy) and dir!="Short" and isPeriod and vol and count<max_day and filter1 and (isPeriod and allow) and ema20_b and ema_b
    lsl := low * (1-sl)
    ltp:= math.min( close + ((close-lsl)*rr), close * (1+max_prof))
    key = str.tostring(strategy.position_size)
    latp:= str.tostring(math.round((math.abs(ltp-close)/close)*100,2))
    lasl:= str.tostring(math.round((math.abs(lsl-close)/close)*100,2))
    if maxProfitOrLossNotReached
        if use_qty
            buff = math.round( usd/close, round)
            if rev
                strategy.entry(id ="LongRev"+key, direction = strategy.short,alert_message = send('se',buff), qty=buff)
                strategy.exit("Long Exit",from_entry ="LongRev"+key,stop = ltp ,limit = lsl,alert_message = send('sx',buff), qty=buff)
            else
                strategy.entry(id ="Long"+key, direction = strategy.long,alert_message = send('le',buff), qty=buff)
                strategy.exit("Long Exit",from_entry ="Long"+key,stop = lsl ,limit = ltp,alert_message = send('lx',buff), qty=buff)
        else
            buff = math.round(risk/math.abs(close-lsl), round)
            if (buff*close)<=maxe
                if rev
                    strategy.entry(id ="LongRev"+key, direction = strategy.short, qty = buff,alert_message = send('se', buff))
                    strategy.exit("Long Exit",from_entry ="LongRev"+key,stop = ltp ,limit = lsl,alert_message = send('sx',buff), qty=buff)
                else
                    strategy.entry(id ="Long"+key, direction = strategy.long, qty = buff,alert_message = send('le', buff))
                    strategy.exit("Long Exit",from_entry ="Long"+key,stop = lsl ,limit = ltp,alert_message = send('lx',buff), qty=buff)
    box.new(bar_index, ltp, bar_index+10, close, color.new(color.green, 100), bgcolor = color.new(color.green, 80))
    box.new(bar_index, lsl, bar_index+10, close, color.new(color.green, 100), bgcolor = color.new(color.red, 80))
    count:=count+1


if (short or x_short or add_sell ) and dir!="Long" and isPeriod and vol and count<max_day and filter1 and (isPeriod and allow) and ema20_s and ema_s
    ssl := high * (1+sl)
    stp:= math.max(close - ((ssl-close)*rr), close * (1-max_prof))
    key = str.tostring(strategy.position_size)
    satp:= str.tostring(math.round( (math.abs(stp-close)/close)*100, 2))
    sasl:= str.tostring(math.round( (math.abs(ssl-close)/close)*100, 2))
    if maxProfitOrLossNotReached
        if use_qty
            buff = math.round( usd/close, round)
            if rev
                strategy.entry(id ="ShortRev"+key, direction = strategy.long,alert_message = send('le', buff) , qty=buff)
                strategy.exit("Short Exit"+key,from_entry ="ShortRev"+key,stop = stp ,limit = ssl,alert_message = send('lx', buff), qty=buff)    
            else
                strategy.entry(id ="Short"+key, direction = strategy.short,alert_message = send('se', buff) , qty=buff)
                strategy.exit("Short Exit"+key,from_entry ="Short"+key,stop = ssl ,limit = stp,alert_message = send('sx', buff), qty=buff)    
        else
            buff = math.round(risk/math.abs(close-ssl),round)
            if (buff*close)<=maxe
                if rev
                    strategy.entry(id ="ShortRev"+key, direction = strategy.long, qty = buff,alert_message = send('se', buff))
                    strategy.exit("Short Exit"+key,from_entry ="ShortRev"+key,stop = stp ,limit = ssl,alert_message = send('sx', buff), qty=buff)    
                else
                    strategy.entry(id ="Short"+key, direction = strategy.short, qty = buff,alert_message = send('se', buff))
                    strategy.exit("Short Exit"+key,from_entry ="Short"+key,stop = ssl ,limit = stp,alert_message = send('sx', buff), qty=buff)    
    box.new(bar_index, stp, bar_index+10, close, color.new(color.green, 100), bgcolor = color.new(color.green, 80))
    box.new(bar_index, ssl, bar_index+10, close, color.new(color.green, 100), bgcolor = color.new(color.red, 80))
    count:=count+1

// Extracting PNL. This is different calculation for each deal close type
float lastTradeProfit = na
if strategy.position_size != strategy.position_size[1]
    lastTradeProfit := strategy.netprofit - strategy.netprofit[1]
BarsSinceLastEntry =  bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) 
    
get_bg_color_red(val)=>
    val>0 ? color.green:color.red

if (strategy.closedtrades!=strategy.closedtrades[1])
    label.new(bar_index, low, text=str.tostring(lastTradeProfit, format.mintick) +         '  ' + str.tostring(syminfo.currency) ,   yloc=yloc.price, size=size.normal, style=label.style_label_down, textcolor=color.black, color=get_bg_color_red(lastTradeProfit) )



if not (Session1 and maxProfitOrLossNotReached)
	strategy.cancel_all()
    strategy.close_all()