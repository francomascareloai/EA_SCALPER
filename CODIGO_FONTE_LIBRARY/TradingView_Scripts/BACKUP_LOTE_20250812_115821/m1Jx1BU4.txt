// LOVE JOY PEACE PATIENCE KINDNESS GOODNESS FAITHFULNESS GENTLENESS SELF-CONTROL 
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//  Trade Concept:  Brian Beamish (TRI)
//
//  Authors:        JoshuaMcGowan
//  Date:           06192020
//  Revision:       

//@version=5

indicator(title='SCDTM - The Duke of Ronaville w/ Time', overlay=true, precision=7)

//
src = input(close, title='Strategy Source')

////////////////////////////////////////////////
//* Variable and Global Variable Declaration *//
////////////////////////////////////////////////

var longCloseLoss = 0  // These are used when stopped out in an active trade
var shortCloseLoss = 0

var longCloseMega = 0  // These are used when target reached in an active trade
var shortCloseMega = 0

var longClosePartial = 0  // These are used when target reached in an active trade
var shortClosePartial = 0

var longCloseBE = 0  // These are used when stop at scratch in an active trade. 
var shortCloseBE = 0

var longCloseBERem = 0  // These are used when stop at scratch in an active trade after Target hit. 
var shortCloseBERem = 0

// Global Checkpoint Variable Declarations
var cp1 = 0  // Trending EMAs
var cp2 = 0  // Stoch RSI Signal w/ Trend 
var cp3 = 0  // Structure w/ cp1 and cp2 and tradeState==0
var cp4 = 0  // When CP3 fires it sets CP4==1 with persistence as "Unconfirmed Signal"
var cp5 = 0  // Market Buy on Stop of Breakout Level. Trade Active
var cp6 = 0  // Stop to BE Active
var cp7 = 0  // Will use this flag for selling half at target and trailing stop
var cp8 = 0  // Unused

// Checkpoint 3 - Global Variables
//Trade State Values. 
//0=No orders working and not in active trade. 
//1=Orders working.
//2=Active long.
//3=Active short.
var tradeState = 0

// Checkpoint 4 - Global Variables
var float bull_breakout_price = na
var float bull_sl = na
var float bear_breakout_price = na
var float bear_sl = na

var float entry_buy = na
var float entry_sell = na
var float entry_fill = na
var float entry_dist = na
var float entry_be = na
var float entry_tgt = na

var confirmed = 0  // Unused
var filled = 0  // Unused

// Plot Counters //  
var plotPartialCounter = 0  // Sell Half at Target
// plotPartialCounter := nz(plotPartialCounter[1])

var plotLossCounter = 0  // Trade Stopped Out
// plotLossCounter := nz(plotLossCounter[1])

var plotBECounter = 0  // Trade Stopped at Scratch
// plotBECounter := nz(plotBECounter[1])

var plotMegaCounter = 0  // Remaining Half Sold at Trailing Stop
// plotMegaCounter := nz(plotMegaCounter[1])

var plotBERemCounter = 0  // Remaining Half Stopped at Scratch
// plotBERemCounter := nz(plotBECounter[1])

// Adding Time Filter Components Here //
i_startTime = input.time(timestamp("1 Nov 2023"), title="Start Date")
i_endTime = input.time(timestamp("30 Nov 2023"), title="End Date")
inDateRange = time >= i_startTime and time <= i_endTime

/////////////////////////////////////////////////////////////////////////////////////////////////
// Checkpoint 1 - Institutional Bias or Brian's Bias across 3 timeframes pointing same direction. 
/////////////////////////////////////////////////////////////////////////////////////////////////

// Inputs for MA
ma1Period = input.int(9, title='Fast MA Period', minval=1, step=1)
ma1Type = input.string(title='Fast MA Type', defval='EMA', options=['RMA', 'SMA', 'EMA', 'WMA', 'HMA', 'DEMA', 'TEMA', 'VWMA'])
ma1Source = input(title='Fast MA Source', defval=close)

ma2Period = input.int(18, title='Slow MA Period', minval=1, step=1)
ma2Type = input.string(title='Slow MA Type', defval='EMA', options=['RMA', 'SMA', 'EMA', 'WMA', 'HMA', 'DEMA', 'TEMA', 'VWMA'])
ma2Source = input(title='Slow MA Source', defval=close)

// Function for MA Components
ma(MAType, MASource, MAPeriod) =>
    if MAType == 'SMA'
        ta.sma(MASource, MAPeriod)
    else
        if MAType == 'EMA'
            ta.ema(MASource, MAPeriod)
        else
            if MAType == 'WMA'
                ta.wma(MASource, MAPeriod)
            else
                if MAType == 'RMA'
                    ta.rma(MASource, MAPeriod)
                else
                    if MAType == 'HMA'
                        ta.wma(2 * ta.wma(MASource, MAPeriod / 2) - ta.wma(MASource, MAPeriod), math.round(math.sqrt(MAPeriod)))
                    else
                        if MAType == 'DEMA'
                            e = ta.ema(MASource, MAPeriod)
                            2 * e - ta.ema(e, MAPeriod)
                        else
                            if MAType == 'TEMA'
                                e = ta.ema(MASource, MAPeriod)
                                3 * (e - ta.ema(e, MAPeriod)) + ta.ema(ta.ema(e, MAPeriod), MAPeriod)
                            else
                                if MAType == 'VWMA'
                                    ta.vwma(MASource, MAPeriod)

// Daily TF
ma1_D = request.security(syminfo.tickerid, 'D', ma(ma1Type, ma1Source, ma1Period), lookahead=barmerge.lookahead_on)
ma2_D = request.security(syminfo.tickerid, 'D', ma(ma2Type, ma2Source, ma2Period), lookahead=barmerge.lookahead_on)

bull_ema_daily = ma1_D >= ma2_D ? 1 : 0
bear_ema_daily = ma1_D < ma2_D ? 1 : 0

// 4HR TF
ma1_H4 = request.security(syminfo.tickerid, '240', ma(ma1Type, ma1Source, ma1Period), lookahead=barmerge.lookahead_on)
ma2_H4 = request.security(syminfo.tickerid, '240', ma(ma2Type, ma2Source, ma2Period), lookahead=barmerge.lookahead_on)

bull_ema_H4 = ma1_H4 >= ma2_H4 ? 1 : 0
bear_ema_H4 = ma1_H4 < ma2_H4 ? 1 : 0

// 1HR TF
ma1_H1 = request.security(syminfo.tickerid, '60', ma(ma1Type, ma1Source, ma1Period), lookahead=barmerge.lookahead_on)
ma2_H1 = request.security(syminfo.tickerid, '60', ma(ma2Type, ma2Source, ma2Period), lookahead=barmerge.lookahead_on)

bull_ema_H1 = ma1_H1 >= ma2_H1 ? 1 : 0
bear_ema_H1 = ma1_H1 < ma2_H1 ? 1 : 0

// Consolidating the EMA conditons
bull_ema_index = bull_ema_daily + bull_ema_H4 + bull_ema_H1
bull_ema = bull_ema_index == 3

bear_ema_index = bear_ema_daily + bear_ema_H4 + bear_ema_H1
bear_ema = bear_ema_index == 3

if ((bull_ema_index == 3 or bear_ema_index == 3) and inDateRange) // adding start and stop dates for backtest here to filter 
    cp1 := 1
    cp1
else
    cp1 := 0
    cp1

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checkpoint 2 - With CP1 equal to 1 we are looking for indicator confirmation. For now will just be %B 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Stoch RSI Component
smoothK = input.int(3, minval=1)
smoothD = input.int(3, minval=1)
lengthRSI = input.int(14, minval=1)
lengthStoch = input.int(14, minval=1)
srcStoch = input(close, title='RSI Source')
upThreshStoch = input.int(80, minval=1)
dnThreshStoch = input.int(20, minval=1)

rsi1 = ta.rsi(src, lengthRSI)
k = ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch), smoothK)  // fast
d = ta.sma(k, smoothD)  // slow

// Signals Long/Short Return To The Mean
var long_rsi = 0  // Global Variable 

if k >= d or d <= 20  // and d <= dnThreshStoch // Fast over slow
    long_rsi := 1
    long_rsi
else
    long_rsi := 0
    long_rsi

var short_rsi = 0  // Global Variable 

if d >= k or d >= 80  // and d >= upThreshStoch // Slow over fast
    short_rsi := 1
    short_rsi
else
    short_rsi := 0
    short_rsi

// Sets Checkpoint 2 // Requires Trending MA's and Stoch RSI in agreement. 
if ((bear_ema_index == 3 and short_rsi == 1 or bull_ema_index == 3 and long_rsi == 1) and inDateRange)
    cp2 := 1
    cp2
else
    cp2 := 0
    cp2

// This would be a great place to add an alert for trading this manually
alertcondition(ta.change(cp2) and cp2==1, "SCDTM Trending EMA's w/ Indicator - Hunt Structure w/ Trend")

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checkpoint 3 - With CP2 equal to 1 we are looking for inside bars, 3, or 5 bar fractals going the same direction when not in an active trade. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Define "n" as the number of periods and keep a minimum value of 2 for error handling.
n = input.int(title='Fractal Period', defval=2, minval=2)
structure = input.string(title='Structure', defval='Inside Bars', options=['3 Bar Fractal', '5 Bar Fractal', 'Inside Bars'])
colorcandles = input(title='Colored Candles', defval=false)

// Logic 
dnFractal = if structure == '5 Bar Fractal'
    dnFractal5 = high[n - 2] < high[n] and high[n - 1] < high[n] and high[n + 1] < high[n] and high[n + 2] < high[n]
    dnFractal5
else
    if structure == '3 Bar Fractal'
        dnFractal3 = high[n - 1] < high[n] and high[n + 1] < high[n]
        dnFractal3

upFractal = if structure == '5 Bar Fractal'
    upFractal5 = low[n - 2] > low[n] and low[n - 1] > low[n] and low[n + 1] > low[n] and low[n + 2] > low[n]
    upFractal5
else
    if structure == '3 Bar Fractal'
        upFractal3 = low[n - 1] > low[n] and low[n + 1] > low[n]
        upFractal3

upInsideBar = structure == 'Inside Bars' ? close > open and high < high[1] and low > low[1] : true
dnInsideBar = structure == 'Inside Bars' ? close < open and high < high[1] and low > low[1] : true

//Bar Color Definitions
isorange = structure == '3 Bar Fractal'
ispurple = structure == '5 Bar Fractal'

candlecolor = isorange ? color.new(#FF9F20, 50) : ispurple ? color.new(#500050, 50) : color.gray

// // Adding this to troubleshoot mis-fire bug. 
// var dnFractalConf = 0
// var upFractalConf = 0

// // Need to monitor to potentially make this Persistent vs On/Off. 
// if dnFractal==true
//     dnFractalConf := 1
// else
//     dnFractalConf := 0

// if upFractal==true
//     upFractalConf := 1
// else
//     upFractalConf := 0

// // Updates Global Variable Without Persistence (On/Off Switch) // Exclude Fractal Midpoints that occur on Close Signals
// if (cp2==1) 
//  and not (longCloseLoss[2] or shortCloseLoss[2] or longCloseMega[2] or shortCloseMega[2] or longClosePartial[2] or shortClosePartial[2] or longCloseBE[2] or shortCloseBE[2] or longCloseBERem[2] or shortCloseBERem[2]
//  or longCloseLoss[1] or shortCloseLoss[1] or longCloseMega[1] or shortCloseMega[1] or longClosePartial[1] or shortClosePartial[1] or longCloseBE[1] or shortCloseBE[1] or longCloseBERem[1] or shortCloseBERem[1]) 
//  and ((upFractal==true or upInsideBar==true and bull_ema_index == 3 and tradeState==0) or (dnFractal==true or dnInsideBar==true and bear_ema_index == 3 and tradeState==0))
//     cp3 := 1
//     cp4 := 1 // Adding this so its a persistent signal to work with for the breakout signaling process. 
//     longCloseLoss := 0 // These are added to ensure close signals are proper w/ potential signal
//     shortCloseLoss := 0
//     longCloseMega := 0
//     shortCloseMega := 0
//     longClosePartial := 0
//     shortClosePartial := 0
//     longCloseBE := 0
//     shortCloseBE := 0
//     longCloseBERem := 0
//     shortCloseBERem := 0
// else
//     cp3 := 0

// Updates Global Variable CP4 With Persistence // Exclude Fractal Midpoints that occur on Close Signals. Adding in [1] to structure as a test (wait for close before firing)
if cp2 == 1 and (upFractal[1] == true or upInsideBar[1] == true and bull_ema_index == 3 and tradeState == 0 or dnFractal[1] == true or dnInsideBar[1] == true and bear_ema_index == 3 and tradeState == 0)
    cp3 := 1
    cp4 := 1  // Adding this so its a persistent signal to work with for the breakout signaling process. 
    longCloseLoss := 0  // These are added to ensure close signals are proper w/ potential signal
    shortCloseLoss := 0
    longCloseMega := 0
    shortCloseMega := 0
    longClosePartial := 0
    shortClosePartial := 0
    longCloseBE := 0
    shortCloseBE := 0
    longCloseBERem := 0
    shortCloseBERem := 0
    shortCloseBERem
else
    cp3 := 0
    cp3

// Testing a bug fix where cp4==1 w/ tradeState==0 and cp4 never resets or levels aren't set correctly making cp4 stuck
if tradeState == 0 and cp4 == 1 and tradeState[1] == 0 and cp4[1] == 1 and tradeState[2] == 0 and cp4[2] == 1
    cp4 := 0
    cp4

// When CP3 becomes true we need to make note of a few levels to work with for the Trade Management process. CP4 is waiting for Breakout to occur.
//  Stop (one tick below low of candle structure for bullish setups)
//  Confirmation Level (Price to confirm breakout of structure before tripping stop levels)
//  Potential Entry Level // This would be used for limit orders, not using with this approach. 
//  Breakeven 1:1 Level (Triggers move stop to scratch) // Not using move stops to BE for this approach 
//  Target 1 (2:1 Risk/Reward Level)  // Once signaling is stable adjust this closer to 3:1 if possible

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checkpoint 5 - With CP3&4 equal to 1 we look for price to breakout to confirm the fractal or invalidate the setup by tripping the stop level (cp2, cp3, cp4 == 0). 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Variables and Inputs for Position Sizing
TradeSizeInXBT = 0.00000
TradeSizeInXBT := nz(TradeSizeInXBT[1])
TradeSizeInUSD = 0.0
TradeSizeInUSD := nz(TradeSizeInUSD[1])

rr = input.float(defval=2.00, minval=2.0, title='Risk to Reward Ratio')
be = input.float(defval=1.00, minval=0.25, title='Breakeven Level')
Leverage = input(defval=1, title='Leverage Amount')
commission = input(title='Estimated Commission', defval=0.2)
// USDRiskPerTrade = input(defval=1, title="USD Risk Per Trade", type=input.integer) // Changing to $2 from $50 for Production
USDRiskPerTrade = input(defval=5.0, title='USD Risk Per Trade')  // Changing to 0.5 for testnet amount limitations

sellPosition = input(defval=0.5, title='Sell % of Position at Target')
closeRemaining = 1 - sellPosition

targetQuantity = TradeSizeInUSD * sellPosition  // Use this for sell at target quantity
remQuantity = TradeSizeInUSD * closeRemaining  // Use this for sell remaining at stop or trailing stop


//Set Levels For Potential Setup // Need to create these for each structure condition. 3 bar or 5 bar fractals and Inside Bars. 

// 3 Bar Fractals
// if change(cp4) and cp4==1 and bull_ema_index == 3 and (structure == "3 Bar Fractal") 
//     bull_sl := valuewhen(upFractal, low[1], 0) - (1*syminfo.mintick)
//     bull_breakout_price := valuewhen(upFractal, high, 0) + (1*syminfo.mintick)
//     entry_buy   := high
//     entry_dist := bull_breakout_price - bull_sl
//     entry_be := bull_breakout_price + (entry_dist * be)
//     entry_tgt := bull_breakout_price + (entry_dist * rr)
//     tradeState := 1
//     TradeSizeInXBT := USDRiskPerTrade / entry_dist
//     TradeSizeInUSD := round(bull_breakout_price * TradeSizeInXBT) 

// if change(cp4) and cp4==1 and bear_ema_index == 3 and (structure == "3 Bar Fractal")
//     bear_sl := valuewhen(dnFractal, high[1], 0) + (1*syminfo.mintick)
//     bear_breakout_price := valuewhen(dnFractal, low, 0) - (1*syminfo.mintick)
//     entry_sell  := low
//     entry_dist := bear_sl - bear_breakout_price
//     entry_be := bear_breakout_price - (entry_dist * be)
//     entry_tgt := bear_breakout_price - (entry_dist * rr)
//     tradeState := 1
//     TradeSizeInXBT := USDRiskPerTrade / entry_dist
//     TradeSizeInUSD := round(bear_breakout_price * TradeSizeInXBT) 

if ta.change(cp4) and cp4 == 1 and bull_ema_index == 3 and structure == '3 Bar Fractal'
    bull_sl := low[2] - 1 * syminfo.mintick
    bull_breakout_price := high[1] + 1 * syminfo.mintick
    entry_buy := high[1]
    entry_dist := bull_breakout_price - bull_sl
    entry_be := bull_breakout_price + entry_dist * be
    entry_tgt := bull_breakout_price + entry_dist * rr
    tradeState := 1
    TradeSizeInXBT := USDRiskPerTrade / entry_dist
    TradeSizeInUSD := math.round(bull_breakout_price * TradeSizeInXBT)
    TradeSizeInUSD

if ta.change(cp4) and cp4 == 1 and bear_ema_index == 3 and structure == '3 Bar Fractal'
    bear_sl := high[2] + 1 * syminfo.mintick
    bear_breakout_price := low[1] - 1 * syminfo.mintick
    entry_sell := low[1]
    entry_dist := bear_sl - bear_breakout_price
    entry_be := bear_breakout_price - entry_dist * be
    entry_tgt := bear_breakout_price - entry_dist * rr
    tradeState := 1
    TradeSizeInXBT := USDRiskPerTrade / entry_dist
    TradeSizeInUSD := math.round(bear_breakout_price * TradeSizeInXBT)
    TradeSizeInUSD

// 5 Bar Fractals    
// if change(cp4) and cp4==1 and bull_ema_index == 3 and (structure == "5 Bar Fractal")
//     bull_sl := valuewhen(upFractal, low[2], 0) - (1*syminfo.mintick)
//     bull_breakout_price := valuewhen(upFractal, high, 0) + (1*syminfo.mintick)
//     entry_buy   := high
//     entry_dist := bull_breakout_price - bull_sl
//     entry_be := bull_breakout_price + (entry_dist * be)
//     entry_tgt := bull_breakout_price + (entry_dist * rr)
//     tradeState := 1
//     TradeSizeInXBT := USDRiskPerTrade / entry_dist
//     TradeSizeInUSD := round(bull_breakout_price * TradeSizeInXBT) 

// if change(cp4) and cp4==1 and bear_ema_index == 3 and (structure == "5 Bar Fractal")
//     bear_sl := valuewhen(dnFractal, high[2], 0) + (1*syminfo.mintick)
//     bear_breakout_price := valuewhen(dnFractal, low, 0) - (1*syminfo.mintick)
//     entry_sell  := low
//     entry_dist := bear_sl - bear_breakout_price
//     entry_be := bear_breakout_price - (entry_dist * be)
//     entry_tgt := bear_breakout_price - (entry_dist * rr)
//     tradeState := 1
//     TradeSizeInXBT := USDRiskPerTrade / entry_dist
//     TradeSizeInUSD := round(bear_breakout_price * TradeSizeInXBT) 

if ta.change(cp4) and cp4 == 1 and bull_ema_index == 3 and structure == '5 Bar Fractal'
    bull_sl := low[3] - 1 * syminfo.mintick
    bull_breakout_price := high[1] + 1 * syminfo.mintick
    entry_buy := high[1]
    entry_dist := bull_breakout_price - bull_sl
    entry_be := bull_breakout_price + entry_dist * be
    entry_tgt := bull_breakout_price + entry_dist * rr
    tradeState := 1
    TradeSizeInXBT := USDRiskPerTrade / entry_dist
    TradeSizeInUSD := math.round(bull_breakout_price * TradeSizeInXBT)
    TradeSizeInUSD

if ta.change(cp4) and cp4 == 1 and bear_ema_index == 3 and structure == '5 Bar Fractal'
    bear_sl := high[3] + 1 * syminfo.mintick
    bear_breakout_price := low[1] - 1 * syminfo.mintick
    entry_sell := low[1]
    entry_dist := bear_sl - bear_breakout_price
    entry_be := bear_breakout_price - entry_dist * be
    entry_tgt := bear_breakout_price - entry_dist * rr
    tradeState := 1
    TradeSizeInXBT := USDRiskPerTrade / entry_dist
    TradeSizeInUSD := math.round(bear_breakout_price * TradeSizeInXBT)
    TradeSizeInUSD

// Inside Bars  
// if change(cp4) and cp4==1 and bull_ema_index == 3 and (structure == "Inside Bars")
//     bull_sl := valuewhen(upInsideBar, low[1], 0) - (1*syminfo.mintick)
//     bull_breakout_price := valuewhen(upInsideBar, high, 0) + (1*syminfo.mintick)
//     entry_buy   := high
//     entry_dist := bull_breakout_price - bull_sl
//     entry_be := bull_breakout_price + (entry_dist * be)
//     entry_tgt := bull_breakout_price + (entry_dist * rr)
//     tradeState := 1
//     TradeSizeInXBT := USDRiskPerTrade / entry_dist
//     TradeSizeInUSD := round(bull_breakout_price * TradeSizeInXBT) 

// if change(cp4) and cp4==1 and bear_ema_index == 3 and (structure == "Inside Bars")
//     bear_sl := valuewhen(dnInsideBar, high[1], 0) + (1*syminfo.mintick)
//     bear_breakout_price := valuewhen(dnInsideBar, low, 0) - (1*syminfo.mintick)
//     entry_sell  := low
//     entry_dist := bear_sl - bear_breakout_price
//     entry_be := bear_breakout_price - (entry_dist * be)
//     entry_tgt := bear_breakout_price - (entry_dist * rr)
//     tradeState := 1
//     TradeSizeInXBT := USDRiskPerTrade / entry_dist
//     TradeSizeInUSD := round(bear_breakout_price * TradeSizeInXBT) 

if ta.change(cp4) and cp4 == 1 and bull_ema_index >= 2 and structure == 'Inside Bars'  // make >2 for emas 
    bull_sl := low[2] - 1 * syminfo.mintick
    bull_breakout_price := high[1] + 1 * syminfo.mintick
    entry_buy := high[1]
    entry_dist := bull_breakout_price - bull_sl
    entry_be := bull_breakout_price + entry_dist * be
    entry_tgt := bull_breakout_price + entry_dist * rr
    tradeState := 1
    TradeSizeInXBT := USDRiskPerTrade / entry_dist
    TradeSizeInUSD := math.round(bull_breakout_price * TradeSizeInXBT)
    TradeSizeInUSD

if ta.change(cp4) and cp4 == 1 and bear_ema_index >= 2 and structure == 'Inside Bars'
    bear_sl := high[2] + 1 * syminfo.mintick
    bear_breakout_price := low[1] - 1 * syminfo.mintick
    entry_sell := low[1]
    entry_dist := bear_sl - bear_breakout_price
    entry_be := bear_breakout_price - entry_dist * be
    entry_tgt := bear_breakout_price - entry_dist * rr
    tradeState := 1
    TradeSizeInXBT := USDRiskPerTrade / entry_dist
    TradeSizeInUSD := math.round(bear_breakout_price * TradeSizeInXBT)
    TradeSizeInUSD

if bull_ema_index == 3
    entry_fill := bull_breakout_price
    entry_fill
if bear_ema_index == 3
    entry_fill := bear_breakout_price
    entry_fill

//Stop tripped prior to breakout with tradeState==1 (waiting for breakout). 
if low < bull_sl and tradeState == 1
    bull_sl := na
    bull_breakout_price := na
    entry_buy := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    TradeSizeInUSD := 0
    TradeSizeInUSD

if high > bear_sl and tradeState == 1
    bear_sl := na
    bear_breakout_price := na
    entry_sell := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    TradeSizeInUSD := 0
    TradeSizeInUSD

//With CP4==1 and tradeState==0 and CP1 changing to 0 clean up variables. This is causing another bug. Maybe add a few candles back to test and check cp1[3] or something...
if ta.change(cp1) and cp1 == 0 and cp4 == 1 and bull_ema_index >= 2 and tradeState == 0
    bull_sl := na
    bull_breakout_price := na
    entry_buy := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    TradeSizeInUSD := 0
    TradeSizeInUSD

if ta.change(cp1) and cp1 == 0 and cp4 == 1 and bear_ema_index >= 2 and tradeState == 0
    bear_sl := na
    bear_breakout_price := na
    entry_sell := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    TradeSizeInUSD := 0
    TradeSizeInUSD

//Position Sizing Module Plots// Used for Autoview messages
// Plot 0
plot(TradeSizeInUSD, title='TradeSizeInUSD', transp=100)  // This will be the q=
// Plot 1
plot(USDRiskPerTrade, title="USDRiskPerTrade", transp=100) // Shows risk per trade/loss. Multiply by Risk/Reward for Win estimates
plot(targetQuantity, title='targetQuantity', transp=100)
// Plot 2
plot(rr, title="rr", transp=100)
plot(remQuantity, title='remQuantity', transp=100)


// Breakout Signal
if cp4 == 1 and high >= bull_breakout_price and bull_ema_index >= 2
    tradeState := 2
    cp5 := 1
    cp5

if cp4 == 1 and low <= bear_breakout_price and bear_ema_index >= 2
    tradeState := 3
    cp5 := 1
    cp5

// Alert Signals for Autoview // Similar to above issue modifed ema's to be >=2 vs ==3 
alertcondition(ta.change(cp5) and cp5 == 1 and bull_ema_index >= 2, title='Entry Buy', message='e=bitmex s=xbtusd b=long q={{plot("TradeSizeInUSD")}} l=1 t=market')
alertcondition(ta.change(cp5) and cp5 == 1 and bear_ema_index >= 2, title='Entry Sell', message='e=bitmex s=xbtusd b=short q={{plot("TradeSizeInUSD")}} l=1 t=market')

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checkpoint 6a - Stop to Breakeven & Active Trade Modules
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// Losing Trade Section. Trades will either be loss, be, partial, or mega
///////////////////////////////////////////////////////////////////////////

// Stop tripped up while in active trade (tradeState==2 or 3) // This is where trade logging would be added for counters
if low < bull_sl and tradeState == 2 and cp6 == 0 and not cp7 == 1  // and not longClosePartial[1] or longCloseMega[1])
    longCloseLoss := 1
    longCloseLoss
else
    longCloseLoss := 0
    longCloseLoss

if high > bear_sl and tradeState == 3 and cp6 == 0 and not cp7 == 1  // and not shortClosePartial==1 or shortCloseMega==1)
    shortCloseLoss := 1
    shortCloseLoss
else
    shortCloseLoss := 0
    shortCloseLoss

// Plots and Alerts for Long and Short Close From Stop Tripped
plotshape(ta.change(longCloseLoss) and longCloseLoss == 1 ? close : na, title='Long Close Loss', color=color.new(color.maroon, 0), textcolor=color.new(color.white, 0), style=shape.labeldown, location=location.abovebar, size=size.tiny, text='Long\nClose\nLoss', offset=0)
plotshape(ta.change(shortCloseLoss) and shortCloseLoss == 1 ? close : na, title='Short Close Loss', color=color.new(color.green, 0), textcolor=color.new(color.white, 0), style=shape.labelup, location=location.belowbar, size=size.tiny, text='Short\nClose\nLoss', offset=0)

alertcondition(ta.change(longCloseLoss) and longCloseLoss == 1, title='Long Close Loss', message='e=bitmex s=xbtusd c=position q={{plot("TradeSizeInUSD")}} t=market ro=1')
alertcondition(ta.change(shortCloseLoss) and shortCloseLoss == 1, title='Short Close Loss', message='e=bitmex s=xbtusd c=position q={{plot("TradeSizeInUSD")}} t=market ro=1')

// If a trade gets stopped will clean up levels etc on the next candle. Can evaluate removing the [1] syntax but want to ensure close signals are reliable first. 
if ta.change(longCloseLoss[1]) and longCloseLoss[1] == 1
    bull_sl := na
    bull_breakout_price := na
    entry_buy := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotLossCounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD

if ta.change(shortCloseLoss[1]) and shortCloseLoss[1] == 1
    bear_sl := na
    bear_breakout_price := na
    entry_sell := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotLossCounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD

///////////////////////////////////////////////////////////////////////////
// Move Stop to Breakeven cp6==1 & BE Trade Section
///////////////////////////////////////////////////////////////////////////

if high >= entry_be and cp5 == 1 and bull_ema_index == 3 and tradeState == 2
    bull_sl := entry_buy
    cp6 := 1
    cp6

if low <= entry_be and cp5 == 1 and bear_ema_index == 3 and tradeState == 3
    bear_sl := entry_sell
    cp6 := 1
    cp6

// Stop tripped up while in active trade (tradeState==2 or 3) and BE Active w/ target not yet hit. Entire position at scratch // Need to change this to crossover/under also added and cp6[1]==1
// if ((low < bull_sl) and tradeState==2 and cp6==1 and cp7==0 and not (longClosePartial[1] or longCloseMega[1] or tradeState[1]==1)) and longClosePartial==0
//     longCloseBE := 1
// else
//     longCloseBE := 0

// if ((high > bear_sl) and tradeState==3 and cp6==1 and cp7==0 and not (shortClosePartial[1] or shortCloseMega[1] or tradeState[1]==1)) and shortClosePartial==0
//     shortCloseBE := 1
// else
//     shortCloseBE := 0

if ta.crossunder(low, bull_sl) and tradeState == 2 and cp6 == 1 and cp7 == 0 and not(longClosePartial[1] or longCloseMega[1] or tradeState[1] == 1) and longClosePartial == 0 and cp6[1] == 1
    longCloseBE := 1
    longCloseBE
else
    longCloseBE := 0
    longCloseBE

if ta.crossover(high, bear_sl) and tradeState == 3 and cp6 == 1 and cp7 == 0 and not(shortClosePartial[1] or shortCloseMega[1] or tradeState[1] == 1) and shortClosePartial == 0 and cp6[1] == 1
    shortCloseBE := 1
    shortCloseBE
else
    shortCloseBE := 0
    shortCloseBE

// Plots and Alerts for Long and Short Close From Stop at Scratch
plotshape(ta.change(longCloseBE) and longCloseBE == 1 ? close : na, title='Long Close BE', color=color.new(color.maroon, 0), textcolor=color.new(color.white, 0), style=shape.labeldown, location=location.abovebar, size=size.tiny, text='Long\nClose\nBE', offset=0)
plotshape(ta.change(shortCloseBE) and shortCloseBE == 1 ? close : na, title='Short Close BE', color=color.new(color.green, 0), textcolor=color.new(color.white, 0), style=shape.labelup, location=location.belowbar, size=size.tiny, text='Short\nClose\nBE', offset=0)

alertcondition(ta.change(longCloseBE) and longCloseBE == 1, title='Long Close BE', message='e=bitmex s=xbtusd c=position q={{plot("TradeSizeInUSD")}} t=market ro=1')
alertcondition(ta.change(shortCloseBE) and shortCloseBE == 1, title='Short Close BE', message='e=bitmex s=xbtusd c=position q={{plot("TradeSizeInUSD")}} t=market ro=1')

// If a trade gets stopped at scratch will clean up levels etc on the next candle. Can evaluate removing the [1] syntax but want to ensure close signals are reliable first. 
if ta.change(longCloseBE[1]) and longCloseBE[1] == 1
    bull_sl := na
    bull_breakout_price := na
    entry_buy := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotBECounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD

if ta.change(shortCloseBE[1]) and shortCloseBE[1] == 1
    bear_sl := na
    bear_breakout_price := na
    entry_sell := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotBECounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD

///////////////////////////////////////////////////////////////////////////
// Winning Trade Section. Trades will either be loss, be, partial, or mega
///////////////////////////////////////////////////////////////////////////

// Sell Half w/ remaining at scratch and Trailing Stop active. 

// Target tripped up while in active trade (tradeState==2 or 3) // This is where trade logging would be added for counters
if high >= entry_tgt and tradeState == 2 and not longCloseLoss[1]
    longClosePartial := 1
    cp7 := 1
    cp7

if low <= entry_tgt and tradeState == 3 and not shortCloseLoss[1]
    shortClosePartial := 1
    cp7 := 1
    cp7
// else
//     shortClosePartial := 0 // Changing these to be Persistent

// Plots and Alerts for Long and Short Close From Target Reached
plotshape(ta.change(longClosePartial) and longClosePartial == 1 ? close : na, title='Long Sell Half', color=color.new(color.maroon, 0), textcolor=color.new(color.white, 0), style=shape.labeldown, location=location.abovebar, size=size.tiny, text='Long\nSell\nHalf', offset=0)
plotshape(ta.change(shortClosePartial) and shortClosePartial == 1 ? close : na, title='Short Sell Half', color=color.new(color.green, 0), textcolor=color.new(color.white, 0), style=shape.labelup, location=location.belowbar, size=size.tiny, text='Short\nSell\nHalf', offset=0)

alertcondition(ta.change(longClosePartial) and longClosePartial == 1, title='Long Sell Half', message='e=bitmex s=xbtusd c=position q={{plot("targetQuantity")}} t=market ro=1')
alertcondition(ta.change(shortClosePartial) and shortClosePartial == 1, title='Short Sell Half', message='e=bitmex s=xbtusd c=position q={{plot("targetQuantity")}} t=market ro=1')

// If a trade reaches target will not clean up levels etc on the next candle. Just add counter.  
if ta.change(longClosePartial[1]) and longClosePartial[1] == 1
    plotPartialCounter += 1
    plotPartialCounter

if ta.change(shortClosePartial[1]) and shortClosePartial[1] == 1
    plotPartialCounter += 1
    plotPartialCounter

///////////////////////////////////////////////////////////////////////////
// W/ CP7==1 and Stop at Scratch Tripped Up
///////////////////////////////////////////////////////////////////////////

// Initialise var for trailing stop checks

longTrail = 0.0
longTrail := nz(longTrail[1], na)
shortTrail = 0.0
shortTrail := nz(shortTrail[1], na)

// Stop tripped up while in active trade (tradeState==2 or 3) and BE Active w/ target hit. Partial position at scratch
if low < bull_sl and bull_sl >= longTrail and tradeState == 2 and cp7 == 1 and not cp7[1] == 0
    longCloseBERem := 1
    longCloseBERem

if high > bear_sl and bear_sl <= shortTrail and tradeState == 3 and cp7 == 1 and not cp7[1] == 0  // and not (shortClosePartial[1] or shortCloseMega[1] or shortCloseBERem[1])) // Commenting this out for testing and simplicity
    shortCloseBERem := 1
    shortCloseBERem

// Plots and Alerts for Long and Short Close From Stop at Scratch
plotshape(ta.change(longCloseBERem) and longCloseBERem == 1 ? close : na, title='Long Close BE Remaining', color=color.new(color.maroon, 0), textcolor=color.new(color.white, 0), style=shape.labeldown, location=location.abovebar, size=size.tiny, text='Long\nBE\nRemaining', offset=0)
plotshape(ta.change(shortCloseBERem) and shortCloseBERem == 1 ? close : na, title='Short Close BE Remaining', color=color.new(color.green, 0), textcolor=color.new(color.white, 0), style=shape.labelup, location=location.belowbar, size=size.tiny, text='Short\nBE\nRemaining', offset=0)

alertcondition(ta.change(longCloseBERem) and longCloseBERem == 1, title='Long Close BE Remaining', message='e=bitmex s=xbtusd c=position q={{plot("remQuantity")}} t=market ro=1')
alertcondition(ta.change(shortCloseBERem) and shortCloseBERem == 1, title='Short Close BE Remaining', message='e=bitmex s=xbtusd c=position q={{plot("remQuantity")}} t=market ro=1')

// If a trade gets stopped at scratch will clean up levels etc on the next candle. Can evaluate removing the [1] syntax but want to ensure close signals are reliable first. 
if ta.change(longCloseBERem[1]) and longCloseBERem[1] == 1
    bull_sl := na
    bull_breakout_price := na
    entry_buy := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotBERemCounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD

if ta.change(shortCloseBERem[1]) and shortCloseBERem[1] == 1
    bear_sl := na
    bear_breakout_price := na
    entry_sell := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotBERemCounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD


// O M G // SMALL KINE MIRACLE TO GET THIS FAR // GOD IS GOOD //

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checkpoint 6b - Trailing Stop Section
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This Trailing Stop Starts as soon as trade is Started
isTS = input(true, 'Trailing Stop')
ts = input.float(0.1, 'Trailing Stop (%)', minval=0, step=0.1) / 100

// Initialise and track highs and lows
short_ts = false
long_ts = false
last_high = 0.0
last_high := nz(last_high[1], na)
last_low = 0.0
last_low := nz(last_low[1], na)
last_high_short = 0.0
last_high_short := nz(last_high_short[1], na)
last_low_long = 0.0
last_low_long := nz(last_low_long[1], na)

// LONGS TSL
// For inside bar, start trailing when TP is touched
if cp1 == 1 and bull_ema_index >= 2 and cp7 == 1  // high >= entry_tgt
    last_high := na(last_high) or high > last_high ? high : last_high
    last_low_long := na(last_low_long) or low < last_low_long ? low : last_low_long
    long_ts := isTS and low <= last_high - last_high * ts
    long_ts
else
    long_ts := false
    last_high := na
    last_low_long := na
    last_low_long
//end if

//SHORTS TSL
if cp1 == 1 and bear_ema_index >= 2 and cp7 == 1  // low <= entry_tgt
    last_low := na(last_low) or low < last_low ? low : last_low
    last_high_short := na(last_high_short) or high > last_high_short ? high : last_high_short
    short_ts := isTS and high >= last_low + last_low * ts
    short_ts
else
    short_ts := false
    last_low := na
    last_high_short := na
    last_high_short
//end if

// Adding in some variables and logic to fix bug with BE Remaining firing after Mega Win on same candle. 
longTrail := isTS and bull_ema_index >= 2 and cp7 == 1 ? last_high - last_high * ts : na
shortTrail := isTS and bear_ema_index >= 2 and cp7 == 1 ? last_low + last_low * ts : na

///////////////////////////////////////////////////////////////////////////
// Mega Trade Section. Trades will either be loss, be, partial, or mega
///////////////////////////////////////////////////////////////////////////

// Trailing Stop Exit Condition
if cp7 == 1 and tradeState == 2 and long_ts == 1 and longCloseBERem == 0 and longClosePartial[1] == 1  // changing to cp7==1. Adding condition to ignore if stop at scratch on remaining hit on same candle. 
    longCloseMega := 1
    longCloseMega
else
    longCloseMega := 0
    longCloseMega

if cp7 == 1 and tradeState == 3 and short_ts == 1 and shortCloseBERem == 0 and shortClosePartial[1] == 1  // Added the partial part to exclude partial and mega on same candle. 
    shortCloseMega := 1
    shortCloseMega
else
    shortCloseMega := 0
    shortCloseMega

// Plots and Alerts for Long and Short Close From Trailing Stop Reached
plotshape(ta.change(longCloseMega) and longCloseMega == 1 ? close : na, title='Long Mega Win', color=color.new(color.maroon, 0), textcolor=color.new(color.white, 0), style=shape.labeldown, location=location.abovebar, size=size.tiny, text='Long\nMega\nWin', offset=0)
plotshape(ta.change(shortCloseMega) and shortCloseMega == 1 ? close : na, title='Short Mega Win', color=color.new(color.green, 0), textcolor=color.new(color.white, 0), style=shape.labelup, location=location.belowbar, size=size.tiny, text='Short\nMega\nWin', offset=0)

alertcondition(ta.change(longCloseMega) and longCloseMega == 1, title='Long Mega Win', message='e=bitmex s=xbtusd c=position q={{plot("remQuantity")}} t=market ro=1')
alertcondition(ta.change(shortCloseMega) and shortCloseMega == 1, title='Short Mega Win', message='e=bitmex s=xbtusd c=position q={{plot("remQuantity")}} t=market ro=1')

// If a trade reaches trailing stop target will clean up levels etc on the next candle. Can evaluate removing the [1] syntax but want to ensure close signals are reliable first. 
if ta.change(longCloseMega[1]) and longCloseMega[1] == 1
    bull_sl := na
    bull_breakout_price := na
    entry_buy := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotMegaCounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD

if ta.change(shortCloseMega[1]) and shortCloseMega[1] == 1
    bear_sl := na
    bear_breakout_price := na
    entry_sell := na
    entry_fill := na
    entry_dist := na
    entry_be := na
    entry_tgt := na
    cp2 := 0
    cp3 := 0
    cp4 := 0
    cp5 := 0
    cp6 := 0
    cp7 := 0
    cp8 := 0
    tradeState := 0
    plotMegaCounter += 1
    TradeSizeInUSD := 0
    TradeSizeInUSD


////////////////////////////////////////////////////////////////////////////////////////////////////
// Plot Section //
////////////////////////////////////////////////////////////////////////////////////////////////////

// Adding background color to easily see 
bgcolor(bull_ema_index == 2 ? color.green : na, transp=95)
bgcolor(bear_ema_index == 2 ? color.red : na, transp=95)

bgcolor(bull_ema_index == 3 ? color.green : na, transp=75)
bgcolor(bear_ema_index == 3 ? color.red : na, transp=75)

// -- debugs EMA (Checkpoint 1)
// plot(bull_ema_index, title='bull_ema_index', transp=100)
// plot(bear_ema_index, title='bear_ema_index', transp=100)    

// Fractal Plots
// Plot the fractals as shapes on the chart // Down Arrow above candles // Up Arrow below candles // Added [2] to tradeState to reflect 5 bar fractals. Need to code this better if using 3 bar fractals. 
plotshape(bull_ema_index == 3 and upFractal and structure == '5 Bar Fractal' and tradeState[2] == 0, 'Up Fractal', style=shape.triangleup, location=location.belowbar, size=size.tiny, offset=-2, color=color.new(color.green, 25))
plotshape(bear_ema_index == 3 and dnFractal and structure == '5 Bar Fractal' and tradeState[2] == 0, 'Down Fractal', style=shape.triangledown, location=location.abovebar, size=size.tiny, offset=-2, color=color.new(color.red, 25))

plotshape(bull_ema_index == 3 and upFractal and structure == '3 Bar Fractal' and tradeState[1] == 0, 'Up Fractal', style=shape.triangleup, location=location.belowbar, size=size.tiny, offset=-1, color=color.new(color.green, 25))
plotshape(bear_ema_index == 3 and dnFractal and structure == '3 Bar Fractal' and tradeState[1] == 0, 'Down Fractal', style=shape.triangledown, location=location.abovebar, size=size.tiny, offset=-1, color=color.new(color.red, 25))

// Inside Bar Plots
plotshape(bull_ema_index == 3 and upInsideBar and structure == 'Inside Bars' and tradeState[1] == 0, 'Up Inside Bar', style=shape.triangleup, location=location.belowbar, size=size.tiny, offset=-0, color=color.new(color.green, 25))
plotshape(bear_ema_index == 3 and dnInsideBar and structure == 'Inside Bars' and tradeState[1] == 0, 'Down Inside Bar', style=shape.triangledown, location=location.abovebar, size=size.tiny, offset=-0, color=color.new(color.red, 25))
// Alerts for Potential Inside Bar Setups
alertcondition(bull_ema_index == 3 and upInsideBar and structure == 'Inside Bars' and tradeState[1] == 0, "Potential Inside Bar Bullish Setup")
alertcondition(bear_ema_index == 3 and dnInsideBar and structure == 'Inside Bars' and tradeState[1] == 0, "Potential Inside Bar Bearish Setup")

// color candles
barcolor(colorcandles ? candlecolor : na)

plot(tradeState, title='tradeState', transp=100)

// Checkpoint Debugs
plot(cp1, title='cp1', transp=100)
plot(cp2, title='cp2', transp=100)
plot(cp3, title='cp3', transp=100)
plot(cp4, title='cp4', transp=100)
plot(cp5, title='cp5', transp=100)
plot(cp6, title='cp6', transp=100)
plot(cp7, title='cp7', transp=100)

// plotshape(bull_ema_index == 3 and cp1==1, "CP1 - bull_ema", shape.circle, location.top, color.green, text = "1", size = size.small)
// plotshape(bear_ema_index == 3 and cp1==1, "CP1 - bear_ema", shape.circle, location.top, color.red, text = "1", size = size.small)

// plotshape(bull_ema_index == 3 and cp2==1, "CP2 - Long Stoch RSI w/ Trend", shape.diamond, location.top, color.green, text = "2", size = size.tiny)
// plotshape(bear_ema_index == 3 and cp2==1, "CP2 - Short Stoch RSI w/ Trend", shape.diamond, location.top, color.red, text = "2", size = size.tiny)

// plotshape(upFractal==true and bull_ema_index == 3 and cp2==1, "CP3 - Bull Structure w/ Trend", shape.circle, location.bottom, color.green, text = "3", size = size.small)
// plotshape(dnFractal==true and bear_ema_index == 3 and cp2==1, "CP3 - Bear Structure w/ Trend", shape.circle, location.bottom, color.red, text = "3", size = size.small)

// -- debugs for levels, confirmation, and invalidation conditions
plot(bull_sl, 'bull_sl', color=color.new(color.red, 10), linewidth=2, style=plot.style_circles, join=false, editable=true)
plot(bear_sl, 'bear_sl', color=color.new(color.red, 10), linewidth=2, style=plot.style_circles, join=false, editable=true)

plot(bull_breakout_price, 'bull_breakout_price', color=color.new(color.yellow, 10), linewidth=2, style=plot.style_circles, join=false, editable=true)
plot(bear_breakout_price, 'bear_breakout_price', color=color.new(color.yellow, 10), linewidth=2, style=plot.style_circles, join=false, editable=true)

plot(entry_tgt, 'entry_tgt', color=color.new(color.green, 10), linewidth=2, style=plot.style_circles, join=false, editable=true)
plot(entry_be, 'entry_be', color=color.new(color.aqua, 10), linewidth=2, style=plot.style_circles, join=false, editable=true)

// Trailing Stop
plot(isTS and bull_ema_index >= 2 and cp7 == 1 ? last_high - last_high * ts : na, 'Long Trailing Stop', color.new(color.fuchsia, 0), style=plot.style_linebr, linewidth=2, offset=1)

plot(isTS and bear_ema_index >= 2 and cp7 == 1 ? last_low + last_low * ts : na, 'Short Trailing Stop', color.new(color.fuchsia, 0), style=plot.style_linebr, linewidth=2, offset=1)

plot(short_ts ? 1 : 0, title='short_ts', transp=100)
plot(long_ts ? 1 : 0, title='long_ts', transp=100)

plot(longTrail, title='longTrail', transp=100)
plot(shortTrail, title='shortTrail', transp=100)


// plot(longCloseBE, title='longCloseBE', transp=100)
// plot(shortCloseBE, title='shortCloseBE', transp=100)

// Adjusting this plot signal for ema's being >=2 vs ==3. For CP4 to fire it requires ==3 so this shouldn't affect signals. Key word is "shouldn't" haha
plotshape(ta.change(cp5) and cp5 == 1 and bull_ema_index >= 2 ? close : na, title='Long', color=color.new(color.yellow, 0), textcolor=color.new(color.green, 0), style=shape.triangleup, location=location.belowbar, size=size.tiny, text='LONG', offset=0)

plotshape(ta.change(cp5) and cp5 == 1 and bear_ema_index >= 2 ? close : na, title='Short', color=color.new(color.yellow, 0), textcolor=color.new(color.red, 0), style=shape.triangledown, location=location.abovebar, size=size.tiny, text='SHORT', offset=0)

////////////////////////////////////////////////////////////////////////////////////////////////////
// Win Loss Statistics //
////////////////////////////////////////////////////////////////////////////////////////////////////

StatisticsVerticalOffset = 3.14 * ta.atr(14)

if longCloseLoss[1] and not longCloseLoss[2] or shortCloseLoss[1] and not shortCloseLoss[2] or longClosePartial[1] and not longClosePartial[2] or shortClosePartial[1] and not shortClosePartial[2] or longCloseBE[1] and not longCloseBE[2] or shortCloseBE[1] and not shortCloseBE[2] or longCloseBERem[1] and not longCloseBERem[2] or shortCloseBERem[1] and not shortCloseBERem[2] or longCloseMega[1] and not longCloseMega[2] or shortCloseMega[1] and not shortCloseMega[2]
    l = label.new(bar_index, high + StatisticsVerticalOffset, style=label.style_none, text='Win : ' + str.tostring(plotPartialCounter) + '\nLoss : ' + str.tostring(plotLossCounter) + '\nBE : ' + str.tostring(plotBECounter) + '\nBE Rem : ' + str.tostring(plotBERemCounter) + '\nMega : ' + str.tostring(plotMegaCounter), color=color.white, textcolor=color.white)
    l

// plot(plotPartialCounter, title='plotPartialCounter', transp=100)
// plot(plotLossCounter, title='plotLossCounter', transp=100)
// plot(plotBECounter, title='plotBECounter', transp=100)
// plot(plotBERemCounter, title='plotBERemCounter', transp=100)
// plot(plotMegaCounter, title='plotMegaCounter', transp=100)

// plot(longCloseLoss, title='longCloseLoss', transp=100)
// plot(shortCloseLoss, title='shortCloseLoss', transp=100)
// plot(longClosePartial, title='longClosePartial', transp=100)
// plot(shortClosePartial, title='shortClosePartial', transp=100)
// plot(longCloseMega, title='longCloseMega', transp=100)
// plot(shortCloseMega, title='shortCloseMega', transp=100)
// plot(longCloseBE, title='longCloseBE', transp=100)
// plot(shortCloseBE, title='shortCloseBE', transp=100)
// plot(longCloseBERem, title='longCloseBERem', transp=100)
// plot(shortCloseBERem, title='shortCloseBERem', transp=100)

// plot(targetQuantity, title='targetQuantity', transp=100)
// plot(remQuantity, title='remQuantity', transp=100)


// END //

