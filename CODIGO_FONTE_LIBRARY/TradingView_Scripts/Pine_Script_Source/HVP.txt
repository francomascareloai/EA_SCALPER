//@version=
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//$                                                                                 $
//$ Благодарность приветствуется!                                                   $
//$ Gratitude is appreciated!                                                       $
//$                                                                                 $
//$ Вы можете сделать пожертвование через:                                          $
//$ You may donate via:                                                             $
//$                                                                                 $
//$ Крипто-мультивалютный кошелек                                                   $
//$ Crypto-multi-currency wallet                                                    $
//$                                                                                 $
//$ https://tinyurl.com/4f9dr9nw                                                    $
//$                                                                                 $
//$    - BTC: 1EpDN7pg1WqURcK7te5kQtgx3H17wuHiV7                                    $
//$                                                                                 $
//$    - LTC: MJyEtVt7EFmA18Bo1vjRMbguivHnVbbWvp                                    $
//$                                                                                 $
//$ Пожертвуйте столько, сколько считаете нужным.                                   $
//$ Donate as much as you see fit.                                                  $
//$                                                                                 $
//$ Сделайте это, если найдете этот материал полезным!                              $
//$ Do it if you find the stuff useful!                                             $
//$                                                                                 $
//$ Disclaimer: I am not a financial advisor.                                       $
//$ Отказ от ответственности: я не финансовый консультант.                          $
//$                                                                                 $
//$ For purpose educate only. Use at your own risk.                                 $
//$ Только в образовательных целях. Используйте на свой страх и риск.               $
//$                                                                                 $
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
indicator("<[Точки большого объема c Зона максимальной реакции]>", '<{BV MR Zones}>', overlay = true, max_polylines_count = 100, max_lines_count = 17, max_labels_count = 500, max_bars_back = 1000)

var high_i = int(na)
var high_v = float(na)
var low_i = int(na)
var low_v = float(na)

// ВХОДНЫЕ ДАННЫЕ
lookback = input(72, title="Период поиска максимума и минимума")
multiplier = input.float(1, "Ширина зон", step = 0.1, inline = "h/l")
high_col = input.color(color.orange, "", inline = "h/l")
low_col  = input.color(color.blue, "", inline = "h/l")

// ВЫЧИСЛЕНИЯ
highest = ta.highest(lookback)
lowest = ta.lowest(lookback)

atr = ta.atr(200) * multiplier

if high[1] == highest[1] and high < highest
    high_i := bar_index-1
    high_v := high[1]

if low[1] == lowest[1] and low > lowest
    low_i := bar_index-1
    low_v := low[1]

draw_zone(x, y, h_l, color)=>

    dist = h_l ? -atr : atr

    line.delete(line.new(x, y, bar_index, y, color = color, style = line.style_solid, width = 2)[1])
    line.delete(line.new(x+3, y+dist, bar_index, y+dist, color = color, style = line.style_dashed)[1])
    label.delete(label.new(bar_index, y, str.tostring(y, "#,###.####"), color = color(na), style = label.style_label_left, textcolor = color)[1])

// ОТРИСОВКА
if barstate.islast

    size = bar_index - (high_i > low_i ? low_i : high_i)

    draw_zone(high_i, high_v, true, high_col)
    draw_zone(low_i, low_v, false, low_col)
    mid = math.avg(high_v, low_v)
    mid_index = bar_index -  size/2

    line.delete(line.new(mid_index, mid, bar_index, mid, color = chart.fg_color, style = line.style_dashed)[1])
    label.delete(label.new(bar_index, mid, str.tostring(mid, "#,###.####"), color = color(na), style = label.style_label_left, textcolor = chart.fg_color)[1])

    for i = 0 to size
   
        index = bar_index-i-2

        if low[i+3] > low_v+atr and low[i+2] < low_v+atr and high[i+1] > low_v+atr and index > low_i
            label.new(index, low[i+2], "", style = label.style_label_up, color = low_col, size = size.tiny)

        if high[i+3] < high_v-atr and high[i+2] > high_v-atr and low[i+1] < high_v-atr and index > high_i
            label.new(index, high[i+2], "", style = label.style_label_down, color = high_col, size = size.tiny)

// ВХОДНЫЕ ДАННЫЕ

// Диаметр кругов
step = input.float(0.6, 'Диаметр кругов', step = 0.1, group = 'Настройки')

// Порог объема для фильтрации точек
filter_vol = input.float(2, 'Фильтр точек по объему', step = 0.1, group = 'Настройки', minval = 0, maxval = 6)

// Количество баров слева от пивота
int leftBars = input(15, "Длина")
int rightBars = leftBars

// Опция для отображения уровней
show_lvl = input.bool(true, 'Показывать уровни', group = 'Визуализация')

// Определение масштабирующих факторов
float xScale = 2.0
float yScale = 0.5 * ta.atr(500)

// Определение цветов
color upper_col = input.color(#fda05e, "", inline = "1")
color lower_col = input.color(#2fd68e, "", inline = "1")

// Динамическая ширина уровней
int width1 = 0
int width2 = 0

// Инициализация массивов для хранения точек и уровней
var points = array.new<chart.point>()
var levels = array.new<line>()

// ВЫЧИСЛЕНИЯ

// Вычисление пивота high и пивота low
ph = ta.pivothigh(leftBars, rightBars)
pl = ta.pivotlow(leftBars, rightBars)

volume_ = math.sum(volume, leftBars * 2)

// Вычисление нормализованного дельты объема
float vol = volume_

// Получение минимального и максимального объема в пределах периода
min_vol = ta.lowest(volume_, 300)
max_vol = ta.highest(volume_, 300)

// Нормализация объема между 0 и 6

reference_vol = ta.percentile_nearest_rank(volume_, 1000, 95)
norm_vol = volume_ / reference_vol * 5

check_cross(arrayOfLines) =>
    int qtyOfLines = array.size(arrayOfLines)

    for lineNo = 0 to qtyOfLines > 0 ? qtyOfLines - 1 : na by 1

        if lineNo < array.size(arrayOfLines)
            line currentLine = array.get(arrayOfLines, lineNo)
            float lineLevel = line.get_price(currentLine, bar_index)
            bool lineWasCrossed = math.sign(close[1] - lineLevel) != math.sign(close - lineLevel)

            if lineWasCrossed
                line.set_style(currentLine, line.style_dotted)
                array.remove(arrayOfLines, lineNo)
                int(na)
            else
                line.set_x2(currentLine, bar_index)
                int(na)

method draw_circle(bool src, int mult_x, int mult_y) =>
    points.clear()

    float angle = 0
    var float source = 0.
    var color color = na

    switch 
        src => 
    	    source := high[rightBars]
    	    color := upper_col
    	    color
        => 
    	    source := low[rightBars]
    	    color := lower_col
    	    color

    for i = 1 to 11 by 1
        int xValue = int(math.round(xScale * mult_x * math.sin(angle))) + bar_index - rightBars
        float yValue = yScale * mult_y * math.cos(angle) + source
        angle := angle + math.pi / 5

        points.push(chart.point.from_index(xValue, yValue))

    polyline.new(points, curved = false, line_color = color, fill_color = color.new(color, 90), line_width = 1)

// Отрисовка уровня.
method draw_level(float src, int n, width, color) =>
    line.new(x1 = n, y1 = src, x2 = n, y2 = src, style = line.style_solid, width = math.round(width / 3), color = color)

// ОТРИСОВКА

if last_bar_index - bar_index < 300

    // ————— Логика отрисовки для пивотов high
    for i = 0 to 10 by 1
        condition = not na(ph) and norm_vol > i and norm_vol > filter_vol

        if condition and barstate.isconfirmed
            true.draw_circle(math.round(i * step), math.round(i * step))

            width1 := width1 + 1
            width1

    if not na(ph) and norm_vol > filter_vol and barstate.isconfirmed
        int n = bar_index - rightBars
        float src = high[rightBars]
        chart.point cp = chart.point.from_index(n, src)

        levels.push(src.draw_level(n, width1, upper_col))

        label.new(cp, textcolor = chart.fg_color, color = color.new(upper_col, 30), style = label.style_circle, size = size.tiny)

        label.new(cp, text = str.tostring(vol, format.volume), textcolor = chart.fg_color, color = color(na), style = label.style_label_down)

    // ————— Логика отрисовки для пивотов low
    for i = 10 to 0 by 1
        condition = not na(pl) and norm_vol > i and norm_vol > filter_vol

        if condition and norm_vol > filter_vol and barstate.isconfirmed
            false.draw_circle(math.round(i * step), math.round(i * step))

            width2 := width2 + 1
            width2

    if not na(pl) and norm_vol > filter_vol and barstate.isconfirmed
        int n = bar_index - rightBars
        float src = low[rightBars]
        chart.point cp = chart.point.from_index(n, src)

        levels.push(src.draw_level(n, width2, lower_col))

        label.new(cp, textcolor = chart.fg_color, color = color.new(lower_col, 30), style = label.style_circle, size = size.tiny)

        label.new(cp, text = str.tostring(vol, format.volume), textcolor = chart.fg_color, color = color(na), style = label.style_label_up)

// Проверка и обновление пересечений
check_cross(levels)

// Очистка линий, если уровни не отображаются
a_allLines = line.all
if array.size(a_allLines) > 0 and not show_lvl
    for i = 0 to array.size(a_allLines) - 1 by 1
        line.delete(array.get(a_allLines, i))

// ======================================================================================================================================== //