// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Join our channel for more free tools: https://t.me/simpleforextools

//@version=6
indicator("Combined SCOB, FVG HTF, Liquidation Level Screener & Pure Price Action Liquidity Sweeps [UAlgo]", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=1)

// ====================== SCOB (Single Candle Order Block) ======================
// Пользовательские настройки SCOB
showSCOB = input.bool(true, title="Show Single Candle Order Block (SCOB)", group="Single Candle Order Block Settings")
mitigationStyle = input.string("Close", title="Mitigation Method", options=["Close", "Wick"], group="Single Candle Order Block Settings")
showLast = input.int(3, title="Show Last X Single Candle Order Blocks", group="Single Candle Order Block Settings", minval=1, maxval=15)
volatilityFilter = input.bool(false, title="Apply Volatility Filter", group="Single Candle Order Block Settings",
 tooltip="Enables filtering of Order Blocks based on volatility. When enabled, only Order Blocks with an Average True Range (ATR) above the mean value of the ATR")
bullishScobColor = input.color(color.new(#00FF00, 80), title="Bullish SCOB Color", group="Single Candle Order Block Style Settings", inline="color")
bearishScobColor = input.color(color.new(#BD10E0, 80), title="Bearish SCOB Color", group="Single Candle Order Block Style Settings", inline="color")

// Тип данных для SCOB
type scob
    float top
    float bottom
    int barStart
    box block
    bool broken

// Массивы для хранения SCOB
var array<scob> bullishScobArray = array.new<scob>()
var array<scob> bearishScobArray = array.new<scob>()

// Функция для проверки перекрытия SCOB
f_check_overlap(array<scob> scobArray, float top, float bottom) =>
    overlap = false
    if scobArray.size() > 1
        for i = 0 to array.size(scobArray) - 1
            scobElement = array.get(scobArray, i)
            if ((top < scobElement.top and top > scobElement.bottom) or (bottom > scobElement.bottom and bottom < scobElement.top))
                overlap := true
    overlap

// Логика обнаружения SCOB
detectBullishSCOB = open[2] > close[2] and close[1] > open[1] and close > open and low[1] < low[2] and close > high[1]
detectBearishSCOB = open[2] < close[2] and close[1] < open[1] and close < open and high[1] > high[2] and close < low[1]
atr = ta.atr(14)
atrFilter = ta.sma(atr, 200)

if detectBearishSCOB
    newScob = scob.new(top=high[1], bottom=low[1], barStart=time[1], block=na, broken=false)
    if not f_check_overlap(bearishScobArray, newScob.top, newScob.bottom)
        if volatilityFilter and atr > atrFilter
            array.push(bearishScobArray, newScob)
        if not volatilityFilter
            array.push(bearishScobArray, newScob)
    if bearishScobArray.size() > 20
        testScob = bearishScobArray.shift()
        box.delete(testScob.block)

if detectBullishSCOB
    newScob = scob.new(top=high[1], bottom=low[1], barStart=time[1], block=na, broken=false)
    if not f_check_overlap(bullishScobArray, newScob.top, newScob.bottom)
        if volatilityFilter and atr > atrFilter
            array.push(bullishScobArray, newScob)
        if not volatilityFilter
            array.push(bullishScobArray, newScob)
    if bullishScobArray.size() > 20
        testScob = bullishScobArray.shift()
        box.delete(testScob.block)

if showSCOB
    if bullishScobArray.size() > 0
        counter = 0
        for i = bullishScobArray.size() - 1 to 0
            bullishScob = bullishScobArray.get(i)
            if counter < showLast
                if na(bullishScob.block)
                    bullishScob.block := box.new(top=bullishScob.top, bottom=bullishScob.bottom, left=bullishScob.barStart, right=time, xloc=xloc.bar_time, bgcolor=bullishScobColor, border_color=bullishScobColor,
                     text="Bu-SCOB", text_color=color.new(color.white, 65), text_halign=text.align_right, text_size=size.tiny)
                if not na(bullishScob.block) and bullishScob.bottom > (mitigationStyle == "Close" ? close : low)
                    deletedScob = bullishScobArray.remove(i)
                    deletedScob.block.delete()
                    break
                counter := counter + 1
                bullishScob.block.set_right(time)
            else
                bullishScob.block.delete()
                bullishScob.block := na

    if bearishScobArray.size() > 0
        counter = 0
        for i = bearishScobArray.size() - 1 to 0
            bearishScob = bearishScobArray.get(i)
            if counter < showLast
                if na(bearishScob.block)
                    bearishScob.block := box.new(top=bearishScob.top, bottom=bearishScob.bottom, left=bearishScob.barStart, right=time, xloc=xloc.bar_time, bgcolor=bearishScobColor, border_color=bearishScobColor,
                     text="Be-SCOB", text_color=color.new(color.white, 65), text_halign=text.align_right, text_size=size.tiny)
                if not na(bearishScob.block) and bearishScob.top < (mitigationStyle == "Close" ? close : high)
                    deletedScob = bearishScobArray.remove(i)
                    deletedScob.block.delete()
                    break
                counter := counter + 1
                bearishScob.block.set_right(time)
            else
                bearishScob.block.delete()
                bearishScob.block := na

// ====================== FVG HTF (Fair Value Gap) ======================
// Пользовательские настройки FVG
htf_timeframe = input.timeframe("", "Таймфрейм старшего периода")
max_bars_back = input.int(300, "Максимальное количество баров для поиска FVG", minval=1)
box_length = input.int(20, "Длина прямоугольников (в барах)", minval=1)
bullColor = input.color(color.new(color.green, 80), "Цвет бычьего FVG")
bearColor = input.color(color.new(color.red, 80), "Цвет медвежьего FVG")
tick_buffer = input.int(1, "Буфер в тиках для проверки закрытия FVG", minval=1)

// Тип данных для FVG
type fvg_struct
    float max
    float min
    bool isBullish
    int t

// Функция для обнаружения FVG
fvg_detect(htf_high, htf_low, htf_close) =>
    fvg_struct new_fvg = na
    bool bull_fvg = htf_low > htf_high[2] and htf_close[1] > htf_high[2]
    bool bear_fvg = htf_high < htf_low[2] and htf_close[1] < htf_low[2]
    
    if bull_fvg
        new_fvg := fvg_struct.new(htf_high[2], htf_low, true, bar_index)
    else if bear_fvg
        new_fvg := fvg_struct.new(htf_high, htf_low[2], false, bar_index)
    new_fvg

// Получение данных старшего таймфрейма
htf_high = request.security(syminfo.tickerid, htf_timeframe, high)
htf_low = request.security(syminfo.tickerid, htf_timeframe, low)
htf_close = request.security(syminfo.tickerid, htf_timeframe, close)

// Обнаружение FVG
new_fvg = fvg_detect(htf_high, htf_low, htf_close)

// Массивы для хранения FVG
var htf_fvg_records = array.new<fvg_struct>(0)
var htf_fvg_boxes = array.new<box>(0)

// Добавление новых FVG
if not na(new_fvg)
    array.unshift(htf_fvg_records, new_fvg)
    fvg_box = box.new(left=bar_index, right=bar_index + box_length, top=new_fvg.max, bottom=new_fvg.min, bgcolor=new_fvg.isBullish ? bullColor : bearColor, border_width=1, border_color=new_fvg.isBullish ? color.green : color.red)
    array.unshift(htf_fvg_boxes, fvg_box)

// Удаление старых FVG
if array.size(htf_fvg_records) > 0
    delete_indices = array.new_int()
    for i = 0 to array.size(htf_fvg_records) - 1
        fvg = array.get(htf_fvg_records, i)
        is_filled = fvg.isBullish ? (close < (fvg.min - tick_buffer * syminfo.mintick)) : (close > (fvg.max + tick_buffer * syminfo.mintick))
        is_old = (bar_index - fvg.t) > max_bars_back
        if is_filled or is_old
            array.push(delete_indices, i)
    if array.size(delete_indices) > 0
        for j = array.size(delete_indices) - 1 to 0
            idx = array.get(delete_indices, j)
            if array.size(htf_fvg_boxes) > idx
                box.delete(array.get(htf_fvg_boxes, idx))
            array.remove(htf_fvg_records, idx)

// ====================== Liquidation Level Screener ======================
// Libraries
import gotbeatz26107/ma_/2 as ma

// Input
show_line = input(true, title="Show lines", group="Liquidation Level Screener")
show_hist = input(true, title="Show histogram", group="Liquidation Level Screener")

tip = 'In order for indicator to work, you need to keep at least one of the level groups on the chart'
showl1 = input(true, title="Show Liquidations Level 1", tooltip=tip, group="Liquidation Level Screener")
showl2 = input(true, title="Show Liquidations Level 2", tooltip=tip, group="Liquidation Level Screener")
showl3 = input(true, title="Show Liquidations Level 3", tooltip=tip, group="Liquidation Level Screener")
show_params = input(false, title="Show OI delta parameters", tooltip=tip, group="Liquidation Level Screener")

// Moving Average
ma_length = input(80, title="Length", group="Liquidation Level Screener")
averageType = input.string("VWMA", options=["SMA", "EMA", "ALMA", "AHMA", "BMF", "DEMA", "DSWF", "EVWMA", "ESD", "FRAMA", "FLSMA", "GMMA", "HCF", "HMA", "JMA", "KAMA", "KIJUN", "LSMA", "LMA", "MD", "MF", "MM", "SMMA", "SSMA", "SWMA", "TEMA", "TSF", "VAR", "VAMA", "VMA", "VBMA", "VIDA", "VWMA", "WMA", "QMA", "RPMA", "RSRMA", "ZLEMA"], title="Type", group="Liquidation Level Screener")

// Input Source
src = input(ohlc4, title="Source", group="Liquidation Level Screener")

// Histogram Settings
hist_amnt = input(30, "Number of histograms (density)", group="Liquidation Level Screener")
bars_amnt = input(1000, "Number of bars to lookback", group="Liquidation Level Screener")
dist_from_candle = input(5, "Histogram distance from last candle", group="Liquidation Level Screener")

// Liquidation levels
lines_amnt = input(1000, title="Number of lines to plot", group="Liquidation Level Screener")
h3 = input.float(3.4, step=0.1, title="Large Liquidation Level", group="Liquidation Level Screener")
h2 = input.float(2.2, step=0.1, title="Middle Liquidation Level", group="Liquidation Level Screener")
h1 = input.float(1.8, step=0.1, title="Small Liquidation Level", group="Liquidation Level Screener")

// Colors
color_5x = input.color(color.rgb(179, 181, 190, 70), "5x Leverage color", group="Liquidation Level Screener")
color_10x = input.color(color.rgb(0, 137, 123, 70), "10x Leverage color", group="Liquidation Level Screener")
color_25x = input.color(color.rgb(255, 235, 59, 70), "25x Leverage color", group="Liquidation Level Screener")
color_50x = input.color(color.rgb(255, 82, 82, 70), "50x Leverage color", group="Liquidation Level Screener")
color_100x = input.color(color.rgb(136, 14, 79, 70), "100x Leverage color", group="Liquidation Level Screener")

// OI data
currency = syminfo.basecurrency
xbt = currency == 'BTC' ? 'XBT' : string(currency)
delta = close - close[1]

[oid1, oic1, oio1, oih1, oil1] = request.security('BINANCE:' + string(currency) + 'USDT.P_OI', timeframe.period, [delta, close, open, high, low], ignore_invalid_symbol=true)
[oid2, oic2, oio2, oih2, oil2] = request.security('BINANCE:' + string(currency) + 'USD.P_OI', timeframe.period, [delta, close, open, high, low], ignore_invalid_symbol=true)
[oid3, oic3, oio3, oih3, oil3] = request.security('BINANCE:' + string(currency) + 'BUSD.P_OI', timeframe.period, [delta, close, open, high, low], ignore_invalid_symbol=true)
[oid4, oic4, oio4, oih4, oil4] = request.security('BITMEX:' + xbt + 'USD.P_OI', timeframe.period, [delta, close, open, high, low], ignore_invalid_symbol=true)
[oid5, oic5, oio5, oih5, oil5] = request.security('BITMEX:' + xbt + 'USDT.P_OI', timeframe.period, [delta, close, open, high, low], ignore_invalid_symbol=true)
[oid6, oic6, oio6, oih6, oil6] = request.security('KRAKEN:' + string(currency) + 'USD.P_OI', timeframe.period, [delta, close, open, high, low], ignore_invalid_symbol=true)

oid7 = request.security('BITFINEX:BTCUSDLONGS', timeframe.period, delta) + request.security('BITFINEX:BTCUSDSHORTS', timeframe.period, delta) + request.security('BITFINEX:BTCUSTLONGS', timeframe.period, delta) + request.security('BITFINEX:BTCUSTSHORTS', timeframe.period, delta)
oio7 = request.security('BITFINEX:BTCUSDLONGS', timeframe.period, open) + request.security('BITFINEX:BTCUSDSHORTS', timeframe.period, open) + request.security('BITFINEX:BTCUSTLONGS', timeframe.period, open) + request.security('BITFINEX:BTCUSTSHORTS', timeframe.period, open)
oic7 = request.security('BITFINEX:BTCUSDLONGS', timeframe.period, close) + request.security('BITFINEX:BTCUSDSHORTS', timeframe.period, close) + request.security('BITFINEX:BTCUSTLONGS', timeframe.period, close) + request.security('BITFINEX:BTCUSTSHORTS', timeframe.period, close)
oih7 = request.security('BITFINEX:BTCUSDLONGS', timeframe.period, high) + request.security('BITFINEX:BTCUSDSHORTS', timeframe.period, high) + request.security('BITFINEX:BTCUSTLONGS', timeframe.period, high) + request.security('BITFINEX:BTCUSTSHORTS', timeframe.period, high)
oil7 = request.security('BITFINEX:BTCUSDLONGS', timeframe.period, low) + request.security('BITFINEX:BTCUSDSHORTS', timeframe.period, low) + request.security('BITFINEX:BTCUSTLONGS', timeframe.period, low) + request.security('BITFINEX:BTCUSTSHORTS', timeframe.period, low)

// Calculation
OI_delta = currency == 'BTC' ? nz(oid1, 0) + nz(oid2, 0) / close + nz(oid3, 0) + nz(oid4, 0) / close + nz(oid5, 0) / close + nz(oid6, 0) / close + nz(oid7, 0) : nz(oid1, 0) + nz(oid2, 0) / close + nz(oid3, 0) + nz(oid4, 0) / close + nz(oid5, 0) / close + nz(oid6, 0) / close

OI_delta_abs = math.abs(OI_delta)
OI_delta_MA = ma.selector(OI_delta, ma_length, averageType)
OI_delta_abs_MA = ma.selector(OI_delta_abs, ma_length, averageType)

OI_delta_open_h3 = OI_delta_abs >= OI_delta_abs_MA * h3 and OI_delta > 0
OI_delta_open_h2 = OI_delta_abs >= OI_delta_abs_MA * h2 and OI_delta_abs < OI_delta_abs_MA * h3 and OI_delta > 0
OI_delta_open_h1 = OI_delta_abs >= OI_delta_abs_MA * h1 and OI_delta_abs < OI_delta_abs_MA * h2 and OI_delta > 0

// Level Calculations And Plotting
local_high = ta.highest(high, bars_amnt)
local_low = ta.lowest(low, bars_amnt)
range_high = local_high * (1 + local_high / local_low / 10)
range_low = local_low * (1 - local_high / local_low / 10)
range_height = range_high - range_low

hist_height = range_height / hist_amnt
hist_lower_list = array.new_float(hist_amnt, na)
hist_higher_list = array.new_float(hist_amnt, na)
hist_data = array.new_float()
hist_targets = array.new_float(hist_amnt, 0.0)

var h3_array = array.new_line()
var h2_array = array.new_line()
var h1_array = array.new_line()
var bars_array = array.new_box(hist_amnt, na)

// Clean up drawings every tick
for i = 0 to hist_amnt - 1 by 1
    box.delete(array.get(bars_array, i))

// Indicators functions
f_drawLine(x1, x2, y_value, line_color, style, width) =>
    line.new(x1, y_value, x2, y_value, color=line_color, style=style, width=width)

f_extendArray(line_array, extend_lines) =>
    if array.size(line_array) > 0
        for _i = array.size(line_array) - 1 to 0 by 1
            x2 = line.get_x2(array.get(line_array, _i))
            y_value = line.get_y1(array.get(line_array, _i))
            if extend_lines or bar_index - 1 == x2 - 1 and not (high > y_value and low < y_value)
                line.set_x2(array.get(line_array, _i), bar_index + 1)
                if bar_index == last_bar_index
                    array.push(hist_data, y_value)

calculate_leverage(pivot_value, leverage, short_sell) =>
    short_sell ? pivot_value * (1 - leverage) : pivot_value * (1 + leverage)

float y_value = na
int x1 = na
int x2 = na
line l = na

x1 := bar_index
x2 := bar_index

f_append(Array, l) =>
    if array.size(Array) == lines_amnt
        line.delete(array.shift(Array))
    array.push(Array, l)

if OI_delta_open_h3 and showl3
    y_value := calculate_leverage(src, 0.01, true)
    l := f_drawLine(x1, x2, y_value, color_100x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.01, false)
    l := f_drawLine(x1, x2, y_value, color_100x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.02, true)
    l := f_drawLine(x1, x2, y_value, color_50x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.02, false)
    l := f_drawLine(x1, x2, y_value, color_50x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.04, true)
    l := f_drawLine(x1, x2, y_value, color_25x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.04, false)
    l := f_drawLine(x1, x2, y_value, color_25x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.1, true)
    l := f_drawLine(x1, x2, y_value, color_10x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.1, false)
    l := f_drawLine(x1, x2, y_value, color_10x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.2, true)
    l := f_drawLine(x1, x2, y_value, color_5x, line.style_solid, 3)
    f_append(h3_array, l)

    y_value := calculate_leverage(src, 0.2, false)
    l := f_drawLine(x1, x2, y_value, color_5x, line.style_solid, 3)
    f_append(h3_array, l)

if OI_delta_open_h2 and not OI_delta_open_h3 and showl2
    y_value := calculate_leverage(src, 0.01, true)
    l := f_drawLine(x1, x2, y_value, color_100x, line.style_solid, 2)
    f_append(h2_array, l)

    y_value := calculate_leverage(src, 0.01, false)
    l := f_drawLine(x1, x2, y_value, color_100x, line.style_solid, 2)
    f_append(h2_array, l)

    y_value := calculate_leverage(src, 0.02, true)
    l := f_drawLine(x1, x2, y_value, color_50x, line.style_solid, 2)
    f_append(h2_array, l)

    y_value := calculate_leverage(src, 0.02, false)
    l := f_drawLine(x1, x2, y_value, color_50x, line.style_solid, 2)
    f_append(h2_array, l)

    y_value := calculate_leverage(src, 0.04, true)
    l := f_drawLine(x1, x2, y_value, color_25x, line.style_solid, 2)
    f_append(h2_array, l)

    y_value := calculate_leverage(src, 0.04, false)
    l := f_drawLine(x1, x2, y_value, color_25x, line.style_solid, 2)
    f_append(h2_array, l)

    y_value := calculate_leverage(src, 0.1, true)
    l := f_drawLine(x1, x2, y_value, color_10x, line.style_solid, 2)
    f_append(h2_array, l)

    y_value := calculate_leverage(src, 0.1, false)
    l := f_drawLine(x1, x2, y_value, color_10x, line.style_solid, 2)
    f_append(h2_array, l)

if OI_delta_open_h1 and not OI_delta_open_h2 and not OI_delta_open_h3 and showl1
    y_value := calculate_leverage(src, 0.01, true)
    l := f_drawLine(x1, x2, y_value, color_100x, line.style_dotted, 1)
    f_append(h1_array, l)

    y_value := calculate_leverage(src, 0.01, false)
    l := f_drawLine(x1, x2, y_value, color_100x, line.style_dotted, 1)
    f_append(h1_array, l)

    y_value := calculate_leverage(src, 0.02, true)
    l := f_drawLine(x1, x2, y_value, color_50x, line.style_dotted, 1)
    f_append(h1_array, l)

    y_value := calculate_leverage(src, 0.02, false)
    l := f_drawLine(x1, x2, y_value, color_50x, line.style_dotted, 1)
    f_append(h1_array, l)

    y_value := calculate_leverage(src, 0.04, true)
    l := f_drawLine(x1, x2, y_value, color_25x, line.style_dotted, 1)
    f_append(h1_array, l)

    y_value := calculate_leverage(src, 0.04, false)
    l := f_drawLine(x1, x2, y_value, color_25x, line.style_dotted, 1)
    f_append(h1_array, l)

f_extendArray(h3_array, false)
f_extendArray(h2_array, false)
f_extendArray(h1_array, false)

// Draw Histogram
if barstate.islast and show_hist
    // Define lows and highs of the histograms
    for i = 0 to hist_amnt - 1 by 1
        histogramLow = range_low + hist_height * i
        histogramHigh = range_low + hist_height * (i + 1)
        array.set(hist_lower_list, i, histogramLow)
        array.set(hist_higher_list, i, histogramHigh)

    // Only process hist_data if it has elements
    if array.size(hist_data) > 0
        for i = 0 to array.size(hist_data) - 1 by 1
            y = array.get(hist_data, i)

            for j = 0 to hist_amnt - 1 by 1
                histogramLow = array.get(hist_lower_list, j)
                histogramHigh = array.get(hist_higher_list, j)
                if y >= histogramLow and y <= histogramHigh
                    array.set(hist_targets, j, array.get(hist_targets, j) + 1)

        maxHistogramtarget = array.max(hist_targets)  // Get the max target value

        for i = 0 to hist_amnt - 1 by 1
            histogramLow = array.get(hist_lower_list, i)
            histogramHigh = array.get(hist_higher_list, i)
            histogramtarget = array.get(hist_targets, i)
            histogramWidth = math.floor((histogramtarget + 0.49) * 2)

            // Compute alpha based on the size of the histogram, max alpha is 100
            alpha = maxHistogramtarget > 0 ? 100 - math.floor(histogramtarget / maxHistogramtarget * 100) : 100

            // Define color based on comparison with close price
            barColor = histogramHigh > close ? color.new(color.red, alpha) : color.new(color.teal, alpha)

            // Draw histograms
            array.set(bars_array, i, box.new(left=bar_index + dist_from_candle, top=histogramHigh, right=bar_index + dist_from_candle + histogramWidth, bottom=histogramLow, bgcolor=barColor, border_color=barColor))

// Update Positions
if barstate.islast and not show_line
    for i = 0 to array.size(h3_array) - 1 by 1
        line.delete(array.get(h3_array, i))

    for i = 0 to array.size(h2_array) - 1 by 1
        line.delete(array.get(h2_array, i))

    for i = 0 to array.size(h1_array) - 1 by 1
        line.delete(array.get(h1_array, i))

// Parameters for settings
plot(show_params ? OI_delta_abs : na, color = color.red)
plot(show_params ? OI_delta_abs_MA * h3 : na, color = color.white)
plot(show_params ? OI_delta_abs_MA * h2 : na, color = color.yellow)
plot(show_params ? OI_delta_abs_MA * h1 : na, color = color.orange)

// ====================== Pure Price Action Liquidity Sweeps ======================
// Settings
term = input.string('Long Term', 'Detection', options = ['Short Term', 'Intermediate Term', 'Long Term'], display = display.all - display.status_line)

//Style
colBl = input.color(#089981, 'Bullish Level', inline = 'c1', group = 'Style')
colBlS = input.color(#08998180, 'Sweep', inline = 'c1', group = 'Style')

colBr = input.color(#f23645, 'Bearish Level', inline = 'c2', group = 'Style')
colBrS = input.color(#f2364580, 'Sweep', inline = 'c2', group = 'Style')

// User Defined Types
type piv
    float prc
    int bix
    bool mit
    bool wic
    line lin

type boxBr
    box bx
    int dr

type swing
    float y = na
    int x = na

type vector
    array<swing> v

// Variables
n = bar_index

depth = switch term
    'Short Term' => 1
    'Intermediate Term' => 2
    'Long Term' => 3

// Functions / Methods
method l(piv get, color c) =>
    line.new(get.bix, get.prc, n, get.prc, color = c, style = line.style_solid)

method br(piv get, color c, int d) =>
    y1 = d == 1 ? high : get.prc
    y2 = d == 1 ? get.prc : low
    boxBr.new(box.new(n - 1, y1, n + 1, y2, border_color = color(na), bgcolor = c), d)

method detect(array<vector> id, mode, depth) =>
    var swing swingLevel = swing.new(na, na)
    for i = 0 to depth - 1 by 1
        get_v = id.get(i).v

        if get_v.size() == 3
            pivot = switch mode
                'bull' => math.max(get_v.get(0).y, get_v.get(1).y, get_v.get(2).y)
                'bear' => math.min(get_v.get(0).y, get_v.get(1).y, get_v.get(2).y)

            if pivot == get_v.get(1).y
                if i < depth - 1
                    id.get(i + 1).v.unshift(get_v.get(1))

                    if id.get(i + 1).v.size() > 3
                        id.get(i + 1).v.pop()
                else
                    swingLevel := swing.new(get_v.get(1).y, get_v.get(1).x)
                    swingLevel

                get_v.pop()
                get_v.pop()
    swingLevel

// Calculations
var fh = array.new<vector>(0)
var fl = array.new<vector>(0)

//Detect swings
if barstate.isfirst
    for i = 0 to depth - 1 by 1
        fh.push(vector.new(array.new<swing>(0)))
        fl.push(vector.new(array.new<swing>(0)))

fh.get(0).v.unshift(swing.new(high, n))
fl.get(0).v.unshift(swing.new(low, n))

if fh.get(0).v.size() > 3
    fh.get(0).v

// ==========================================================================================

// === Dashboard with Telegram Link ===
var table myTable = table.new(position.top_center, 1, 1, border_width=1, frame_color=color.black, bgcolor=color.white)

// Add Telegram Message to Dashboard
table.cell(myTable, 0, 0, "Join Telegram @simpleforextools", bgcolor=color.blue, text_color=color.white, text_size=size.normal)