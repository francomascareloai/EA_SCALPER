//@version=5

indicator("Pieki Algo | Signals & Overlays [v.2.5]", "Pieki Algo"
  , overlay = true
  , max_labels_count = 500
  , max_lines_count = 500
  , max_boxes_count = 500
  , max_bars_back = 2500
  , max_polylines_count = 100)

// # ========================================================================= #
// #                |  Pieki Algo | Signals & Overlays [v.2.5]  |
// # ========================================================================= #

// # ============================[GET USERS INPUT]============================ #
// Colors
gr_col = "Colors"
bullish = input.color(#0068ca, "Bullish", tooltip = "Changes the color of the Bullish trend", inline = "1",group = gr_col)
bearish = input.color(#818181, "Bearish", tooltip = "Changes the color of the Bearish trend", inline = "1",group = gr_col)
// # ========================================================================= #

// Signals
gr_signals = "SIGNALS SETTINGS"
showsignal = input(true, "Show Signals", group = gr_signals, inline = "00")
sigsensiviti = input.float(3, "Sensivity", step = 0.1, group = gr_signals, inline = "01") 

// Features
gr_fts = "FEATURES"

// Indicator Overlays
gr_overlays = "INDICATOR OVERLAYS"
showcandle = input(true, "Coloring Candle", group = gr_overlays, inline = "11")
candleoption = input.string("Trend", "", options = ["Trend","RSI Gradient"],group = gr_overlays, inline = "11")
shoowtrendwave = input(true, "Wave Trend", group = gr_overlays, inline ="12")
wavelenght = input(20, "", inline = "1", tooltip = "Smoothed Moving Average (HMA), helps in the direction of the current trend.", group = gr_fts)

// Market Structure
gr_ms = "MARKET STRUCTURE"
show_swing_ms = input.string("All", "Swing", inline = "1", group = gr_ms, options = ["All", "CHoCH", "CHoCH+", "BOS", "None"])
show_internal_ms = input.string("All", "Internal", inline = "2", group = gr_ms, options = ["All", "CHoCH", "CHoCH+", "BOS", "None"])
internal_r_lookback = input.int(5, "", inline = "2", group = gr_ms, minval = 2)
swing_r_lookback = input.int(50, "", inline = "1", group = gr_ms, minval = 2)
ms_mode = input.string("Manual", "Market Structure Mode", inline = "a", group = gr_ms,options = ["Manual", "Dynamic"])
show_mtf_str = input.bool(false, "MTF Scanner", inline = "9", group = gr_ms)
show_eql = input.bool(false, "Show EQH/EQL", inline = "6", group = gr_ms)

// VOLUMETRIC ORDER BLOCKS
gr_ob = "VOLUMETRIC ORDER BLOCKS"
ob_show = input.bool(false, "Show Last", inline = "1", group = gr_ob)
ob_num = input.int(5, "", inline = "1", group = gr_ob,minval = 1, maxval = 10)
ob_metrics_show= input.bool(false, "Internal Buy/Sell Activity",group = gr_ob)
css_metric_up = input.color(color.new(#089981,  50), "", inline = "2", group = gr_ob)
css_metric_dn = input.color(color.new(#f23645 , 50), "", inline = "2", group = gr_ob)
ob_swings = input.bool(false, "Swing Order Blocks", inline = "a", group = gr_ob)
css_swing_up = input.color(color.new(color.gray  , 90), "", inline = "a", group = gr_ob)
css_swing_dn = input.color(color.new(color.silver, 90), "", inline = "a", group = gr_ob)
ob_filter = input.string("None", "Filtering", inline = "d", group = gr_ob, options = ["None", "BOS", "CHoCH", "CHoCH+"])
ob_mitigation = input.string("Absolute", "Mitigation", inline = "4", group = gr_ob, options = ["Absolute", "Middle"])
ob_pos = input.string("Precise", "Positioning", inline = "k", group = gr_ob,options = ["Full", "Middle", "Accurate", "Precise"])
use_grayscale = input.bool(false, "Grayscale", inline = "6", group = gr_ob)
use_show_metric = input.bool(false, "Show Metrics", inline = "7", group = gr_ob)
use_middle_line = input.bool(false, "Show Middle-Line", inline = "8", group = gr_ob)
use_overlap = input.bool(false, "Hide Overlap", inline = "9", group = gr_ob         , tooltip = "Hide overlapping order blocks")
use_overlap_method = input.string("Previous", "Overlap Method", inline = "Z", group = gr_ob, options = ["Recent", "Previous"])
ob_bull_css = input.color(color.new(#089981 ,  90), "", inline = "1", group = gr_ob)
ob_bear_css = input.color(color.new(#f23645 ,  90), "", inline = "1", group = gr_ob)

// Support & Resistance 
gr_sr = "SUPPORT & RESISTANCE"
showsr = input(false, title="Show Support & Resistance", group = gr_sr)
swing_length = input.int(defval=8, title="Sensitivity", group = gr_sr)
box_width = input.float(defval=4, title="Zone Width", group = gr_sr)
box_extend_option = input.string("Right", title="Extend Box", options=["Right", "Both"], group = gr_sr) 
res = input.timeframe(title='Time Frame', defval='', group= gr_sr)
s1 = request.security(syminfo.tickerid, res, showsr, gaps=barmerge.gaps_on)
demand_color = input.color(#089981, title = 'Support & Resistance Color', group = gr_sr ,inline = "1")
supply_color = input.color(#f23645, title = '', group = gr_sr, inline = "1")
sidewaysThreshold = input.int(title='ADX Sideways Threshold (10-30)', minval=2, defval=15)

// Dashboard
gr_dashboard = "DASHBOARD SETTINGS"
showDash  = input(true, "Dashboard", group = gr_dashboard)
dashLoc  = input.string('Bottom Right', 'Location', options = ['Top Right', 'Bottom Right', 'Bottom Left'], group = gr_dashboard)
textSize = input.string('Normal', 'Size', options = ['Tiny', 'Small', 'Normal'], group = gr_dashboard)

// Risk Management 
gr_risk = "RISK Management"
levels      = input.bool(false, "Show TP/SL Levels" , group = gr_risk , inline = "MMDB2")
lvlLines    = input.bool(false, "Show Lines ", inline="levels", group = gr_risk)
linesStyle  = input.string("SOLID", "", ["SOLID", "DASHED", "DOTTED"], inline="levels", group = gr_risk)
lvlDistance = input.int(1, "Distance", 1, inline="levels2", group = gr_risk)
lvlDecimals = input.int(2, "   Decimals", 1, 8, inline="levels2", group = gr_risk)
atrRisk     = input.int(1, "Risk % ", 1, group = gr_risk , inline="levels3")
atrLen      = input.int(14, "  ATR Length", 1, group = gr_risk , inline="levels3")
decimals  = lvlDecimals == 1 ? "#.#" : lvlDecimals == 2 ? "#.##" : lvlDecimals == 3 ? "#.###" : lvlDecimals == 4 ? "#.####" : lvlDecimals == 5 ? "#.#####" : lvlDecimals == 6 ? "#.######" : lvlDecimals == 7 ? "#.#######" : "#.########"


// # ========================================================================= #
//                                  SIGNALS
// # ========================================================================= #

// Signal Generation
supertrend(_close, factor, atrLen) =>
	atr = ta.atr(atrLen)
	upperBand = _close + factor * atr
	lowerBand = _close - factor * atr
	prevLowerBand = nz(lowerBand[1])
	prevUpperBand = nz(upperBand[1])
	lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
	upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
	int direction = na
	float superTrend = na
	prevSuperTrend = superTrend[1]
	if na(atr[1])
		direction := 1
	else if prevSuperTrend == prevUpperBand
		direction := close > upperBand ? -1 : 1
	else
		direction := close < lowerBand ? 1 : -1
	superTrend := direction == -1 ? lowerBand : upperBand
	[superTrend, direction] 
	
// SMA 
ocAvg       = math.avg(open, close)
sma4        = ta.sma(close, 8)
sma5        = ta.sma(close, 9)
sma9        = ta.sma(close, 13)
psar        = ta.sar(0.02, 0.02, 0.2)

//*in Easy Words Super Trend + SMA = Signals
[supertrend, direction] = supertrend(close, sigsensiviti*2, 11)

source = close, period = 150
bull = ta.crossover(close, supertrend) and close >= sma9
bear = ta.crossunder(close, supertrend) and close <= sma9
y1 = low - (ta.atr(30) * 2), y1B = low - ta.atr(30)
y2 = high + (ta.atr(30) * 2), y2B = high + ta.atr(30)

buy  =   bull and showsignal ? label.new(bar_index, y1, sma4 >= sma5 ? "▲ +" : "▲", xloc.bar_index, yloc.price, bullish, label.style_label_up, color.white, size.normal) : na
sell =   bear and showsignal ? label.new(bar_index, y2, sma4 <= sma5 ? "▼ +" : "▼", xloc.bar_index, yloc.price, bearish, label.style_label_down, color.white, size.normal) : na


// # ========================================================================= #
//                                INDICATOR OVERLAYS
// # ========================================================================= #

// # =============================[CANDLE COLORS]============================= #
// Data reference
[macd, signal, hist] = ta.macd(close, 12, 26, 9)

// Candle Colors
greenHigh = #05df09
greenMidHigh = #05df09
greenMidLow = #388E3C
greenLow = #5f3a97
yellowLow = #5f3a97
redHigh = #ea0402
redMidHigh = #ea0402
redMidLow = #cc0402
redLow = #5f3a97
candleBody = yellowLow

// Ranging trend
if hist > 0
    if hist > hist[1] and hist[1] > 0
        candleBody := greenLow
        
if hist < 0
    if hist < hist[1] and hist[1] < 0
        candleBody := redLow

// Bullish trend
if macd > 0 and hist > 0
    candleBody := greenMidLow
    
    if hist > hist[1] and macd[1] > 0 and hist[1] > 0
        candleBody := greenMidHigh
        
        if hist > hist[2] and macd[2] > 0 and hist[2] > 0
            candleBody := greenHigh

// Bearish trend
if macd < 0 and hist < 0
    candleBody := redMidLow
    
    if hist < hist[1] and macd[1] < 0 and hist[1] < 0
        candleBody := redMidHigh
        
        if hist < hist[2] and macd[2] < 0 and hist[2] < 0
            candleBody := redHigh

barcolor(candleoption == "Trend" and showcandle ? candleBody : na)
// # ========================================================================= #
srccandle = close
lencandle = 14
upcandle = ta.rma(math.max(ta.change(srccandle), 0), lencandle)
downcandle = ta.rma(-math.min(ta.change(srccandle), 0), lencandle)
rsi = downcandle == 0 ? 100 : upcandle == 0 ? 0 : 100 - 100 / (1 + upcandle / downcandle)

//Defining ranges by 10% increments
tier1 = rsi <= 20
tier2 = rsi > 20 and rsi <= 21
tier3 = rsi > 21 and rsi <= 22
tier4 = rsi > 22 and rsi <= 23
tier5 = rsi > 23 and rsi <= 24
tier6 = rsi > 24 and rsi <= 25
tier7 = rsi > 25 and rsi <= 26
tier8 = rsi > 26 and rsi <= 27
tier9 = rsi > 27 and rsi <= 28
tier10 = rsi > 28 and rsi <=29
tier11 = rsi > 29 and rsi <=30
tier12 = rsi > 30 and rsi <=31
tier13 = rsi > 31 and rsi <=32
tier14 = rsi > 32 and rsi <=33
tier15 = rsi > 33 and rsi <=34
tier16 = rsi > 34 and rsi <=35
tier17 = rsi > 35 and rsi <=36
tier18 = rsi > 36 and rsi <=37
tier19 = rsi > 37 and rsi <=38
tier20 = rsi > 38 and rsi <=39
tier21 = rsi > 39 and rsi <=40
tier22 = rsi > 40 and rsi <=41
tier23 = rsi > 41 and rsi <=42
tier24 = rsi > 42 and rsi <=43
tier25 = rsi > 43 and rsi <=44
tier26 = rsi > 44 and rsi <=45
tier27 = rsi > 45 and rsi <=46
tier28 = rsi > 46 and rsi <=47
tier29 = rsi > 47 and rsi <=48
tier30 = rsi > 48 and rsi <=49
tier31 = rsi > 49 and rsi <=50
tier32 = rsi > 50 and rsi <=51
tier33 = rsi > 51 and rsi <=52
tier34 = rsi > 52 and rsi <=53
tier35 = rsi > 53 and rsi <=54
tier36 = rsi > 54 and rsi <=55
tier37 = rsi > 55 and rsi <=56
tier38 = rsi > 56 and rsi <=57
tier39 = rsi > 57 and rsi <=58
tier40 = rsi > 58 and rsi <=59
tier41 = rsi > 59 and rsi <=60
tier42 = rsi > 60 and rsi <=61
tier43 = rsi > 61 and rsi <=62
tier44 = rsi > 62 and rsi <=63
tier45 = rsi > 63 and rsi <=64
tier46 = rsi > 64 and rsi <=65
tier47 = rsi > 65 and rsi <=66
tier48 = rsi > 66 and rsi <=67
tier49 = rsi > 67 and rsi <=68
tier50 = rsi > 68 and rsi <=69
tier51 = rsi > 69 and rsi <=70
tier52 = rsi > 70 and rsi <=71
tier53 = rsi > 71 and rsi <=72
tier54 = rsi > 72 and rsi <=73
tier55 = rsi > 73 and rsi <=74
tier56 = rsi > 74 and rsi <=75
tier57 = rsi > 75 and rsi <=76
tier58 = rsi > 76 and rsi <=77
tier59 = rsi > 77 and rsi <=78
tier60 = rsi > 78 and rsi <=79
tier61 = rsi > 79 and rsi <=80

//Assign color based on range
barcolor(candleoption == "RSI Gradient" ? tier1 ? #FF0000 : tier2 ? #FB0009 : tier3 ? #F2001A : tier4 ? #ED0023 : tier5 ? #E9002C : tier6 ? #E50035 : tier7 ? #E0003E : tier8 ? #DC0046 : tier9 ? #D7004F : tier10 ? #D30058 : tier11 ? #CE0061 : tier12 ? #CA006A : tier13 ? #C60072 : tier14 ? #C1007B : tier15 ? #BD0084 : tier16 ? #B8008D : tier17 ? #B40095 : tier18 ? #B0009E : tier19 ? #AB00A7 : tier20 ? #A700B0 : tier21 ? #A200B9 : tier22 ? #9E00C1 : tier23 ? #9900CA : tier24 ? #9500D3 : tier25 ? #9100DC : tier26 ? #8C00E5 : tier27 ? #8800ED : tier28 ? #8300F6 : tier29 ? #7F00FF : tier30 ? #7F00FF : tier31 ? #7B09F6 : tier32 ? #7612ED : tier33 ? #721AE5 : tier34 ? #6D23DC : tier35 ? #692CD3 : tier36 ? #6535CA : tier37 ? #603EC1 : tier38 ? #5C46B9 : tier39 ? #584FB0 : tier40 ? #5358A7 : tier41 ? #4F619E : tier42 ? #4A6A95 : tier43 ? #46728D : tier44 ? #427B84 : tier45 ? #3D847B : tier46 ? #398D72 : tier47 ? #35956A : tier48 ? #309E61 : tier48 ? #2CA758 : tier50 ? #27B04F : tier51 ? #23B946 : tier52 ? #1FC13E : tier53 ? #1ACA35 : tier54 ? #16D32C : tier55 ? #12DC23 : tier56 ? #0DE51A : tier57 ? #09ED12 : tier58 ? #04F609 : tier59 ? #00FF00 : na : na)

// # =============================[WAVE TREND]============================= #
// Get Compponents
wtlength = 20
wma  = ta.wma(close, wtlength)
wma1 = ta.wma(close, wtlength)
a = 3 * wma - 2 * wma1
a1 = ta.sma(close, wtlength)

// Functions
diff = a - a1
x = diff
len = 100
xMax = ta.highest(x, len)
xMin = ta.lowest(x, len)
range_ = xMax - xMin
y = x / range_
g = math.round(y*40)

// Plot
color1 = color.from_gradient(g, -2, 2, bearish, bullish)
tw1 = plot(shoowtrendwave ? a : na, 'HEMA', color1, 2, editable = false)
tw2 = plot(shoowtrendwave ? a1 : na, 'SMA', color1, 2, editable = false)
fill(tw1, tw2, color = color1)


// # ========================================================================= #
//                                Support & Resistance 
// # ========================================================================= #

history_of_demand_to_keep = 20
show_zigzag = false
show_price_action_labels = false
// Other initializations
avg_volume = ta.sma(volume, 20)
very_weak_multiplier = 0.5
weak_multiplier = 1
strong_multiplier = 1.5

// Rejection handling
var int[] demandRejections = array.new_int(history_of_demand_to_keep, 0)
var int[] supplyRejections = array.new_int(history_of_demand_to_keep, 0)
var int[] demandCreationBars = array.new_int(history_of_demand_to_keep, na)
var int[] supplyCreationBars = array.new_int(history_of_demand_to_keep, na)

var box[] current_demand_box = array.new_box(history_of_demand_to_keep, na)
var box[] current_supply_box = array.new_box(history_of_demand_to_keep, na)

f_check_demand_rejections() =>
    for i = 0 to history_of_demand_to_keep - 1
        if not na(array.get(demandCreationBars, i))
            if bar_index - array.get(demandCreationBars, i) > 15 and bar_index - array.get(demandCreationBars, i) % 15 == 0
                label.new(bar_index, high, "Checking demand rejection", color=color.red)
                dBox = array.get(current_demand_box, i)
                if (na(dBox))
                    continue
                withinBox = (high >= box.get_bottom(dBox) and high <= box.get_top(dBox)) or (close >= box.get_bottom(dBox) and close <= box.get_top(dBox))
                bearishCandlesCount = math.sum(close < open ? 1 : 0, 15)
                if withinBox and bearishCandlesCount >= 7
                    label.new(bar_index, low, "Bearish count > 7", color=color.blue)
                    array.set(demandRejections, i, array.get(demandRejections, i) + 1)

f_check_supply_rejections() =>
    for i = 0 to history_of_demand_to_keep - 1
        if not na(array.get(supplyCreationBars, i))
            if bar_index - array.get(supplyCreationBars, i) > 15 and bar_index - array.get(supplyCreationBars, i) % 15 == 0
                label.new(bar_index, low, "Checking supply rejection", color=color.red)
                sBox = array.get(current_supply_box, i)
                if (na(sBox))
                    continue
                withinBox = (low <= box.get_top(sBox) and low >= box.get_bottom(sBox)) or (close <= box.get_top(sBox) and close >= box.get_bottom(sBox))
                bullishCandlesCount = math.sum(close > open ? 1 : 0, 15)
                if withinBox and bullishCandlesCount >= 7
                    label.new(bar_index, high, "Bullish count > 7", color=color.blue)
                    array.set(supplyRejections, i, array.get(supplyRejections, i) + 1)

f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

f_sh_sl_labels(array, swing_type) =>
    var string label_text = na
    if swing_type == 1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HH'
        else
            label_text := 'LH'
        label.new(bar_index - swing_length, array.get(array,0), text = label_text, style=label.style_label_down, textcolor = color.white, color = color.new(color.white, 100), size = size.tiny)
    else if swing_type == -1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HL'
        else
            label_text := 'LL'
        label.new(bar_index - swing_length, array.get(array,0), text = label_text, style=label.style_label_up, textcolor = color.white, color = color.new(color.white, 100), size = size.tiny)

f_check_overlapping(new_poi, box_array, atr) =>
    atr_threshold = atr * 2
    okay_to_draw = true
    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2
        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold
        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw

f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atr) =>
    atr_buffer = atr * (box_width / 10)
    box_left = array.get(bn_array, 0)
    box_right = bar_index + 20
    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00
    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2
    okay_to_draw = f_check_overlapping(poi, box_array, atr)
    swing_volume = volume[swing_length]
    var string strength_text = ""
    
    highest_volume_last_20 = ta.highest(volume, 20)
    volume_percentage = math.round(swing_volume / highest_volume_last_20 * 100) 
    volume_percentage := math.min(volume_percentage, 100)  // Cap the volume percentage to 100

    var extend_option = extend.right
    if box_extend_option == "Right"
        extend_option := extend.right
    else if box_extend_option == "Both"
        extend_option := extend.both
    if box_type == 1 and okay_to_draw and s1
        box.delete( array.get(box_array, array.size(box_array) - 5) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = color.rgb(242,54,69,50), border_width=1,
             bgcolor = supply_color, extend = extend_option, text = strength_text, text_halign = text.align_right, text_valign = text.align_center, text_color = color.white, text_size = size.small, xloc = xloc.bar_index))
        box.delete( array.get(label_array, array.size(label_array) - 5) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.rgb(242,54,69,50), border_width=1, border_style=line.style_dotted,
             bgcolor = color.new(color.black,100), extend = extend_option,  text = '', text_halign = text.align_left, text_valign = text.align_center, text_color = color.white, text_size = size.small, xloc = xloc.bar_index))
    else if box_type == -1 and okay_to_draw and s1
        box.delete( array.get(box_array, array.size(box_array) - 5) )
        f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = color.rgb(0,188,212,50), border_width=1,
             bgcolor = demand_color, extend = extend_option,  text = strength_text, text_halign = text.align_right, text_valign = text.align_center, text_color = color.white, text_size = size.small, xloc = xloc.bar_index))
        box.delete( array.get(label_array, array.size(label_array) - 5) )
        f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.rgb(0,188,212,50), border_width=1, border_style=line.style_dotted,
             bgcolor = color.new(color.black,100), extend = extend_option,  text = '', text_halign = text.align_left, text_valign = text.align_center, text_color = color.white, text_size = size.small, xloc = xloc.bar_index))

f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>
    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            if close >= level_to_break
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))
    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            if close <= level_to_break
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

f_extend_box_endpoint(box_array) =>
    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), bar_index + 30) // Extend only 20 bars

atr567 = ta.atr(50)
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)
var swing_high_values = array.new_float(5,0.00)
var swing_low_values = array.new_float(5,0.00)
var swing_high_bns = array.new_int(5,0)
var swing_low_bns = array.new_int(5,0)
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)
var supply_bos = array.new_box(5, na)
var demand_bos = array.new_box(5, na)
if not na(swing_high)
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_high_values, 1)
    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atr567)
else if not na(swing_low)
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_low_values, -1)
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atr567)
f_sd_to_bos(current_supply_box, supply_bos, current_supply_poi, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_poi, -1)
f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

// Inside the main execution, after the box is drawn, check for rejections
if not na(swing_low)
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_low_values, -1)
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atr567)
    f_check_demand_rejections()

if not na(swing_high)
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_high_values, 1)
    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atr567)
    f_check_supply_rejections()


// # ========================================================================= #
//                                SMC
// # ========================================================================= #

lvl_daily = false, css_d = color.blue, s_d = '⎯⎯⎯' 
lvl_weekly = false, css_w = color.blue, s_w = '⎯⎯⎯' 
lvl_monthly = false, css_m = color.blue, s_m = '⎯⎯⎯'
lvl_yearly = false, css_y = color.blue, s_y = '⎯⎯⎯'  
t = color.t(ob_bull_css)
invcol = color.new(color.white, 100)
// # =============================[BOOLEAN SETUP]============================= #
s_BOS        = 0
s_CHoCH      = 1
i_BOS        = 2
i_CHoCH      = 3
i_pp_CHoCH   = 4
green_candle = 5
red_candle   = 6
s_CHoCHP     = 7
i_CHoCHP     = 8

boolean =
 array.from(
   false
 , false 
 , false 
 , false 
 , false 
 , false 
 , false 
 , false
 , false
 )
/// # =============================[UDT]============================= #
type bar
    float   o = open
    float   c = close
    float   h = high
    float   l = low
    float   v = volume
    int     n = bar_index
    int     t = time

type Zphl
    line   top
    line   bottom
    label  top_label
    label  bottom_label
    bool   stopcross
    bool   sbottomcross
    bool   itopcross
    bool   ibottomcross
    string txtup
    string txtdn
    float  topy
    float  bottomy
    float  topx
    float  bottomx
    float  tup
    float  tdn
    int    tupx
    int    tdnx
    float  itopy
    float  itopx
    float  ibottomy
    float  ibottomx
    float  uV
    float  dV

type FVG
    box [] box
    line[] ln
    bool   bull
    float  top
    float  btm
    int    left
    int    right

type ms
	float[] p
	int  [] n
    float[] l

type msDraw
	int    n
	float  p
	color  css
	string txt
	bool   bull

type obC 
    float[] top
    float[] btm
    int  [] left
    float[] avg
    float[] dV 
    float[] cV 
    int  [] wM 
    int  [] blVP 
    int  [] brVP 
    int  [] dir  
    float[] h
    float[] l
    int  [] n

type obD 
    box [] ob 
    box [] eOB
    box [] blB 
    box [] brB 
    line[] mL

type zone
    chart.point points
    float p
    int   c
    int   t

type hqlzone
    box   pbx
    box   ebx
    box   lbx
    label plb
    label elb
    label lbl

type ehl
    float pt
    int   t
    float pb
    int   b

type pattern
    string found = "None"
    bool isfound = false
    int   period = 0
    bool  bull   = false

type alerts
    bool chochswing     = false
    bool chochplusswing = false
    bool swingbos       = false
    bool chochplus      = false
    bool choch          = false
    bool bos            = false
    bool equal          = false
    bool ob             = false
    bool swingob        = false
    bool zone           = false
    bool fvg            = false
    bool obtouch        = false

// # =============================[GENERAL SETUP]============================= #
bar         b      = bar.new()
var pattern p      = pattern.new()

alerts      blalert = alerts.new()
alerts      bralert = alerts.new()

if p.isfound

    p.period += 1

if p.period == 50

    p.period  := 0
    p.found   := "None"
    p.isfound := false
    p.bull    := na

switch

    b.c > b.o => boolean.set(green_candle, true)
    b.c < b.o => boolean.set(red_candle  , true)

f_zscore(src, lookback) =>

    (src - ta.sma(src, lookback)) / ta.stdev(src, lookback)

var int iLen = internal_r_lookback
var int sLen = swing_r_lookback

vv = f_zscore(((close - close[iLen]) / close[iLen]) * 100,iLen)

if ms_mode == "Dynamic"

    switch

        vv >= 1.5 or vv <= -1.5 => iLen := 10
        vv >= 1.6 or vv <= -1.6 => iLen := 9
        vv >= 1.7 or vv <= -1.7 => iLen := 8
        vv >= 1.8 or vv <= -1.8 => iLen := 7
        vv >= 1.9 or vv <= -1.9 => iLen := 6
        vv >= 2.0 or vv <= -2.0 => iLen := 5
        =>                         iLen

var msline = array.new<line>(0)

iH = ta.pivothigh(high, iLen, iLen)
sH = ta.pivothigh(high, sLen, sLen)
iL = ta.pivotlow (low , iLen, iLen)
sL = ta.pivotlow (low , sLen, sLen)

// # =============================[ARRAYS]============================= #
hl  () => [high, low]

[pdh, pdl] = request.security(syminfo.tickerid , 'D'  , hl() , lookahead = barmerge.lookahead_on)
[pwh, pwl] = request.security(syminfo.tickerid , 'W'  , hl() , lookahead = barmerge.lookahead_on)
[pmh, pml] = request.security(syminfo.tickerid , 'M'  , hl() , lookahead = barmerge.lookahead_on)
[pyh, pyl] = request.security(syminfo.tickerid , '12M', hl() , lookahead = barmerge.lookahead_on)

lstyle(style) =>

    out = switch style

        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

mtfphl(h, l ,tf ,css, pdhl_style) =>

    var line hl = line.new(
       na
     , na
     , na
     , na
     , xloc      = xloc.bar_time
     , color     = css
     , style     = lstyle(pdhl_style)
     )

    var line ll   = line.new(
       na
     , na
     , na
     , na
     , xloc      = xloc.bar_time
     , color     = css
     , style     = lstyle(pdhl_style)
     )

    var label lbl = label.new(
       na
     , na
     , xloc      = xloc.bar_time
     , text      = str.format('P{0}L', tf)
     , color     = invcol
     , textcolor = css
     , size      = size.small
     , style     = label.style_label_left
     )

    var label hlb = label.new(
       na
     , na
     , xloc      = xloc.bar_time
     , text      = str.format('P{0}H', tf)
     , color     = invcol
     , textcolor = css
     , size      = size.small
     , style     = label.style_label_left
     )

    hy = ta.valuewhen(h != h[1] , h    , 1)
    hx = ta.valuewhen(h == high , time , 1)
    ly = ta.valuewhen(l != l[1] , l    , 1)
    lx = ta.valuewhen(l == low  , time , 1)

    if barstate.islast

        extension = time + (time - time[1]) * 50
    
        line.set_xy1(hl , hx        , hy)
        line.set_xy2(hl , extension , hy)
        label.set_xy(hlb, extension , hy)
        line.set_xy1(ll , lx        , ly)
        line.set_xy2(ll , extension , ly)
        label.set_xy(lbl, extension , ly)

if lvl_daily

    mtfphl(pdh   , pdl , 'D'  , css_d, s_d)

if lvl_weekly

    mtfphl(pwh   , pwl , 'W'  , css_w, s_w)

if lvl_monthly

    mtfphl(pmh   , pml,  'M'  , css_m, s_m)

if lvl_yearly

    mtfphl(pyh   , pyl , '12M', css_y, s_y)

// # =============================[MARKET STRUCTURE]============================= #
method darkcss(color css, float factor, bool bull) =>

    blue  = color.b(css) * (1 - factor)
    red   = color.r(css) * (1 - factor)
    green = color.g(css) * (1 - factor)

    color.rgb(red, green, blue, 0)

method f_line(msDraw d, size, style) =>

    var line  id  = na
    var label lbl = na

    id := line.new(
       d.n
     , d.p
     , b.n
     , d.p
     , color = d.css
     , width = 1
     , style = style
     )

    if msline.size() >= 250

        line.delete(msline.shift())

    msline.push(id)

    lbl := label.new(
       int(math.avg(d.n, b.n))
     , d.p
     , d.txt
     , color            = invcol
     , textcolor        = d.css
     , style            = d.bull ? label.style_label_down : label.style_label_up
     , size             = size
     , text_font_family = font.family_monospace
     )

structure(bool mtf) =>

	msDraw drw     = na

    bool isdrw     = false
    bool isdrwS   = false

    var color css  = na
    var color icss = na

	var int itrend = 0
    var int  trend = 0

    bool bull_ob   = false
    bool bear_ob   = false

    bool s_bull_ob = false
    bool s_bear_ob = false

    n = bar_index
	
	var ms up = ms.new(
		   array.new<float>()
		 , array.new< int >()
         , array.new<float>()
		 )

	var ms dn = ms.new(
		   array.new<float>()
		 , array.new< int >()
         , array.new<float>()
		 )

	var ms sup = ms.new(
		   array.new<float>()
		 , array.new< int >()
         , array.new<float>()
		 )

	var ms sdn = ms.new(
		   array.new<float>()
		 , array.new< int >()
         , array.new<float>()
		 )

    switch show_swing_ms

        "All"      =>  boolean.set(s_BOS , true ),  boolean.set(s_CHoCH, true ) , boolean.set(s_CHoCHP, true  )  
        "CHoCH"    =>  boolean.set(s_BOS , false),  boolean.set(s_CHoCH, true ) , boolean.set(s_CHoCHP, false )   
        "CHoCH+"   =>  boolean.set(s_BOS , false),  boolean.set(s_CHoCH, false) , boolean.set(s_CHoCHP, true  )  
        "BOS"      =>  boolean.set(s_BOS , true ),  boolean.set(s_CHoCH, false) , boolean.set(s_CHoCHP, false )  
        "None"     =>  boolean.set(s_BOS , false),  boolean.set(s_CHoCH, false) , boolean.set(s_CHoCHP, false )  
        => na

    switch show_internal_ms

        "All"      =>  boolean.set(i_BOS, true ),  boolean.set(i_CHoCH, true  ),  boolean.set(i_CHoCHP, true )
        "CHoCH"    =>  boolean.set(i_BOS, false),  boolean.set(i_CHoCH, true  ),  boolean.set(i_CHoCHP, false) 
        "CHoCH+"   =>  boolean.set(i_BOS, false),  boolean.set(i_CHoCH, false ),  boolean.set(i_CHoCHP, true ) 
        "BOS"      =>  boolean.set(i_BOS, true ),  boolean.set(i_CHoCH, false ),  boolean.set(i_CHoCHP, false) 
        "None"     =>  boolean.set(i_BOS, false),  boolean.set(i_CHoCH, false ),  boolean.set(i_CHoCHP, false) 
        => na
        
    switch
        iH =>

            up.p.unshift(b.h[iLen])
            up.l.unshift(b.h[iLen])
            up.n.unshift(n  [iLen])

        iL =>

            dn.p.unshift(b.l[iLen])
            dn.l.unshift(b.l[iLen])
            dn.n.unshift(n  [iLen])

        sL =>

            sdn.p.unshift(b.l[sLen])
            sdn.l.unshift(b.l[sLen])
            sdn.n.unshift(n  [sLen])

        sH =>

            sup.p.unshift(b.h[sLen])
            sup.l.unshift(b.h[sLen])
            sup.n.unshift(n  [sLen])

	// INTERNAL BULLISH STRUCTURE
	if up.p.size() > 0 and dn.l.size() > 1

		if ta.crossover(b.c, up.p.first())

			bool CHoCH = na
			string txt = na

			if itrend < 0

				CHoCH := true

			switch

				not CHoCH =>

					txt := "BOS"
					css := bullish

                    blalert.bos := true

					if boolean.get(i_BOS) and mtf == false and na(drw)

                        isdrw := true
						drw := msDraw.new(
							   up.n.first()
							 , up.p.first()
							 , bullish
							 , txt
							 , true
							 )	

				CHoCH => 

                    dn.l.first() > dn.l.get(1) ? blalert.chochplus : blalert.choch

					txt := dn.l.first() > dn.l.get(1) ? "CHoCH+" : "CHoCH"
					css := bullish.darkcss(0.25, true)

					if (dn.l.first() > dn.l.get(1) ? boolean.get(i_CHoCHP) : boolean.get(i_CHoCH)) and mtf == false and na(drw)

                        isdrw := true
						drw := msDraw.new(
							   up.n.first()
							 , up.p.first()
							 , bullish.darkcss(0.25, true)
							 , txt
							 , true
							 )				

			if mtf == false

				switch

					ob_filter == "None" 					    => bull_ob := true
					ob_filter == "BOS"    and txt == "BOS"      => bull_ob := true
					ob_filter == "CHoCH"  and txt == "CHoCH"    => bull_ob := true
					ob_filter == "CHoCH+" and txt == "CHoCH+"   => bull_ob := true

			itrend := 1
            up.n.clear()
            up.p.clear()

	// INTERNAL BEARISH STRUCTURE
	if dn.p.size() > 0 and up.l.size() > 1

		if ta.crossunder(b.c, dn.p.first())
            
			bool CHoCH = na
			string txt = na

			if itrend > 0

				CHoCH := true

			switch

				not CHoCH =>

                    bralert.bos := true

					txt := "BOS"
					css := bearish

					if boolean.get(i_BOS) and mtf == false and na(drw)

                        isdrw := true
						drw := msDraw.new(
							   dn.n.first()
							 , dn.p.first()
							 , bearish
							 , txt
							 , false
							 )	

				CHoCH => 

                    if up.l.first() < up.l.get(1)
                        bralert.chochplus := true
                    else 
                        bralert.choch := true

					txt := up.l.first() < up.l.get(1) ? "CHoCH+" : "CHoCH"
					css := bearish.darkcss(0.25, false)

					if (up.l.first() < up.l.get(1) ? boolean.get(i_CHoCHP) : boolean.get(i_CHoCH)) and mtf == false and na(drw)

                        isdrw := true
						drw := msDraw.new(
							   dn.n.first()
							 , dn.p.first()
							 , bearish.darkcss(0.25, false)
							 , txt
							 , false
							 )			

			if mtf == false

				switch

					ob_filter == "None" 					    => bear_ob := true
					ob_filter == "BOS"    and txt == "BOS"      => bear_ob := true
					ob_filter == "CHoCH"  and txt == "CHoCH"    => bear_ob := true
					ob_filter == "CHoCH+" and txt == "CHoCH+"   => bear_ob := true

			itrend := -1
            dn.n.clear()
            dn.p.clear()

	// SWING BULLISH STRUCTURE
	if sup.p.size() > 0 and sdn.l.size() > 1

		if ta.crossover(b.c, sup.p.first())

			bool CHoCH = na
			string txt = na

			if trend < 0

				CHoCH := true

			switch

				not CHoCH =>

                    blalert.swingbos := true

					txt := "BOS"
					icss := bullish

					if boolean.get(s_BOS) and mtf == false and na(drw)

                        isdrwS := true
						drw := msDraw.new(
							   sup.n.first()
							 , sup.p.first()
							 , bullish
							 , txt
							 , true
							 )	

				CHoCH => 

                    if sdn.l.first() > sdn.l.get(1)
                        blalert.chochplusswing := true
                    else 
                        blalert.chochswing := true

					txt := sdn.l.first() > sdn.l.get(1) ? "CHoCH+" : "CHoCH"
					icss := bullish.darkcss(0.25, true)

					if (sdn.l.first() > sdn.l.get(1) ? boolean.get(s_CHoCHP) : boolean.get(s_CHoCH)) and mtf == false and na(drw)

                        isdrwS := true
						drw := msDraw.new(
							   sup.n.first()
							 , sup.p.first()
							 , bullish.darkcss(0.25, true)
							 , txt
							 , true
							 )	

			if mtf == false

				switch
                
					ob_filter == "None" 					  => s_bull_ob := true
					ob_filter == "BOS"    and txt == "BOS"    => s_bull_ob := true
					ob_filter == "CHoCH"  and txt == "CHoCH"  => s_bull_ob := true
					ob_filter == "CHoCH+" and txt == "CHoCH+" => s_bull_ob := true

			trend := 1
            sup.n.clear()
            sup.p.clear()

	// SWING BEARISH STRUCTURE
	if sdn.p.size() > 0 and sup.l.size() > 1

		if ta.crossunder(b.c, sdn.p.first())

			bool CHoCH = na
			string txt = na

			if trend > 0

				CHoCH := true

			switch

				not CHoCH =>

                    bralert.swingbos := true

					txt := "BOS"
					icss := bearish

					if boolean.get(s_BOS) and mtf == false and na(drw)

                        isdrwS := true
						drw := msDraw.new(
							   sdn.n.first()
							 , sdn.p.first()
							 , bearish
							 , txt
							 , false
							 )	

				CHoCH => 

                    if sup.l.first() < sup.l.get(1)
                        bralert.chochplusswing := true
                    else
                        bralert.chochswing := true

					txt := sup.l.first() < sup.l.get(1) ? "CHoCH+" : "CHoCH"
					icss := bearish.darkcss(0.25, false)

					if (sup.l.first() < sup.l.get(1) ? boolean.get(s_CHoCHP) : boolean.get(s_CHoCH)) and mtf == false and na(drw)

                        isdrwS := true
						drw := msDraw.new(
							   sdn.n.first()
							 , sdn.p.first()
							 , bearish.darkcss(0.25, false)
							 , txt
							 , false
							 )		

			if mtf == false

				switch

					ob_filter == "None" 					   => s_bear_ob := true
					ob_filter == "BOS"     and txt == "BOS"    => s_bear_ob := true
					ob_filter == "CHoCH"   and txt == "CHoCH"  => s_bear_ob := true
					ob_filter == "CHoCH+"  and txt == "CHoCH+" => s_bear_ob := true

			trend := -1
            sdn.n.clear()
            sdn.p.clear()

    [css, bear_ob, bull_ob, itrend, drw, isdrw, s_bear_ob, s_bull_ob, trend, icss, isdrwS]


[css, bear_ob, bull_ob, itrend, drw, isdrw, s_bear_ob, s_bull_ob, trend, icss, isdrwS] = structure(false)

if isdrw
    f_line(drw, size.small, line.style_dashed)

if isdrwS
    f_line(drw, size.small, line.style_solid)

[_, _, _, itrend15, _, _, _, _, _, _, _] = request.security("", "15"    , structure(true))
[_, _, _, itrend1H, _, _, _, _, _, _, _] = request.security("", "60"    , structure(true))
[_, _, _, itrend4H, _, _, _, _, _, _, _] = request.security("", "240"   , structure(true))
[_, _, _, itrend1D, _, _, _, _, _, _, _] = request.security("", "1440"  , structure(true))

if show_mtf_str

    var tab = table.new(position = position.top_right, columns = 10, rows = 10, bgcolor = na, frame_color = color.rgb(54, 58, 69, 0), frame_width = 1, border_color = color.rgb(54, 58, 69, 100), border_width = 1)
    table.cell(tab, 0, 1, text = "15" , text_color = color.silver, text_halign = text.align_center, text_size = size.normal, bgcolor = chart.bg_color, text_font_family = font.family_monospace, width = 2)
    table.cell(tab, 0, 2, text = "1H"  , text_color = color.silver, text_halign = text.align_center, text_size = size.normal, bgcolor = chart.bg_color, text_font_family = font.family_monospace, width = 2)
    table.cell(tab, 0, 3, text = "4H"  , text_color = color.silver, text_halign = text.align_center, text_size = size.normal, bgcolor = chart.bg_color, text_font_family = font.family_monospace, width = 2)
    table.cell(tab, 0, 4, text = "1D"  , text_color = color.silver, text_halign = text.align_center, text_size = size.normal, bgcolor = chart.bg_color, text_font_family = font.family_monospace, width = 2)

    table.cell(tab, 1, 1, text = itrend15 == 1 ? "BULLISH" : itrend15 == -1 ? "BEARISH" : na  , text_halign = text.align_center, text_size = size.normal, text_color = itrend15 == 1 ? bullish.darkcss(-0.25, true) : itrend15 == -1 ? bearish.darkcss(0.25, false) : color.gray, bgcolor = chart.bg_color, text_font_family = font.family_monospace)
    table.cell(tab, 1, 2, text = itrend1H == 1 ? "BULLISH" : itrend1H == -1 ? "BEARISH" : na  , text_halign = text.align_center, text_size = size.normal, text_color = itrend1H == 1 ? bullish.darkcss(-0.25, true) : itrend1H == -1 ? bearish.darkcss(0.25, false) : color.gray, bgcolor = chart.bg_color, text_font_family = font.family_monospace)
    table.cell(tab, 1, 3, text = itrend4H == 1 ? "BULLISH" : itrend4H == -1 ? "BEARISH" : na  , text_halign = text.align_center, text_size = size.normal, text_color = itrend4H == 1 ? bullish.darkcss(-0.25, true) : itrend4H == -1 ? bearish.darkcss(0.25, false) : color.gray, bgcolor = chart.bg_color, text_font_family = font.family_monospace)
    table.cell(tab, 1, 4, text = itrend1D == 1 ? "BULLISH" : itrend1D == -1 ? "BEARISH" : na  , text_halign = text.align_center, text_size = size.normal, text_color = itrend1D == 1 ? bullish.darkcss(-0.25, true) : itrend1D == -1 ? bearish.darkcss(0.25, false) : color.gray, bgcolor = chart.bg_color, text_font_family = font.family_monospace)

    table.cell(tab, 0, 5, text = "Detected Pattern", text_halign = text.align_center, text_size = size.normal, text_color = color.silver, bgcolor = chart.bg_color, text_font_family = font.family_monospace)
    table.cell(tab, 0, 6, text = p.found, text_halign = text.align_center, text_size = size.normal, text_color = na(p.bull) ? color.white : p.bull ? bullish.darkcss(-0.25, true) : p.bull == false ? bearish.darkcss(0.25, false) : na, bgcolor = chart.bg_color, text_font_family = font.family_monospace)
    
    table.merge_cells(tab, 0, 5, 1, 5)
    table.merge_cells(tab, 0, 6, 1, 6)

show_acc_dist_zone              = input.bool        (false                            , ""                            , inline = "1", group = "Accumulation And Distribution")
zone_mode                       = input.string      ("Fast"                           , ""                            , inline = "1", group = "Accumulation And Distribution"   , tooltip = "[Fast] Find small zone pattern formation\n[Slow] Find bigger zone pattern formation" ,options = ["Slow", "Fast"])
acc_css                         = input.color       (color.new(#089981   , 60)      , ""                            , inline = "1", group = "Accumulation And Distribution")
dist_css                        = input.color       (color.new(#f23645   , 60)      , ""                            , inline = "1", group = "Accumulation And Distribution")

drawZone(int len) =>
    var zone[]  z = array.new<zone>()

    if iH

        z.unshift(
             zone.new(
                 chart.point.from_time(
                       time[len]
                     , high [len]
                     )
                     , high [len]
                     ,  1
                     , time[len]
                 )
             )
    if iL
        z.unshift(
             zone.new(
                 chart.point.from_time(
                       time[len]
                     , low [len]
                     )
                     , low [len]
                     , -1
                     , time[len]
                 )
             )
    if z.size() > 1
        if z.get(0).c == z.get(1).c
            z.clear()
    
    switch

        zone_mode == "Slow" =>

            if z.size() > 5

                if z.get(0).c == -1 and z.get(1).c == 1 and z.get(2).c == -1 and z.get(3).c == 1 and z.get(4).c == -1 and z.get(5).c == 1

                    if z.get(0).p > z.get(2).p and z.get(2).p > z.get(4).p

                        if z.get(1).p < z.get(3).p and z.get(3).p < z.get(5).p   

                            blalert.zone := true

                            box.new(top = z.get(5).p, bottom = z.get(4).p, left = z.get(5).t, right = z.get(0).t, bgcolor = acc_css, border_color = color.new(color.white, 100), xloc = xloc.bar_time)
                            slice = array.new<chart.point>()

                            for i = 0 to 5

                                slice.unshift(z.get(i).points)

                            polyline.new(slice, xloc = xloc.bar_time, line_color = color.new(acc_css, 0), line_width = 2)
                            p.found := "Accumulation Zone"
                            p.bull := true
                            p.isfound := true
                            p.period := 0
                            z.clear()

            if z.size() > 5

                if z.get(0).c == 1 and z.get(1).c == -1 and z.get(2).c == 1 and z.get(3).c == -1 and z.get(4).c == 1 and z.get(5).c == -1

                    if z.get(0).p < z.get(2).p and z.get(2).p < z.get(4).p

                        if z.get(1).p > z.get(3).p and z.get(3).p > z.get(5).p    

                            bralert.zone := true

                            box.new(top = z.get(5).p, bottom = z.get(4).p, left = z.get(5).t, right = z.get(0).t, bgcolor = dist_css, border_color = color.new(color.white, 100), xloc = xloc.bar_time)
                            slice = array.new<chart.point>()

                            for i = 0 to 5

                                slice.unshift(z.get(i).points)

                            polyline.new(slice, xloc = xloc.bar_time, line_color = color.new(dist_css, 0), line_width = 2)
                            p.found := "Distribution Zone"
                            p.bull := false
                            p.isfound := true
                            p.period := 0
                            z.clear()   

        zone_mode == "Fast" =>    

            if z.size() > 3

                if z.get(0).c == -1 and z.get(1).c == 1 and z.get(2).c == -1 and z.get(3).c == 1

                    if z.get(0).p > z.get(2).p

                        if z.get(1).p < z.get(3).p   

                            blalert.zone := true

                            box.new(top = z.get(3).p, bottom = z.get(2).p, left = z.get(3).t, right = z.get(0).t, bgcolor = acc_css, border_color = color.new(color.white, 100), xloc = xloc.bar_time)
                            slice = array.new<chart.point>()

                            for i = 0 to 3

                                slice.unshift(z.get(i).points)

                            polyline.new(slice, xloc = xloc.bar_time, line_color = color.new(acc_css, 0), line_width = 2)
                            p.found := "Accumulation Zone"
                            p.bull := true
                            p.isfound := true
                            p.period := 0
                            z.clear()

            if z.size() > 3

                if z.get(0).c == 1 and z.get(1).c == -1 and z.get(2).c == 1 and z.get(3).c == -1

                    if z.get(0).p < z.get(2).p

                        if z.get(1).p > z.get(3).p  

                            bralert.zone := true

                            box.new(top = z.get(2).p, bottom = z.get(3).p, left = z.get(3).t, right = z.get(0).t, bgcolor = dist_css, border_color = color.new(color.white, 100), xloc = xloc.bar_time)
                            slice = array.new<chart.point>()

                            for i = 0 to 3

                                slice.unshift(z.get(i).points)

                            polyline.new(slice, xloc = xloc.bar_time, line_color = color.new(dist_css, 0), line_width = 2)
                            p.found := "Distribution Zone"
                            p.bull := false
                            p.isfound := true
                            p.period := 0
                            z.clear()   

if show_acc_dist_zone

    drawZone(iLen)

// # =============================[ORDER BLOCKS]============================= #
method eB(box[] b, bool ext, color css, bool swing) =>
    b.unshift(
         box.new(
               na
             , na
             , na
             , na
             , xloc             = xloc.bar_time
             , text_font_family = font.family_monospace
             , extend           = ext ? extend.right : extend.none
             , border_color     = swing ? color.new(css, 0) : color.new(color.white,100)
             , bgcolor          = css
             , border_width     = 1
              )
             )

method eL(line[] l, bool ext, bool solid, color css) =>
    l.unshift(
         line.new(
               na
             , na
             , na
             , na
             , width  = 1
             , color  = css
             , xloc   = xloc.bar_time
             , extend = ext   ? extend.right     : extend.none
             , style  = solid ? line.style_solid : line.style_dashed
              )
             )

method drawVOB(bool cdn, bool bull, color css, int loc, bool swing) =>

    [cC, oO, hH, lL, vV] = request.security(
         syminfo.tickerid
         , ""

         ,   [

               close
             , open
             , high
             , low
             , volume

             ]

         , lookahead = barmerge.lookahead_off
                                           )
    var obC obj  = obC.new(
                   array.new<float>()
                 , array.new<float>()
                 , array.new< int >()
                 , array.new<float>()
                 , array.new<float>()
                 , array.new<float>()
                 , array.new< int >()
                 , array.new< int >()
                 , array.new< int >()
                 , array.new< int >()
                 , array.new<float>()
                 , array.new<float>()
                 , array.new< int >()
                 )

    var obD draw = obD.new(
                   array.new<box >()
                 , array.new<box >()
                 , array.new<box >()
                 , array.new<box >()
                 , array.new<line>()
                 )

    if barstate.isfirst

        for i = 0 to ob_num - 1

            draw.mL .eL(false, false, use_grayscale ? color.new(color.gray, 0) : color.new(css,0))
            draw.ob .eB(false, use_grayscale ? color.new(color.gray, 90) : css, swing)
            draw.blB.eB(false, css_metric_up                                  , swing)
            draw.brB.eB(false, css_metric_dn                                  , swing)
            draw.eOB.eB(true , use_grayscale ? color.new(color.gray, 90) : css, swing)

    float pos = ob_pos == "Full" 
         ? (bull ? high : low) 
         : ob_pos == "Middle" 
             ? ohlc4 
             : ob_pos == "Accurate" 
                 ? hl2 
                 : hl2

    if cdn

        obj.h.clear()
        obj.l.clear()
        obj.n.clear()

        for i = 1 to math.abs((loc - b.n)) - 1

            obj.h.push(hH[i])
            obj.l.push(lL[i])
            obj.n.push(b.t[i])

        // obj.h.reverse()
        // obj.l.reverse()

        int iU = obj.l.indexof(obj.l.min()) + 1
        int iD = obj.h.indexof(obj.h.max()) + 1

        obj.dir.unshift(
             bull 
                 ? (b.c[iU] > b.o[iU] ? 1 : -1) 
                 : (b.c[iD] > b.o[iD] ? 1 : -1)
             )

        obj.top.unshift(
             bull 
                 ? pos[iU] 
                 : obj.h.max()
             )

        obj.btm.unshift(
             bull 
                 ? obj.l.min() 
                 : pos[iD]
             )

        obj.left.unshift(
             bull 
                 ? obj.n.get(obj.l.indexof(obj.l.min())) 
                 : obj.n.get(obj.h.indexof(obj.h.max()))
             )

        obj.avg.unshift(
             math.avg(obj.top.first(), obj.btm.first())
             )

        obj.cV.unshift(
             bull 
                 ? b.v[iU] 
                 : b.v[iD]
             )

        if ob_pos == "Precise"

            switch bull
                true =>
                    if obj.avg.get(0) < (b.c[iU] < b.o[iU] ? b.c[iU] : b.o[iU]) and obj.top.get(0) > hlcc4[iU]
                        obj.top.set(0, obj.avg.get(0))
                        obj.avg.set(0, math.avg(obj.top.first(), obj.btm.first()))
                false =>
                    if obj.avg.get(0) > (b.c[iU] < b.o[iU] ? b.o[iD] : b.c[iD]) and obj.btm.get(0) < hlcc4[iD]
                        obj.btm.set(0, obj.avg.get(0))
                        obj.avg.set(0, math.avg(obj.top.first(), obj.btm.first()))

        obj.blVP.unshift ( 0 )
        obj.brVP.unshift ( 0 )
        obj.wM  .unshift ( 1 )

        if use_overlap

            int rmP = use_overlap_method == "Recent" ? 1 : 0

            if obj.avg.size() > 1

                if bull 

                     ? obj.btm.first() < obj.top.get(1) 
                     : obj.top.first() > obj.btm.get(1)
                    obj.wM   .remove(rmP)
                    obj.cV   .remove(rmP)
                    obj.dir  .remove(rmP)
                    obj.top  .remove(rmP)
                    obj.avg  .remove(rmP) 
                    obj.btm  .remove(rmP)
                    obj.left .remove(rmP)
                    obj.blVP .remove(rmP)
                    obj.brVP .remove(rmP)

    if barstate.isconfirmed

        for x = 0 to ob_num - 1

            tg = switch ob_mitigation
                "Middle"   => obj.avg
                "Absolute" => bull ? obj.btm : obj.top

            for [idx, pt] in tg

                if (bull ? cC < pt : cC > pt)
                    obj.wM   .remove(idx)
                    obj.cV   .remove(idx)
                    obj.dir  .remove(idx)
                    obj.top  .remove(idx)
                    obj.avg  .remove(idx) 
                    obj.btm  .remove(idx)
                    obj.left .remove(idx)
                    obj.blVP .remove(idx)
                    obj.brVP .remove(idx)
            
    if barstate.islast

        if obj.avg.size() > 0

            // Alert

            if bull 
                 ? ta.crossunder(low , obj.top.get(0)) 
                 : ta.crossover (high, obj.btm.get(0)) 
                switch bull 
                    true  => blalert.obtouch := true 
                    false => bralert.obtouch := true


            float tV = 0
            obj.dV.clear()
            seq = math.min(ob_num - 1, obj.avg.size() - 1)

            for j = 0 to seq

                tV += obj.cV.get(j)

                if j == seq

                    for y = 0 to seq

                        obj.dV.unshift(
                             math.floor(
                                 (obj.cV.get(y) / tV) * 100)
                         )

                obj.dV.reverse()

            for i = 0 to math.min(ob_num - 1, obj.avg.size() - 1)

                dmL   = draw.mL .get(i)
                dOB   = draw.ob .get(i)
                dblB  = draw.blB.get(i)
                dbrB  = draw.brB.get(i)
                deOB  = draw.eOB.get(i)

                dOB.set_lefttop     (obj.left .get(i)           , obj.top.get(i))
                deOB.set_lefttop    (b.t                        , obj.top.get(i))
                dOB.set_rightbottom (b.t                        , obj.btm.get(i))
                deOB.set_rightbottom(b.t + (b.t - b.t[1]) * 100 , obj.btm.get(i))

                if use_middle_line

                    dmL.set_xy1(obj.left.get(i), obj.avg.get(i))
                    dmL.set_xy2(b.t            , obj.avg.get(i))

                if ob_metrics_show

                    dblB.set_lefttop    (obj.left.get(i), obj.top.get(i))
                    dbrB.set_lefttop    (obj.left.get(i), obj.avg.get(i))
                    dblB.set_rightbottom(obj.left.get(i), obj.avg.get(i))
                    dbrB.set_rightbottom(obj.left.get(i), obj.btm.get(i))

                    rpBL = dblB.get_right()
                    rpBR = dbrB.get_right()
                    dbrB.set_right(rpBR + (b.t - b.t[1]) * obj.brVP.get(i))
                    dblB.set_right(rpBL + (b.t - b.t[1]) * obj.blVP.get(i))

                if use_show_metric

                    txt = switch

                        obj.cV.get(i) >= 1000000000 => str.tostring(math.round(obj.cV.get(i) / 1000000000,3)) + "B"
                        obj.cV.get(i) >= 1000000    => str.tostring(math.round(obj.cV.get(i) / 1000000,3))    + "M"
                        obj.cV.get(i) >= 1000       => str.tostring(math.round(obj.cV.get(i) / 1000,3))       + "K"
                        obj.cV.get(i) <  1000       => str.tostring(math.round(obj.cV.get(i)))

                    deOB.set_text(
                         str.tostring(
                         txt + " (" + str.tostring(obj.dV.get(i)) + "%)")
                         )

                    deOB.set_text_size  (size.auto)
                    deOB.set_text_halign(text.align_left)
                    deOB.set_text_color (use_grayscale ? color.silver : color.new(css, 0))

    if ob_metrics_show and barstate.isconfirmed

        if obj.wM.size() > 0
            
            for i = 0 to obj.avg.size() - 1

                switch obj.dir.get(i)

                    1  =>

                        switch obj.wM.get(i)

                            1 => obj.blVP.set(i, obj.blVP.get(i) + 1), obj.wM.set(i, 2)
                            2 => obj.blVP.set(i, obj.blVP.get(i) + 1), obj.wM.set(i, 3)
                            3 => obj.brVP.set(i, obj.brVP.get(i) + 1), obj.wM.set(i, 1)
                    -1 =>

                        switch obj.wM.get(i)

                            1 => obj.brVP.set(i, obj.brVP.get(i) + 1), obj.wM.set(i, 2)
                            2 => obj.brVP.set(i, obj.brVP.get(i) + 1), obj.wM.set(i, 3)
                            3 => obj.blVP.set(i, obj.blVP.get(i) + 1), obj.wM.set(i, 1)

var hN = array.new<int>(1, b.n)
var lN = array.new<int>(1, b.n)
var hS = array.new<int>(1, b.n)
var lS = array.new<int>(1, b.n)

if iH

    hN.pop()
    hN.unshift(int(b.n[iLen]))

if iL

    lN.pop()
    lN.unshift(int(b.n[iLen]))

if sH

    hS.pop()
    hS.unshift(int(b.n[sLen]))

if sL

    lS.pop()
    lS.unshift(int(b.n[sLen]))

if ob_show

    bull_ob.drawVOB(true , ob_bull_css, hN.first(), false)
    bear_ob.drawVOB(false, ob_bear_css, lN.first(), false)


if ob_swings

    s_bull_ob.drawVOB(true , css_swing_up, hS.first(), true)
    s_bear_ob.drawVOB(false, css_swing_dn, lS.first(), true)

if bull_ob
    blalert.ob := true

if bear_ob
    bralert.ob := true

if s_bull_ob
    blalert.swingob := true

if s_bear_ob
    blalert.swingob := true


// #==================================================== #
// [Bu-OB] [Be-OB] Order Blocks
// #==================================================== #

gr_orderblocks = "[Bu-OB] [Be-OB] Order Blocks"

zigzag_len = input.int(9, "ZigZag Length", group=gr_orderblocks)
show_zigzag2 = input.bool(true, "Show Zigzag2", group=gr_orderblocks)
fib_factor = input.float(0.33, "Fib Factor for breakout confirmation", 0, 1, 0.01, group=gr_orderblocks)

tooltip_text = "Some timeframes may not be displayed in current timeframe. Zigzag lines only shows in current timeframe."
time_frame= input.string("Chart", "Timeframe", ["Chart", "5m", "15m", "30m", "1h", "2h", "4h", "D"], tooltip=tooltip_text)

tf = switch time_frame
    "5m" => "5"
    "15m" => "15"
    "30m" => "30"
    "1h" => "60"
    "2h" => "120"
    "4h" => "240"
    "D" => "D"
    => timeframe.period

text_size = input.string(size.tiny, "Text Size", [size.tiny, size.small, size.normal, size.large, size.huge])

bu_ob_inline_color = "Bu-OB Colors"
be_ob_inline_color = "Be-OB Colors"
bu_bb_inline_color = "Bu-BB Colors"
be_bb_inline_color = "Be-BB Colors"

bu_ob_display_settings = "Bu-OB Display Settings"
bu_ob_color = input.color(color.new(color.green, 70), "Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_border_color = input.color(color.green, "Border Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)
bu_ob_text_color = input.color(color.green, "Text Color", group=bu_ob_display_settings, inline=bu_ob_inline_color)

be_ob_display_settings = "Be-OB Display Settings"
be_ob_color = input.color(color.new(color.red, 70), "Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_border_color = input.color(color.red, "Border Color", group=be_ob_display_settings, inline=be_ob_inline_color)
be_ob_text_color = input.color(color.red, "Text Color", group=be_ob_display_settings, inline=be_ob_inline_color)

bu_bb_display_settings = "Bu-BB & Bu-MB Display Settings"
bu_bb_color = input.color(color.new(color.green, 70), "Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_border_color = input.color(color.green, "Border Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)
bu_bb_text_color = input.color(color.green, "Text Color", group=bu_bb_display_settings, inline=bu_bb_inline_color)

be_bb_display_settings = "Be-BB & Be-MB Display Settings"
be_bb_color = input.color(color.new(color.red, 70), "Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_border_color = input.color(color.red, "Border Color", group=be_bb_display_settings, inline=be_bb_inline_color)
be_bb_text_color = input.color(color.red, "Text Color", group=be_bb_display_settings, inline=be_bb_inline_color)

var float[] high_points_arr = array.new_float(5)
var int[] high_index_arr = array.new_int(5)
var float[] low_points_arr = array.new_float(5)
var int[] low_index_arr = array.new_int(5)

var box[] bu_ob_boxes = array.new_box(5)
var box[] be_ob_boxes = array.new_box(5)
var box[] bu_bb_boxes = array.new_box(5)
var box[] be_bb_boxes = array.new_box(5)

f_get_high(ind) =>
    [array.get(high_points_arr, array.size(high_points_arr) - 1 - ind), array.get(high_index_arr, array.size(high_index_arr) - 1 - ind)]

f_get_low(ind) =>
    [array.get(low_points_arr, array.size(low_points_arr) - 1 - ind), array.get(low_index_arr, array.size(low_index_arr) - 1 - ind)]

f_main1() =>
    to_up = high >= ta.highest(zigzag_len)
    to_down = low <= ta.lowest(zigzag_len)
    
    trend = 1
    trend := nz(trend[1], 1)
    trend := trend == 1 and to_down ? -1 : trend == -1 and to_up ? 1 : trend
    
    last_trend_up_since = ta.barssince(to_up[1])
    low_val = ta.lowest(nz(last_trend_up_since > 0 ? last_trend_up_since : 1, 1))
    low_index = bar_index - ta.barssince(low_val == low)
    
    last_trend_down_since = ta.barssince(to_down[1])
    high_val = ta.highest(nz(last_trend_down_since > 0 ? last_trend_down_since : 1, 1))
    high_index = bar_index - ta.barssince(high_val == high)
    
    if ta.change(trend) != 0
        if trend == 1
            array.push(low_points_arr, low_val)
            array.push(low_index_arr, low_index)
        if trend == -1
            array.push(high_points_arr, high_val)
            array.push(high_index_arr, high_index)
    
    [h0, h0i] = f_get_high(0)
    [h1, h1i] = f_get_high(1)
    
    [l0, l0i] = f_get_low(0)
    [l1, l1i] = f_get_low(1)
    
    market = 1
    market := nz(market[1], 1)
    last_l0 = ta.valuewhen(ta.change(market) != 0, l0, 0)
    last_h0 = ta.valuewhen(ta.change(market) != 0, h0, 0)
    market := last_l0 == l0 or last_h0 == h0 ? market : market == 1 and l0 < l1 and l0 < l1 - math.abs(h0 - l1) * fib_factor ? -1 : market == -1 and h0 > h1 and h0 > h1 + math.abs(h1 - l0) * fib_factor ? 1 : market
    
    // For alert
    alert_market = 1
    alert_market := nz(alert_market[1], 1)
    alert_market := last_l0 == l0 or last_h0 == h0 ? alert_market : alert_market == 1 and trend == -1 and close < l0 and close < l0 - math.abs(h0 - l0) * fib_factor ? -1 : alert_market == -1 and trend == 1 and close > h0 and close > h0 + math.abs(h0 - l0) * fib_factor ? 1 : alert_market
    
    bu_ob_index = bar_index
    bu_ob_index := nz(bu_ob_index[1], bar_index)
    for i=h1i to l0i[zigzag_len]
        index = bar_index - i 
        if open[index] > close[index]
            bu_ob_index := bar_index[index]
    
    bu_ob_since = bar_index - bu_ob_index
    
    be_ob_index = bar_index
    be_ob_index := nz(be_ob_index[1], bar_index)
    for i=l1i to h0i[zigzag_len]
        index = bar_index - i 
        if open[index] < close[index]
            be_ob_index := bar_index[index]
    
    be_ob_since = bar_index - be_ob_index
    
    be_bb_index = bar_index
    be_bb_index := nz(be_bb_index[1], bar_index)
    for i=h1i - zigzag_len to l1i
        index = bar_index - i
        if open[index] > close[index]
            be_bb_index := bar_index[index]
    
    be_bb_since = bar_index - be_bb_index
    
    bu_bb_index = bar_index
    bu_bb_index := nz(bu_bb_index[1], bar_index)
    for i=l1i - zigzag_len to h1i
        index = bar_index - i
        if open[index] < close[index]
            bu_bb_index := bar_index[index]
    
    bu_bb_since = bar_index - bu_bb_index
        
    bu_ob_since_high = high[bu_ob_since]
    bu_ob_since_low = low[bu_ob_since]
    be_ob_since_high = high[be_ob_since]
    be_ob_since_low = low[be_ob_since]
    be_bb_since_high = high[be_bb_since]
    be_bb_since_low = low[be_bb_since]
    bu_bb_since_high = high[bu_bb_since]
    bu_bb_since_low = low[bu_bb_since]
    
    [trend, h0i, h0, l0i, l0, market, h1i, h1, l1i, l1, bu_ob_since_high, bu_ob_since_low, be_ob_since_high, be_ob_since_low]
    
f_main2() =>
    to_up = high >= ta.highest(zigzag_len)
    to_down = low <= ta.lowest(zigzag_len)
    
    trendms = 1
    trendms := nz(trendms[1], 1)
    trendms := trendms == 1 and to_down ? -1 : trendms == -1 and to_up ? 1 : trendms
    
    last_trendms_up_since = ta.barssince(to_up[1])
    low_val = ta.lowest(nz(last_trendms_up_since > 0 ? last_trendms_up_since : 1, 1))
    low_index = bar_index - ta.barssince(low_val == low)
    
    last_trendms_down_since = ta.barssince(to_down[1])
    high_val = ta.highest(nz(last_trendms_down_since > 0 ? last_trendms_down_since : 1, 1))
    high_index = bar_index - ta.barssince(high_val == high)
    
    if ta.change(trendms) != 0
        if trendms == 1
            array.push(low_points_arr, low_val)
            array.push(low_index_arr, low_index)
        if trendms == -1
            array.push(high_points_arr, high_val)
            array.push(high_index_arr, high_index)
    
    [h0, h0i] = f_get_high(0)
    [h1, h1i] = f_get_high(1)
    
    [l0, l0i] = f_get_low(0)
    [l1, l1i] = f_get_low(1)
    
    market = 1
    market := nz(market[1], 1)
    last_l0 = ta.valuewhen(ta.change(market) != 0, l0, 0)
    last_h0 = ta.valuewhen(ta.change(market) != 0, h0, 0)
    market := last_l0 == l0 or last_h0 == h0 ? market : market == 1 and l0 < l1 and l0 < l1 - math.abs(h0 - l1) * fib_factor ? -1 : market == -1 and h0 > h1 and h0 > h1 + math.abs(h1 - l0) * fib_factor ? 1 : market
    
    // For alert
    alert_market = 1
    alert_market := nz(alert_market[1], 1)
    alert_market := last_l0 == l0 or last_h0 == h0 ? alert_market : alert_market == 1 and trendms == -1 and close < l0 and close < l0 - math.abs(h0 - l0) * fib_factor ? -1 : alert_market == -1 and trendms == 1 and close > h0 and close > h0 + math.abs(h0 - l0) * fib_factor ? 1 : alert_market
    
    bu_ob_index = bar_index
    bu_ob_index := nz(bu_ob_index[1], bar_index)
    for i=h1i to l0i[zigzag_len]
        index = bar_index - i 
        if open[index] > close[index]
            bu_ob_index := bar_index[index]
    
    bu_ob_since = bar_index - bu_ob_index
    
    be_ob_index = bar_index
    be_ob_index := nz(be_ob_index[1], bar_index)
    for i=l1i to h0i[zigzag_len]
        index = bar_index - i 
        if open[index] < close[index]
            be_ob_index := bar_index[index]
    
    be_ob_since = bar_index - be_ob_index
    
    be_bb_index = bar_index
    be_bb_index := nz(be_bb_index[1], bar_index)
    for i=h1i - zigzag_len to l1i
        index = bar_index - i
        if open[index] > close[index]
            be_bb_index := bar_index[index]
    
    be_bb_since = bar_index - be_bb_index
    
    bu_bb_index = bar_index
    bu_bb_index := nz(bu_bb_index[1], bar_index)
    for i=l1i - zigzag_len to h1i
        index = bar_index - i
        if open[index] < close[index]
            bu_bb_index := bar_index[index]
    
    bu_bb_since = bar_index - bu_bb_index
    
    bu_ob_since_high = high[bu_ob_since]
    bu_ob_since_low = low[bu_ob_since]
    be_ob_since_high = high[be_ob_since]
    be_ob_since_low = low[be_ob_since]
    be_bb_since_high = high[be_bb_since]
    be_bb_since_low = low[be_bb_since]
    bu_bb_since_high = high[bu_bb_since]
    bu_bb_since_low = low[bu_bb_since]
    
    [alert_market, be_bb_since_high, be_bb_since_low, bu_bb_since_high, bu_bb_since_low, bu_ob_index, bu_bb_index, be_ob_index, be_bb_index]

[trendms, h0i, h0, l0i, l0, market, h1i, h1, l1i, l1, bu_ob_since_high, bu_ob_since_low, be_ob_since_high, be_ob_since_low] = request.security(syminfo.tickerid, tf, f_main1())
[alert_market, be_bb_since_high, be_bb_since_low, bu_bb_since_high, bu_bb_since_low, bu_ob_index, bu_bb_index, be_ob_index, be_bb_index] = request.security(syminfo.tickerid, tf, f_main2())

// Be_bb_since olanlar değişecek be_ob_index ler eklenecek

if ta.change(trendms) != 0 and show_zigzag
    if trendms == 1
        line.new(h0i, h0, l0i, l0)
    if trendms == -1
        line.new(l0i, l0, h0i, h0)

if ta.change(market) != 0
    if market == 1
        line.new(h1i, h1, h0i, h1, color=color.green, width=2)
        label.new(int(math.avg(h1i, l0i)), h1, "MSB", color=color.new(color.black, 100), style=label.style_label_down, textcolor=color.green, size=size.small)
        bu_ob = box.new(bu_ob_index, bu_ob_since_high, bar_index + 10, bu_ob_since_low, bgcolor=bu_ob_color, border_color=bu_ob_border_color, text="Bu-OB", text_color=bu_ob_text_color, text_halign=text.align_right, text_size=text_size)
        bu_bb = box.new(bu_bb_index, bu_bb_since_high, bar_index + 10, bu_bb_since_low, bgcolor=bu_bb_color, border_color=bu_bb_border_color, text=l0 < l1 ? "Bu-BB" : "Bu-MB", text_color=bu_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(bu_ob_boxes, bu_ob)
        array.push(bu_bb_boxes, bu_bb)
    if market == -1
        line.new(l1i, l1, l0i, l1, color=color.red, width=2)
        label.new(int(math.avg(l1i, h0i)), l1, "MSB", color=color.new(color.black, 100), style=label.style_label_up, textcolor=color.red, size=size.small)
        be_ob = box.new(be_ob_index, be_ob_since_high, bar_index + 10, be_ob_since_low, bgcolor=be_ob_color, border_color=be_ob_border_color, text="Be-OB", text_color=be_ob_text_color, text_halign=text.align_right, text_size=text_size)
        be_bb = box.new(be_bb_index, be_bb_since_high, bar_index + 10, be_bb_since_low, bgcolor=be_bb_color, border_color=be_bb_border_color, text=h0 > h1 ? "Be-BB" : "Be-MB", text_color=be_bb_text_color, text_halign=text.align_right, text_size=text_size)
        array.push(be_ob_boxes, be_ob)
        array.push(be_bb_boxes, be_bb)

for bull_ob in bu_ob_boxes
    bottom = box.get_bottom(bull_ob)
    if close < bottom
        box.delete(bull_ob)
    else if array.size(bu_ob_boxes) == 5
        box.delete(array.shift(bu_ob_boxes))
    else
        box.set_right(bull_ob, bar_index + 10)
    
for bear_ob in be_ob_boxes
    top = box.get_top(bear_ob)
    if close > top
        box.delete(bear_ob)
    else if array.size(be_ob_boxes) == 5
        box.delete(array.shift(be_ob_boxes))
    else
        box.set_right(bear_ob, bar_index + 10)
        
for bear_bb in be_bb_boxes
    top = box.get_top(bear_bb)
    if close > top
        box.delete(bear_bb)
    else if array.size(be_bb_boxes) == 5
        box.delete(array.shift(be_bb_boxes))
    else
        box.set_right(bear_bb, bar_index + 10)
        
for bull_bb in bu_bb_boxes
    bottom = box.get_bottom(bull_bb)
    if close < bottom
        box.delete(bull_bb)
    else if array.size(bu_bb_boxes) == 5
        box.delete(array.shift(bu_bb_boxes))
    else
        box.set_right(bull_bb, bar_index + 10)
        
if ta.change(alert_market) != 0
    alert("MSB", alert.freq_once_per_bar)


//------------------Setting Variables-------------------//
rb = input(2, 'How many right bars for pivots')
lb = input(15, 'How many left bars for pivots?')
sph = input(close, 'Pivot source for bear divs')
spl = input(close, 'Pivots source for bull divs')
len15 = input.int(14, ' RSI length', minval=1)
ob = input.int(70, 'RSI overbought level', minval=70, maxval=100)
os = input.int(30, 'RSI oversold level', minval=30, maxval=100)

showph = input(false, 'Show pivot highs?')
showpl = input(false, 'Show pivot lows?')
lvl = input.int(5, 'Lookback level for divs', options=[1, 2, 3, 4, 5])


// # ========================================================================= #
//                              Auto Fibonacci
// # ========================================================================= #

gr_fib = "Auto Fibonacci"
fib = input(false, "Fibonacci", inline = "12", group = gr_fib)
timeframe       = input.timeframe("240","", inline = "12", tooltip = "Automatically displays Fibonacci lines", group=gr_fib)
leftBars        = input.int(defval = 2, title = "Left", minval = 1, inline = "22",group= gr_fib)
rightBars       = input.int(defval = 2, title = "Right", minval = 1, inline = "22", group=gr_fib)
isColorAll      = input.bool(true, "", group=gr_fib, inline="color")
colorAll        = input.color(color.white, "Color All Lines ----", group=gr_fib, inline="color")
isfib0000       = input.bool(true, "", group=gr_fib, inline="0")
nFib0000        = input.float(0, "", step=0.01, group=gr_fib, inline="0")
colorFib0000    = input.color(color.white, "", group=gr_fib, inline="0")
isfib0206       = input.bool(false, "", group=gr_fib, inline="0")
nFib0206        = input.float(0.206, "", step=0.01, group=gr_fib, inline="0")
colorFib0206    = input.color(color.white, "", group=gr_fib, inline="0")
isfib0382       = input.bool(true, "", group=gr_fib, inline="0.382")
nFib0382        = input.float(0.382, "", step=0.01, group=gr_fib, inline="0.382")
colorFib0382    = input.color(color.white, "", group=gr_fib, inline="0.382")
isfib0500       = input.bool(false, "", group=gr_fib, inline="0.382")
nFib0500        = input.float(0.5, "", step=0.01, group=gr_fib, inline="0.382")
colorFib0500    = input.color(color.white, "", group=gr_fib, inline="0.382")
isfib0618       = input.bool(true, "", group=gr_fib, inline="0.618")
nFib0618        = input.float(0.618, "", step=0.01, group=gr_fib, inline="0.618")
colorFib0618    = input.color(color.white, "", group=gr_fib, inline="0.618")
isfib0786       = input.bool(true, "", group=gr_fib, inline="0.618")
nFib0786        = input.float(0.718, "", step=0.01, group=gr_fib, inline="0.618")
colorFib0786    = input.color(color.white, "", group=gr_fib, inline="0.618")
isfib1000       = input.bool(true, "", group=gr_fib, inline="1")
nFib1000        = input.float(1, "", step=0.01, group=gr_fib, inline="1")
colorFib1000    = input.color(color.white, "", group=gr_fib, inline="1")
isfib1414       = input.bool(false, "", group=gr_fib, inline="1")
nFib1414        = input.float(1.414, "", step=0.01, group=gr_fib, inline="1")
colorFib1414    = input.color(color.white, "", group=gr_fib, inline="1")
isfib1618       = input.bool(false, "", group=gr_fib, inline="1.618")
nFib1618        = input.float(1.618, "", step=0.01, group=gr_fib, inline="1.618")
colorFib1618    = input.color(color.white, "", group=gr_fib, inline="1.618")
isfib2000       = input.bool(false, "", group=gr_fib, inline="1.618")
nFib2000        = input.float(2, "", step=0.01, group=gr_fib, inline="1.618")
colorFib2000    = input.color(color.white, "", group=gr_fib, inline="1.618")
isfib2618       = input.bool(false, "", group=gr_fib, inline="2.618")
nFib2618        = input.float(2.618, "", step=0.01, group=gr_fib, inline="2.618")
colorFib2618    = input.color(color.white, "", group=gr_fib, inline="2.618")

// # ============================[AUTOFIB]============================ #
// ] —————— Vars —————— [
var fib0000     = close
var fib0206     = close
var fib0382     = close
var fib0500     = close
var fib0618     = close
var fib0786     = close
var fib1000     = close
var fib1414     = close
var fib1618     = close
var fib2000     = close
var fib2618     = close

// ] —————— Find Dev Pivots —————— [

getMultiTfPivots()=>
    float ph1    = ta.pivothigh(leftBars, rightBars)
    float pl1    = ta.pivotlow(leftBars, rightBars)
    ph1BIndexS   = ph1 ? time[rightBars] : na
    plBIndexS   = pl1 ? time[rightBars] : na

    [ph1, ph1BIndexS, pl1, plBIndexS]

// get if there if Pivot High/low and their start/end times
[ph1, ph1BIndexS, pl1, plBIndexS] = request.security(syminfo.tickerid, timeframe, getMultiTfPivots(), lookahead = barmerge.lookahead_on)

// ] —————— Fibs Handles —————— [
// Get last highs/lows.
pivothigh           = na(ph1[1]) and ph1 ? ph1 : na
pivotlow            = na(pl1[1]) and pl1 ? pl1 : na
var isHighLast      = true
var curPivotP       = 0.    
var lastPivotP      = 0. 
var curPivotBi      = 0    
var lastPivotBi     = 0

// Special case: where high & low detected at the same time.
if not na(pivothigh) and not na(pivotlow)
    lastPivotP          := isHighLast ? pl1 : ph1
    curPivotP           := isHighLast ? ph1 : pl1
    lastPivotBi         := isHighLast ? plBIndexS : ph1BIndexS
    curPivotBi          := isHighLast ? ph1BIndexS : plBIndexS
// All cases
else 
    isHighLast          := not na(pivothigh) ? true : not na(pivotlow) ? false : isHighLast
    
    lastPivotP          := not na(pivothigh) and not isHighLast[1] or not na(pivotlow) and isHighLast[1] ? curPivotP : lastPivotP
    curPivotP           := not na(pivothigh) ? ph1 : not na(pivotlow) ? pl1 : curPivotP
    
    lastPivotBi         := not na(pivothigh) and not isHighLast[1] or not na(pivotlow) and isHighLast[1] ? curPivotBi : lastPivotBi
    curPivotBi          := not na(pivothigh) ? ph1BIndexS : not na(pivotlow) ? plBIndexS : curPivotBi

// Logic fibo direction.
fiboDirUp           = isHighLast

// Last Update Barindex.
var barLastUpdate = 0
barLastUpdate       := lastPivotBi

// Calculate fibs levels.
rangeD          = isHighLast ? curPivotP - lastPivotP : lastPivotP - curPivotP
fib0000         := fiboDirUp ? curPivotP - nFib0000 * rangeD : curPivotP + nFib0000 * rangeD
fib0206         := fiboDirUp ? curPivotP - nFib0206 * rangeD : curPivotP + nFib0206 * rangeD
fib0382         := fiboDirUp ? curPivotP - nFib0382 * rangeD : curPivotP + nFib0382 * rangeD
fib0500         := fiboDirUp ? curPivotP - nFib0500 * rangeD : curPivotP + nFib0500 * rangeD
fib0618         := fiboDirUp ? curPivotP - nFib0618 * rangeD : curPivotP + nFib0618 * rangeD
fib0786         := fiboDirUp ? curPivotP - nFib0786 * rangeD : curPivotP + nFib0786 * rangeD
fib1000         := fiboDirUp ? curPivotP - nFib1000 * rangeD : curPivotP + nFib1000 * rangeD
fib1414         := fiboDirUp ? curPivotP - nFib1414 * rangeD : curPivotP + nFib1414 * rangeD
fib1618         := fiboDirUp ? curPivotP - nFib1618 * rangeD : curPivotP + nFib1618 * rangeD
fib2000         := fiboDirUp ? curPivotP - nFib2000 * rangeD : curPivotP + nFib2000 * rangeD
fib2618         := fiboDirUp ? curPivotP - nFib2618 * rangeD : curPivotP + nFib2618 * rangeD

// ] —————— Plot —————— [
var fib0000Line     = line.new(0, low, bar_index, high)
var fib0000Label    = label.new(bar_index, low, text="Init")

var fib0206Line     = line.new(0, low, bar_index, high)
var fib0206Label    = label.new(bar_index, low, text="Init")

var fib0382Line     = line.new(0, low, bar_index, high)
var fib0382Label    = label.new(bar_index, low, text="Init")

var fib0500Line     = line.new(0, low, bar_index, high)
var fib0500Label    = label.new(bar_index, low, text="Init")

var fib0618Line     = line.new(0, low, bar_index, high)
var fib0618Label    = label.new(bar_index, low, text="Init")

var fib0786Line     = line.new(0, low, bar_index, high)
var fib0786Label    = label.new(bar_index, low, text="Init")

var fib1000Line     = line.new(0, low, bar_index, high)
var fib1000Label    = label.new(bar_index, low, text="Init")

var fib1414Line     = line.new(0, low, bar_index, high)
var fib1414Label    = label.new(bar_index, low, text="Init")

var fib1618Line     = line.new(0, low, bar_index, high)
var fib1618Label    = label.new(bar_index, low, text="Init")

var fib2000Line     = line.new(0, low, bar_index, high)
var fib2000Label    = label.new(bar_index, low, text="Init")

var fib2618Line     = line.new(0, low, bar_index, high)
var fib2618Label    = label.new(bar_index, low, text="Init")

labelOffset = 15
if fib
    if isfib0000
        line.delete(fib0000Line)
        label.delete(fib0000Label)
        fib0000Line     := line.new(barLastUpdate, fib0000, time, fib0000, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib0000,  width=1)
        fib0000Label    := label.new(x=bar_index + labelOffset, y = fib0000, xloc=xloc.bar_index, text=str.tostring(nFib0000), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib0000, textalign=text.align_center)

    if isfib0206
        line.delete(fib0206Line)
        label.delete(fib0206Label)
        fib0206Line     := line.new(barLastUpdate, fib0206, time, fib0206, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib0206,  width=1)
        fib0206Label    := label.new(x=bar_index + labelOffset, y = fib0206, xloc=xloc.bar_index, text=str.tostring(nFib0206), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib0206, textalign=text.align_center)

    if isfib0382
        line.delete(fib0382Line)
        label.delete(fib0382Label)
        fib0382Line     := line.new(barLastUpdate, fib0382, time, fib0382, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib0382,  width=1)
        fib0382Label    := label.new(x=bar_index + labelOffset, y = fib0382, xloc=xloc.bar_index, text=str.tostring(nFib0382), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib0382, textalign=text.align_center)

    if isfib0500
        line.delete(fib0500Line)
        label.delete(fib0500Label)
        fib0500Line     := line.new(barLastUpdate, fib0500, time, fib0500, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib0500,  width=1)
        fib0500Label    := label.new(x=bar_index + labelOffset, y = fib0500, xloc=xloc.bar_index, text=str.tostring(nFib0500), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib0500, textalign=text.align_center)

    if isfib0618
        line.delete(fib0618Line)
        label.delete(fib0618Label)
        fib0618Line     := line.new(barLastUpdate, fib0618, time, fib0618, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib0618,  width=1)
        fib0618Label    := label.new(x=bar_index + labelOffset, y = fib0618, xloc=xloc.bar_index, text=str.tostring(nFib0618), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib0618, textalign=text.align_center)

    if isfib0786
        line.delete(fib0786Line)
        label.delete(fib0786Label)
        fib0786Line     := line.new(barLastUpdate, fib0786, time, fib0786, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib0786,  width=1)
        fib0786Label    := label.new(x=bar_index + labelOffset, y = fib0786, xloc=xloc.bar_index, text=str.tostring(nFib0786), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib0786, textalign=text.align_center)

    if isfib1000
        line.delete(fib1000Line)
        label.delete(fib1000Label)
        fib1000Line     := line.new(barLastUpdate, fib1000, time, fib1000, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib1000,  width=1)
        fib1000Label    := label.new(x=bar_index + labelOffset, y = fib1000, xloc=xloc.bar_index, text=str.tostring(nFib1000), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib1000, textalign=text.align_center)

    if isfib1414
        line.delete(fib1414Line)
        label.delete(fib1414Label)
        fib1414Line     := line.new(barLastUpdate, fib1414, time, fib1414, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib1414,  width=1)
        fib1414Label    := label.new(x=bar_index + labelOffset, y = fib1414, xloc=xloc.bar_index, text=str.tostring(nFib1414), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib1414, textalign=text.align_center)

    if isfib1618
        line.delete(fib1618Line)
        label.delete(fib1618Label)
        fib1618Line     := line.new(barLastUpdate, fib1618, time, fib1618, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib1618,  width=1)
        fib1618Label    := label.new(x=bar_index + labelOffset, y = fib1618, xloc=xloc.bar_index, text=str.tostring(nFib1618), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib1618, textalign=text.align_center)

    if isfib2000
        line.delete(fib2000Line)
        label.delete(fib2000Label)
        fib2000Line     := line.new(barLastUpdate, fib2000, time, fib2000, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib2000,  width=1)
        fib2000Label    := label.new(x=bar_index + labelOffset, y = fib2000, xloc=xloc.bar_index, text=str.tostring(nFib2000), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib2000, textalign=text.align_center)

    if isfib2618
        line.delete(fib2618Line)
        label.delete(fib2618Label)
        fib2618Line     := line.new(barLastUpdate, fib2618, time, fib2618, xloc=xloc.bar_time, color=isColorAll ? colorAll : colorFib2618,  width=1)
        fib2618Label    := label.new(x=bar_index + labelOffset, y = fib2618, xloc=xloc.bar_index, text=str.tostring(nFib2618), style=label.style_none, size=size.small, textcolor=isColorAll ? colorAll : colorFib2618, textalign=text.align_center)


// # ========================================================================= #
//                              ICT KILL ZONES
// # ========================================================================= #

gr_ict = "ICT KILL ZONES"
i_tz                    = input.string('GMT-5', title= 'Timezone', options=['GMT-11', 'GMT-10', 'GMT-9', 'GMT-8', 'GMT-7', 'GMT-6', 'GMT-5', 'GMT-4', 'GMT-3', 'GMT-2', 'GMT-1', 'GMT', 'GMT+1', 'GMT+2', 'GMT+3', 'GMT+330', 'GMT+4', 'GMT+430', 'GMT+5', 'GMT+530', 'GMT+6', 'GMT+7', 'GMT+8', 'GMT+9', 'GMT+10', 'GMT+11', 'GMT+12'], tooltip='e.g. \'America/New_York\', \'Asia/Tokyo\', \'GMT-4\', \'GMT+9\'...', group=gr_ict, inline = "1")
i_history_period        = input.int(1, 'History', minval=0, maxval=100, group = gr_ict, inline = "1" )
var bool canPlot        = (timeframe.isminutes and timeframe.multiplier <= 60) or timeframe.isseconds
i_show                  = i_history_period > 0 and canPlot
i_lookback              = 12 * 60
LoSB         = input(false, title="3-4 am", group = gr_ict,inline = "2")
NYSB         = input(false, title="10-11 am", group = gr_ict,inline = "2")
NYPM         = input(false, title="2-3 Pm", group = gr_ict,inline = "2")
LSBcolor       = input.color(color.new(#5d606b,0),title="",  group = gr_ict,inline = "2")
LSBstyle     = input.string ("Dashed", "", options=["Solid", "Dotted", "Dashed"], group = gr_ict,inline = "2")
LST    = LSBstyle    ==    "Solid" ? line.style_solid : LSBstyle == "Dotted" ? line.style_dotted : line.style_dashed
i_show_sess1            = input.bool(defval= true, title ="" ,group=gr_ict, inline="a") and i_show
i_sess1Text             = input.string  ("Asian Range", title ="" ,group=gr_ict, inline="a")
i_sess1_color           = input.color(defval=color.new(#2a2e39, 0), title="", group=gr_ict, inline="a")
i_sess1                 = input.session('1900-2400', 'Time', group=gr_ict, inline="a")
var i_sess1_extend      ='× No'
var i_sess1_op          = true
i_show_sess2            = input.bool(defval= true, title ="" , group=gr_ict, inline="b") and i_show
i_sess2Text             = input.string  ("London", title ="" , group=gr_ict, inline="b")
i_sess2_color           = input.color(defval=color.new(#5b9cf6, 0), title="", group=gr_ict, inline="b")
i_sess2                 = input.session('0200-0500', "Time" , group=gr_ict, inline="b")
var i_sess2_extend      ='× No'
var i_sess2_op          = true
i_show_sess3            = input.bool(defval= true, title ="" ,group=gr_ict, inline="t") and i_show
i_sess3Text             = input.string  ("New York", title ="" ,group=gr_ict, inline="t")
i_sess3_color           = input.color(defval=color.new(#22ab94, 0), title="", group=gr_ict, inline="t")
i_sess3                 = input.session('0700-1000', "Time" ,  group=gr_ict, inline="t")
var i_sess3_extend      ='× No'
var i_sess3_op          = true
i_show_sess4            = input.bool(defval= false , title ="" ,group=gr_ict, inline="h" ) and i_show
i_sess4Text             = input.string  ("New York cl", title ="" ,group=gr_ict, inline="h")
i_sess4_color           = input.color(defval=color.new(#ec407a, 0), title="", group=gr_ict, inline="h")
i_sess4                 = input.session('1300-1600', "Time" ,  group=gr_ict, inline="h")
var i_sess4_extend      ='× No'
var i_sess4_op          = true
i_show_sess5            = input.bool(defval= false , title ="" ,group=gr_ict, inline="hz" ) and i_show
i_sess5Text             = input.string  ("input name", title ="" ,group=gr_ict, inline="hz")
i_sess5_color           = input.color(defval=color.new(#ba68c8, 0), title="", group=gr_ict, inline="hz")
i_sess5                 = input.session('1600-1630', "Time" ,  group=gr_ict, inline="hz")
var i_sess5_extend      ='× No'
var i_sess5_op          = true
i_sess_box_style        = input.string('Sandwich', 'Style', options=['Box', 'Sandwich'], group=gr_ict, inline="q")
i_sess_border_style     = input.string(line.style_solid, 'Line style', options=[line.style_solid, line.style_dotted, line.style_dashed], group=gr_ict, inline="q")
i_sess_border_width     = input.int(1, 'Thickness', minval=0, group=gr_ict, inline="qq")
i_sess_bgopacity        = input.int(94, 'Transp', minval=0, maxval=100, step=1, group=gr_ict, tooltip='Setting the 100 is no background color', inline="qq")
f_get_label_position (_y, _side) =>
    switch _y
        'top'    => _side == 'outside' ? label.style_label_lower_left : label.style_label_upper_left
        'bottom' => _side == 'outside' ? label.style_label_upper_left : label.style_label_lower_left
i_label_show            = input.bool(true, 'Show labels', group=gr_ict, inline='label_show') and i_show
i_label_size            = str.lower(input.string('Small', '', options=['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], group=gr_ict, inline='label_show'))
i_label_position_y      = str.lower(input.string('Top', '', options=['Top', 'Bottom'], group=gr_ict, inline='label_show'))
i_label_position_s      = str.lower(input.string('Outside', '', options=['Inside', 'Outside'], group=gr_ict, inline='label_show'))
i_label_position        = f_get_label_position(i_label_position_y, i_label_position_s)
i_label_format_name     = input.bool(true, 'Name', group=gr_ict, inline='label_format')
i_label_format_day      = input.bool(false, 'Day', group=gr_ict, inline='label_format')
i_label_format_price    = input.bool(false, 'Price', group=gr_ict, inline='label_format')
i_label_format_pips     = input.bool(false, 'Pips', group=gr_ict, inline='label_format')


// # ========================================================================= #
//                                DASHBOARD
// # ========================================================================= #
// Optimal Sensivity 

// Trend Strength Function
rsilength = 14
overboughtlevel = 70 
oversoldlevel = 30

rsiValue = ta.rsi(close, rsilength)

trendStrength = rsiValue > overboughtlevel ? 100 : rsiValue < oversoldlevel ? 0 : ((rsiValue - oversoldlevel) / (overboughtlevel - oversoldlevel)) * 100

isTrending = trendStrength > 50
trendStrengthPercentage = math.round(trendStrength, 2)
trendIndication = isTrending ? "🔥" : "❄️"
trendemote = isTrending ? "🐮" : "🐻"
trendtext = isTrending ? "Bullish" : "Bearish"
textColorstrength = trendStrengthPercentage < 50 ? bearish : bullish

// Volume Function
vollength = 20
buyThreshold = 0.7
sellThreshold = -0.7

volumeRatio = volume / ta.sma(volume, vollength)

volumeSentiment = (math.min(math.max(volumeRatio - 0.5, -0.5), 0.5) * 200)

isBuySentiment = volumeSentiment > buyThreshold
isSellSentiment = volumeSentiment < sellThreshold
textcolorvolu = isBuySentiment ? bullish : bearish

// Volatility Function
volatilength = 20
lowVolatilityThreshold = 0.5
highVolatilityThreshold = 1.5

Volatility = ta.atr(1) / ta.atr(volatilength)

isRisingVolatility = Volatility > ta.sma(Volatility, volatilength)
isFallingVolatility = Volatility < ta.sma(Volatility, volatilength)

isLowVolatility = Volatility < lowVolatilityThreshold
isHighVolatility = Volatility > highVolatilityThreshold

volatilityPercentage = math.min(Volatility * 100, 100)
volatilityIndication = isRisingVolatility ? "📈" : isFallingVolatility ? "📉" : ""
volatilitycolor = isHighVolatility ? bearish : bullish

// Drawing Dashboard
var table_position = dashLoc == 'Bottom Left' ? position.bottom_left 
  : dashLoc == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = textSize == 'Tiny' ? size.tiny 
  : textSize == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 7, 7
  , bgcolor = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color = #373a46
  , frame_width = 1)

if showDash
    if barstate.isfirst
        tb.cell(0, 0, "Pieki Dashboard", text_color = color.white, text_size = table_size)
        tb.merge_cells(0,0,1,0)

    if barstate.islast
        tb.cell(0, 3, str.tostring(trendIndication) + "Trend Strenght", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(0, 4, "💠 Volume", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(0, 5, str.tostring(volatilityIndication) + " Volatility", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(0, 6, str.tostring(trendemote) + " Trend", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(1, 3, str.tostring(trendStrengthPercentage, format.percent), text_color=textColorstrength, text_size=table_size)
        tb.cell(1, 4, str.tostring(volumeSentiment, format.percent), text_color = textcolorvolu, text_size = table_size)
        tb.cell(1, 5, str.tostring(volatilityPercentage, format.percent), text_color=volatilitycolor, text_size=table_size)
        tb.cell(1, 6, str.tostring(trendtext), text_color = textColorstrength, text_size = table_size)


// # ========================================================================= #
//                                Risk Managment
// # ========================================================================= #

trigger2 = bull ? 1 : 0
countBull = ta.barssince(bull)
countBear = ta.barssince(bear)
trigger   = nz(countBull, bar_index) < nz(countBear, bar_index) ? 1 : 0
atrBand = ta.atr(atrLen) * atrRisk
atrStop = trigger == 1 ? low - atrBand : high + atrBand

lastTrade(close) => ta.valuewhen(bull or bear , close, 0)

stop_y = lastTrade(atrStop)
stop  = levels ? label.new(time, close, "SL " + str.tostring(stop_y, decimals), xloc.bar_time, yloc.price, bearish, label.style_label_left, color.white, size.normal) : na
label.set_x(stop, label.get_x(stop) + math.round(ta.change(time) * 1))
label.set_y(stop, stop_y)
label.delete(stop[1])

tp1Rl_y = (lastTrade(close)-lastTrade(atrStop))*1 + lastTrade(close)
tp1Rl   = levels ? label.new(time, close, "1:1 TP " + str.tostring(tp1Rl_y, decimals), xloc.bar_time, yloc.price, bullish, label.style_label_left, color.white, size.normal ) : na
label.set_x(tp1Rl, label.get_x(tp1Rl) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp1Rl, tp1Rl_y)
label.delete(tp1Rl[1])

tp2RL_y = (lastTrade(close)-lastTrade(atrStop))*2 + lastTrade(close)
tp2RL   = levels ? label.new(time, close, "2:1 TP " + str.tostring(tp2RL_y, decimals), xloc.bar_time, yloc.price, bearish, label.style_label_left, color.white, size.normal) : na
label.set_x(tp2RL, label.get_x(tp2RL) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp2RL, tp2RL_y)
label.delete(tp2RL[1])

tp3RL_y = (lastTrade(close)-lastTrade(atrStop))*3 + lastTrade(close)
tp3RL   = levels ? label.new(time, close, "3:1 TP " + str.tostring(tp3RL_y, decimals), xloc.bar_time, yloc.price, bullish, label.style_label_left, color.white, size.normal) : na
label.set_x(tp3RL, label.get_x(tp3RL) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp3RL, tp3RL_y)
label.delete(tp3RL[1])

tp4RL_y = (lastTrade(close)-lastTrade(atrStop))*4 + lastTrade(close)
tp4RL   = levels ? label.new(time, close, "4:1 TP " + str.tostring(tp4RL_y, decimals), xloc.bar_time, yloc.price, bullish, label.style_label_left, color.white, size.normal) : na
label.set_x(tp4RL, label.get_x(tp4RL) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp4RL, tp4RL_y)
label.delete(tp4RL[1])

tp5RL_y = (lastTrade(close)-lastTrade(atrStop))*5 + lastTrade(close)
tp5RL   = levels ? label.new(time, close, "5:1 TP " + str.tostring(tp5RL_y, decimals), xloc.bar_time, yloc.price, bullish, label.style_label_left, color.white, size.normal) : na
label.set_x(tp5RL, label.get_x(tp5RL) + math.round(ta.change(time) * lvlDistance))
label.set_y(tp5RL, tp5RL_y)
label.delete(tp5RL[1])

style = linesStyle == "SOLID" ? line.style_solid : linesStyle == "DASHED" ? line.style_dashed : line.style_dotted
lineStop    = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), stop_y, bar_index + 1, stop_y, xloc.bar_index, extend.none, bearish, style, 2) : na, line.delete(lineStop[1])
lineTp1Rl   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp1Rl_y, bar_index + 1, tp1Rl_y, xloc.bar_index, extend.none, bullish, style, 2) : na, line.delete(lineTp1Rl[1])
lineTp2RL   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp2RL_y, bar_index + lvlDistance, tp2RL_y, xloc.bar_index, extend.none, bullish, style, 2) : na, line.delete(lineTp2RL[1])
lineTp3RL   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp3RL_y, bar_index + lvlDistance, tp3RL_y, xloc.bar_index, extend.none, bullish, style, 2) : na, line.delete(lineTp3RL[1])
lineTp4RL   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp4RL_y, bar_index + lvlDistance, tp4RL_y, xloc.bar_index, extend.none, bullish, style, 2) : na, line.delete(lineTp4RL[1])
lineTp5RL   = levels and lvlLines ? line.new(bar_index - (trigger == 0 ? countBull : countBear), tp5RL_y, bar_index + lvlDistance, tp5RL_y, xloc.bar_index, extend.none, bullish, style, 2) : na, line.delete(lineTp5RL[1])


// # ========================================================================= #
//                        Premium Zones
// # ========================================================================= #

// User inputs
show_lbl                        = input.bool        (false                            , "Show swing point"            , inline = "1", group = "Premium Zones"                    , tooltip = "Display swing point")
show_mtb                        = input.bool        (false                            , "Show High/Low/Equilibrium"   , inline = "2", group = "Premium Zones"                    , tooltip = "Display Strong/Weak High And Low and Equilibrium")
toplvl                          = input.color       (color.red                      , "Premium Zone   "             , inline = "3", group = "Premium Zones")
midlvl                          = input.color       (color.white                    , "Equilibrium Zone"            , inline = "4", group = "Premium Zones")
btmlvl                          = input.color       (#089981                        , "Discount Zone    "           , inline = "5", group = "Premium Zones")

fvg_enable                      = input.bool        (false                            , "        "                    , inline = "1", group = "FAIR VALUE GAP"                  , tooltip = "Display fair value gap")
what_fvg                        = input.string      ("FVG"                            , ""                            , inline = "1", group = "FAIR VALUE GAP"                  , tooltip = "Display fair value gap", options = ["FVG", "VI", "OG"])
fvg_num                         = input.int         (5                                , "Show Last  "                 , inline = "1a", group = "FAIR VALUE GAP"                 , tooltip = "Number of fvg to show")
fvg_upcss                       = input.color       (color.new(#089981,  80)        , ""                            , inline = "1", group = "FAIR VALUE GAP")
fvg_dncss                       = input.color       (color.new(color.red ,  80)     , ""                            , inline = "1", group = "FAIR VALUE GAP")
fvg_extend                      = input.int         (10                               , "Extend FVG"                  , inline = "2", group = "FAIR VALUE GAP"                  , tooltip = "Extend the display of the FVG.")
fvg_src                         = input.string      ("Close"                          , "Mitigation  "                , inline = "3", group = "FAIR VALUE GAP"                  , tooltip = "[Close] Use the close of the body as trigger\n\n[Wick] Use the extreme point of the body as trigger", options = ["Close", "Wick"])
fvg_tf                          = input.timeframe   (""                               , "Timeframe "                  , inline = "4", group = "FAIR VALUE GAP"                  , tooltip = "Timeframe of the fair value gap")

i_ms_up_BOS                   = input.color       (#089981                          , ""                            , inline = "2", group = "MARKET STRUCTURE")
i_ms_dn_BOS                   = input.color       (#f23645                          , ""                            , inline = "2", group = "MARKET STRUCTURE")
s_ms_up_BOS                   = input.color       (#089981                          , ""                            , inline = "1", group = "MARKET STRUCTURE")
s_ms_dn_BOS                   = input.color       (#f23645                          , ""                            , inline = "1", group = "MARKET STRUCTURE")


// # ========================================================================= #
//                            FVG | VI | OG 
// # ========================================================================= #

ghl() => request.security(syminfo.tickerid, fvg_tf, [high[2], low[2], close[1], open[1]])
tfG() => request.security(syminfo.tickerid, fvg_tf, [open, high, low, close])

cG(bool bull) =>

    [h, l, c, o]     = ghl()
    [go, gh, gl, gc] = tfG()

    var FVG draw   = FVG.new(
           array.new<box>()
         , array.new<line>()
         )

    var FVG[] cords = array.new<FVG>()

    float pup = na
    float pdn = na
    bool  cdn = na
    int   pos = 2
    cc        = timeframe.change(fvg_tf)

    if barstate.isfirst

        for i = 0 to fvg_num - 1

            draw.box.unshift(box.new (na, na, na, na, border_color = color.new(color.white, 100), xloc = xloc.bar_time))
            draw.ln.unshift (line.new(na, na, na, na, xloc = xloc.bar_time, width = 1, style = line.style_solid))

    switch what_fvg

        "FVG" => 

            pup := bull ?            gl : l
            pdn := bull ?      h        : gh
            cdn := bull ? gl > h and cc : gh < l and cc
            pos := 2

        "VI" =>

            pup := bull 
                 ? (gc > go 
                  ? go 
                   : gc) 
                 : (gc[1] > go[1] 
                  ? go[1] 
                   : gc[1])
            pdn := bull 
                 ? (gc[1] > go[1] 
                  ? gc[1] 
                   : go[1]) 
                 : (gc > go 
                  ? gc 
                   : go)
            cdn := bull 
                 ? go > gc[1] and gh[1] > gl and gc > gc[1] and go > go[1] and gh[1]  < math.min(gc, go) and cc
                 : go < gc[1] and gl[1] < gh and gc < gc[1] and go < go[1] and gl[1]  > math.max(gc, go) and cc
            pos := 1

        "OG" =>

            pup := bull ?               b.l : gl[1]
            pdn := bull ?      gh[1]        : gh
            cdn := bull ? gl > gh[1] and cc : gh < gl[1] and cc
            pos := 1       

    if not na(cdn) and cdn

        cords.unshift(
             FVG.new(
               na
             , na
             , bull 
              ? true 
              : false 
             , pup 
             , pdn
             , b.t - (b.t - b.t[1]) * pos
             , b.t + (b.t - b.t[1]) * fvg_extend)
             )
            
        if bull
            blalert.fvg := true
        else
            bralert.fvg := true
    
    if barstate.isconfirmed

        for [idx, obj] in cords

            if obj.bull ? b.c < obj.btm : b.c > obj.top

                cords.remove(idx)
        
    if barstate.islast

        if cords.size() > 0

            for i = math.min(fvg_num - 1, cords.size() - 1) to 0

                gbx = draw.box.get(i)
                gln = draw.ln.get(i)
                gcd = cords.get(i)
                
                gtop   = gcd.top
                gbtm   = gcd.btm
                left  = gcd.left
                right = gcd.right

                gbx.set_lefttop(left, gtop)
                gbx.set_rightbottom(right, gbtm)
                gbx.set_bgcolor(gcd.bull ? fvg_upcss : fvg_dncss)

                gln.set_xy1(left, math.avg(gbx.get_top(), gbx.get_bottom()))
                gln.set_xy2(right, math.avg(gbx.get_top(), gbx.get_bottom()))
                gln.set_color(gcd.bull ? fvg_upcss : fvg_dncss)

if fvg_enable       

    cG(true )
    cG(false)


// # ========================================================================= #
//                      Strong/Weak High/Low And Equilibrium  
// # ========================================================================= #

var phl = Zphl.new(
   na
 , na
 , label.new(na , na , color = invcol , textcolor = i_ms_dn_BOS , style = label.style_label_down , size = size.tiny , text = "")
 , label.new(na , na , color = invcol , textcolor = i_ms_up_BOS , style = label.style_label_up   , size = size.tiny , text = "")
 , true
 , true
 , true
 , true
 , ""
 , ""
 , 0
 , 0
 , 0
 , 0
 , high
 , low
 , 0
 , 0
 , 0
 , 0
 , 0
 , 0
 , na
 , na
 )

zhl(len)=>    

    upper = ta.highest(len)
    lower = ta.lowest(len)

    var float out = 0
    out := b.h[len] > upper ? 0 : b.l[len] < lower ? 1 : out[1]

    top = out == 0 and out[1] != 0 ? b.h[len] : 0
    btm = out == 1 and out[1] != 1 ? b.l[len] : 0

    [top, btm]

[top , btm ] = zhl(sLen)
[itop, ibtm] = zhl(iLen)

upphl(trend) =>

    var label lbl = label.new(
       na
     , na
     , color     = invcol
     , textcolor = toplvl
     , style     = label.style_label_down
     , size      = size.small
     )

    if top

        phl.stopcross := true
        phl.txtup     := top > phl.topy ? "HH" : "HL"

        if show_lbl

            topl = label.new(
               b.n - swing_r_lookback
             , top
             , phl.txtup
             , color     = invcol
             , textcolor = toplvl
             , style     = label.style_label_down
             , size      = size.small
             )

        line.delete(phl.top[1])

        phl.top := line.new(
               b.n - sLen
             , top
             , b.n
             , top
             , color = toplvl)

        phl.topy      := top
        phl.topx      := b.n - sLen
        phl.tup       := top
        phl.tupx      := b.n - sLen

    if itop

        phl.itopcross := true
        phl.itopy     := itop
        phl.itopx     := b.n - iLen

    phl.tup           := math.max(high, phl.tup)
    phl.tupx          := phl.tup == high ? b.n : phl.tupx
    phl.uV            := phl.tup != phl.tup[1] ? b.v : phl.uV

    if barstate.islast 

        line.set_xy1(
               phl.top
             , phl.tupx
             , phl.tup
             )

        line.set_xy2(
               phl.top
             , b.n + 50
             , phl.tup
             )

        label.set_x(
               lbl
             , b.n + 50
             )

        label.set_y(
               lbl
             , phl.tup
             )

        dist = math.abs(phl.uV / (phl.uV + phl.dV)) * 100
        label.set_text (lbl, trend < 0 
             ? "Strong High | " + str.tostring(phl.uV, format.volume) + " (" + str.tostring(math.round(dist,0)) + "%)" 
             : "Weak High | "   + str.tostring(phl.uV, format.volume) + " (" + str.tostring(math.round(dist,0)) + "%)")

dnphl(trend) =>

    var label lbl = label.new(
       na
     , na
     , color     = invcol
     , textcolor = btmlvl
     , style     = label.style_label_up
     , size      = size.small
     )

    if btm

        phl.sbottomcross := true
        phl.txtdn        := btm > phl.bottomy ? "LH" : "LL"

        if show_lbl

            btml = label.new(
               b.n - swing_r_lookback
             , btm, phl.txtdn
             , color = invcol
             , textcolor = btmlvl
             , style = label.style_label_up
             , size = size.small
             )

        line.delete(phl.bottom[1])
        
        phl.bottom := line.new(
           b.n - sLen
         , btm
         , b.n
         , btm
         , color = btmlvl
         )

        phl.bottomy      := btm
        phl.bottomx      := b.n - sLen
        phl.tdn          := btm
        phl.tdnx         := b.n - sLen

    if ibtm

        phl.ibottomcross := true
        phl.ibottomy     := ibtm
        phl.ibottomx     := b.n - iLen

    phl.tdn              := math.min(low, phl.tdn)
    phl.tdnx             := phl.tdn == low ? b.n : phl.tdnx
    phl.dV               := phl.tdn != phl.tdn[1] ? b.v : phl.dV

    if barstate.islast

        line.set_xy1(
           phl.bottom
         , phl.tdnx
         , phl.tdn
         )

        line.set_xy2(
           phl.bottom
         , b.n + 50
         , phl.tdn
         )

        label.set_x(
           lbl
         , b.n + 50
         )

        label.set_y(
           lbl
         , phl.tdn
         )
         
        dist = math.abs(phl.dV / (phl.uV + phl.dV)) * 100
        label.set_text (lbl, trend > 0 
             ? "Strong Low | " + str.tostring(phl.dV, format.volume) + " (" + str.tostring(math.round(dist,0)) + "%)" 
             : "Weak Low | "   + str.tostring(phl.uV, format.volume) + " (" + str.tostring(math.round(dist,0)) + "%)")

midphl() =>

    avg = math.avg(phl.bottom.get_y2(), phl.top.get_y2())
    
    var line l = line.new(
       y1 = avg
     , y2 = avg
     , x1 = b.n - sLen
     , x2 = b.n + 50
     , color = midlvl
     , style = line.style_solid
     )

    var label lbl = label.new(
       x = b.n + 50
     , y = avg
     , text = "Equilibrium"
     , style = label.style_label_left
     , color = invcol
     , textcolor = midlvl
     , size = size.small
     )
     
    if barstate.islast

        more = (phl.bottom.get_x1() + phl.bottom.get_x2()) > (phl.top.get_x1() + phl.top.get_x2()) ? phl.top.get_x1() : phl.bottom.get_x1()
        line.set_xy1(l   , more    , avg)
        line.set_xy2(l   , b.n + 50, avg)
        label.set_x (lbl , b.n + 50     )
        label.set_y (lbl , avg          )
        dist = math.abs((l.get_y2() - close) / close) * 100
        label.set_text (lbl, "Equilibrium (" + str.tostring(math.round(dist,0)) + "%)")     
          
hqlzone() =>

    if barstate.islast

        var hqlzone dZone = hqlzone.new(
           box.new(
               na
             , na
             , na
             , na
             , bgcolor = color.new(toplvl, 70)
             , border_color = na
             )
         , box.new(
               na
             , na
             , na
             , na
             , bgcolor = color.new(midlvl, 70)
             , border_color = na
             )
         , box.new(
               na
             , na
             , na
             , na
             , bgcolor = color.new(btmlvl, 70)
             , border_color = na
             )

         , label.new(na, na, text = "Premium"    , color = invcol, textcolor = toplvl, style = label.style_label_down, size = size.small)
         , label.new(na, na, text = "Equilibrium", color = invcol, textcolor = midlvl, style = label.style_label_left, size = size.small)
         , label.new(na, na, text = "Discount"   , color = invcol, textcolor = btmlvl, style = label.style_label_up  , size = size.small)
         )

        dZone.pbx.set_lefttop(int(math.max(phl.topx, phl.bottomx))                          , phl.tup)
        dZone.pbx.set_rightbottom(b.n + 50                        , 0.95  * phl.tup + 0.05  * phl.tdn)

        dZone.ebx.set_lefttop(int(math.max(phl.topx, phl.bottomx)), 0.525 * phl.tup + 0.475 * phl.tdn)
        dZone.ebx.set_rightbottom(b.n + 50                        , 0.525 * phl.tdn + 0.475 * phl.tup)

        dZone.lbx.set_lefttop(int(math.max(phl.topx, phl.bottomx)), 0.95  * phl.tdn + 0.05  * phl.tup)
        dZone.lbx.set_rightbottom(b.n + 50                                                  , phl.tdn)

        dZone.plb.set_xy( int(math.avg(math.max(phl.topx, phl.bottomx), int(b.n + 50))) , phl.tup)
        dZone.elb.set_xy( int(b.n + 50)                                                 , math.avg(phl.tup, phl.tdn))
        dZone.lbl.set_xy( int(math.avg(math.max(phl.topx, phl.bottomx), int(b.n + 50))) , phl.tdn)

             
if show_mtb

    upphl (trend)
    dnphl (trend)
    hqlzone()


// # ========================================================================= #
//                        Money Moves [Channel Balance]
// # ========================================================================= #

// Money Moves [Tool Kit Premium] Color Scheme
colors = input.string(title='Color Scheme', defval='DARK', options=['DARK', 'LIGHT'] , group="Money Moves [Tool Kit Premium]")
bullcolor = colors == 'DARK' ? #00DBFF : color.rgb(0, 255, 8) 
bearcolor = colors == 'DARK' ? #E91E63 : color.rgb(255, 0, 0)

// Get user input
channelBal  = input.bool(false, " Show Channel Balance" , tooltip = "Enable Money Moves [Channel Balance] " , group = "Money Moves [Channel Balance]")
channelSensi  = input.float(1.0, "Channel Balance  Sensitivity", 0.5, 3.0 , group="Money Moves [Channel Balance]")

// Get Components
ocAvg1       = math.avg(open, close)
sma1        = ta.sma(close, 5 )
sma22        = ta.sma(close, 6)
sma3        = ta.sma(close, 7)
sma41        = ta.sma(close, 8)
sma51        = ta.sma(close, 9)
sma6        = ta.sma(close, 10)
sma7        = ta.sma(close, 11)
sma8        = ta.sma(close, 12)
sma91        = ta.sma(close, 13)
sma10       = ta.sma(close, 14)
sma11       = ta.sma(close, 15)
sma12       = ta.sma(close, 16)
sma13       = ta.sma(close, 17)
sma14       = ta.sma(close, 18)
sma15       = ta.sma(close, 19)
sma16       = ta.sma(close, 20)

[middleKC1, upperKC1, lowerKC1] = ta.kc(close, 80, 10.5 * channelSensi)
[middleKC2, upperKC2, lowerKC2] = ta.kc(close, 80, 9.5 * channelSensi)
[middleKC3, upperKC3, lowerKC3] = ta.kc(close, 80, 8 * channelSensi)
[middleKC4, upperKC4, lowerKC4] = ta.kc(close, 80, 3 * channelSensi)

// Colors
cyan1       = color.rgb(0, 196, 226), cyan2   = bullcolor
pink1         = #bd104a, pink2     = bearcolor

// Plots
k1 = plot(ta.ema(upperKC1, 50), "", na, editable=false)
k2 = plot(ta.ema(upperKC2, 50), "", na, editable=false)
k3 = plot(ta.ema(upperKC3, 50), "", na, editable=false)
k4 = plot(ta.ema(upperKC4, 50), "", na, editable=false)
k5 = plot(ta.ema(lowerKC4, 50), "", na, editable=false)
k6 = plot(ta.ema(lowerKC3, 50), "", na, editable=false)
k7 = plot(ta.ema(lowerKC2, 50), "", na, editable=false)
k8 = plot(ta.ema(lowerKC1, 50), "", na, editable=false)
fill(k1, k2, channelBal  ? color.new(pink2, 40) : na, editable=false)
fill(k2, k3, channelBal ? color.new(pink2, 65) : na, editable=false)
fill(k3, k4, channelBal  ? color.new(pink2, 90) : na, editable=false)
fill(k5, k6, channelBal ? color.new(cyan2, 90) : na, editable=false)
fill(k6, k7, channelBal  ? color.new(cyan2, 65) : na, editable=false)
fill(k7, k8, channelBal ? color.new(cyan2, 40) : na, editable=false)


//-----------------------------------------------------------------------------
// Trendlines with Breaks [LuxAlgo]
//-----------------------------------------------------------------------------

// TRENDLINES
trendlines = "Trendlines with Breaks [LuxAlgo]"

// TRENDLINES COLORS
upCss = input.color(color.teal, 'Up Trendline Color', group = 'trendlines')
dnCss = input.color(color.red, 'Down Trendline Color', group = 'trendlines')
showExt = input(true, 'Show Extended Lines')

//Settings
length1 = input.int(14, 'Swing Detection Lookback')
mult = input.float(1., 'Slope', minval = 0, step = .1)
calcMethod = input.string('Atr', 'Slope Calculation Method', options = ['Atr','Stdev','Linreg'])
backpaint = input(true, tooltip = 'Backpainting offset displayed elements in the past. Disable backpainting to see real time information returned by the indicator.')

//Calculations
var upper1 = 0.
var lower1 = 0.
var slope_ph2 = 0.
var slope_pl2 = 0.

var offset = backpaint ? length1 : 0

n1 = bar_index
src1 = close

ph2 = ta.pivothigh(length1, length1)
pl2 = ta.pivotlow(length1, length1)

//Slope Calculation Method
slope = switch calcMethod
    'Atr'    => ta.atr(length1) / length1 * mult
    'Stdev'  => ta.stdev(src1,length1) / length1 * mult
    'Linreg' => math.abs(ta.sma(src1 * n1, length1) - ta.sma(src1, length1) * ta.sma(n1, length1)) / ta.variance(n1, length1) / 2 * mult

//Get slopes and calculate trendlines
slope_ph2 := ph2 ? slope : slope_ph2
slope_pl2 := pl2 ? slope : slope_pl2

upper1 := ph2 ? ph2 : upper1 - slope_ph2
lower1 := pl2 ? pl2 : lower1 + slope_pl2

var upos = 0
var dnos = 0
upos := ph2 ? 0 : close > upper1 - slope_ph2 * length1 ? 1 : upos
dnos := pl2 ? 0 : close < lower1 + slope_pl2 * length1 ? 1 : dnos

//Extended Lines
var uptl  = line.new(na,na,na,na, color = upCss, style = line.style_dashed, extend = extend.right)
var dntl  = line.new(na,na,na,na, color = dnCss, style = line.style_dashed, extend = extend.right)

if ph2 and showExt
    uptl.set_xy1(n1-offset, backpaint ? ph1 : upper1 - slope_ph2 * length1)
    uptl.set_xy2(n1-offset+1, backpaint ? ph1 - slope : upper1 - slope_ph2 * (length1+1))

if pl2 and showExt
    dntl.set_xy1(n1-offset, backpaint ? pl2 : lower1 + slope_pl2 * length1)
    dntl.set_xy2(n1-offset+1, backpaint ? pl2 + slope : lower1 + slope_pl2 * (length1+1))

//Plots
plot(backpaint ? upper1 : upper1 - slope_ph2 * length1, 'Upper', color = ph2 ? na : upCss, offset = -offset)
plot(backpaint ? lower1 : lower1 + slope_pl2 * length1, 'Lower', color = pl2 ? na : dnCss, offset = -offset)

//Breakouts
plotshape(upos > upos[1] ? low : na, "Upper Break"
  , shape.labelup
  , location.absolute
  , upCss
  , text = "B"
  , textcolor = color.white
  , size = size.tiny)

plotshape(dnos > dnos[1] ? high : na, "Lower Break"
  , shape.labeldown
  , location.absolute
  , dnCss
  , text = "B"
  , textcolor = color.white
  , size = size.tiny)


//Alerts
alertcondition(upos > upos[1], 'Upward Breakout', 'Price broke the down-trendline upward')
alertcondition(dnos > dnos[1], 'Downward Breakout', 'Price broke the up-trendline downward')
//END TrendLines with Breaks----------------------------------------------------------------}


var tLog = table.new(position = position.bottom_left, rows = 1, columns = 2, border_width=-6)
table.cell(tLog, row = 0, column = 0, text = " PIEKI ", text_size=size.normal, text_color = #ffffff)
table.cell(tLog, row = 0, column = 1, text = "ALGO ", text_size=size.normal, text_color = #00def6)

//END Strategy ---------------------------