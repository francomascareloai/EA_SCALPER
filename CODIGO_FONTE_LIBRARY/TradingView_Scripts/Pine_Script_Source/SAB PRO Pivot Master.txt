//@version=5
indicator('SAB PRO Pivot Master', shorttitle='Pivot Master', overlay=true)

length = input(title='Length', defval=14)
src = input(title='Source', defval=hlc3)
obLevel = input(title='OB Level', defval=70)
osLevel = input(title='OS Level', defval=30)
highlightBreakouts = input(title='Highlight Overbought/Oversold Breakouts ?', defval=false)

f8 = 100 * src
f10 = nz(f8[1])
v8 = f8 - f10

f18 = 3 / (length + 2)
f20 = 1 - f18

f28 = 0.0
f28 := f20 * nz(f28[1]) + f18 * v8

f30 = 0.0
f30 := f18 * f28 + f20 * nz(f30[1])
vC = f28 * 1.5 - f30 * 0.5

f38 = 0.0
f38 := f20 * nz(f38[1]) + f18 * vC

f40 = 0.0
f40 := f18 * f38 + f20 * nz(f40[1])
v10 = f38 * 1.5 - f40 * 0.5

f48 = 0.0
f48 := f20 * nz(f48[1]) + f18 * v10

f50 = 0.0
f50 := f18 * f48 + f20 * nz(f50[1])
v14 = f48 * 1.5 - f50 * 0.5

f58 = 0.0
f58 := f20 * nz(f58[1]) + f18 * math.abs(v8)

f60 = 0.0
f60 := f18 * f58 + f20 * nz(f60[1])
v18 = f58 * 1.5 - f60 * 0.5

f68 = 0.0
f68 := f20 * nz(f68[1]) + f18 * v18

f70 = 0.0
f70 := f18 * f68 + f20 * nz(f70[1])
v1C = f68 * 1.5 - f70 * 0.5

f78 = 0.0
f78 := f20 * nz(f78[1]) + f18 * v1C

f80 = 0.0
f80 := f18 * f78 + f20 * nz(f80[1])
v20 = f78 * 1.5 - f80 * 0.5

f88_ = 0.0
f90_ = 0.0

f88 = 0.0
f90_ := nz(f90_[1]) == 0 ? 1 : nz(f88[1]) <= nz(f90_[1]) ? nz(f88[1]) + 1 : nz(f90_[1]) + 1
f88 := nz(f90_[1]) == 0 and length - 1 >= 5 ? length - 1 : 5

f0 = f88 >= f90_ and f8 != f10 ? 1 : 0
f90 = f88 == f90_ and f0 == 0 ? 0 : f90_

v4_ = f88 < f90 and v20 > 0 ? (v14 / v20 + 1) * 50 : 50
rsx = v4_ > 100 ? 100 : v4_ < 0 ? 0 : v4_

rsxColor = rsx > obLevel ? #0ebb23 : rsx < osLevel ? #ff0000 : #512DA8
//plot(rsx, title='RSX', linewidth=2, color=rsxColor, transp=0)

transparent = color.new(color.white, 100)

//maxLevelPlot = hline(100, title='Max Level', linestyle=hline.style_dotted, color=transparent)
//obLevelPlot = hline(obLevel, title='Overbought Level', linestyle=hline.style_dotted)
//hline(50, title='Middle Level', linestyle=hline.style_dotted)
//osLevelPlot = hline(osLevel, title='Oversold Level', linestyle=hline.style_dotted)
//minLevelPlot = hline(0, title='Min Level', linestyle=hline.style_dotted, color=transparent)

//fill(obLevelPlot, osLevelPlot, color=color.new(color.purple, 95))

obFillColor = rsx > obLevel and highlightBreakouts ? color.green : transparent
osFillColor = rsx < osLevel and highlightBreakouts ? color.red : transparent

//fill(maxLevelPlot, obLevelPlot, color=obFillColor, transp=90)
//fill(minLevelPlot, osLevelPlot, color=osFillColor, transp=90)

piv = input(false, 'Hide pivots?')
shrt = input(false, 'Shorter labels?')
xbars = input.int(90, 'Div lookback period (bars)?', minval=1)
hb = math.abs(ta.highestbars(rsx, xbars))  // Finds bar with highest value in last X bars
lb = math.abs(ta.lowestbars(rsx, xbars))  // Finds bar with lowest value in last X bars
max = float(na)
max_rsi = float(na)
min = float(na)
min_rsi = float(na)
pivoth = bool(na)
pivotl = bool(na)
divbear = bool(na)
divbull = bool(na)

// If bar with lowest / highest is current bar, use it's value
max := hb == 0 ? close : na(max[1]) ? close : max[1]
max_rsi := hb == 0 ? rsx : na(max_rsi[1]) ? rsx : max_rsi[1]
min := lb == 0 ? close : na(min[1]) ? close : min[1]
min_rsi := lb == 0 ? rsx : na(min_rsi[1]) ? rsx : min_rsi[1]

// Compare high of current bar being examined with previous bar's high
// If curr bar high is higher than the max bar high in the lookback window range
if close > max  // we have a new high
    max := close  // change variable "max" to use current bar's high value
    max
if rsx > max_rsi  // we have a new high
    max_rsi := rsx  // change variable "max_rsi" to use current bar's RSI value
    max_rsi
if close < min  // we have a new low
    min := close  // change variable "min" to use current bar's low value
    min
if rsx < min_rsi  // we have a new low
    min_rsi := rsx  // change variable "min_rsi" to use current bar's RSI value
    min_rsi

// Finds pivot point with at least 2 right candles with lower value
pivoth := max_rsi == max_rsi[2] and max_rsi[2] != max_rsi[3] ? true : na
pivotl := min_rsi == min_rsi[2] and min_rsi[2] != min_rsi[3] ? true : na

// Detects divergences between price and indicator with 1 candle delay so it filters out repeating divergences
if max[1] > max[2] and rsx[1] < max_rsi and rsx <= rsx[1]
    divbear := true
    divbear
if min[1] < min[2] and rsx[1] > min_rsi and rsx >= rsx[1]
    divbull := true
    divbull

// Alerts
alertcondition(divbear, title='Bear div', message='Bear div')
alertcondition(divbull, title='Bull div', message='Bull div')

// Plots divergences and pivots with offest
// Longer labels
plotshape(shrt ? na : divbear ? rsx[1] + 1 : na, location=location.abovebar, style=shape.circle, color=color.new(#f7f320, 0), size=size.tiny, textcolor=color.new(color.white, 0), offset=-1)
plotshape(shrt ? na : divbull ? rsx[1] - 1 : na, location=location.belowbar, style=shape.circle, color=color.new(#e2f72a, 0), size=size.tiny, textcolor=color.new(color.white, 0), offset=-1)
plotshape(piv ? na : shrt ? na : pivoth ? max_rsi + 1 : na, location=location.abovebar, style=shape.circle, color=color.new(#def321, 0), size=size.small, textcolor=color.new(color.white, 0), offset=-2)
plotshape(piv ? na : shrt ? na : pivotl ? min_rsi - 1 : na, location=location.belowbar, style=shape.circle, color=color.new(#e5f321, 0), size=size.small, textcolor=color.new(color.white, 0), offset=-2)

// Shorter labels
//plotshape(shrt ? divbear ? rsx[1] + 3 : na : na, location=location.abovebar, style=shape.triangledown, color=color.new(color.red, 0), size=size.tiny, offset=-1)
//plotshape(shrt ? divbull ? rsx[1] - 3 : na : na, location=location.belowbar, style=shape.triangleup, color=color.new(color.green, 0), size=size.tiny, offset=-1)
//plotshape(piv ? na : shrt ? pivoth ? max_rsi + 3 : na : na, location=location.abovebar, style=shape.triangledown, color=color.new(color.blue, 0), size=size.tiny, offset=-2)
//plotshape(piv ? na : shrt ? pivotl ? min_rsi - 3 : na : na, location=location.belowbar, style=shape.triangleup, color=color.new(color.blue, 0), size=size.tiny, offset=-2)
//@version=5
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//indicator('Phoenix Ascending', overlay=true)

// Sources:
src0 = open
src1 = high
src2 = low
src3 = close
src4 = hl2
src5 = hlc3
src6 = ohlc4
src7 = ta.tr
vol = volume

// Inputs:
n1 = input(9, 'Phx master')
n2 = input(6, 'Phx time 1')
n3 = input(3, 'Phx time 2')

// 4 principal components: tci, mf, willy, csi
tci(src) =>
    ta.ema((src - ta.ema(src, n1)) / (0.025 * ta.ema(math.abs(src - ta.ema(src, n1)), n1)), n2) + 50

mf(src) =>
    100.0 - 100.0 / (1.0 + math.sum(volume * (ta.change(src) <= 0 ? 0 : src), n3) / math.sum(volume * (ta.change(src) >= 0 ? 0 : src), n3))

willy(src) =>
    60 * (src - ta.highest(src, n2)) / (ta.highest(src, n2) - ta.lowest(src, n2)) + 80

csi(src) =>
    math.avg(ta.rsi(src, n3), ta.tsi(src0, n1, n2) * 50 + 50)

// "Phoenix Ascending" average of tci, csi, mf, willy:
phoenix(src) =>
    math.avg(tci(src), csi(src), mf(src), willy(src))

// "Tradition" average of tci, mf, rsi
tradition(src) =>
    math.avg(tci(src), mf(src), ta.rsi(src, n3))

wt1 = tradition(src5)
wt2 = ta.sma(wt1, 6)

ext1 = wt2 < 20 ? wt2 + 5 : wt2 > 80 ? wt2 - 5 : na

//plot(ext1 ? ext1 : na, 'Pressure', color=color.new(color.orange, 0), style=plot.style_circles, linewidth=2)

plotshape(ext1 ? wt2 < 20 ? wt2 + 5 : na : na, title="Caution", color=color.rgb(250, 236, 37),  style=shape.circle, location=location.belowbar)
plotshape(ext1 ? wt2 > 80 ? wt2 - 5 : na : na, title="Caution", color=color.rgb(253, 231, 30),  style=shape.circle, location=location.abovebar)
// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ozerolupa

//@version=5
//indicator("My script", overlay=true)
sensitivity = input.float(4, "SENSITIVITY (1-20)", 0.1, 10)


//FUNCTIONS
smoothrng(x, t, m) =>
    wper = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    smoothrng = ta.ema(avrng, wper) * m
rngfilt(x, r) =>
    rngfilt = x
    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r
f_top_fractal(src) => src[4] < src[2] and src[3] < src[2] and src[2] > src[1] and src[2] > src[0]
f_bot_fractal(src) => src[4] > src[2] and src[3] > src[2] and src[2] < src[1] and src[2] < src[0]
f_fractalize (src) => f_top_fractal(src) ? 1 : f_bot_fractal(src) ? -1 : 0
f_findDivs(src, topLimit, botLimit) =>
    fractalTop = f_fractalize(src) > 0 and src[2] >= topLimit ? src[2] : na
    fractalBot = f_fractalize(src) < 0 and src[2] <= botLimit ? src[2] : na
    highPrev = ta.valuewhen(fractalTop, src[2], 0)[2]
    highPrice = ta.valuewhen(fractalTop, high[2], 0)[2]
    lowPrev = ta.valuewhen(fractalBot, src[2], 0)[2]
    lowPrice = ta.valuewhen(fractalBot, low[2], 0)[2]
    bearSignal = fractalTop and high[1] > highPrice and src[1] < highPrev
    bullSignal = fractalBot and low[1] < lowPrice and src[1] > lowPrev
    [bearSignal, bullSignal]

f_kc(src, len, sensitivity) =>
    basis = ta.sma(src, len)
    span  = ta.atr(len)
    [basis + span * sensitivity, basis - span * sensitivity]

wavetrend(src, chlLen, avgLen) =>
    esa = ta.ema(src, chlLen)
    d = ta.ema(math.abs(src - esa), chlLen)
    ci = (src - esa) / (0.015 * d)
    wt11 = ta.ema(ci, avgLen)
    wt22 = ta.sma(wt11, 3)
    [wt11, wt22]

[wt11, wt22] = wavetrend(close, 5, 10)
[wtDivBear1, wtDivBull1] = f_findDivs(wt22, 10, -35)
[wtDivBear2, wtDivBull2] = f_findDivs(wt22, 40, -70)
wtDivBull = wtDivBull1 or wtDivBull2
wtDivBear = wtDivBear1 or wtDivBear2

plotshape(ta.crossover (wt11, wt22) and wt22 <= -60, "DON'T SELL/BOTTOM" , shape.circle, location.belowbar, color(#00ddf63f), size=size.normal)
plotshape(ta.crossunder(wt11, wt22) and wt22 >=  60, "DON'T BUY/TOP"     , shape.circle, location.abovebar, color(#00ddf63b), size=size.normal)
//END OF DIVERGANCE
// © weeklystockcharts

// Candle Type w/ only 3-1 Pine Script

//study("Candle Type w/only 3-1", overlay=true, precision=0)

// check for 3-1 inside + up buy
buyx = high[3] < high[2] and low[3] > low[2] and high[1] < high[2] and low[1] > low[2] and high > high[1] and high[1] <= high[2] and low[1] >= low[2] and not(low < low[1])
plotchar(buyx, title='Inside + Up Buy Label', location=location.belowbar,  size=size.tiny, color=color.new(#4CAF50, 0))

// check for 3-1 inside + dn sell
sellx = high[3] < high[2] and low[3] > low[2] and high[1] < high[2] and low[1] > low[2] and low < low[1] and low[1] >= low[2] and high[1] <= high[2] and not(high > high[1])
plotchar(sellx, title='Inside + Up Buy Label', location=location.abovebar, size=size.tiny, color=color.new(color.red, 0))
//end of this part


// © cyatophilum


//@version=5
//indicator("My script", overlay=true)
//-----------------------------------------------------------------------------///
TD = 0
TD := close > close[4] ? nz(TD[1])+1 : 0
TDUp = TD - ta.valuewhen(TD < TD[1], TD, 1)

plotshape(TDUp==7?true:na,style=shape.triangledown, color=color.rgb(218, 47, 70, 66), text="7",textcolor=color.rgb(239, 245, 243), location=location.abovebar)
plotshape(TDUp==8?true:na,style=shape.triangledown, color=color.rgb(233, 34, 44, 71), text="8",textcolor=color.rgb(234, 243, 243), location=location.abovebar)
plotshape(TDUp==9?true:na,style=shape.triangledown, color=color.rgb(250, 69, 69, 64), text="⛔️",textcolor=color.red, location=location.abovebar)

TS = 0
TS := close < close[4] ? nz(TS[1])+1 : 0
TDDn = TS - ta.valuewhen(TS < TS[1], TS, 1)

plotshape(TDDn==7?true:na,style=shape.triangleup, color=color.rgb(19, 224, 46, 60), text="7",textcolor=color.rgb(240, 243, 243), location=location.belowbar)
plotshape(TDDn==8?true:na,style=shape.triangleup, color=color.rgb(20, 173, 79, 60), text="8",textcolor=color.rgb(229, 237, 238), location=location.belowbar)
plotshape(TDDn==9?true:na,style=shape.triangleup, color=color.rgb(76, 175, 79, 57),text="✅",textcolor=color.green, location=location.belowbar)

//----------------------------------------------------------------------------------------------------///
bb_input = input.int(20, title = "BB Length")
std_dev = input.float(2.0, title = "BB StdDev")
rsi_input = input.int(14, title = "RSI Length")
sto_input = input.int(14, title = "STO Length")
sma_input = input.int(3, title = "SMA Length")
basis = ta.sma(close, bb_input)
dev = std_dev * ta.stdev(close, bb_input)
upper = basis + dev
lower = basis - dev
rsi33 = ta.rsi(close, rsi_input)
stoch = ta.stoch(rsi33, rsi33, rsi33, sto_input)
sma = ta.sma(stoch, sma_input)
upper_limit = input.float(80, title="Upper Limit")
lower_limit = input.float(20, title="Lower Limit")
bull22 = close[1] < lower[1] and close > lower and sma[1] < lower_limit
bear11 = close[1] > upper[1] and close < upper and sma[1] > upper_limit
plotshape(bull22, title="Buy",style=shape.circle, color=color.rgb(238, 36, 228, 44), location=location.belowbar, size=size.small) //text='🛫'
plotshape(bear11, title="Sell", style=shape.circle, color=color.rgb(218, 44, 241, 43), location=location.abovebar, size=size.small) //text='🛬️'
alertcondition(bull22, title="Buy", message="Buy Signal!")
alertcondition(bear11, title="Sell", message="Sell Signal!")


//@version=5
//indicator("My script", overlay=true)
////////////////////////////////
///// RSI EXTREME
//////////////////////////////
RSIEswitch = input.bool (true, "RSI Extremes")
G_RSIExtreme = "████████RSI EXTREME████████"

RSIPeriodExtreme = input.int(14, title='Period', step=1, minval=1, group=G_RSIExtreme, inline='RSIE1')
RSISourceExtreme = input(title='Source', defval=close, group=G_RSIExtreme, inline='RSIE')
RSIlabelSizeExtreme = input.string('Small', 'Label Size', options = ['Tiny', 'Small', 'Normal', 'Large'], group=G_RSIExtreme, inline='RSIE')
OversoldForRSIExtreme = input.int(30, title='Oversold Level', maxval=100, minval=1, step=1, group=G_RSIExtreme, inline='RSIE2')
OverboughtForRSIExtreme = input.int(70, title='Overbought Level', maxval=100, minval=1, step=1, group=G_RSIExtreme, inline='RSIE2')

RSIExtreme = ta.rsi(RSISourceExtreme, RSIPeriodExtreme)

sizerLabel = switch RSIlabelSizeExtreme
    'Normal'  => size.normal
    'Tiny'    => size.tiny
    'Small'   => size.small
    'Large'   => size.large

bool IsOversoldForRSIExtreme = false
bool IsOverboughtForRSIExtreme = false

if RSIExtreme <= OversoldForRSIExtreme and RSIEswitch
    label lup = label.new(bar_index, na, str.tostring(int(RSIExtreme)), color=color.new(color.lime, 0), textcolor=color.rgb(141, 141, 141), style=label.style_arrowup, size=sizerLabel, yloc=yloc.belowbar)
    IsOversoldForRSIExtreme := true
    if RSIExtreme <= OversoldForRSIExtreme and RSIExtreme[1] <= OversoldForRSIExtreme
        if low[1] > low
            if RSIExtreme[1] <= RSIExtreme 
                label.delete(lup[1])
        if low[1] > low
            if RSIExtreme[1] >= RSIExtreme 
                label.delete(lup[1])
        if low[1] < low        
            if RSIExtreme[1] >= RSIExtreme    
                label.delete(lup)
        if low[1] < low        
            if RSIExtreme[1] <= RSIExtreme    
                label.delete(lup)
    if RSIExtreme <= OversoldForRSIExtreme and RSIExtreme[2] <= OversoldForRSIExtreme
        if low[2] > low
            if RSIExtreme[2] <= RSIExtreme 
                label.delete(lup[2])
        if low[2] > low
            if RSIExtreme[2] >= RSIExtreme 
                label.delete(lup[2])
        if low[2] < low        
            if RSIExtreme[2] >= RSIExtreme    
                label.delete(lup)
        if low[2] < low        
            if RSIExtreme[2] <= RSIExtreme    
                label.delete(lup)                  

if RSIExtreme >= OverboughtForRSIExtreme and RSIEswitch
    label ldw = label.new(bar_index, na, str.tostring(int(RSIExtreme)), color=color.new(color.red, 0), textcolor=color.rgb(141, 141, 141), style=label.style_arrowdown, size=sizerLabel, yloc=yloc.abovebar)
    IsOverboughtForRSIExtreme := true
    if RSIExtreme >= OverboughtForRSIExtreme and RSIExtreme[1] >= OverboughtForRSIExtreme
        if high[1] < high
            if RSIExtreme[1] <= RSIExtreme 
                label.delete(ldw[1])
        if high[1] < high
            if RSIExtreme[1] >= RSIExtreme 
                label.delete(ldw[1])
        if high[1] > high        
            if RSIExtreme[1] >= RSIExtreme    
                label.delete(ldw)
        if high[1] > high        
            if RSIExtreme[1] <= RSIExtreme    
                label.delete(ldw)

    if RSIExtreme >= OverboughtForRSIExtreme and RSIExtreme[2] >= OverboughtForRSIExtreme
        if high[2] < high
            if RSIExtreme[2] <= RSIExtreme 
                label.delete(ldw[2])
        if high[2] < high
            if RSIExtreme[1] >= RSIExtreme 
                label.delete(ldw[2])
        if high[2] > high        
            if RSIExtreme[2] >= RSIExtreme    
                label.delete(ldw)
        if high[2] > high        
            if RSIExtreme[2] <= RSIExtreme    
                label.delete(ldw)

alertcondition(IsOversoldForRSIExtreme and IsOverboughtForRSIExtreme, 'Extreme RSI Overbought-Oversold Call', 'Extreme RSI Overbought-Oversold Call found SZ')
// This Pine Scriptô code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © forexninja69
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ahmedirshad419

//@version=5
//indicator('EngulfingCandle', overlay=true)
bullishCandle6 = close >= open[1] and close[1] < open[1]  //and high >= high[1] and low <= low[1]
bearishCandle6 = close <= open[1] and close[1] > open[1]  //and high > high[1] and low < low[1]
// RSI integration
rsiSource = input(title='rsiSource', defval=close)
rsiLenghth6 = input(title='rsi length', defval=14)
rsiOverBought6 = input(title='rsi overbought level', defval=70)
rsiOverSold6 = input(title='rsi over sold level', defval=30)
//rsiOverBoughtThreshold=input(title="rsiOBThreshold level", type=input.integer, defval=97)
//rsiOverSoldThreshold=input(title="rsiOSThreshold level", type=input.integer, defval=18)
//get RSI value
rsiValue6 = ta.rsi(rsiSource, rsiLenghth6)
isRSIOB6 = rsiValue6 >= rsiOverBought6 and rsiValue6
isRSIOS6 = rsiValue6 <= rsiOverSold6 and rsiValue6

tradeSignal6 = (isRSIOS6 or isRSIOS6[1] or isRSIOS6[2]) and bullishCandle6 or (isRSIOB6 or isRSIOB6[1] or isRSIOB6[2]) and bearishCandle6
//plot on chart
plotshape(tradeSignal6 and bullishCandle6, title='bullish', location=location.belowbar, color=color.new(#eef1f1, 61), style=shape.circle, size=size.small)
plotshape(tradeSignal6 and bearishCandle6, title='bearish', location=location.abovebar, color=color.new(#edf3f3, 62), style=shape.circle, size=size.small)
// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © VanHe1sing   
//@version=5
//indicator("MyPivot", "My Pivots", overlay=true, max_lines_count=500, max_labels_count=500)



ema200 = ta.ema(close, 200)
ema100 = ta.ema(close, 100)
ema50 = ta.ema(close, 50) 
ema20 = ta.ema(close, 20)

crossoverb=ta.crossover(ema20,ema200 )
downb=ta.crossunder(ema20,ema200)

plotshape(crossoverb,  title = "XX", style = shape.circle,   location = location.belowbar, color=color.rgb(19, 224, 46, 60), textcolor = color.white, size = size.large)
plotshape(downb, title = "XXX", style = shape.circle, location = location.abovebar, color=color.rgb(240, 23, 23, 60),   textcolor = color.white, size = size.large)

//@version=5
// @author seiglerj
// MFI indicator based on LazyBear's MFI/RSI indicator
// 
// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/


//@version=5
//indicator(title="WaveTrend-CCI-RSI-MACD-DEMA-Volume Momentum", shorttitle="Geliştirilmiş WT Stratejisi", overlay=true)

// WaveTrend Stratejisi Parametreleri
altBant = input(-60, title="Alt Bant")
ustBant = input(60, title="Üst Bant")
wtUzunluk = input(10, title="WT Uzunluk")
kanalUzunlugu = input(21, title="Kanal Uzunluğu")
ortalamaUzunluk = input(34, title="Ortalama Uzunluk")

// CCI Parametreleri
cciUzunluk = input(14, title="CCI Uzunlugu")
cciAsiriAlim = input(100, title="CCI Asiri Alim")
cciAsiriSatim = input(-100, title="CCI Asiri Satim")

// RSI Parametreleri
rsiUzunluk = input(14, title="RSI Uzunlugu")
rsiAlimSeviyesi = input(30, title="RSI Alim Seviyesi")
rsiSatimSeviyesi = input(70, title="RSI Satim Seviyesi")

// MACD Parametreleri
macdUzunluk = input(12, title="MACD Uzunluk")
macdHizliUzunluk = input(26, title="MACD Hızlı Uzunluk")
macdSignalUzunluk = input(9, title="MACD Sinyal Uzunluk")

// Hesaplamalar
src67 = close
esa = ta.ema(src67, wtUzunluk)
d = ta.ema(math.abs(src67 - esa), wtUzunluk)
ci = (src67 - esa) / (0.015 * d)
tci = ta.ema(ci, kanalUzunlugu)
wt111 = ta.sma(tci, ortalamaUzunluk)

cci = ta.cci(src67, cciUzunluk)
rsi = ta.rsi(src67, rsiUzunluk)

// MACD Hesaplama
[macdLine, signalLine, _] = ta.macd(src67, macdUzunluk, macdHizliUzunluk, macdSignalUzunluk)

// Alim ve Satim Sinyalleri
alSinyali = (tci < altBant) and (cci < cciAsiriSatim) and (rsi < rsiAlimSeviyesi) and (macdLine < signalLine) 
satSinyali = (tci > ustBant) and (cci > cciAsiriAlim) and (rsi > rsiSatimSeviyesi) and (macdLine > signalLine) 

// Alim ve Satim Sinyallerine Göre İkonlar
plotshape(series=alSinyali, title="Al Sinyali", style=shape.circle, location=location.belowbar, color=color.green, size=size.small)
plotshape(series=satSinyali, title="Sat Sinyali", style=shape.circle, location=location.abovebar, color=color.red, size=size.small)
// © informanerd
//@version=5

//indicator("Hybrid Overbought/Oversold Overlay", "Hyb.OB/OS", true)

// inputs & definitions {

pos1 = "Top Left", pos2 = "Top Center", pos3 = "Top Right"
pos4 = "Middle Left", pos5 = "Middle Center", pos6 = "Middle Right"
pos7 = "Bottom Left", pos8 = "Bottom Center", pos9 = "Bottom Right"

sc1 = "Price Pass Signal Levels"
sc2 = "Price Come Back before Signal Levels"

hybSrc = input.source(close, "Source", inline = "hyb")
hybLen = input.int(14, "                        Length", 1, inline = "hyb")
diagramPos = input.string(pos6, "Diagram Position                                              ", [pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, pos9], display = display.data_window)
tableLen = input.int(30, "Diagram Bars →", 1, inline = "hybBars")
cellSize = input.float(.3, "     Thickness:", 0, step = .1, inline = "hybBars")
obColor = input.color(color.red, "Colors →   OB:", inline = "hybColor")
osColor = input.color(color.green, "  OS:", inline = "hybColor")
curBarObColor = input.color(color.white, "     Current Bar:", inline = "hybColor")
curBarOsColor = input.color(color.white, "", inline = "hybColor")
showSignal = input.bool(true, "Show Signals →", inline = "hybSignal")
signalC = input.string(sc2, "                         Condition:", [sc1, sc2], inline = "hybSignal", display = display.data_window)
hybOsManual = input.int(0, "Signal Levels →   OS:", 0, 100, inline = "hybLevel")
hybObManual = input.int(100, "  OB:", 0, 100, tooltip = "(0, 100) = Auto.", inline = "hybLevel")

signalCondition = signalC == sc1 ? 1 : 2
oscCount = 12
maxArraySize = 100000

tablePos = switch diagramPos
    pos1 => position.top_left
    pos2 => position.top_center
    pos3 => position.top_right
    pos4 => position.middle_left
    pos5 => position.middle_center
    pos6 => position.middle_right
    pos7 => position.bottom_left
    pos8 => position.bottom_center
    pos9 => position.bottom_right
var table hybTable = table.new(tablePos, tableLen + 1, oscCount * 2 + 1, na, chart.fg_color, 1)
hybTable.merge_cells(tableLen - 1, oscCount, tableLen, oscCount)

var bObSum = array.new_int()
var bOsSum = array.new_int()
if array.size(bObSum) == maxArraySize
    array.shift(bObSum)
if array.size(bOsSum) == maxArraySize
    array.shift(bOsSum)
var cciObSum = array.new_int()
var cciOsSum = array.new_int()
if array.size(cciObSum) == maxArraySize
    array.shift(cciObSum)
if array.size(cciOsSum) == maxArraySize
    array.shift(cciOsSum)
var cmfObSum = array.new_int()
var cmfOsSum = array.new_int()
if array.size(cmfObSum) == maxArraySize
    array.shift(cmfObSum)
if array.size(cmfOsSum) == maxArraySize
    array.shift(cmfOsSum)
var cmoObSum = array.new_int()
var cmoOsSum = array.new_int()
if array.size(cmoObSum) == maxArraySize
    array.shift(cmoObSum)
if array.size(cmoOsSum) == maxArraySize
    array.shift(cmoOsSum)
var dixObSum = array.new_int()
var dixOsSum = array.new_int()
if array.size(dixObSum) == maxArraySize
    array.shift(dixObSum)
if array.size(dixOsSum) == maxArraySize
    array.shift(dixOsSum)
var kObSum = array.new_int()
var kOsSum = array.new_int()
if array.size(kObSum) == maxArraySize
    array.shift(kObSum)
if array.size(kOsSum) == maxArraySize
    array.shift(kOsSum)
var mfiObSum = array.new_int()
var mfiOsSum = array.new_int()
if array.size(mfiObSum) == maxArraySize
    array.shift(mfiObSum)
if array.size(mfiOsSum) == maxArraySize
    array.shift(mfiOsSum)
var rocObSum = array.new_int()
var rocOsSum = array.new_int()
if array.size(rocObSum) == maxArraySize
    array.shift(rocObSum)
if array.size(rocOsSum) == maxArraySize
    array.shift(rocOsSum)
var rsiObSum = array.new_int()
var rsiOsSum = array.new_int()
if array.size(rsiObSum) == maxArraySize
    array.shift(rsiObSum)
if array.size(rsiOsSum) == maxArraySize
    array.shift(rsiOsSum)
var rviObSum = array.new_int()
var rviOsSum = array.new_int()
if array.size(rviObSum) == maxArraySize
    array.shift(rviObSum)
if array.size(rviOsSum) == maxArraySize
    array.shift(rviOsSum)
var stoObSum = array.new_int()
var stoOsSum = array.new_int()
if array.size(stoObSum) == maxArraySize
    array.shift(stoObSum)
if array.size(stoOsSum) == maxArraySize
    array.shift(stoOsSum)
var tmfObSum = array.new_int()
var tmfOsSum = array.new_int()
if array.size(tmfObSum) == maxArraySize
    array.shift(tmfObSum)
if array.size(tmfOsSum) == maxArraySize
    array.shift(tmfOsSum)

var hybObSum = array.new_int()
var hybOsSum = array.new_int()
if array.size(hybObSum) == maxArraySize
    array.shift(hybObSum)
if array.size(hybOsSum) == maxArraySize
    array.shift(hybOsSum)

float hybrid = na

//}
// functions {

normal(s, min, max) =>
    var hMin = 1e11
    var hMax = -1e11
    hMin := math.min(nz(s, hMin), hMin)
    hMax := math.max(nz(s, hMax), hMax)
    min + (max - min) * (s - hMin) / math.max(hMax - hMin, 0)

graphs(src, len) =>
    b = normal((src - ta.sma(src, len) + ta.stdev(src, len)) / (2 * ta.stdev(src, len)), 0, 100)
    cci = normal(ta.cci(src, len), 0, 100)
    cmf = normal(math.sum((high == low) ? 0 : volume * (2 * src - low - high) / (high - low), len) / math.sum(volume, len), 0, 100)
    cmo = (ta.cmo(src, len) + 100) / 2
    dix = (((src - ta.sma(src, len)) / ta.sma(src, len) * 100) + 1) * 50
    k = normal((src - (ta.ema(src, len) - ta.atr(len))) / (2 * ta.atr(len)), 0, 100)
    mfi = ta.mfi(src, len)
    roc = normal(ta.roc(src, len), 0, 100)
    rsi = ta.rsi(src, len)
    rvi = ((math.sum(ta.swma(close - open), len) / math.sum(ta.swma(high - low), len)) + 1) * 50
    sto = ta.stoch(src, high, low, len)
    tmf = normal(ta.ema((((src - math.min(low, src[1])) - (math.max(high, src[1]) - src)) / (math.max(high, src[1]) - math.min(low, src[1]))) * volume, len) / ta.ema(volume, len), 0, 100)
    [b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf]

obos(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf, bOb, cciOb, cmfOb, cmoOb, dixOb, kOb, mfiOb, rocOb, rsiOb, rviOb, stoOb, tmfOb, bOs, cciOs, cmfOs, cmoOs, dixOs, kOs, mfiOs, rocOs, rsiOs, rviOs, stoOs, tmfOs) =>
    cnt = 0
    if b > bOb
        cnt += 1
    if b < bOs
        cnt -= 1
    if cci > cciOb
        cnt += 1
    if cci < cciOs
        cnt -= 1
    if cmf > cmfOb
        cnt += 1
    if cmf < cmfOs
        cnt -= 1
    if cmo > cmoOb
        cnt += 1
    if cmo < cmoOs
        cnt -= 1
    if dix > dixOb
        cnt += 1
    if dix < dixOs
        cnt -= 1
    if k > kOb
        cnt += 1
    if k < kOs
        cnt -= 1
    if mfi > mfiOb
        cnt += 1
    if mfi < mfiOs
        cnt -= 1
    if roc > rocOb
        cnt += 1
    if roc < rocOs
        cnt -= 1
    if rsi > rsiOb
        cnt += 1
    if rsi < rsiOs
        cnt -= 1
    if rvi > rviOb
        cnt += 1
    if rvi < rviOs
        cnt -= 1
    if sto > stoOb
        cnt += 1
    if sto < stoOs
        cnt -= 1
    if tmf > tmfOb
        cnt += 1
    if tmf < tmfOs
        cnt -= 1
    cnt * (50. / oscCount) + 50

levels(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf) =>
    if close < open and close[1] > open[1] and
     b[1] > 50 and cci[1] > 50 and cmf[1] > 50 and cmo[1] > 50 and
     dix[1] > 50 and k[1] > 50 and mfi[1] > 50 and roc[1] > 50 and
     rsi[1] > 50 and rvi[1] > 50 and sto[1] > 50 and tmf[1] > 50
        array.push(bObSum, math.ceil(b[1]))
        array.push(cciObSum, math.ceil(cci[1]))
        array.push(cmfObSum, math.ceil(cmf[1]))
        array.push(cmoObSum, math.ceil(cmo[1]))
        array.push(dixObSum, math.ceil(dix[1]))
        array.push(kObSum, math.ceil(k[1]))
        array.push(mfiObSum, math.ceil(mfi[1]))
        array.push(rocObSum, math.ceil(roc[1]))
        array.push(rsiObSum, math.ceil(rsi[1]))
        array.push(rviObSum, math.ceil(rvi[1]))
        array.push(stoObSum, math.ceil(sto[1]))
        array.push(tmfObSum, math.ceil(tmf[1]))
    if close > open and close[1] < open[1] and
     b[1] < 50 and cci[1] < 50 and cmf[1] < 50 and cmo[1] < 50 and
     dix[1] < 50 and k[1] < 50 and mfi[1] < 50 and roc[1] < 50 and
     rsi[1] < 50 and rvi[1] < 50 and sto[1] < 50 and tmf[1] < 50
        array.push(bOsSum, math.floor(b[1]))
        array.push(cciOsSum, math.floor(cci[1]))
        array.push(cmfOsSum, math.floor(cmf[1]))
        array.push(cmoOsSum, math.floor(cmo[1]))
        array.push(dixOsSum, math.floor(dix[1]))
        array.push(kOsSum, math.floor(k[1]))
        array.push(mfiOsSum, math.floor(mfi[1]))
        array.push(rocOsSum, math.floor(roc[1]))
        array.push(rsiOsSum, math.floor(rsi[1]))
        array.push(rviOsSum, math.floor(rvi[1]))
        array.push(stoOsSum, math.floor(sto[1]))
        array.push(tmfOsSum, math.floor(tmf[1]))
    bOb = math.ceil(array.avg(bObSum)), bOs = math.floor(array.avg(bOsSum))
    cciOb = math.ceil(array.avg(cciObSum)), cciOs = math.floor(array.avg(cciOsSum))
    cmfOb = math.ceil(array.avg(cmfObSum)), cmfOs = math.floor(array.avg(cmfOsSum))
    cmoOb = math.ceil(array.avg(cmoObSum)), cmoOs = math.floor(array.avg(cmoOsSum))
    dixOb = math.ceil(array.avg(dixObSum)), dixOs = math.floor(array.avg(dixOsSum))
    kOb = math.ceil(array.avg(kObSum)), kOs = math.floor(array.avg(kOsSum))
    mfiOb = math.ceil(array.avg(mfiObSum)), mfiOs = math.floor(array.avg(mfiOsSum))
    rocOb = math.ceil(array.avg(rocObSum)), rocOs = math.floor(array.avg(rocOsSum))
    rsiOb = math.ceil(array.avg(rsiObSum)), rsiOs = math.floor(array.avg(rsiOsSum))
    rviOb = math.ceil(array.avg(rviObSum)), rviOs = math.floor(array.avg(rviOsSum))
    stoOb = math.ceil(array.avg(stoObSum)), stoOs = math.floor(array.avg(stoOsSum))
    tmfOb = math.ceil(array.avg(tmfObSum)), tmfOs = math.floor(array.avg(tmfOsSum))
    [bOb, bOs, cciOb, cciOs, cmfOb, cmfOs, cmoOb, cmoOs, dixOb, dixOs, kOb, kOs, mfiOb, mfiOs, rocOb, rocOs, rsiOb, rsiOs, rviOb, rviOs, stoOb, stoOs, tmfOb, tmfOs]

hybLevels(hyb) =>
    if close < open and close[1] > open[1] and hyb[1] > 50
        array.push(hybObSum, math.ceil(hyb[1]))
    if close > open and close[1] < open[1] and hyb[1] < 50
        array.push(hybOsSum, math.floor(hyb[1]))
    [math.ceil(array.avg(hybObSum)), math.floor(array.avg(hybOsSum))]

showHybColumn(col, hyb) =>
    columnCell = hyb / (100. / (oscCount * 2))
    hybObColor = color.new(col == tableLen - 1 ? curBarObColor : obColor, (100. / oscCount) * (oscCount * 2 - columnCell))
    hybOsColor = color.new(col == tableLen - 1 ? curBarOsColor : osColor, (100. / oscCount) * columnCell)
    for i = 0 to oscCount - 1
        hybTable.cell(col, i, "", cellSize, cellSize, bgcolor = columnCell > oscCount * 2 - 1 - i ? hybObColor : na)
    hybTable.cell(col, oscCount, "", cellSize, cellSize, bgcolor = color.new(hybrid < 50 ? curBarOsColor : hybrid > 50 ? curBarObColor : chart.fg_color, 90))
    for i = oscCount + 1 to oscCount * 2
        hybTable.cell(col, i, "", cellSize, cellSize, bgcolor = columnCell < oscCount * 2 + 1 - i ? hybOsColor : na)
    if col == tableLen - 1
        hybTable.cell(col, oscCount, str.tostring(math.round(hybrid)), text_color = chart.bg_color, text_size = size.tiny, bgcolor = hybrid < 50 ? curBarOsColor : hybrid > 50 ? curBarObColor : chart.fg_color)

//}
// calculate ob/os levels & hybrid graph {

[b, cci7, cmf, cmo, dix, k, mfi, roc, rsi7, rvi, sto, tmf] = graphs(hybSrc, hybLen)
[bOb, bOs, cciOb, cciOs, cmfOb, cmfOs, cmoOb, cmoOs, dixOb, dixOs, kOb, kOs, mfiOb, mfiOs, rocOb, rocOs, rsiOb, rsiOs, rviOb, rviOs, stoOb, stoOs, tmfOb, tmfOs] = levels(b, cci7, cmf, cmo, dix, k, mfi, roc, rsi7, rvi, sto, tmf)
hybrid := obos(b, cci7, cmf, cmo, dix, k, mfi, roc, rsi7, rvi, sto, tmf, bOb, cciOb, cmfOb, cmoOb, dixOb, kOb, mfiOb, rocOb, rsiOb, rviOb, stoOb, tmfOb, bOs, cciOs, cmfOs, cmoOs, dixOs, kOs, mfiOs, rocOs, rsiOs, rviOs, stoOs, tmfOs)

//}
// show diagram {

for i = 1 to tableLen
    showHybColumn(tableLen - i, hybrid[i - 1])
c = 100. / (oscCount * 2 + 2)
for i = 0 to oscCount - 1
    hybTable.cell(tableLen, i, str.tostring(math.round(normal(i, 100 - c, 50 + c))), text_color = chart.fg_color, text_size = size.tiny)
for i = oscCount + 1 to oscCount * 2
    hybTable.cell(tableLen, i, str.tostring(math.round(normal(i, 50 - c, 0 + c))), text_color = chart.fg_color, text_size = size.tiny)

//}
// signals {

[hybObAuto, hybOsAuto] = hybLevels(hybrid)
hybOb = hybObManual == 100 ? hybObAuto : hybObManual
hybOs = hybOsManual == 0 ? hybOsAuto : hybOsManual

up = signalCondition == 1 ? hybrid < hybOs : ta.crossover(hybrid, hybOs)
down = signalCondition == 1 ? hybrid > hybOb : ta.crossunder(hybrid, hybOb)

plotshape(showSignal ? up : na, "Up", shape.circle, location.belowbar, curBarOsColor, size = size.small)
plotshape(showSignal ? down : na, "Down", shape.circle, location.abovebar, curBarObColor, size = size.small)
plot(up ? 1 : down ? -1 : 0, "External Signal", display = display.none)

//}
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Mxwll Capital

//@version=5
//indicator("Pivot Profit Target", overlay=true, max_lines_count = 500, max_boxes_count = 500, max_labels_count = 500, max_polylines_count = 100)

show         = input.bool(defval = true, title= "Show Previous Projections")
showPath     = input.bool(defval = true, title = "Show Price Path")
showPivotLab = input.bool(defval = true, title = "Show Pivot Label")

ph = (ta.pivothigh(high, 20, 20))
pl = (ta.pivotlow ( low, 20, 20))

type preValuesObjects
    
    line  pvLine
    line  pvStart
    label pvLabel
    box   pvBox

type preValues 
    
    int   phT 
    float phP 
    float phP1 
    float plP1 
    int   phTime 
    int   plTime

    float htl 
    float ltl 
    float btl 
    float ttl 



var pv = matrix.new<preValuesObjects>(4, 1), var phLen = matrix.new<float>(9), var plLen = matrix.new<float>(9), var int dir = 0

method divide(float id, float ) => 
    
    float / id - 1


method pivotCalcH(matrix <float> id, matrix<float> id2) =>

    var timeArr = array.new<int>(), var closeArr = array.new<float>()

    timeArr.unshift(time), closeArr.unshift(close)


    var preValues [] valArr = array.from(
                             
                             preValues.new(phT  = 0                  ), 
                             preValues.new(phP  = close              ), 
                             preValues.new(phP1 = close              ), 
                             preValues.new(plP1 = close              ), 
                             preValues.new(phTime = 0                ),
                             preValues.new(plTime = 0                )
     ) 


    var stats = map.new<string, int>()

    if stats.size() == 0 

        stats.put("Total", 0)
        stats.put("Success", 0)


    bv = preValues.new(htl = high[20], ltl = low[20], btl = bar_index[20], ttl = time[20])

    if not na(ph) and dir != 1

        if show and plLen.columns() > 0 and phLen.columns() > 0
    
            if not na(pv.get(0, 0))

                pv.get(1, 0).pvBox.set_right(int(valArr.get(5).plTime))
                pv.get(2, 0).pvLine.set_x2  (int(valArr.get(5).plTime))

                stats.put("Total" , stats.get("Total") + 1)

                points = array.new<chart.point>()

                for i =  timeArr.indexof(pv.get(1, 0).pvBox.get_left()) to timeArr.indexof(int(valArr.get(5).plTime))
                    
                    points.push(chart.point.from_time(timeArr.get(i), closeArr.get(i)))

                    if closeArr.get(i) >= pv.get(1, 0).pvBox.get_bottom()

                        stats.put("Success", stats.get("Success") + 1)

                        if showPath
                            polyline.new(points, xloc = xloc.bar_time, line_color = #14D990, line_width = 2)

                        break


            pv.set(0, 0, preValuesObjects.new(pvStart = 
                         
                         line.new(
                             
                             int(phLen.get(2, 0)), 
                             phLen.get(3, 0),
                             int(phLen.get(2, 0)),
                             phLen.get(3, 0) * (1 + plLen.row(4).median()), 
                             color = #F26948, 
                             style = line.style_dotted, 
                             xloc  = xloc.bar_time
             )))
                 
      
            pv.set(1, 0, preValuesObjects.new(pvBox = 
                             box.new(         int(phLen.get(2, 0)), 
                             phLen.get(3, 0) * (1 + plLen.row(5).median()),
                             time,
                             phLen.get(3, 0) * (1 + plLen.row(4).median()), 
                             bgcolor      = color.new(#F26948, 80), 
                             border_color = color.new(color.white, 80),
                             border_width = 1,                                     
                             xloc = xloc.bar_time


                      )))
                 

            pv.set(2, 0, preValuesObjects.new(pvLine = 
                             line.new(
                             int(phLen.get(2, 0)), 
                             phLen.get(3, 0) * (1 + plLen.row(1).median()),
                             time, 
                             phLen.get(3, 0) * (1 + plLen.row(1).median()), color = color.new(#F26948, 50), 
                             style = line.style_solid,                                      
                             xloc = xloc.bar_time
             )))

                
            pv.set(3, 0, preValuesObjects.new(pvLabel = 
                                         label.new(        int(phLen.get(2, 0)), phLen.get(3, 0) * 1.01, 
                                         style = label.style_text_outline, 
                                         text = showPivotLab ? "⬤" : "", 
                                         color =color.white, 
                                         textcolor = #F26948,
                                         size = size.small,                                     
                                         xloc = xloc.bar_time


                     )))
                 
        switchCond = bv.htl > valArr.get(2).phP1
        [r4, r5, r6, r7] = switch switchCond
            
            true => [na, valArr.get(1).phP.divide(bv.htl), na, bv.btl - valArr.get(1).phP]
            =>      [valArr.get(1).phP.divide(bv.htl), na, bv.btl - valArr.get(1).phP, na]

        r8 = switch bv.htl > valArr.get(1).phP
            
            true => valArr.get(1).phP.divide(bv.htl)
            =>      na

        id.add_col(0, array.from(bv.btl - valArr.get(1).phP, 
         valArr.get(1).phP.divide(bv.htl), bv.ttl, bv.htl, r4, r5, r6, r7, r8))
        
        valArr.set(0, preValues.new(phT = int(bv.btl))), valArr.set(2, preValues.new(phP1 = valArr.get(1).phP))
        valArr.set(1, preValues.new(phP = bv.htl))     , valArr.set(5, preValues.new(plTime = int(bv.ttl)))

        
    if not na(pl) and dir != -1

        if show and plLen.columns() > 0 and phLen.columns() > 0
            if not na(pv.get(0, 0))

                pv.get(1, 0).pvBox.set_right(int(valArr.get(4).phTime))
                pv.get(2, 0).pvLine.set_x2  (int(valArr.get(4).phTime))

                stats.put("Total" , stats.get("Total") + 1)

                points = array.new<chart.point>()

                for i =  timeArr.indexof(pv.get(1, 0).pvBox.get_left()) to timeArr.indexof(int(valArr.get(4).phTime))
                    
                    points.push(chart.point.from_time(timeArr.get(i), closeArr.get(i)))

                    if closeArr.get(i) <= pv.get(1, 0).pvBox.get_bottom()

                        stats.put("Success", stats.get("Success") + 1)

                        if showPath
                            polyline.new(points, xloc = xloc.bar_time, line_color = #F24968, line_width = 2)

                        break




            pv.set(0, 0, 
                     
                     preValuesObjects.new(pvStart = 
                         
                         line.new(
                             
                             int(plLen.get(2, 0)), 
                             plLen.get    (3, 0),
                             int(plLen.get(2, 0)),
                             plLen.get    (3, 0) * (1 + phLen.row(4).median()), 
                             color = #14D990, 
                             style = line.style_dotted,
                             xloc  = xloc.bar_time
             )))

             
                  
            pv.set(1, 0, 
                     
                     preValuesObjects.new(pvBox = 
                         
                         box.new(int(plLen.get(2, 0)), 
                             
                             plLen.get(3, 0) * (1 + phLen.row(5).median()),
                             time,
                             plLen.get(3, 0) * (1 + phLen.row(4).median()), 
                             bgcolor      = color.new(#14D990, 80), 
                             border_color = color.new(color.white, 80),
                             border_width = 1,                                     
                             xloc         = xloc.bar_time

                  )))
             
            pv.set(2, 0, 
                
                 preValuesObjects.new(pvLine = 
                         
                         line.new(

                             int(plLen.get(2, 0)), 
                             plLen.get(3, 0) * (1 + phLen.row(1).median()),
                             time,
                             plLen.get(3, 0) * (1 + phLen.row(1).median()), 
                             color = color.new(#14D990, 50), 
                             style = line.style_solid,
                             xloc  = xloc.bar_time
             )))

            
            pv.set(3, 0, 
                 
                 preValuesObjects.new(
                    
                     pvLabel = label.new(int(plLen.get(2, 0)), plLen.get(3, 0) * .99, 
                                     style     = label.style_text_outline, 
                                     text      = showPivotLab ? "⬤" : "", 
                                     color     =color.white, 
                                     textcolor = color.aqua,
                                     size      = size.small,
                                     xloc      = xloc.bar_time
                 )))
                 

        switchCond2 = bv.ltl < valArr.get(3).plP1
        [r4, r5, r6, r7] = switch switchCond2
            
            true => [na, valArr.get(1).phP.divide(bv.ltl), na, bv.btl - valArr.get(1).phP]
            =>      [valArr.get(1).phP.divide(bv.ltl), na, bv.btl - valArr.get(1).phP, na]

        r8 = switch bv.ltl < valArr.get(1).phP
            
            true => valArr.get(1).phP.divide(bv.ltl)
            =>      na


        id2.add_col(0, array.from(bv.btl - valArr.get(1).phP, 
         valArr.get(1).phP.divide(bv.ltl), bv.ttl, bv.ltl, r4, r5, r6, r7, r8))
        
        valArr.set(0, preValues.new(phT = int(bv.btl))), valArr.set(3, preValues.new(plP1 = valArr.get(1).phP))
        valArr.set(1, preValues.new(phP = bv.ltl))       , valArr.set(4, preValues.new(phTime = int(bv.ttl)))

    stats

stats = phLen.pivotCalcH(plLen)

if not na(ph)
    dir := 1
if not na(pl)
    dir := -1


if barstate.islast 

    var tab = table.new(position.bottom_right, 99, 99, bgcolor = #20222C, border_color = #363843, frame_color = #363843, border_width = 1, frame_width = 1)
    tab.cell(0, 0, "Projections", text_color = color.white)
    tab.cell(1, 0, "Successful", text_color = color.white)
    tab.cell(2, 0, "Failed", text_color = color.white)

    getTotal   = stats.get("Total")
    getSuccess = stats.get("Success")

    tab.cell(0, 1, str.tostring(getTotal), text_color = color.white)
    tab.cell(1, 1, str.tostring(getSuccess), text_color = #14D990)
    tab.cell(2, 1, str.tostring(getTotal - getSuccess), text_color = #F24968)


    var line [] projectLine = array.new_line(), var label [] projectLabel = array.new_label(), var box [] projectBox = array.new_box()
    
    if projectLine.size() > 0 
        for i = 0 to projectLine.size() - 1
            projectLine.shift().delete()
    
    if projectLabel.size() > 0 
        for i = 0 to projectLabel.size() - 1
            projectLabel.shift().delete()
    
    if projectBox.size() > 0 
        for i = 0 to projectBox.size() - 1
            projectBox.shift().delete()

    switch dir

        1  =>  projectLine.unshift(
                     line.new(
                             int(plLen.get(2, 0)), 
                             plLen.get(3, 0),
                             int(plLen.get(2, 0)),
                             plLen.get(3, 0) * (1 + phLen.row(4).median()), 
                             color = #14D990, 
                             style = line.style_dotted, 
                             xloc  = xloc.bar_time
                         )), 
                 
                 projectBox.unshift(
                      
                       box.new(int(plLen.get(2, 0)), 
                             plLen.get(3, 0) * (1 + phLen.row(5).median()),
                             time,
                             plLen.get(3, 0) * (1 + phLen.row(4).median()), 
                             bgcolor      = color.new(#14D990, 80), 
                             border_color = color.new(color.white, 80),
                             border_width = 1,                                     
                             xloc         = xloc.bar_time


                      )
                 ),

                 projectLine.unshift(
                     line.new(
                             int(plLen.get(2, 0)), 
                             plLen.get(3, 0) * (1 + phLen.row(1).median()),
                             time,
                             plLen.get(3, 0) * (1 + phLen.row(1).median()), color = color.new(#14D990, 50), 
                             style = line.style_solid,                                     
                             xloc  = xloc.bar_time
                             )), 
                
                 projectLabel.unshift(
                     label.new(int(plLen.get(2, 0)), plLen.get(3, 0) * .99, 
                                         style     = label.style_text_outline, 
                                         text      = showPivotLab ? "⬤" : "", 
                                         color     =color.white, 
                                         textcolor = color.aqua,
                                         size      = size.small,                                      
                                         xloc      = xloc.bar_time


                     )
                 )

        -1 => projectLine.unshift(
                     line.new(
                             int(phLen.get(2, 0)), 
                             phLen.get(3, 0),
                             int(phLen.get(2, 0)),
                             phLen.get(3, 0) * (1 + plLen.row(4).median()), 
                             color = #F26948, 
                             style = line.style_dotted,                                      
                             xloc  = xloc.bar_time
                     )), 
                 
                 projectBox.unshift(
                      
                       box.new(int(phLen.get(2, 0)), 
                             phLen.get(3, 0) * (1 + plLen.row(5).median()),
                             time,
                             phLen.get(3, 0) * (1 + plLen.row(4).median()), 
                             bgcolor      = color.new(#F26948, 80), 
                             border_color = color.new(color.white, 80),
                             border_width = 1,                                      
                             xloc = xloc.bar_time


                      )
                 ),

                 projectLine.unshift(
                     line.new(
                             int(phLen.get(2, 0)), 
                             phLen.get(3, 0) * (1 + plLen.row(1).median()),
                             time, 
                             phLen.get(3, 0) * (1 + plLen.row(1).median()), color = color.new(#F26948, 50), 
                             style = line.style_solid,                              
                             xloc  = xloc.bar_time
                                 )), 
                
                 projectLabel.unshift(
                     label.new(int(phLen.get(2, 0)), phLen.get(3, 0) * 1.01, 
                                         style     = label.style_text_outline, 
                                         text      = showPivotLab ? "⬤" : "", 
                                         color     =color.white, 
                                         textcolor = #F26948,
                                         size      = size.small,                             
                                         xloc      = xloc.bar_time


                     )
                 )


