//+------------------------------------------------------------------+
//|                    Enhanced Dynamic Distance Breakeven Flipper EA |
//|                                          Copyright 2025, Your Name |
//|                        FULLY FIXED MULTIPLE ITERATION VERSION   |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025"
#property link      ""
#property version   "2.03"
#property strict

//--- Input Parameters
input group "=== BASIC SETTINGS ==="
input double InitialLotSize = 0.01;
input double RecoveryMultiplier = 2.0;
input double LossThresholdUSD = 10.0;
input double RecoveryProfitTarget = 5.0;
input int MagicNumber = 123456;

input group "=== FIRST TRADE SETTINGS ==="
input double TakeProfit = 100.0;           // Take Profit in points
input bool UseTrailingStop = true;
input double TrailingStart = 50.0;         // Points in profit to start trailing
input double TrailingStep = 10.0;          // Minimum points to move trailing stop
input double TrailingDistance = 30.0;      // Distance from current price

input group "=== ADX FILTER (First Trade Only) ==="
input bool UseADXFilter = true;
input int ADXPeriod = 14;
input double MinADXLevel = 25.0;           // Minimum ADX for trend strength

input group "=== FLIP BREAKEVEN SETTINGS ==="
input int MaxFlipRecoveries = 5;           // Maximum flip recoveries before Dynamic Distance
input bool EnableUnlimitedFlips = true;    // Enable unlimited flip breakeven
input bool AutoRestoreHedge = true;        // Keep hedge restoration

input group "=== DYNAMIC DISTANCE STRATEGY ==="
input bool EnableDynamicDistance = true;   // Enable dynamic distance strategy
input double ZDistance = 100.0;            // Distance in points from older trade
input double AggregrateProfitThreshold = 8.0;  // Aggregate profit threshold for exit
input bool MaintainLotProgression = true;  // Continue lot size multiplication series

input group "=== RISK CONTROLS ==="
input int MaxRecoveryDepth = 999999;       // Maximum recovery cycles
input double MaxLotSize = 99999999.0;      // Maximum lot size
input double MaxEquityDrawdownPercent = 50.0; // Maximum drawdown tolerance
input double MaxSpreadPoints = 50.0;       // Maximum spread tolerance
input int MaxSlippagePoints = 10;          // Maximum slippage tolerance

input group "=== TIMING CONTROLS ==="
input int CooldownSeconds = 5;             // Cooldown between operations
input int TradeOpenRetries = 10;           // Trade open retry attempts

//--- Global Variables
enum TRADE_STATE
{
   STATE_WAITING_FIRST_TRADE,
   STATE_FIRST_TRADE_ACTIVE,
   STATE_RECOVERY_ACTIVE,
   STATE_FLIP_IN_PROGRESS,
   STATE_DYNAMIC_DISTANCE_ACTIVE,
   STATE_ERROR_RECOVERY
};

enum FLIP_STATE
{
   FLIP_IDLE,
   FLIP_VALIDATING,
   FLIP_CLOSING_OLD,
   FLIP_OPENING_NEW,
   FLIP_VERIFYING,
   FLIP_COMPLETE,
   FLIP_FAILED
};

struct TradeInfo
{
   int ticket;
   int type;
   double lots;
   double openPrice;
   datetime openTime;
   bool isOlder;
   bool verified;
   bool hasDynamicTP;
   double dynamicTPPrice;
};

struct FlipOperation
{
   FLIP_STATE state;
   int oldTicket;
   int oldType;
   double oldLots;
   double newLots;
   int newTicket;
   datetime startTime;
};

struct DynamicDistanceStats
{
   int totalTPHits;
   double totalTPProfit;
   datetime lastTPHit;
   double currentLotSizeForNext;
};

// Global state variables
TRADE_STATE currentState = STATE_WAITING_FIRST_TRADE;
TradeInfo activeTrades[2];
int activeTradeCount = 0;
int recoveryDepth = 0;
int totalFlipCount = 0;
datetime lastRecoveryTime = 0;
double initialEquity = 0;
bool emergencyMode = false;
bool dynamicDistanceActive = false;

// Operation structures
FlipOperation currentFlip;
DynamicDistanceStats ddStats;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("=== FULLY FIXED DYNAMIC DISTANCE EA INITIALIZED ===");
   Print("Version: 2.03 - Complete Flow Fixed");
   initialEquity = AccountEquity();
   
   // Validate inputs
   if(InitialLotSize <= 0 || RecoveryMultiplier <= 1.0)
   {
      Alert("Invalid lot size or recovery multiplier settings!");
      return INIT_PARAMETERS_INCORRECT;
   }
   
   if(EnableDynamicDistance)
   {
      if(ZDistance <= 0)
      {
         Alert("Invalid Z Distance setting!");
         return INIT_PARAMETERS_INCORRECT;
      }
      
      Print("=== DYNAMIC DISTANCE SETTINGS ===");
      Print("- Max Flip Recoveries: ", MaxFlipRecoveries);
      Print("- Z Distance: ", ZDistance, " points");
      Print("- Aggregate Profit Threshold: $", AggregrateProfitThreshold);
      Print("- Lot Progression: ", (MaintainLotProgression ? "ENABLED" : "DISABLED"));
      Print("- CONTINUOUS CYCLE: ENABLED");
   }
   
   // Initialize structures
   InitializeTradeArray();
   ResetFlipOperation();
   InitializeDynamicDistanceStats();
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Initialize trade array                                           |
//+------------------------------------------------------------------+
void InitializeTradeArray()
{
   for(int i = 0; i < 2; i++)
   {
      activeTrades[i].ticket = -1;
      activeTrades[i].type = -1;
      activeTrades[i].lots = 0;
      activeTrades[i].openPrice = 0;
      activeTrades[i].openTime = 0;
      activeTrades[i].isOlder = false;
      activeTrades[i].verified = false;
      activeTrades[i].hasDynamicTP = false;
      activeTrades[i].dynamicTPPrice = 0;
   }
}

//+------------------------------------------------------------------+
//| Initialize Dynamic Distance statistics                           |
//+------------------------------------------------------------------+
void InitializeDynamicDistanceStats()
{
   ddStats.totalTPHits = 0;
   ddStats.totalTPProfit = 0;
   ddStats.lastTPHit = 0;
   ddStats.currentLotSizeForNext = 0;
}

//+------------------------------------------------------------------+
//| Reset flip operation structure                                   |
//+------------------------------------------------------------------+
void ResetFlipOperation()
{
   currentFlip.state = FLIP_IDLE;
   currentFlip.oldTicket = -1;
   currentFlip.oldType = -1;
   currentFlip.oldLots = 0;
   currentFlip.newLots = 0;
   currentFlip.newTicket = -1;
   currentFlip.startTime = 0;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("=== DYNAMIC DISTANCE EA DEINITIALIZED ===");
   Print("Reason: ", reason);
   Print("=== FINAL STATISTICS ===");
   Print("Total flips performed: ", totalFlipCount);
   Print("Final recovery depth: ", recoveryDepth);
   
   if(EnableDynamicDistance && ddStats.totalTPHits > 0)
   {
      Print("=== DYNAMIC DISTANCE STATISTICS ===");
      Print("Total TP hits: ", ddStats.totalTPHits);
      Print("Total TP profit: $", NormalizeDouble(ddStats.totalTPProfit, 2));
      Print("Average profit per TP: $", NormalizeDouble(ddStats.totalTPProfit / ddStats.totalTPHits, 2));
   }
   
   if(currentFlip.state != FLIP_IDLE)
   {
      Print("WARNING: EA deinitialized during flip operation. State: ", EnumToString(currentFlip.state));
   }
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Update active trades info
   UpdateActiveTradesInfo();
   
   // Check for Dynamic Distance TP hits first (highest priority)
   if(dynamicDistanceActive && EnableDynamicDistance)
   {
      CheckDynamicDistanceTPHits();
   }
   
   // Handle ongoing flip operation
   if(currentFlip.state != FLIP_IDLE)
   {
      HandleFlipOperation();
      return;
   }
   
   // Risk and market condition checks
   if(!CheckRiskControls()) return;
   if(!CheckMarketConditions()) return;
   
   // State machine logic
   switch(currentState)
   {
      case STATE_WAITING_FIRST_TRADE:
         HandleWaitingFirstTrade();
         break;
         
      case STATE_FIRST_TRADE_ACTIVE:
         HandleFirstTradeActive();
         break;
         
      case STATE_RECOVERY_ACTIVE:
         HandleRecoveryActive();
         break;
         
      case STATE_DYNAMIC_DISTANCE_ACTIVE:
         HandleDynamicDistanceActive();
         break;
         
      case STATE_ERROR_RECOVERY:
         HandleErrorRecovery();
         break;
   }
   
   // Handle trailing stop for first trade
   if(currentState == STATE_FIRST_TRADE_ACTIVE && UseTrailingStop)
   {
      HandleTrailingStop();
   }
}

//+------------------------------------------------------------------+
//| Handle flip operation                                            |
//+------------------------------------------------------------------+
void HandleFlipOperation()
{
   // Simple timeout check
   if(TimeCurrent() - currentFlip.startTime > 300)
   {
      Print("Flip operation timeout after 300 seconds.");
      ResetFlipOperation();
      currentState = STATE_ERROR_RECOVERY;
      return;
   }
   
   switch(currentFlip.state)
   {
      case FLIP_VALIDATING:
         ContinueFlipValidation();
         break;
         
      case FLIP_CLOSING_OLD:
         ContinueClosingOldTrade();
         break;
         
      case FLIP_OPENING_NEW:
         ContinueOpeningNewTrade();
         break;
         
      case FLIP_VERIFYING:
         ContinueFlipVerification();
         break;
         
      case FLIP_COMPLETE:
         CompleteFlipOperation();
         break;
         
      case FLIP_FAILED:
         HandleFlipFailure();
         break;
   }
}

//+------------------------------------------------------------------+
//| Continue flip validation phase                                   |
//+------------------------------------------------------------------+
void ContinueFlipValidation()
{
   Print("🔍 Validating flip conditions...");
   
   if(!OrderSelect(currentFlip.oldTicket, SELECT_BY_TICKET))
   {
      Print("❌ Old trade no longer exists. Flip cancelled.");
      currentFlip.state = FLIP_FAILED;
      return;
   }
   
   double newMarginRequired = MarketInfo(Symbol(), MODE_MARGINREQUIRED) * currentFlip.newLots;
   double freeMargin = AccountFreeMargin();
   
   if(freeMargin < newMarginRequired * 1.1)
   {
      Print("❌ Insufficient margin for flip.");
      currentFlip.state = FLIP_FAILED;
      return;
   }
   
   if(currentFlip.newLots > MaxLotSize)
   {
      Print("❌ New lot size exceeds maximum.");
      currentFlip.state = FLIP_FAILED;
      return;
   }
   
   Print("✅ Validation completed - Proceeding with flip!");
   currentFlip.state = FLIP_CLOSING_OLD;
}

//+------------------------------------------------------------------+
//| Continue closing old trade phase                                 |
//+------------------------------------------------------------------+
void ContinueClosingOldTrade()
{
   Print("Attempting to close old trade...");
   
   bool closed = false;
   
   if(OrderSelect(currentFlip.oldTicket, SELECT_BY_TICKET))
   {
      RefreshRates();
      double closePrice = (OrderType() == OP_BUY) ? Bid : Ask;
      
      closed = OrderClose(OrderTicket(), OrderLots(), closePrice, MaxSlippagePoints);
   }
   
   if(closed)
   {
      Print("✅ Old trade closed successfully. Proceeding to open new trade.");
      currentFlip.state = FLIP_OPENING_NEW;
   }
   else
   {
      Print("❌ Failed to close old trade");
      currentFlip.state = FLIP_FAILED;
   }
}

//+------------------------------------------------------------------+
//| Continue opening new trade phase                                 |
//+------------------------------------------------------------------+
void ContinueOpeningNewTrade()
{
   Print("Attempting to open new trade...");
   
   int ticket = OpenTrade(currentFlip.oldType, currentFlip.newLots, false);
   
   if(ticket > 0)
   {
      currentFlip.newTicket = ticket;
      Print("✅ New trade opened successfully. Ticket: ", ticket);
      currentFlip.state = FLIP_VERIFYING;
   }
   else
   {
      Print("❌ Failed to open new trade");
      currentFlip.state = FLIP_FAILED;
   }
}

//+------------------------------------------------------------------+
//| Continue flip verification phase                                 |
//+------------------------------------------------------------------+
void ContinueFlipVerification()
{
   Print("Verifying flip completion...");
   
   if(OrderSelect(currentFlip.newTicket, SELECT_BY_TICKET))
   {
      bool lotSizeMatch = (MathAbs(OrderLots() - currentFlip.newLots) < 0.01);
      
      if(OrderMagicNumber() == MagicNumber && 
         OrderSymbol() == Symbol() && 
         OrderType() == currentFlip.oldType &&
         lotSizeMatch)
      {
         Print("✅ Flip verification successful!");
         currentFlip.state = FLIP_COMPLETE;
      }
      else
      {
         Print("❌ Flip verification failed - trade parameters don't match!");
         currentFlip.state = FLIP_FAILED;
      }
   }
   else
   {
      Print("Cannot verify new trade");
      currentFlip.state = FLIP_FAILED;
   }
}

//+------------------------------------------------------------------+
//| Complete flip operation                                          |
//+------------------------------------------------------------------+
void CompleteFlipOperation()
{
   totalFlipCount++;
   
   Print("=== FLIP OPERATION COMPLETED SUCCESSFULLY ===");
   Print("Flip #", totalFlipCount, " - Old trade ", currentFlip.oldTicket, " closed, new trade ", currentFlip.newTicket, " opened");
   Print("New lot size: ", currentFlip.newLots);
   Print("Recovery depth: ", recoveryDepth, " -> ", recoveryDepth + 1);
   
   recoveryDepth++;
   
   // Check if we should activate Dynamic Distance after this flip
   if(EnableDynamicDistance && totalFlipCount >= MaxFlipRecoveries)
   {
      Print("🎯 FLIP RECOVERY LIMIT REACHED - Dynamic Distance will activate next cycle");
   }
   
   ResetFlipOperation();
   currentState = STATE_RECOVERY_ACTIVE;
   
   Print("Flip completed. Ready for next opportunity.");
}

//+------------------------------------------------------------------+
//| Handle flip failure                                              |
//+------------------------------------------------------------------+
void HandleFlipFailure()
{
   Print("=== FLIP OPERATION FAILED ===");
   Print("Failed flip would have been #", totalFlipCount + 1);
   
   ResetFlipOperation();
   currentState = STATE_ERROR_RECOVERY;
}

//+------------------------------------------------------------------+
//| Handle error recovery state                                      |
//+------------------------------------------------------------------+
void HandleErrorRecovery()
{
   Print("In error recovery state. Analyzing situation...");
   
   if(TimeCurrent() - lastRecoveryTime < CooldownSeconds)
   {
      return;
   }
   
   if(activeTradeCount == 0)
   {
      ResetToWaitingState();
      Print("Error recovery: No trades found, resetting to WAITING state");
   }
   else if(activeTradeCount == 1)
   {
      if(recoveryDepth > 0 && AutoRestoreHedge)
      {
         RestoreHedge();
      }
      currentState = STATE_RECOVERY_ACTIVE;
      Print("Error recovery: Single trade found, returning to RECOVERY state");
   }
   else if(activeTradeCount == 2)
   {
      // Determine the appropriate state based on flip count
      if(EnableDynamicDistance && totalFlipCount >= MaxFlipRecoveries)
      {
         dynamicDistanceActive = true;
         currentState = STATE_DYNAMIC_DISTANCE_ACTIVE;
      }
      else
      {
         currentState = STATE_RECOVERY_ACTIVE;
      }
      Print("Error recovery: Two trades found, returning to appropriate state");
   }
   else
   {
      Print("Error recovery: Unexpected trade count (", activeTradeCount, "), closing all");
      CloseAllTrades();
      ResetToWaitingState();
   }
}

//+------------------------------------------------------------------+
//| Restore missing hedge trade                                      |
//+------------------------------------------------------------------+
void RestoreHedge()
{
   if(activeTradeCount == 1)
   {
      Print("Attempting to restore missing hedge trade...");
      
      int oppositeType = (activeTrades[0].type == OP_BUY) ? OP_SELL : OP_BUY;
      double hedgeLots = activeTrades[0].lots * RecoveryMultiplier;
      
      int hedgeTicket = OpenTrade(oppositeType, hedgeLots, false);
      if(hedgeTicket > 0)
      {
         Print("✅ Emergency hedge restored successfully. Ticket: ", hedgeTicket);
         
         // Wait and update trade info
         Sleep(1000);
         UpdateActiveTradesInfo();
      }
      else
      {
         Print("❌ Failed to restore hedge.");
      }
   }
}

//+------------------------------------------------------------------+
//| Open a trade                                                     |
//+------------------------------------------------------------------+
int OpenTrade(int type, double lots, bool isFirstTrade)
{
   double minLot = MarketInfo(Symbol(), MODE_MINLOT);
   double maxLot = MarketInfo(Symbol(), MODE_MAXLOT);
   double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
   
   // Normalize lot size
   lots = MathMax(minLot, MathMin(maxLot, NormalizeDouble(lots / lotStep, 0) * lotStep));
   
   double price = (type == OP_BUY) ? Ask : Bid;
   double sl = 0;
   double tp = 0;
   
   if(isFirstTrade && TakeProfit > 0)
   {
      if(type == OP_BUY)
         tp = price + TakeProfit * Point;
      else
         tp = price - TakeProfit * Point;
   }
   
   RefreshRates();
   price = (type == OP_BUY) ? Ask : Bid;
   
   string comment = dynamicDistanceActive ? "Dynamic Distance EA" : "Enhanced Breakeven EA";
   
   int ticket = OrderSend(Symbol(), type, lots, price, MaxSlippagePoints, sl, tp, 
                         comment, MagicNumber, 0, 
                         (type == OP_BUY) ? clrBlue : clrRed);
   
   if(ticket > 0)
   {
      Print("Trade opened: Ticket=", ticket, " Type=", type, " Lots=", lots, " Price=", price);
      if(dynamicDistanceActive)
      {
         Print("🎯 Dynamic Distance mode trade opened successfully");
      }
   }
   else
   {
      Print("Failed to open trade. Error: ", GetLastError());
   }
   
   return ticket;
}

//+------------------------------------------------------------------+
//| Handle trailing stop                                             |
//+------------------------------------------------------------------+
void HandleTrailingStop()
{
   if(activeTradeCount != 1) return;
   
   if(OrderSelect(activeTrades[0].ticket, SELECT_BY_TICKET))
   {
      double profit = OrderProfit() + OrderSwap() + OrderCommission();
      
      if(profit >= TrailingStart * MarketInfo(Symbol(), MODE_TICKVALUE) * OrderLots())
      {
         double newSL = 0;
         bool modify = false;
         
         if(OrderType() == OP_BUY)
         {
            newSL = Bid - TrailingDistance * Point;
            if(newSL > OrderStopLoss() + TrailingStep * Point)
            {
               modify = true;
            }
         }
         else if(OrderType() == OP_SELL)
         {
            newSL = Ask + TrailingDistance * Point;
            if(newSL < OrderStopLoss() - TrailingStep * Point || OrderStopLoss() == 0)
            {
               modify = true;
            }
         }
         
         if(modify)
         {
            bool result = OrderModify(OrderTicket(), OrderOpenPrice(), newSL, OrderTakeProfit(), 0);
            if(result)
            {
               Print("Trailing stop updated for ticket ", OrderTicket(), " New SL: ", newSL);
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Get trade profit                                                 |
//+------------------------------------------------------------------+
double GetTradeProfit(int ticket)
{
   if(OrderSelect(ticket, SELECT_BY_TICKET))
   {
      return OrderProfit() + OrderSwap() + OrderCommission();
   }
   return 0;
}

//+------------------------------------------------------------------+
//| Close all trades                                                 |
//+------------------------------------------------------------------+
void CloseAllTrades()
{
   Print("Closing all trades...");
   
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS) && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
      {
         double closePrice = (OrderType() == OP_BUY) ? Bid : Ask;
         
         bool closed = OrderClose(OrderTicket(), OrderLots(), closePrice, MaxSlippagePoints);
         
         if(closed)
         {
            Print("Trade closed: Ticket=", OrderTicket());
         }
         else
         {
            Print("Failed to close trade: Ticket=", OrderTicket(), " Error: ", GetLastError());
         }
      }
   }
   
   if(totalFlipCount > 0 || ddStats.totalTPHits > 0)
   {
      Print("🏁 SESSION ENDED:");
      Print("- Total flips performed: ", totalFlipCount);
      Print("- Maximum recovery depth reached: ", recoveryDepth);
      if(EnableDynamicDistance && ddStats.totalTPHits > 0)
      {
         Print("- Total TP hits: ", ddStats.totalTPHits);
         Print("- Total TP profit: $", NormalizeDouble(ddStats.totalTPProfit, 2));
         Print("- Average profit per TP: $", NormalizeDouble(ddStats.totalTPProfit / ddStats.totalTPHits, 2));
      }
      Print("- Final equity: $", NormalizeDouble(AccountEquity(), 2));
      Print("- Session P&L: $", NormalizeDouble(AccountEquity() - initialEquity, 2));
   }
}

//+------------------------------------------------------------------+
//| Check risk controls                                              |
//+------------------------------------------------------------------+
bool CheckRiskControls()
{
   double currentEquity = AccountEquity();
   double drawdownPercent = (initialEquity - currentEquity) / initialEquity * 100.0;
   
   if(drawdownPercent > MaxEquityDrawdownPercent)
   {
      Print("Maximum equity drawdown reached: ", drawdownPercent, "%");
      CloseAllTrades();
      emergencyMode = true;
      return false;
   }
   
   if(recoveryDepth > MaxRecoveryDepth)
   {
      Print("Maximum recovery depth reached: ", recoveryDepth);
      CloseAllTrades();
      emergencyMode = true;
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Check market conditions                                          |
//+------------------------------------------------------------------+
bool CheckMarketConditions()
{
   if(emergencyMode)
   {
      return false;
   }
   
   double spread = (Ask - Bid) / Point;
   if(spread > MaxSpreadPoints)
   {
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Update active trades information                                 |
//+------------------------------------------------------------------+
void UpdateActiveTradesInfo()
{
   activeTradeCount = 0;
   
   // Reset trade info
   InitializeTradeArray();
   
   // Scan for our trades
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS) && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
      {
         if(activeTradeCount < 2)
         {
            activeTrades[activeTradeCount].ticket = OrderTicket();
            activeTrades[activeTradeCount].type = OrderType();
            activeTrades[activeTradeCount].lots = OrderLots();
            activeTrades[activeTradeCount].openPrice = OrderOpenPrice();
            activeTrades[activeTradeCount].openTime = OrderOpenTime();
            activeTrades[activeTradeCount].verified = true;
            
            // Check if trade has TP (for dynamic TP tracking)
            if(OrderTakeProfit() > 0)
            {
               activeTrades[activeTradeCount].hasDynamicTP = true;
               activeTrades[activeTradeCount].dynamicTPPrice = OrderTakeProfit();
            }
            
            activeTradeCount++;
         }
      }
   }
   
   // Determine which trade is older
   if(activeTradeCount == 2)
   {
      DetermineOlderAndNewerTrades();
   }
}

//+------------------------------------------------------------------+
//| Determine older/newer trades                                     |
//+------------------------------------------------------------------+
void DetermineOlderAndNewerTrades()
{
   int olderIndex = -1;
   int newerIndex = -1;
   
   // Determine based on time
   if(activeTrades[0].openTime < activeTrades[1].openTime)
   {
      olderIndex = 0;
      newerIndex = 1;
   }
   else
   {
      olderIndex = 1;
      newerIndex = 0;
   }
   
   activeTrades[olderIndex].isOlder = true;
   activeTrades[newerIndex].isOlder = false;
   
   static datetime lastClassificationLog = 0;
   if(TimeCurrent() - lastClassificationLog >= 30) // Log every 30 seconds
   {
      Print("Trade classification: Older=", activeTrades[olderIndex].ticket, 
            " (", activeTrades[olderIndex].lots, " lots), Newer=", activeTrades[newerIndex].ticket,
            " (", activeTrades[newerIndex].lots, " lots)");
      lastClassificationLog = TimeCurrent();
   }
}

//+------------------------------------------------------------------+
//| Validate trade entry conditions                                 |
//+------------------------------------------------------------------+
bool ValidateTradeEntryConditions(string tradeType)
{
   Print("=== Validating ", tradeType, " trade entry conditions ===");
   
   if(emergencyMode)
   {
      Print("❌ Emergency mode active - no trading allowed");
      return false;
   }
   
   double spread = (Ask - Bid) / Point;
   if(spread > MaxSpreadPoints)
   {
      Print("❌ Spread too high: ", spread, " > ", MaxSpreadPoints);
      return false;
   }
   
   if(tradeType == "FIRST" && TimeCurrent() - lastRecoveryTime < CooldownSeconds)
   {
      Print("❌ Cooldown active: ", (CooldownSeconds - (TimeCurrent() - lastRecoveryTime)), " seconds remaining");
      return false;
   }
   
   if(tradeType == "FIRST" && UseADXFilter)
   {
      double adx = iADX(Symbol(), 0, ADXPeriod, PRICE_HIGH, MODE_MAIN, 1);
      if(adx < MinADXLevel)
      {
         Print("❌ ADX filter failed: ", adx, " < ", MinADXLevel);
         return false;
      }
      else
      {
         Print("✅ ADX filter passed: ", adx, " >= ", MinADXLevel);
      }
   }
   
   double freeMargin = AccountFreeMargin();
   double marginRequired = MarketInfo(Symbol(), MODE_MARGINREQUIRED) * InitialLotSize;
   
   if(freeMargin < marginRequired * 2.0)
   {
      Print("❌ Insufficient margin: Required ", marginRequired, ", Available ", freeMargin);
      return false;
   }
   
   Print("✅ All ", tradeType, " trade conditions validated");
   return true;
}

//+------------------------------------------------------------------+
//| Handle waiting for first trade state                            |
//+------------------------------------------------------------------+
void HandleWaitingFirstTrade()
{
   if(!ValidateTradeEntryConditions("FIRST"))
   {
      return;
   }
   
   if(emergencyMode && TimeCurrent() - lastRecoveryTime >= CooldownSeconds * 2)
   {
      emergencyMode = false;
      Print("Emergency mode reset after extended cooldown");
   }
   
   Print("=== Opening First Trade ===");
   Print("Current time: ", TimeToString(TimeCurrent()));
   Print("Spread: ", (Ask - Bid) / Point, " points");
   Print("Free margin: ", AccountFreeMargin());
   Print("Initial lot size: ", InitialLotSize);
   if(EnableDynamicDistance)
   {
      Print("🎯 DYNAMIC DISTANCE READY: Max flip recoveries = ", MaxFlipRecoveries);
   }
   
   int direction = MathRand() % 2;
   string directionStr = (direction == 0) ? "BUY" : "SELL";
   Print("Selected direction: ", directionStr);
   
   int ticket = -1;
   
   if(direction == 0)
   {
      ticket = OpenTrade(OP_BUY, InitialLotSize, true);
   }
   else
   {
      ticket = OpenTrade(OP_SELL, InitialLotSize, true);
   }
   
   if(ticket > 0)
   {
      currentState = STATE_FIRST_TRADE_ACTIVE;
      Print("✅ First trade opened successfully. Ticket: ", ticket, " State: FIRST_TRADE_ACTIVE");
      Print("- Session equity change: $", NormalizeDouble(AccountEquity() - initialEquity, 2));
   }
   else
   {
      Print("❌ Failed to open first trade");
   }
   
   recoveryDepth = 0;
}

//+------------------------------------------------------------------+
//| Handle first trade active state                                  |
//+------------------------------------------------------------------+
void HandleFirstTradeActive()
{
   if(activeTradeCount == 0)
   {
      ResetToWaitingState();
      Print("✅ First trade closed successfully. Returning to WAITING state");
      return;
   }
   
   if(activeTradeCount == 1)
   {
      double tradeProfit = GetTradeProfit(activeTrades[0].ticket);
      string tradeTypeStr = (activeTrades[0].type == OP_BUY) ? "BUY" : "SELL";
      
      static datetime lastStatusLog = 0;
      int logInterval = 10;
      
      if(TimeCurrent() - lastStatusLog >= logInterval)
      {
         Print("First trade status - Ticket: ", activeTrades[0].ticket, 
               " Type: ", tradeTypeStr, " Lots: ", activeTrades[0].lots, 
               " Profit: $", NormalizeDouble(tradeProfit, 2));
         if(EnableDynamicDistance)
         {
            Print("🎯 Dynamic Distance system ready for hedge activation");
         }
         lastStatusLog = TimeCurrent();
      }
      
      if(tradeProfit <= -LossThresholdUSD)
      {
         Print("=== HEDGE TRIGGER ACTIVATED ===");
         Print("First trade loss: $", NormalizeDouble(tradeProfit, 2), " exceeds threshold: $", LossThresholdUSD);
         
         if(!ValidateTradeEntryConditions("HEDGE"))
         {
            Print("❌ Hedge trade conditions not met - will retry next tick");
            return;
         }
         
         int oppositeType = (activeTrades[0].type == OP_BUY) ? OP_SELL : OP_BUY;
         double hedgeLots = activeTrades[0].lots * RecoveryMultiplier;
         string hedgeTypeStr = (oppositeType == OP_BUY) ? "BUY" : "SELL";
         
         Print("Hedge parameters: Type=", hedgeTypeStr, " Lots=", hedgeLots);
         
         double hedgeMarginRequired = MarketInfo(Symbol(), MODE_MARGINREQUIRED) * hedgeLots;
         double freeMargin = AccountFreeMargin();
         
         if(freeMargin < hedgeMarginRequired * 1.1)
         {
            Print("❌ Insufficient margin for hedge");
            return;
         }
         
         Print("✅ Opening hedge trade...");
         int hedgeTicket = OpenTrade(oppositeType, hedgeLots, false);
         
         if(hedgeTicket > 0)
         {
            currentState = STATE_RECOVERY_ACTIVE;
            recoveryDepth = 1;
            
            Print("🚀 RECOVERY MODE ACTIVATED!");
            Print("Hedge trade opened - Ticket: ", hedgeTicket);
            Print("Recovery depth: ", recoveryDepth);
            Print("State changed to: RECOVERY_ACTIVE");
            if(EnableDynamicDistance)
            {
               Print("🎯 Dynamic Distance will activate after ", MaxFlipRecoveries, " flips!");
            }
         }
         else
         {
            Print("❌ CRITICAL: Failed to open hedge trade!");
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Handle recovery active state                                     |
//+------------------------------------------------------------------+
void HandleRecoveryActive()
{
   // Validate trade count
   if(activeTradeCount < 2)
   {
      if(activeTradeCount == 1 && AutoRestoreHedge)
      {
         RestoreHedge();
      }
      else if(activeTradeCount == 0)
      {
         ResetToWaitingState();
      }
      return;
   }
   
   // Check if we should activate Dynamic Distance Strategy
   if(EnableDynamicDistance && totalFlipCount >= MaxFlipRecoveries)
   {
      ActivateDynamicDistanceStrategy();
      return;
   }
   
   // Check regular recovery profit target
   double totalProfit = GetCombinedProfit();
   if(totalProfit >= RecoveryProfitTarget)
   {
      Print("🎉 REGULAR RECOVERY COMPLETE!");
      Print("Final profit: $", NormalizeDouble(totalProfit, 2));
      Print("Total flips: ", totalFlipCount);
      
      CloseAllTrades();
      ResetToWaitingState();
      return;
   }
   
   // Continue with regular breakeven flip logic
   CheckBreakevenFlip();
}

//+------------------------------------------------------------------+
//| Check for breakeven flip opportunity                            |
//+------------------------------------------------------------------+
void CheckBreakevenFlip()
{
   if(currentFlip.state != FLIP_IDLE)
   {
      return;
   }
   
   if(activeTradeCount != 2)
   {
      return;
   }
   
   // Find older trade
   int olderIndex = -1;
   int newerIndex = -1;
   
   for(int i = 0; i < activeTradeCount; i++)
   {
      if(activeTrades[i].isOlder)
      {
         olderIndex = i;
         newerIndex = (i == 0) ? 1 : 0;
         break;
      }
   }
   
   if(olderIndex == -1)
   {
      return;
   }
   
   // Check if price has returned to breakeven of older trade
   bool atBreakeven = false;
   double currentPrice = (activeTrades[olderIndex].type == OP_BUY) ? Bid : Ask;
   double threshold = 10 * Point;
   double priceDifference = MathAbs(currentPrice - activeTrades[olderIndex].openPrice);
   
   if(priceDifference <= threshold)
   {
      atBreakeven = true;
   }
   
   if(atBreakeven)
   {
      double newerProfit = GetTradeProfit(activeTrades[newerIndex].ticket);
      
      if(newerProfit <= 0)
      {
         double newLotSize = CalculateFlipLotSize(activeTrades[newerIndex].lots);
         
         if(ValidateFlip(newLotSize))
         {
            Print("✅ FLIP CONDITIONS MET - Flip #", totalFlipCount + 1);
            Print("New lot size: ", newLotSize);
            StartBreakevenFlip(olderIndex, newerIndex);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate lot size for flip                                      |
//+------------------------------------------------------------------+
double CalculateFlipLotSize(double currentLots)
{
   double newLots = currentLots * RecoveryMultiplier;
   
   Print("📊 FLIP LOT SIZE CALCULATION:");
   Print("- Current lots: ", currentLots);
   Print("- Recovery multiplier: ", RecoveryMultiplier);
   Print("- New lots: ", newLots);
   
   return newLots;
}

//+------------------------------------------------------------------+
//| Validate flip conditions                                         |
//+------------------------------------------------------------------+
bool ValidateFlip(double newLotSize)
{
   if(!EnableUnlimitedFlips && totalFlipCount >= MaxFlipRecoveries)
   {
      Print("❌ Maximum flip recoveries reached: ", totalFlipCount, "/", MaxFlipRecoveries);
      return false;
   }
   
   Print("🔍 VALIDATING FLIP:");
   Print("- New lot size: ", newLotSize);
   Print("- Flip count: ", totalFlipCount, "/", MaxFlipRecoveries);
   
   double brokerMaxLot = MarketInfo(Symbol(), MODE_MAXLOT);
   if(newLotSize > brokerMaxLot)
   {
      Print("❌ Lot size ", newLotSize, " exceeds broker maximum: ", brokerMaxLot);
      return false;
   }
   
   double newMarginRequired = MarketInfo(Symbol(), MODE_MARGINREQUIRED) * newLotSize;
   double freeMargin = AccountFreeMargin();
   
   if(freeMargin < newMarginRequired * 1.1)
   {
      Print("❌ Insufficient margin for flip");
      return false;
   }
   
   Print("✅ FLIP VALIDATION PASSED!");
   return true;
}

//+------------------------------------------------------------------+
//| Start breakeven flip operation                                   |
//+------------------------------------------------------------------+
bool StartBreakevenFlip(int olderIndex, int newerIndex)
{
   Print("=== STARTING BREAKEVEN FLIP ===");
   
   double newLots = CalculateFlipLotSize(activeTrades[newerIndex].lots);
   
   currentFlip.state = FLIP_VALIDATING;
   currentFlip.oldTicket = activeTrades[olderIndex].ticket;
   currentFlip.oldType = activeTrades[olderIndex].type;
   currentFlip.oldLots = activeTrades[olderIndex].lots;
   currentFlip.newLots = newLots;
   currentFlip.newTicket = -1;
   currentFlip.startTime = TimeCurrent();
   
   Print("FLIP #", totalFlipCount + 1, " initialized:");
   Print("- Old ticket: ", currentFlip.oldTicket, " (", currentFlip.oldLots, " lots)");
   Print("- New lots: ", currentFlip.newLots);
   Print("- Recovery depth: ", recoveryDepth, " -> ", recoveryDepth + 1);
   
   currentState = STATE_FLIP_IN_PROGRESS;
   
   return true;
}

//+------------------------------------------------------------------+
//| Reset to waiting state                                           |
//+------------------------------------------------------------------+
void ResetToWaitingState()
{
   currentState = STATE_WAITING_FIRST_TRADE;
   lastRecoveryTime = TimeCurrent();
   recoveryDepth = 0;
   totalFlipCount = 0;
   dynamicDistanceActive = false;
   InitializeDynamicDistanceStats();
   Print("✅ Reset to WAITING state. Ready for new cycle.");
}

//+------------------------------------------------------------------+
//| Get combined profit of all active trades                        |
//+------------------------------------------------------------------+
double GetCombinedProfit()
{
   double totalProfit = 0;
   for(int i = 0; i < activeTradeCount; i++)
   {
      totalProfit += GetTradeProfit(activeTrades[i].ticket);
   }
   return totalProfit;
}

//+------------------------------------------------------------------+
//| FIXED: Check for Dynamic Distance Take Profit hits              |
//+------------------------------------------------------------------+
void CheckDynamicDistanceTPHits()
{
   for(int i = 0; i < activeTradeCount; i++)
   {
      if(activeTrades[i].hasDynamicTP && activeTrades[i].ticket > 0)
      {
         // Check if trade was closed (TP hit)
         if(!OrderSelect(activeTrades[i].ticket, SELECT_BY_TICKET))
         {
            Print("🎯 DYNAMIC DISTANCE TP HIT DETECTED!");
            Print("Closed trade: Ticket=", activeTrades[i].ticket, 
                  " Type=", (activeTrades[i].type == OP_BUY ? "BUY" : "SELL"),
                  " Lots=", activeTrades[i].lots);
            
            HandleDynamicDistanceTPHit(i);
            return;
         }
         else
         {
            // Check if TP price was reached manually
            double currentPrice = (activeTrades[i].type == OP_BUY) ? Bid : Ask;
            bool tpReached = false;
            
            if(activeTrades[i].type == OP_BUY)
            {
               tpReached = (currentPrice >= activeTrades[i].dynamicTPPrice);
            }
            else
            {
               tpReached = (currentPrice <= activeTrades[i].dynamicTPPrice);
            }
            
            if(tpReached)
            {
               Print("🎯 Dynamic TP price reached, manually closing trade...");
               CloseDynamicDistanceTPTrade(i);
               return;
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| FIXED: Handle Dynamic Distance TP hit - CONTINUOUS CYCLE        |
//+------------------------------------------------------------------+
void HandleDynamicDistanceTPHit(int tradeIndex)
{
   // Update statistics
   ddStats.totalTPHits++;
   ddStats.lastTPHit = TimeCurrent();
   
   // Calculate approximate profit from the TP hit
   double approxProfit = 0;
   if(activeTrades[tradeIndex].type == OP_BUY)
   {
      approxProfit = (activeTrades[tradeIndex].dynamicTPPrice - activeTrades[tradeIndex].openPrice) 
                     * activeTrades[tradeIndex].lots * MarketInfo(Symbol(), MODE_TICKVALUE) / Point;
   }
   else
   {
      approxProfit = (activeTrades[tradeIndex].openPrice - activeTrades[tradeIndex].dynamicTPPrice) 
                     * activeTrades[tradeIndex].lots * MarketInfo(Symbol(), MODE_TICKVALUE) / Point;
   }
   
   ddStats.totalTPProfit += approxProfit;
   
   Print("=== DYNAMIC DISTANCE TP HIT #", ddStats.totalTPHits, " ===");
   Print("Approximate profit: $", NormalizeDouble(approxProfit, 2));
   Print("Total TP profit so far: $", NormalizeDouble(ddStats.totalTPProfit, 2));
   
   // Calculate next lot size using progression
   double nextLotSize;
   if(MaintainLotProgression)
   {
      nextLotSize = activeTrades[tradeIndex].lots * RecoveryMultiplier;
   }
   else
   {
      nextLotSize = activeTrades[tradeIndex].lots; // Same lot size
   }
   
   Print("Next replacement lot size: ", nextLotSize, " (current: ", activeTrades[tradeIndex].lots, ")");
   
   // Open replacement trade in SAME direction with calculated lot size
   int replacementTicket = OpenDynamicDistanceReplacementTrade(tradeIndex, nextLotSize);
   
   if(replacementTicket > 0)
   {
      Print("✅ Replacement trade opened successfully. Ticket: ", replacementTicket);
      
      // CRITICAL: Wait for trade update
      Sleep(2000); // 2 second delay to ensure trade is processed
      UpdateActiveTradesInfo();
      
      // Check if we still have exactly 2 trades
      if(activeTradeCount == 2)
      {
         Print("✅ Trade count verified - continuing Dynamic Distance cycle");
         
         // IMMEDIATE TP PLACEMENT: Set TP on older trade immediately
         SetDynamicDistanceTPOnOlderTradeImmediate();
      }
      else
      {
         Print("❌ Trade count mismatch after replacement: ", activeTradeCount);
         Print("Expected: 2, Found: ", activeTradeCount);
         currentState = STATE_ERROR_RECOVERY;
      }
   }
   else
   {
      Print("❌ CRITICAL: Failed to open replacement trade!");
      currentState = STATE_ERROR_RECOVERY;
   }
}

//+------------------------------------------------------------------+
//| Close Dynamic Distance TP trade manually                        |
//+------------------------------------------------------------------+
void CloseDynamicDistanceTPTrade(int tradeIndex)
{
   if(OrderSelect(activeTrades[tradeIndex].ticket, SELECT_BY_TICKET))
   {
      double closePrice = (OrderType() == OP_BUY) ? Bid : Ask;
      
      bool closed = OrderClose(OrderTicket(), OrderLots(), closePrice, MaxSlippagePoints);
      
      if(closed)
      {
         Print("✅ Dynamic Distance TP trade closed manually");
         HandleDynamicDistanceTPHit(tradeIndex);
      }
      else
      {
         Print("❌ Failed to close dynamic distance TP trade");
      }
   }
}

//+------------------------------------------------------------------+
//| FIXED: Open replacement trade with better error handling        |
//+------------------------------------------------------------------+
int OpenDynamicDistanceReplacementTrade(int closedTradeIndex, double newLotSize)
{
   int tradeType = activeTrades[closedTradeIndex].type; // Same direction as closed trade
   
   Print("🔄 Opening Dynamic Distance replacement trade:");
   Print("- Direction: ", (tradeType == OP_BUY ? "BUY" : "SELL"));
   Print("- Lot size: ", newLotSize);
   Print("- Replacing closed trade: ", activeTrades[closedTradeIndex].ticket);
   
   // Validate lot size before opening
   double minLot = MarketInfo(Symbol(), MODE_MINLOT);
   double maxLot = MarketInfo(Symbol(), MODE_MAXLOT);
   
   if(newLotSize < minLot)
   {
      newLotSize = minLot;
      Print("⚠️ Lot size adjusted to minimum: ", newLotSize);
   }
   else if(newLotSize > maxLot)
   {
      Print("❌ Lot size exceeds broker maximum: ", newLotSize, " > ", maxLot);
      return -1;
   }
   
   // Check margin before opening
   double marginRequired = MarketInfo(Symbol(), MODE_MARGINREQUIRED) * newLotSize;
   double freeMargin = AccountFreeMargin();
   
   if(freeMargin < marginRequired * 1.2) // 20% buffer
   {
      Print("❌ Insufficient margin for replacement trade");
      Print("Required: ", marginRequired, " Available: ", freeMargin);
      return -1;
   }
   
   // Open the replacement trade
   int newTicket = OpenTrade(tradeType, newLotSize, false);
   
   if(newTicket > 0)
   {
      Print("✅ Dynamic Distance replacement opened. Ticket: ", newTicket);
      return newTicket;
   }
   else
   {
      Print("❌ Failed to open Dynamic Distance replacement trade!");
      Print("Error: ", GetLastError());
      return -1;
   }
}

//+------------------------------------------------------------------+
//| Check aggregate profit threshold                                 |
//+------------------------------------------------------------------+
bool CheckAggregrateProfitThreshold()
{
   double totalProfit = GetCombinedProfit();
   
   if(totalProfit >= AggregrateProfitThreshold)
   {
      Print("🎉 AGGREGATE PROFIT THRESHOLD ACHIEVED!");
      Print("Combined profit: $", NormalizeDouble(totalProfit, 2));
      Print("Threshold: $", AggregrateProfitThreshold);
      Print("Total flips: ", totalFlipCount);
      Print("Total TP hits: ", ddStats.totalTPHits);
      Print("Total TP profit: $", NormalizeDouble(ddStats.totalTPProfit, 2));
      
      CloseAllTrades();
      ResetToWaitingState();
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Handle Dynamic Distance Active state                            |
//+------------------------------------------------------------------+
void HandleDynamicDistanceActive()
{
   // Check aggregate profit threshold FIRST (highest priority)
   if(CheckAggregrateProfitThreshold())
   {
      return; // Will reset to waiting state
   }
   
   // Validate trade count
   if(activeTradeCount < 2)
   {
      if(activeTradeCount == 1 && AutoRestoreHedge)
      {
         Print("🔧 Attempting to restore missing hedge in Dynamic Distance mode...");
         RestoreHedge();
         Sleep(2000);
         UpdateActiveTradesInfo();
         
         if(activeTradeCount == 2)
         {
            Print("✅ Hedge restored - setting TP on older trade");
            SetDynamicDistanceTPOnOlderTradeImmediate();
         }
      }
      else if(activeTradeCount == 0)
      {
         Print("No trades found - resetting to waiting state");
         ResetToWaitingState();
      }
      return;
   }
   
   // Log current status periodically
   static datetime lastStatusLog = 0;
   if(TimeCurrent() - lastStatusLog >= 30) // Every 30 seconds
   {
      double totalProfit = GetCombinedProfit();
      Print("🎯 DYNAMIC DISTANCE STATUS:");
      Print("- Combined profit: $", NormalizeDouble(totalProfit, 2), 
            " / Threshold: $", AggregrateProfitThreshold);
      Print("- TP hits so far: ", ddStats.totalTPHits);
      Print("- Total TP profit: $", NormalizeDouble(ddStats.totalTPProfit, 2));
      
      for(int i = 0; i < activeTradeCount; i++)
      {
         double tradeProfit = GetTradeProfit(activeTrades[i].ticket);
         string tpStatus = activeTrades[i].hasDynamicTP ? "HAS TP" : "NO TP";
         string ageStatus = activeTrades[i].isOlder ? "OLDER" : "NEWER";
         Print("- Trade ", activeTrades[i].ticket, " (", 
               (activeTrades[i].type == OP_BUY ? "BUY" : "SELL"), 
               " ", activeTrades[i].lots, " lots, ", ageStatus, "): $", 
               NormalizeDouble(tradeProfit, 2), " [", tpStatus, "]");
      }
      lastStatusLog = TimeCurrent();
   }
}

//+------------------------------------------------------------------+
//| Activate Dynamic Distance Strategy                               |
//+------------------------------------------------------------------+
void ActivateDynamicDistanceStrategy()
{
   if(!EnableDynamicDistance)
   {
      Print("Dynamic Distance is disabled in settings");
      return;
   }
   
   if(activeTradeCount != 2)
   {
      Print("❌ Cannot activate Dynamic Distance - need exactly 2 trades, have ", activeTradeCount);
      return;
   }
   
   Print("🎯 ACTIVATING DYNAMIC DISTANCE STRATEGY!");
   Print("- Trigger: Maximum flip recoveries reached (", totalFlipCount, " flips)");
   Print("- Z Distance: ", ZDistance, " points");
   Print("- Aggregate Profit Threshold: $", AggregrateProfitThreshold);
   Print("- Lot Progression: ", (MaintainLotProgression ? "ENABLED" : "DISABLED"));
   Print("- CONTINUOUS CYCLE: ENABLED");
   
   dynamicDistanceActive = true;
   currentState = STATE_DYNAMIC_DISTANCE_ACTIVE;
   
   // Determine older and newer trades
   DetermineOlderAndNewerTrades();
   
   // IMMEDIATE TP PLACEMENT: Set initial TP on older trade
   SetDynamicDistanceTPOnOlderTradeImmediate();
}

//+------------------------------------------------------------------+
//| FIXED: Set TP immediately with better validation                |
//+------------------------------------------------------------------+
void SetDynamicDistanceTPOnOlderTradeImmediate()
{
   if(activeTradeCount != 2) 
   {
      Print("❌ Cannot set Dynamic TP - need 2 trades, have ", activeTradeCount);
      return;
   }
   
   // Check aggregate profit first - if close to target, don't set TP
   double totalProfit = GetCombinedProfit();
   if(totalProfit >= AggregrateProfitThreshold * 0.95) // Within 95% of target
   {
      Print("🎯 Close to profit target - checking if should exit instead of setting TP");
      if(CheckAggregrateProfitThreshold())
      {
         return; // Will exit
      }
   }
   
   // Find older trade
   int olderIndex = -1;
   int newerIndex = -1;
   for(int i = 0; i < activeTradeCount; i++)
   {
      if(activeTrades[i].isOlder)
      {
         olderIndex = i;
         newerIndex = (i == 0) ? 1 : 0;
         break;
      }
   }
   
   if(olderIndex == -1)
   {
      Print("❌ Could not find older trade for Dynamic Distance TP");
      currentState = STATE_ERROR_RECOVERY;
      return;
   }
   
   // Verify the trade still exists and select it
   if(!OrderSelect(activeTrades[olderIndex].ticket, SELECT_BY_TICKET))
   {
      Print("❌ Older trade no longer exists: ", activeTrades[olderIndex].ticket);
      UpdateActiveTradesInfo(); // Refresh trade info
      return;
   }
   
   // Calculate TP price at Z distance from older trade's open price
   double tpPrice = 0;
   if(activeTrades[olderIndex].type == OP_BUY)
   {
      tpPrice = activeTrades[olderIndex].openPrice + ZDistance * Point;
   }
   else
   {
      tpPrice = activeTrades[olderIndex].openPrice - ZDistance * Point;
   }
   
   Print("🎯 SETTING DYNAMIC DISTANCE TP - Cycle #", ddStats.totalTPHits + 1);
   Print("- Target trade: ", activeTrades[olderIndex].ticket, " (", 
         (activeTrades[olderIndex].type == OP_BUY ? "BUY" : "SELL"), 
         " ", activeTrades[olderIndex].lots, " lots)");
   Print("- Open price: ", activeTrades[olderIndex].openPrice);
   Print("- TP price: ", tpPrice, " (Z distance: ", ZDistance, " points)");
   Print("- Current aggregate profit: $", NormalizeDouble(totalProfit, 2));
   Print("- Aggregate threshold: $", AggregrateProfitThreshold);
   
   // Modify the order to set TP
   bool modified = OrderModify(activeTrades[olderIndex].ticket, 
                              activeTrades[olderIndex].openPrice, 
                              0, // No stop loss
                              tpPrice, 
                              0);
   
   if(modified)
   {
      activeTrades[olderIndex].hasDynamicTP = true;
      activeTrades[olderIndex].dynamicTPPrice = tpPrice;
      
      Print("✅ Dynamic Distance TP set successfully!");
      Print("🔄 CONTINUOUS CYCLE ACTIVE - Ready for TP hit #", ddStats.totalTPHits + 1);
      Print("🎯 System will IMMEDIATELY set new TP after this one hits");
   }
   else
   {
      int error = GetLastError();
      Print("❌ Failed to set Dynamic Distance TP. Error: ", error);
      
      // Don't go to error recovery for minor errors, retry next tick
      if(error != ERR_TRADE_MODIFY_DENIED && error != ERR_INVALID_STOPS)
      {
         Print("Retrying TP placement next tick...");
      }
      else
      {
         Print("Serious error - entering error recovery");
         currentState = STATE_ERROR_RECOVERY;
      }
   }
}

//+------------------------------------------------------------------+
//| END OF FULLY FIXED DYNAMIC DISTANCE BREAKEVEN FLIPPER EA       |
//+------------------------------------------------------------------+