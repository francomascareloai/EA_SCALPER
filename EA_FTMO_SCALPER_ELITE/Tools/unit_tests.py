#!/usr/bin/env python3
"""
EA FTMO Scalper Elite - Unit Tests Framework
Framework de testes unit√°rios para valida√ß√£o dos m√≥dulos
"""

import os
import re
import json
from pathlib import Path
from datetime import datetime

class EAUnitTester:
    def __init__(self):
        self.test_results = {
            "timestamp": datetime.now().isoformat(),
            "total_tests": 0,
            "passed": 0,
            "failed": 0,
            "warnings": 0,
            "modules": {}
        }
        
    def log_test(self, module, test_name, status, message=""):
        """Registra resultado de um teste"""
        if module not in self.test_results["modules"]:
            self.test_results["modules"][module] = {
                "tests": [],
                "passed": 0,
                "failed": 0,
                "warnings": 0
            }
        
        self.test_results["modules"][module]["tests"].append({
            "name": test_name,
            "status": status,
            "message": message
        })
        
        self.test_results["modules"][module][status] += 1
        self.test_results[status] += 1
        self.test_results["total_tests"] += 1
        
        # Print resultado
        status_icon = {"passed": "‚úÖ", "failed": "‚ùå", "warnings": "‚ö†Ô∏è"}
        print(f"  {status_icon[status]} {test_name}: {message}")

    def test_file_structure(self):
        """Testa estrutura de arquivos"""
        print("\nüîç TESTE 1: ESTRUTURA DE ARQUIVOS")
        print("-" * 50)
        
        required_files = [
            "MQL5_Source/EA_FTMO_Scalper_Elite.mq5",
            "MQL5_Source/Source/Core/DataStructures.mqh",
            "MQL5_Source/Source/Core/Interfaces.mqh",
            "MQL5_Source/Source/Core/Logger.mqh",
            "MQL5_Source/Source/Core/ConfigManager.mqh",
            "MQL5_Source/Source/Core/CacheManager.mqh",
            "MQL5_Source/Source/Core/PerformanceAnalyzer.mqh",
            "MQL5_Source/Source/Strategies/ICT/OrderBlockDetector.mqh",
            "MQL5_Source/Source/Strategies/ICT/FVGDetector.mqh",
            "MQL5_Source/Source/Strategies/ICT/LiquidityDetector.mqh",
            "MQL5_Source/Source/Strategies/ICT/MarketStructureAnalyzer.mqh"
        ]
        
        for file_path in required_files:
            path = Path(file_path)
            if path.exists():
                size = path.stat().st_size
                if size > 1000:  # Arquivo deve ter pelo menos 1KB
                    self.log_test("structure", f"File {path.name}", "passed", f"{size} bytes")
                else:
                    self.log_test("structure", f"File {path.name}", "warnings", f"Muito pequeno: {size} bytes")
            else:
                self.log_test("structure", f"File {path.name}", "failed", "Arquivo n√£o encontrado")

    def test_includes_dependencies(self):
        """Testa depend√™ncias de includes"""
        print("\nüîó TESTE 2: DEPEND√äNCIAS DE INCLUDES")
        print("-" * 50)
        
        ea_file = Path("MQL5_Source/EA_FTMO_Scalper_Elite.mq5")
        if not ea_file.exists():
            self.log_test("includes", "EA Principal", "failed", "Arquivo n√£o encontrado")
            return
        
        with open(ea_file, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        # Extrair includes
        includes = re.findall(r'#include\s+"([^"]+)"', content)
        
        for include in includes:
            include_path = Path("MQL5_Source") / include
            if include_path.exists():
                self.log_test("includes", f"Include {include}", "passed", "Encontrado")
            else:
                self.log_test("includes", f"Include {include}", "failed", "N√£o encontrado")

    def test_ftmo_compliance(self):
        """Testa compliance FTMO"""
        print("\nüõ°Ô∏è  TESTE 3: FTMO COMPLIANCE")
        print("-" * 50)
        
        ea_file = Path("MQL5_Source/EA_FTMO_Scalper_Elite.mq5")
        if not ea_file.exists():
            self.log_test("ftmo", "EA Principal", "failed", "Arquivo n√£o encontrado")
            return
        
        with open(ea_file, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        # Testes FTMO obrigat√≥rios
        ftmo_tests = [
            ("Max_Risk_Per_Trade", "Risco por trade definido"),
            ("Daily_Loss_Limit", "Limite de perda di√°ria"),
            ("Max_Drawdown_Limit", "Limite de drawdown"),
            ("StopLoss", "Stop Loss obrigat√≥rio"),
            ("TakeProfit", "Take Profit configurado"),
            ("News_Filter", "Filtro de not√≠cias")
        ]
        
        for pattern, description in ftmo_tests:
            if pattern in content:
                self.log_test("ftmo", description, "passed", f"Padr√£o '{pattern}' encontrado")
            else:
                self.log_test("ftmo", description, "warnings", f"Padr√£o '{pattern}' n√£o encontrado")
        
        # Verificar padr√µes proibidos
        forbidden_patterns = ["martingale", "grid", "recovery"]
        for pattern in forbidden_patterns:
            if pattern.lower() in content.lower():
                self.log_test("ftmo", f"Padr√£o proibido: {pattern}", "failed", "Encontrado no c√≥digo")
            else:
                self.log_test("ftmo", f"Aus√™ncia de {pattern}", "passed", "Padr√£o proibido n√£o encontrado")

    def test_class_definitions(self):
        """Testa defini√ß√µes de classes"""
        print("\nüèóÔ∏è  TESTE 4: DEFINI√á√ïES DE CLASSES")
        print("-" * 50)
        
        expected_classes = [
            ("COrderBlockDetector", "OrderBlockDetector.mqh"),
            ("CFVGDetector", "FVGDetector.mqh"),
            ("CLiquidityDetector", "LiquidityDetector.mqh"),
            ("CMarketStructureAnalyzer", "MarketStructureAnalyzer.mqh"),
            ("CLogger", "Logger.mqh"),
            ("CConfigManager", "ConfigManager.mqh"),
            ("CCacheManager", "CacheManager.mqh"),
            ("CPerformanceAnalyzer", "PerformanceAnalyzer.mqh")
        ]
        
        for class_name, file_name in expected_classes:
            # Procurar arquivo
            file_found = False
            for root, dirs, files in os.walk("MQL5_Source/Source"):
                if file_name in files:
                    file_path = Path(root) / file_name
                    file_found = True
                    
                    # Verificar se classe est√° definida
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    if f"class {class_name}" in content:
                        self.log_test("classes", f"Classe {class_name}", "passed", f"Definida em {file_name}")
                    else:
                        self.log_test("classes", f"Classe {class_name}", "failed", f"N√£o encontrada em {file_name}")
                    break
            
            if not file_found:
                self.log_test("classes", f"Arquivo {file_name}", "failed", "Arquivo n√£o encontrado")

    def test_function_signatures(self):
        """Testa assinaturas de fun√ß√µes principais"""
        print("\n‚öôÔ∏è  TESTE 5: FUN√á√ïES PRINCIPAIS")
        print("-" * 50)
        
        ea_file = Path("MQL5_Source/EA_FTMO_Scalper_Elite.mq5")
        if not ea_file.exists():
            self.log_test("functions", "EA Principal", "failed", "Arquivo n√£o encontrado")
            return
        
        with open(ea_file, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        required_functions = [
            ("OnInit()", "Fun√ß√£o de inicializa√ß√£o"),
            ("OnTick()", "Fun√ß√£o principal de trading"),
            ("OnDeinit(", "Fun√ß√£o de finaliza√ß√£o"),
            ("OnTimer()", "Fun√ß√£o de timer")
        ]
        
        for func_pattern, description in required_functions:
            if func_pattern in content:
                self.log_test("functions", description, "passed", f"Fun√ß√£o {func_pattern} encontrada")
            else:
                self.log_test("functions", description, "failed", f"Fun√ß√£o {func_pattern} n√£o encontrada")

    def test_input_parameters(self):
        """Testa par√¢metros de entrada"""
        print("\nüìä TESTE 6: PAR√ÇMETROS DE ENTRADA")
        print("-" * 50)
        
        ea_file = Path("MQL5_Source/EA_FTMO_Scalper_Elite.mq5")
        if not ea_file.exists():
            self.log_test("parameters", "EA Principal", "failed", "Arquivo n√£o encontrado")
            return
        
        with open(ea_file, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        # Contar par√¢metros input
        input_count = len(re.findall(r'input\s+\w+', content))
        
        if input_count >= 10:
            self.log_test("parameters", "Quantidade de inputs", "passed", f"{input_count} par√¢metros encontrados")
        elif input_count >= 5:
            self.log_test("parameters", "Quantidade de inputs", "warnings", f"Apenas {input_count} par√¢metros")
        else:
            self.log_test("parameters", "Quantidade de inputs", "failed", f"Muito poucos: {input_count}")
        
        # Verificar grupos de par√¢metros
        expected_groups = [
            "CONFIGURA√á√ïES GERAIS",
            "GEST√ÉO DE RISCO FTMO",
            "CONFIGURA√á√ïES ICT/SMC"
        ]
        
        for group in expected_groups:
            if group in content:
                self.log_test("parameters", f"Grupo {group}", "passed", "Grupo encontrado")
            else:
                self.log_test("parameters", f"Grupo {group}", "warnings", "Grupo n√£o encontrado")

    def generate_report(self):
        """Gera relat√≥rio final"""
        print("\n" + "=" * 60)
        print("üìã RELAT√ìRIO FINAL DE TESTES UNIT√ÅRIOS")
        print("=" * 60)
        
        total = self.test_results["total_tests"]
        passed = self.test_results["passed"]
        failed = self.test_results["failed"]
        warnings = self.test_results["warnings"]
        
        print(f"üìä ESTAT√çSTICAS GERAIS:")
        print(f"  ‚Ä¢ Total de testes: {total}")
        print(f"  ‚Ä¢ ‚úÖ Aprovados: {passed} ({passed/total*100:.1f}%)")
        print(f"  ‚Ä¢ ‚ùå Falharam: {failed} ({failed/total*100:.1f}%)")
        print(f"  ‚Ä¢ ‚ö†Ô∏è  Avisos: {warnings} ({warnings/total*100:.1f}%)")
        
        print(f"\nüìã RESUMO POR M√ìDULO:")
        for module, data in self.test_results["modules"].items():
            total_mod = len(data["tests"])
            passed_mod = data["passed"]
            print(f"  ‚Ä¢ {module.upper()}: {passed_mod}/{total_mod} aprovados")
        
        # Determinar status geral
        if failed == 0 and warnings <= total * 0.2:  # M√°ximo 20% de warnings
            status = "‚úÖ APROVADO"
            next_step = "Pronto para Strategy Tester"
        elif failed <= total * 0.1:  # M√°ximo 10% de falhas
            status = "‚ö†Ô∏è  APROVADO COM RESSALVAS"
            next_step = "Corrigir avisos antes do Strategy Tester"
        else:
            status = "‚ùå REPROVADO"
            next_step = "Corrigir erros antes de prosseguir"
        
        print(f"\nüéØ STATUS FINAL: {status}")
        print(f"üìã PR√ìXIMO PASSO: {next_step}")
        
        # Salvar relat√≥rio JSON
        with open("unit_test_report.json", "w", encoding="utf-8") as f:
            json.dump(self.test_results, f, indent=2, ensure_ascii=False)
        
        print(f"\nüíæ Relat√≥rio salvo em: unit_test_report.json")
        
        return failed == 0

    def run_all_tests(self):
        """Executa todos os testes"""
        print("üß™ EA FTMO SCALPER ELITE - TESTES UNIT√ÅRIOS")
        print("=" * 60)
        print(f"üìÖ Data/Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Executar todos os testes
        self.test_file_structure()
        self.test_includes_dependencies()
        self.test_ftmo_compliance()
        self.test_class_definitions()
        self.test_function_signatures()
        self.test_input_parameters()
        
        # Gerar relat√≥rio
        return self.generate_report()

def main():
    """Fun√ß√£o principal"""
    tester = EAUnitTester()
    success = tester.run_all_tests()
    
    print("\n" + "=" * 60)
    exit(0 if success else 1)

if __name__ == "__main__":
    main()